// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "QIFMeasurementResources.hxx"

namespace xsd
{
  namespace qif2
  {
    // MeasurementResourcesType
    // 

    const MeasurementResourcesType::Version_optional& MeasurementResourcesType::
    Version () const
    {
      return this->Version_;
    }

    MeasurementResourcesType::Version_optional& MeasurementResourcesType::
    Version ()
    {
      return this->Version_;
    }

    void MeasurementResourcesType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void MeasurementResourcesType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void MeasurementResourcesType::
    Version (::std::auto_ptr< Version_type > x)
    {
      this->Version_.set (x);
    }

    const MeasurementResourcesType::Carriages_optional& MeasurementResourcesType::
    Carriages () const
    {
      return this->Carriages_;
    }

    MeasurementResourcesType::Carriages_optional& MeasurementResourcesType::
    Carriages ()
    {
      return this->Carriages_;
    }

    void MeasurementResourcesType::
    Carriages (const Carriages_type& x)
    {
      this->Carriages_.set (x);
    }

    void MeasurementResourcesType::
    Carriages (const Carriages_optional& x)
    {
      this->Carriages_ = x;
    }

    void MeasurementResourcesType::
    Carriages (::std::auto_ptr< Carriages_type > x)
    {
      this->Carriages_.set (x);
    }

    const MeasurementResourcesType::Fixtures_optional& MeasurementResourcesType::
    Fixtures () const
    {
      return this->Fixtures_;
    }

    MeasurementResourcesType::Fixtures_optional& MeasurementResourcesType::
    Fixtures ()
    {
      return this->Fixtures_;
    }

    void MeasurementResourcesType::
    Fixtures (const Fixtures_type& x)
    {
      this->Fixtures_.set (x);
    }

    void MeasurementResourcesType::
    Fixtures (const Fixtures_optional& x)
    {
      this->Fixtures_ = x;
    }

    void MeasurementResourcesType::
    Fixtures (::std::auto_ptr< Fixtures_type > x)
    {
      this->Fixtures_.set (x);
    }

    const MeasurementResourcesType::MeasurementDevices_optional& MeasurementResourcesType::
    MeasurementDevices () const
    {
      return this->MeasurementDevices_;
    }

    MeasurementResourcesType::MeasurementDevices_optional& MeasurementResourcesType::
    MeasurementDevices ()
    {
      return this->MeasurementDevices_;
    }

    void MeasurementResourcesType::
    MeasurementDevices (const MeasurementDevices_type& x)
    {
      this->MeasurementDevices_.set (x);
    }

    void MeasurementResourcesType::
    MeasurementDevices (const MeasurementDevices_optional& x)
    {
      this->MeasurementDevices_ = x;
    }

    void MeasurementResourcesType::
    MeasurementDevices (::std::auto_ptr< MeasurementDevices_type > x)
    {
      this->MeasurementDevices_.set (x);
    }

    const MeasurementResourcesType::Sensors_optional& MeasurementResourcesType::
    Sensors () const
    {
      return this->Sensors_;
    }

    MeasurementResourcesType::Sensors_optional& MeasurementResourcesType::
    Sensors ()
    {
      return this->Sensors_;
    }

    void MeasurementResourcesType::
    Sensors (const Sensors_type& x)
    {
      this->Sensors_.set (x);
    }

    void MeasurementResourcesType::
    Sensors (const Sensors_optional& x)
    {
      this->Sensors_ = x;
    }

    void MeasurementResourcesType::
    Sensors (::std::auto_ptr< Sensors_type > x)
    {
      this->Sensors_.set (x);
    }

    const MeasurementResourcesType::Tools_optional& MeasurementResourcesType::
    Tools () const
    {
      return this->Tools_;
    }

    MeasurementResourcesType::Tools_optional& MeasurementResourcesType::
    Tools ()
    {
      return this->Tools_;
    }

    void MeasurementResourcesType::
    Tools (const Tools_type& x)
    {
      this->Tools_.set (x);
    }

    void MeasurementResourcesType::
    Tools (const Tools_optional& x)
    {
      this->Tools_ = x;
    }

    void MeasurementResourcesType::
    Tools (::std::auto_ptr< Tools_type > x)
    {
      this->Tools_.set (x);
    }


    // CarriagesType
    // 

    const CarriagesType::Carriage_sequence& CarriagesType::
    Carriage () const
    {
      return this->Carriage_;
    }

    CarriagesType::Carriage_sequence& CarriagesType::
    Carriage ()
    {
      return this->Carriage_;
    }

    void CarriagesType::
    Carriage (const Carriage_sequence& s)
    {
      this->Carriage_ = s;
    }


    // FixturesType
    // 

    const FixturesType::Fixture_sequence& FixturesType::
    Fixture () const
    {
      return this->Fixture_;
    }

    FixturesType::Fixture_sequence& FixturesType::
    Fixture ()
    {
      return this->Fixture_;
    }

    void FixturesType::
    Fixture (const Fixture_sequence& s)
    {
      this->Fixture_ = s;
    }


    // SensorsType
    // 

    const SensorsType::Sensor_sequence& SensorsType::
    Sensor () const
    {
      return this->Sensor_;
    }

    SensorsType::Sensor_sequence& SensorsType::
    Sensor ()
    {
      return this->Sensor_;
    }

    void SensorsType::
    Sensor (const Sensor_sequence& s)
    {
      this->Sensor_ = s;
    }


    // ToolsType
    // 

    const ToolsType::Tool_sequence& ToolsType::
    Tool () const
    {
      return this->Tool_;
    }

    ToolsType::Tool_sequence& ToolsType::
    Tool ()
    {
      return this->Tool_;
    }

    void ToolsType::
    Tool (const Tool_sequence& s)
    {
      this->Tool_ = s;
    }


    // MeasurementDevicesType
    // 

    const MeasurementDevicesType::MeasurementDevice_sequence& MeasurementDevicesType::
    MeasurementDevice () const
    {
      return this->MeasurementDevice_;
    }

    MeasurementDevicesType::MeasurementDevice_sequence& MeasurementDevicesType::
    MeasurementDevice ()
    {
      return this->MeasurementDevice_;
    }

    void MeasurementDevicesType::
    MeasurementDevice (const MeasurementDevice_sequence& s)
    {
      this->MeasurementDevice_ = s;
    }


    // MeasurementResourceBaseType
    // 

    const MeasurementResourceBaseType::Name_type& MeasurementResourceBaseType::
    Name () const
    {
      return this->Name_.get ();
    }

    MeasurementResourceBaseType::Name_type& MeasurementResourceBaseType::
    Name ()
    {
      return this->Name_.get ();
    }

    void MeasurementResourceBaseType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void MeasurementResourceBaseType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const MeasurementResourceBaseType::Description_optional& MeasurementResourceBaseType::
    Description () const
    {
      return this->Description_;
    }

    MeasurementResourceBaseType::Description_optional& MeasurementResourceBaseType::
    Description ()
    {
      return this->Description_;
    }

    void MeasurementResourceBaseType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void MeasurementResourceBaseType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void MeasurementResourceBaseType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const MeasurementResourceBaseType::Manufacturer_optional& MeasurementResourceBaseType::
    Manufacturer () const
    {
      return this->Manufacturer_;
    }

    MeasurementResourceBaseType::Manufacturer_optional& MeasurementResourceBaseType::
    Manufacturer ()
    {
      return this->Manufacturer_;
    }

    void MeasurementResourceBaseType::
    Manufacturer (const Manufacturer_type& x)
    {
      this->Manufacturer_.set (x);
    }

    void MeasurementResourceBaseType::
    Manufacturer (const Manufacturer_optional& x)
    {
      this->Manufacturer_ = x;
    }

    void MeasurementResourceBaseType::
    Manufacturer (::std::auto_ptr< Manufacturer_type > x)
    {
      this->Manufacturer_.set (x);
    }

    const MeasurementResourceBaseType::ModelNumber_optional& MeasurementResourceBaseType::
    ModelNumber () const
    {
      return this->ModelNumber_;
    }

    MeasurementResourceBaseType::ModelNumber_optional& MeasurementResourceBaseType::
    ModelNumber ()
    {
      return this->ModelNumber_;
    }

    void MeasurementResourceBaseType::
    ModelNumber (const ModelNumber_type& x)
    {
      this->ModelNumber_.set (x);
    }

    void MeasurementResourceBaseType::
    ModelNumber (const ModelNumber_optional& x)
    {
      this->ModelNumber_ = x;
    }

    void MeasurementResourceBaseType::
    ModelNumber (::std::auto_ptr< ModelNumber_type > x)
    {
      this->ModelNumber_.set (x);
    }

    const MeasurementResourceBaseType::SerialNumber_optional& MeasurementResourceBaseType::
    SerialNumber () const
    {
      return this->SerialNumber_;
    }

    MeasurementResourceBaseType::SerialNumber_optional& MeasurementResourceBaseType::
    SerialNumber ()
    {
      return this->SerialNumber_;
    }

    void MeasurementResourceBaseType::
    SerialNumber (const SerialNumber_type& x)
    {
      this->SerialNumber_.set (x);
    }

    void MeasurementResourceBaseType::
    SerialNumber (const SerialNumber_optional& x)
    {
      this->SerialNumber_ = x;
    }

    void MeasurementResourceBaseType::
    SerialNumber (::std::auto_ptr< SerialNumber_type > x)
    {
      this->SerialNumber_.set (x);
    }

    const MeasurementResourceBaseType::LocationId_optional& MeasurementResourceBaseType::
    LocationId () const
    {
      return this->LocationId_;
    }

    MeasurementResourceBaseType::LocationId_optional& MeasurementResourceBaseType::
    LocationId ()
    {
      return this->LocationId_;
    }

    void MeasurementResourceBaseType::
    LocationId (const LocationId_type& x)
    {
      this->LocationId_.set (x);
    }

    void MeasurementResourceBaseType::
    LocationId (const LocationId_optional& x)
    {
      this->LocationId_ = x;
    }

    void MeasurementResourceBaseType::
    LocationId (::std::auto_ptr< LocationId_type > x)
    {
      this->LocationId_.set (x);
    }

    const MeasurementResourceBaseType::Location_optional& MeasurementResourceBaseType::
    Location () const
    {
      return this->Location_;
    }

    MeasurementResourceBaseType::Location_optional& MeasurementResourceBaseType::
    Location ()
    {
      return this->Location_;
    }

    void MeasurementResourceBaseType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void MeasurementResourceBaseType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void MeasurementResourceBaseType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const MeasurementResourceBaseType::id_type& MeasurementResourceBaseType::
    id () const
    {
      return this->id_.get ();
    }

    MeasurementResourceBaseType::id_type& MeasurementResourceBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void MeasurementResourceBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void MeasurementResourceBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // FixtureType
    // 


    // MeasurementDeviceAccuracyBaseType
    // 


    // NumericalLengthAccuracyType
    // 

    const NumericalLengthAccuracyType::AccuracyValue_type& NumericalLengthAccuracyType::
    AccuracyValue () const
    {
      return this->AccuracyValue_.get ();
    }

    NumericalLengthAccuracyType::AccuracyValue_type& NumericalLengthAccuracyType::
    AccuracyValue ()
    {
      return this->AccuracyValue_.get ();
    }

    void NumericalLengthAccuracyType::
    AccuracyValue (const AccuracyValue_type& x)
    {
      this->AccuracyValue_.set (x);
    }

    void NumericalLengthAccuracyType::
    AccuracyValue (::std::auto_ptr< AccuracyValue_type > x)
    {
      this->AccuracyValue_.set (x);
    }


    // MeasurementDeviceType
    // 

    const MeasurementDeviceType::Calibrations_optional& MeasurementDeviceType::
    Calibrations () const
    {
      return this->Calibrations_;
    }

    MeasurementDeviceType::Calibrations_optional& MeasurementDeviceType::
    Calibrations ()
    {
      return this->Calibrations_;
    }

    void MeasurementDeviceType::
    Calibrations (const Calibrations_type& x)
    {
      this->Calibrations_.set (x);
    }

    void MeasurementDeviceType::
    Calibrations (const Calibrations_optional& x)
    {
      this->Calibrations_ = x;
    }

    void MeasurementDeviceType::
    Calibrations (::std::auto_ptr< Calibrations_type > x)
    {
      this->Calibrations_.set (x);
    }

    const MeasurementDeviceType::InspectionTemperatures_optional& MeasurementDeviceType::
    InspectionTemperatures () const
    {
      return this->InspectionTemperatures_;
    }

    MeasurementDeviceType::InspectionTemperatures_optional& MeasurementDeviceType::
    InspectionTemperatures ()
    {
      return this->InspectionTemperatures_;
    }

    void MeasurementDeviceType::
    InspectionTemperatures (const InspectionTemperatures_type& x)
    {
      this->InspectionTemperatures_.set (x);
    }

    void MeasurementDeviceType::
    InspectionTemperatures (const InspectionTemperatures_optional& x)
    {
      this->InspectionTemperatures_ = x;
    }

    void MeasurementDeviceType::
    InspectionTemperatures (::std::auto_ptr< InspectionTemperatures_type > x)
    {
      this->InspectionTemperatures_.set (x);
    }


    // CalibrationMasterType
    // 

    const CalibrationMasterType::SerialNumber_type& CalibrationMasterType::
    SerialNumber () const
    {
      return this->SerialNumber_.get ();
    }

    CalibrationMasterType::SerialNumber_type& CalibrationMasterType::
    SerialNumber ()
    {
      return this->SerialNumber_.get ();
    }

    void CalibrationMasterType::
    SerialNumber (const SerialNumber_type& x)
    {
      this->SerialNumber_.set (x);
    }

    void CalibrationMasterType::
    SerialNumber (::std::auto_ptr< SerialNumber_type > x)
    {
      this->SerialNumber_.set (x);
    }

    const CalibrationMasterType::description_optional& CalibrationMasterType::
    description () const
    {
      return this->description_;
    }

    CalibrationMasterType::description_optional& CalibrationMasterType::
    description ()
    {
      return this->description_;
    }

    void CalibrationMasterType::
    description (const description_type& x)
    {
      this->description_.set (x);
    }

    void CalibrationMasterType::
    description (const description_optional& x)
    {
      this->description_ = x;
    }

    void CalibrationMasterType::
    description (::std::auto_ptr< description_type > x)
    {
      this->description_.set (x);
    }


    // CalibrationType
    // 

    const CalibrationType::CalibrationMaster_optional& CalibrationType::
    CalibrationMaster () const
    {
      return this->CalibrationMaster_;
    }

    CalibrationType::CalibrationMaster_optional& CalibrationType::
    CalibrationMaster ()
    {
      return this->CalibrationMaster_;
    }

    void CalibrationType::
    CalibrationMaster (const CalibrationMaster_type& x)
    {
      this->CalibrationMaster_.set (x);
    }

    void CalibrationType::
    CalibrationMaster (const CalibrationMaster_optional& x)
    {
      this->CalibrationMaster_ = x;
    }

    void CalibrationType::
    CalibrationMaster (::std::auto_ptr< CalibrationMaster_type > x)
    {
      this->CalibrationMaster_.set (x);
    }

    const CalibrationType::Temperatures_type& CalibrationType::
    Temperatures () const
    {
      return this->Temperatures_.get ();
    }

    CalibrationType::Temperatures_type& CalibrationType::
    Temperatures ()
    {
      return this->Temperatures_.get ();
    }

    void CalibrationType::
    Temperatures (const Temperatures_type& x)
    {
      this->Temperatures_.set (x);
    }

    void CalibrationType::
    Temperatures (::std::auto_ptr< Temperatures_type > x)
    {
      this->Temperatures_.set (x);
    }

    const CalibrationType::TimeStamp_type& CalibrationType::
    TimeStamp () const
    {
      return this->TimeStamp_.get ();
    }

    CalibrationType::TimeStamp_type& CalibrationType::
    TimeStamp ()
    {
      return this->TimeStamp_.get ();
    }

    void CalibrationType::
    TimeStamp (const TimeStamp_type& x)
    {
      this->TimeStamp_.set (x);
    }

    void CalibrationType::
    TimeStamp (::std::auto_ptr< TimeStamp_type > x)
    {
      this->TimeStamp_.set (x);
    }


    // CalibrationsType
    // 

    const CalibrationsType::Calibration_sequence& CalibrationsType::
    Calibration () const
    {
      return this->Calibration_;
    }

    CalibrationsType::Calibration_sequence& CalibrationsType::
    Calibration ()
    {
      return this->Calibration_;
    }

    void CalibrationsType::
    Calibration (const Calibration_sequence& s)
    {
      this->Calibration_ = s;
    }


    // TemperaturesType
    // 

    const TemperaturesType::Temperature_sequence& TemperaturesType::
    Temperature () const
    {
      return this->Temperature_;
    }

    TemperaturesType::Temperature_sequence& TemperaturesType::
    Temperature ()
    {
      return this->Temperature_;
    }

    void TemperaturesType::
    Temperature (const Temperature_sequence& s)
    {
      this->Temperature_ = s;
    }


    // TemperatureType
    // 

    const TemperatureType::Attributes_optional& TemperatureType::
    Attributes () const
    {
      return this->Attributes_;
    }

    TemperatureType::Attributes_optional& TemperatureType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void TemperatureType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void TemperatureType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void TemperatureType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const TemperatureType::Temperature_type& TemperatureType::
    Temperature () const
    {
      return this->Temperature_.get ();
    }

    TemperatureType::Temperature_type& TemperatureType::
    Temperature ()
    {
      return this->Temperature_.get ();
    }

    void TemperatureType::
    Temperature (const Temperature_type& x)
    {
      this->Temperature_.set (x);
    }

    void TemperatureType::
    Temperature (::std::auto_ptr< Temperature_type > x)
    {
      this->Temperature_.set (x);
    }

    const TemperatureType::TimeStamp_type& TemperatureType::
    TimeStamp () const
    {
      return this->TimeStamp_.get ();
    }

    TemperatureType::TimeStamp_type& TemperatureType::
    TimeStamp ()
    {
      return this->TimeStamp_.get ();
    }

    void TemperatureType::
    TimeStamp (const TimeStamp_type& x)
    {
      this->TimeStamp_.set (x);
    }

    void TemperatureType::
    TimeStamp (::std::auto_ptr< TimeStamp_type > x)
    {
      this->TimeStamp_.set (x);
    }


    // QualificationsType
    // 

    const QualificationsType::Qualification_sequence& QualificationsType::
    Qualification () const
    {
      return this->Qualification_;
    }

    QualificationsType::Qualification_sequence& QualificationsType::
    Qualification ()
    {
      return this->Qualification_;
    }

    void QualificationsType::
    Qualification (const Qualification_sequence& s)
    {
      this->Qualification_ = s;
    }


    // QualificationType
    // 

    const QualificationType::Attributes_optional& QualificationType::
    Attributes () const
    {
      return this->Attributes_;
    }

    QualificationType::Attributes_optional& QualificationType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void QualificationType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void QualificationType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void QualificationType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const QualificationType::Description_type& QualificationType::
    Description () const
    {
      return this->Description_.get ();
    }

    QualificationType::Description_type& QualificationType::
    Description ()
    {
      return this->Description_.get ();
    }

    void QualificationType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void QualificationType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }


    // SensorType
    // 

    const SensorType::Qualifications_type& SensorType::
    Qualifications () const
    {
      return this->Qualifications_.get ();
    }

    SensorType::Qualifications_type& SensorType::
    Qualifications ()
    {
      return this->Qualifications_.get ();
    }

    void SensorType::
    Qualifications (const Qualifications_type& x)
    {
      this->Qualifications_.set (x);
    }

    void SensorType::
    Qualifications (::std::auto_ptr< Qualifications_type > x)
    {
      this->Qualifications_.set (x);
    }

    const SensorType::AAngle_optional& SensorType::
    AAngle () const
    {
      return this->AAngle_;
    }

    SensorType::AAngle_optional& SensorType::
    AAngle ()
    {
      return this->AAngle_;
    }

    void SensorType::
    AAngle (const AAngle_type& x)
    {
      this->AAngle_.set (x);
    }

    void SensorType::
    AAngle (const AAngle_optional& x)
    {
      this->AAngle_ = x;
    }

    void SensorType::
    AAngle (::std::auto_ptr< AAngle_type > x)
    {
      this->AAngle_.set (x);
    }

    const SensorType::BAngle_optional& SensorType::
    BAngle () const
    {
      return this->BAngle_;
    }

    SensorType::BAngle_optional& SensorType::
    BAngle ()
    {
      return this->BAngle_;
    }

    void SensorType::
    BAngle (const BAngle_type& x)
    {
      this->BAngle_.set (x);
    }

    void SensorType::
    BAngle (const BAngle_optional& x)
    {
      this->BAngle_ = x;
    }

    void SensorType::
    BAngle (::std::auto_ptr< BAngle_type > x)
    {
      this->BAngle_.set (x);
    }


    // TouchProbeType
    // 

    const TouchProbeType::TipDiameter_type& TouchProbeType::
    TipDiameter () const
    {
      return this->TipDiameter_.get ();
    }

    TouchProbeType::TipDiameter_type& TouchProbeType::
    TipDiameter ()
    {
      return this->TipDiameter_.get ();
    }

    void TouchProbeType::
    TipDiameter (const TipDiameter_type& x)
    {
      this->TipDiameter_.set (x);
    }

    void TouchProbeType::
    TipDiameter (::std::auto_ptr< TipDiameter_type > x)
    {
      this->TipDiameter_.set (x);
    }


    // ToolType
    // 

    const ToolType::SensorIds_optional& ToolType::
    SensorIds () const
    {
      return this->SensorIds_;
    }

    ToolType::SensorIds_optional& ToolType::
    SensorIds ()
    {
      return this->SensorIds_;
    }

    void ToolType::
    SensorIds (const SensorIds_type& x)
    {
      this->SensorIds_.set (x);
    }

    void ToolType::
    SensorIds (const SensorIds_optional& x)
    {
      this->SensorIds_ = x;
    }

    void ToolType::
    SensorIds (::std::auto_ptr< SensorIds_type > x)
    {
      this->SensorIds_.set (x);
    }


    // CarriageType
    // 

    const CarriageType::ToolIds_optional& CarriageType::
    ToolIds () const
    {
      return this->ToolIds_;
    }

    CarriageType::ToolIds_optional& CarriageType::
    ToolIds ()
    {
      return this->ToolIds_;
    }

    void CarriageType::
    ToolIds (const ToolIds_type& x)
    {
      this->ToolIds_.set (x);
    }

    void CarriageType::
    ToolIds (const ToolIds_optional& x)
    {
      this->ToolIds_ = x;
    }

    void CarriageType::
    ToolIds (::std::auto_ptr< ToolIds_type > x)
    {
      this->ToolIds_.set (x);
    }


    // ProbingDeviceType
    // 

    const ProbingDeviceType::WorkingVolume_optional& ProbingDeviceType::
    WorkingVolume () const
    {
      return this->WorkingVolume_;
    }

    ProbingDeviceType::WorkingVolume_optional& ProbingDeviceType::
    WorkingVolume ()
    {
      return this->WorkingVolume_;
    }

    void ProbingDeviceType::
    WorkingVolume (const WorkingVolume_type& x)
    {
      this->WorkingVolume_.set (x);
    }

    void ProbingDeviceType::
    WorkingVolume (const WorkingVolume_optional& x)
    {
      this->WorkingVolume_ = x;
    }

    void ProbingDeviceType::
    WorkingVolume (::std::auto_ptr< WorkingVolume_type > x)
    {
      this->WorkingVolume_.set (x);
    }

    const ProbingDeviceType::EffectiveWorkingVolume_optional& ProbingDeviceType::
    EffectiveWorkingVolume () const
    {
      return this->EffectiveWorkingVolume_;
    }

    ProbingDeviceType::EffectiveWorkingVolume_optional& ProbingDeviceType::
    EffectiveWorkingVolume ()
    {
      return this->EffectiveWorkingVolume_;
    }

    void ProbingDeviceType::
    EffectiveWorkingVolume (const EffectiveWorkingVolume_type& x)
    {
      this->EffectiveWorkingVolume_.set (x);
    }

    void ProbingDeviceType::
    EffectiveWorkingVolume (const EffectiveWorkingVolume_optional& x)
    {
      this->EffectiveWorkingVolume_ = x;
    }

    void ProbingDeviceType::
    EffectiveWorkingVolume (::std::auto_ptr< EffectiveWorkingVolume_type > x)
    {
      this->EffectiveWorkingVolume_.set (x);
    }

    const ProbingDeviceType::Resolution_optional& ProbingDeviceType::
    Resolution () const
    {
      return this->Resolution_;
    }

    ProbingDeviceType::Resolution_optional& ProbingDeviceType::
    Resolution ()
    {
      return this->Resolution_;
    }

    void ProbingDeviceType::
    Resolution (const Resolution_type& x)
    {
      this->Resolution_.set (x);
    }

    void ProbingDeviceType::
    Resolution (const Resolution_optional& x)
    {
      this->Resolution_ = x;
    }

    void ProbingDeviceType::
    Resolution (::std::auto_ptr< Resolution_type > x)
    {
      this->Resolution_.set (x);
    }


    // CMMType
    // 

    const CMMType::HomeLocation_optional& CMMType::
    HomeLocation () const
    {
      return this->HomeLocation_;
    }

    CMMType::HomeLocation_optional& CMMType::
    HomeLocation ()
    {
      return this->HomeLocation_;
    }

    void CMMType::
    HomeLocation (const HomeLocation_type& x)
    {
      this->HomeLocation_.set (x);
    }

    void CMMType::
    HomeLocation (const HomeLocation_optional& x)
    {
      this->HomeLocation_ = x;
    }

    void CMMType::
    HomeLocation (::std::auto_ptr< HomeLocation_type > x)
    {
      this->HomeLocation_.set (x);
    }

    const CMMType::MachineGeometry_optional& CMMType::
    MachineGeometry () const
    {
      return this->MachineGeometry_;
    }

    CMMType::MachineGeometry_optional& CMMType::
    MachineGeometry ()
    {
      return this->MachineGeometry_;
    }

    void CMMType::
    MachineGeometry (const MachineGeometry_type& x)
    {
      this->MachineGeometry_.set (x);
    }

    void CMMType::
    MachineGeometry (const MachineGeometry_optional& x)
    {
      this->MachineGeometry_ = x;
    }

    void CMMType::
    MachineGeometry (::std::auto_ptr< MachineGeometry_type > x)
    {
      this->MachineGeometry_.set (x);
    }

    const CMMType::AxisOrientation_optional& CMMType::
    AxisOrientation () const
    {
      return this->AxisOrientation_;
    }

    CMMType::AxisOrientation_optional& CMMType::
    AxisOrientation ()
    {
      return this->AxisOrientation_;
    }

    void CMMType::
    AxisOrientation (const AxisOrientation_type& x)
    {
      this->AxisOrientation_.set (x);
    }

    void CMMType::
    AxisOrientation (const AxisOrientation_optional& x)
    {
      this->AxisOrientation_ = x;
    }

    void CMMType::
    AxisOrientation (::std::auto_ptr< AxisOrientation_type > x)
    {
      this->AxisOrientation_.set (x);
    }

    const CMMType::CMMScales_optional& CMMType::
    CMMScales () const
    {
      return this->CMMScales_;
    }

    CMMType::CMMScales_optional& CMMType::
    CMMScales ()
    {
      return this->CMMScales_;
    }

    void CMMType::
    CMMScales (const CMMScales_type& x)
    {
      this->CMMScales_.set (x);
    }

    void CMMType::
    CMMScales (const CMMScales_optional& x)
    {
      this->CMMScales_ = x;
    }

    void CMMType::
    CMMScales (::std::auto_ptr< CMMScales_type > x)
    {
      this->CMMScales_.set (x);
    }

    const CMMType::MaxWorkpieceHeight_optional& CMMType::
    MaxWorkpieceHeight () const
    {
      return this->MaxWorkpieceHeight_;
    }

    CMMType::MaxWorkpieceHeight_optional& CMMType::
    MaxWorkpieceHeight ()
    {
      return this->MaxWorkpieceHeight_;
    }

    void CMMType::
    MaxWorkpieceHeight (const MaxWorkpieceHeight_type& x)
    {
      this->MaxWorkpieceHeight_.set (x);
    }

    void CMMType::
    MaxWorkpieceHeight (const MaxWorkpieceHeight_optional& x)
    {
      this->MaxWorkpieceHeight_ = x;
    }

    void CMMType::
    MaxWorkpieceHeight (::std::auto_ptr< MaxWorkpieceHeight_type > x)
    {
      this->MaxWorkpieceHeight_.set (x);
    }

    const CMMType::MaxWorkpieceMass_optional& CMMType::
    MaxWorkpieceMass () const
    {
      return this->MaxWorkpieceMass_;
    }

    CMMType::MaxWorkpieceMass_optional& CMMType::
    MaxWorkpieceMass ()
    {
      return this->MaxWorkpieceMass_;
    }

    void CMMType::
    MaxWorkpieceMass (const MaxWorkpieceMass_type& x)
    {
      this->MaxWorkpieceMass_.set (x);
    }

    void CMMType::
    MaxWorkpieceMass (const MaxWorkpieceMass_optional& x)
    {
      this->MaxWorkpieceMass_ = x;
    }

    void CMMType::
    MaxWorkpieceMass (::std::auto_ptr< MaxWorkpieceMass_type > x)
    {
      this->MaxWorkpieceMass_.set (x);
    }

    const CMMType::JoystickSpeeds_optional& CMMType::
    JoystickSpeeds () const
    {
      return this->JoystickSpeeds_;
    }

    CMMType::JoystickSpeeds_optional& CMMType::
    JoystickSpeeds ()
    {
      return this->JoystickSpeeds_;
    }

    void CMMType::
    JoystickSpeeds (const JoystickSpeeds_type& x)
    {
      this->JoystickSpeeds_.set (x);
    }

    void CMMType::
    JoystickSpeeds (const JoystickSpeeds_optional& x)
    {
      this->JoystickSpeeds_ = x;
    }

    void CMMType::
    JoystickSpeeds (::std::auto_ptr< JoystickSpeeds_type > x)
    {
      this->JoystickSpeeds_.set (x);
    }

    const CMMType::CNCSpeeds_optional& CMMType::
    CNCSpeeds () const
    {
      return this->CNCSpeeds_;
    }

    CMMType::CNCSpeeds_optional& CMMType::
    CNCSpeeds ()
    {
      return this->CNCSpeeds_;
    }

    void CMMType::
    CNCSpeeds (const CNCSpeeds_type& x)
    {
      this->CNCSpeeds_.set (x);
    }

    void CMMType::
    CNCSpeeds (const CNCSpeeds_optional& x)
    {
      this->CNCSpeeds_ = x;
    }

    void CMMType::
    CNCSpeeds (::std::auto_ptr< CNCSpeeds_type > x)
    {
      this->CNCSpeeds_.set (x);
    }

    const CMMType::RotaryTable_optional& CMMType::
    RotaryTable () const
    {
      return this->RotaryTable_;
    }

    CMMType::RotaryTable_optional& CMMType::
    RotaryTable ()
    {
      return this->RotaryTable_;
    }

    void CMMType::
    RotaryTable (const RotaryTable_type& x)
    {
      this->RotaryTable_.set (x);
    }

    void CMMType::
    RotaryTable (const RotaryTable_optional& x)
    {
      this->RotaryTable_ = x;
    }

    void CMMType::
    RotaryTable (::std::auto_ptr< RotaryTable_type > x)
    {
      this->RotaryTable_.set (x);
    }

    const CMMType::NominalAccuracy_optional& CMMType::
    NominalAccuracy () const
    {
      return this->NominalAccuracy_;
    }

    CMMType::NominalAccuracy_optional& CMMType::
    NominalAccuracy ()
    {
      return this->NominalAccuracy_;
    }

    void CMMType::
    NominalAccuracy (const NominalAccuracy_type& x)
    {
      this->NominalAccuracy_.set (x);
    }

    void CMMType::
    NominalAccuracy (const NominalAccuracy_optional& x)
    {
      this->NominalAccuracy_ = x;
    }

    void CMMType::
    NominalAccuracy (::std::auto_ptr< NominalAccuracy_type > x)
    {
      this->NominalAccuracy_.set (x);
    }

    const CMMType::ActualAccuracy_optional& CMMType::
    ActualAccuracy () const
    {
      return this->ActualAccuracy_;
    }

    CMMType::ActualAccuracy_optional& CMMType::
    ActualAccuracy ()
    {
      return this->ActualAccuracy_;
    }

    void CMMType::
    ActualAccuracy (const ActualAccuracy_type& x)
    {
      this->ActualAccuracy_.set (x);
    }

    void CMMType::
    ActualAccuracy (const ActualAccuracy_optional& x)
    {
      this->ActualAccuracy_ = x;
    }

    void CMMType::
    ActualAccuracy (::std::auto_ptr< ActualAccuracy_type > x)
    {
      this->ActualAccuracy_.set (x);
    }

    const CMMType::CarriageIds_optional& CMMType::
    CarriageIds () const
    {
      return this->CarriageIds_;
    }

    CMMType::CarriageIds_optional& CMMType::
    CarriageIds ()
    {
      return this->CarriageIds_;
    }

    void CMMType::
    CarriageIds (const CarriageIds_type& x)
    {
      this->CarriageIds_.set (x);
    }

    void CMMType::
    CarriageIds (const CarriageIds_optional& x)
    {
      this->CarriageIds_ = x;
    }

    void CMMType::
    CarriageIds (::std::auto_ptr< CarriageIds_type > x)
    {
      this->CarriageIds_.set (x);
    }

    const CMMType::ToolIds_optional& CMMType::
    ToolIds () const
    {
      return this->ToolIds_;
    }

    CMMType::ToolIds_optional& CMMType::
    ToolIds ()
    {
      return this->ToolIds_;
    }

    void CMMType::
    ToolIds (const ToolIds_type& x)
    {
      this->ToolIds_.set (x);
    }

    void CMMType::
    ToolIds (const ToolIds_optional& x)
    {
      this->ToolIds_ = x;
    }

    void CMMType::
    ToolIds (::std::auto_ptr< ToolIds_type > x)
    {
      this->ToolIds_.set (x);
    }


    // CMMScalesType
    // 

    const CMMScalesType::XScale_type& CMMScalesType::
    XScale () const
    {
      return this->XScale_.get ();
    }

    CMMScalesType::XScale_type& CMMScalesType::
    XScale ()
    {
      return this->XScale_.get ();
    }

    void CMMScalesType::
    XScale (const XScale_type& x)
    {
      this->XScale_.set (x);
    }

    void CMMScalesType::
    XScale (::std::auto_ptr< XScale_type > x)
    {
      this->XScale_.set (x);
    }

    const CMMScalesType::YScale_type& CMMScalesType::
    YScale () const
    {
      return this->YScale_.get ();
    }

    CMMScalesType::YScale_type& CMMScalesType::
    YScale ()
    {
      return this->YScale_.get ();
    }

    void CMMScalesType::
    YScale (const YScale_type& x)
    {
      this->YScale_.set (x);
    }

    void CMMScalesType::
    YScale (::std::auto_ptr< YScale_type > x)
    {
      this->YScale_.set (x);
    }

    const CMMScalesType::ZScale_type& CMMScalesType::
    ZScale () const
    {
      return this->ZScale_.get ();
    }

    CMMScalesType::ZScale_type& CMMScalesType::
    ZScale ()
    {
      return this->ZScale_.get ();
    }

    void CMMScalesType::
    ZScale (const ZScale_type& x)
    {
      this->ZScale_.set (x);
    }

    void CMMScalesType::
    ZScale (::std::auto_ptr< ZScale_type > x)
    {
      this->ZScale_.set (x);
    }


    // CMMScaleType
    // 

    const CMMScaleType::ScaleMaterial_type& CMMScaleType::
    ScaleMaterial () const
    {
      return this->ScaleMaterial_.get ();
    }

    CMMScaleType::ScaleMaterial_type& CMMScaleType::
    ScaleMaterial ()
    {
      return this->ScaleMaterial_.get ();
    }

    void CMMScaleType::
    ScaleMaterial (const ScaleMaterial_type& x)
    {
      this->ScaleMaterial_.set (x);
    }

    void CMMScaleType::
    ScaleMaterial (::std::auto_ptr< ScaleMaterial_type > x)
    {
      this->ScaleMaterial_.set (x);
    }

    const CMMScaleType::ScaleCoefficientOfExpansion_type& CMMScaleType::
    ScaleCoefficientOfExpansion () const
    {
      return this->ScaleCoefficientOfExpansion_.get ();
    }

    CMMScaleType::ScaleCoefficientOfExpansion_type& CMMScaleType::
    ScaleCoefficientOfExpansion ()
    {
      return this->ScaleCoefficientOfExpansion_.get ();
    }

    void CMMScaleType::
    ScaleCoefficientOfExpansion (const ScaleCoefficientOfExpansion_type& x)
    {
      this->ScaleCoefficientOfExpansion_.set (x);
    }

    const CMMScaleType::ScaleCoefficientOfExpansionUncertainty_type& CMMScaleType::
    ScaleCoefficientOfExpansionUncertainty () const
    {
      return this->ScaleCoefficientOfExpansionUncertainty_.get ();
    }

    CMMScaleType::ScaleCoefficientOfExpansionUncertainty_type& CMMScaleType::
    ScaleCoefficientOfExpansionUncertainty ()
    {
      return this->ScaleCoefficientOfExpansionUncertainty_.get ();
    }

    void CMMScaleType::
    ScaleCoefficientOfExpansionUncertainty (const ScaleCoefficientOfExpansionUncertainty_type& x)
    {
      this->ScaleCoefficientOfExpansionUncertainty_.set (x);
    }

    const CMMScaleType::TypeOfScale_type& CMMScaleType::
    TypeOfScale () const
    {
      return this->TypeOfScale_.get ();
    }

    CMMScaleType::TypeOfScale_type& CMMScaleType::
    TypeOfScale ()
    {
      return this->TypeOfScale_.get ();
    }

    void CMMScaleType::
    TypeOfScale (const TypeOfScale_type& x)
    {
      this->TypeOfScale_.set (x);
    }

    void CMMScaleType::
    TypeOfScale (::std::auto_ptr< TypeOfScale_type > x)
    {
      this->TypeOfScale_.set (x);
    }

    const CMMScaleType::ScaleResolution_type& CMMScaleType::
    ScaleResolution () const
    {
      return this->ScaleResolution_.get ();
    }

    CMMScaleType::ScaleResolution_type& CMMScaleType::
    ScaleResolution ()
    {
      return this->ScaleResolution_.get ();
    }

    void CMMScaleType::
    ScaleResolution (const ScaleResolution_type& x)
    {
      this->ScaleResolution_.set (x);
    }

    void CMMScaleType::
    ScaleResolution (::std::auto_ptr< ScaleResolution_type > x)
    {
      this->ScaleResolution_.set (x);
    }


    // CMMSpeedsType
    // 

    const CMMSpeedsType::MaxXTraverseSpeed_type& CMMSpeedsType::
    MaxXTraverseSpeed () const
    {
      return this->MaxXTraverseSpeed_.get ();
    }

    CMMSpeedsType::MaxXTraverseSpeed_type& CMMSpeedsType::
    MaxXTraverseSpeed ()
    {
      return this->MaxXTraverseSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxXTraverseSpeed (const MaxXTraverseSpeed_type& x)
    {
      this->MaxXTraverseSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxXTraverseSpeed (::std::auto_ptr< MaxXTraverseSpeed_type > x)
    {
      this->MaxXTraverseSpeed_.set (x);
    }

    const CMMSpeedsType::MaxYTraverseSpeed_type& CMMSpeedsType::
    MaxYTraverseSpeed () const
    {
      return this->MaxYTraverseSpeed_.get ();
    }

    CMMSpeedsType::MaxYTraverseSpeed_type& CMMSpeedsType::
    MaxYTraverseSpeed ()
    {
      return this->MaxYTraverseSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxYTraverseSpeed (const MaxYTraverseSpeed_type& x)
    {
      this->MaxYTraverseSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxYTraverseSpeed (::std::auto_ptr< MaxYTraverseSpeed_type > x)
    {
      this->MaxYTraverseSpeed_.set (x);
    }

    const CMMSpeedsType::MaxZTraverseSpeed_type& CMMSpeedsType::
    MaxZTraverseSpeed () const
    {
      return this->MaxZTraverseSpeed_.get ();
    }

    CMMSpeedsType::MaxZTraverseSpeed_type& CMMSpeedsType::
    MaxZTraverseSpeed ()
    {
      return this->MaxZTraverseSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxZTraverseSpeed (const MaxZTraverseSpeed_type& x)
    {
      this->MaxZTraverseSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxZTraverseSpeed (::std::auto_ptr< MaxZTraverseSpeed_type > x)
    {
      this->MaxZTraverseSpeed_.set (x);
    }

    const CMMSpeedsType::MaxXProbingSpeed_type& CMMSpeedsType::
    MaxXProbingSpeed () const
    {
      return this->MaxXProbingSpeed_.get ();
    }

    CMMSpeedsType::MaxXProbingSpeed_type& CMMSpeedsType::
    MaxXProbingSpeed ()
    {
      return this->MaxXProbingSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxXProbingSpeed (const MaxXProbingSpeed_type& x)
    {
      this->MaxXProbingSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxXProbingSpeed (::std::auto_ptr< MaxXProbingSpeed_type > x)
    {
      this->MaxXProbingSpeed_.set (x);
    }

    const CMMSpeedsType::MaxYProbingSpeed_type& CMMSpeedsType::
    MaxYProbingSpeed () const
    {
      return this->MaxYProbingSpeed_.get ();
    }

    CMMSpeedsType::MaxYProbingSpeed_type& CMMSpeedsType::
    MaxYProbingSpeed ()
    {
      return this->MaxYProbingSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxYProbingSpeed (const MaxYProbingSpeed_type& x)
    {
      this->MaxYProbingSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxYProbingSpeed (::std::auto_ptr< MaxYProbingSpeed_type > x)
    {
      this->MaxYProbingSpeed_.set (x);
    }

    const CMMSpeedsType::MaxZProbingSpeed_type& CMMSpeedsType::
    MaxZProbingSpeed () const
    {
      return this->MaxZProbingSpeed_.get ();
    }

    CMMSpeedsType::MaxZProbingSpeed_type& CMMSpeedsType::
    MaxZProbingSpeed ()
    {
      return this->MaxZProbingSpeed_.get ();
    }

    void CMMSpeedsType::
    MaxZProbingSpeed (const MaxZProbingSpeed_type& x)
    {
      this->MaxZProbingSpeed_.set (x);
    }

    void CMMSpeedsType::
    MaxZProbingSpeed (::std::auto_ptr< MaxZProbingSpeed_type > x)
    {
      this->MaxZProbingSpeed_.set (x);
    }


    // GageDeviceType
    // 


    // ManualDeviceType
    // 


    // CaliperType
    // 

    const CaliperType::Resolution_optional& CaliperType::
    Resolution () const
    {
      return this->Resolution_;
    }

    CaliperType::Resolution_optional& CaliperType::
    Resolution ()
    {
      return this->Resolution_;
    }

    void CaliperType::
    Resolution (const Resolution_type& x)
    {
      this->Resolution_.set (x);
    }

    void CaliperType::
    Resolution (const Resolution_optional& x)
    {
      this->Resolution_ = x;
    }

    void CaliperType::
    Resolution (::std::auto_ptr< Resolution_type > x)
    {
      this->Resolution_.set (x);
    }

    const CaliperType::Accuracy_optional& CaliperType::
    Accuracy () const
    {
      return this->Accuracy_;
    }

    CaliperType::Accuracy_optional& CaliperType::
    Accuracy ()
    {
      return this->Accuracy_;
    }

    void CaliperType::
    Accuracy (const Accuracy_type& x)
    {
      this->Accuracy_.set (x);
    }

    void CaliperType::
    Accuracy (const Accuracy_optional& x)
    {
      this->Accuracy_ = x;
    }

    void CaliperType::
    Accuracy (::std::auto_ptr< Accuracy_type > x)
    {
      this->Accuracy_.set (x);
    }

    const CaliperType::MinMeasurement_optional& CaliperType::
    MinMeasurement () const
    {
      return this->MinMeasurement_;
    }

    CaliperType::MinMeasurement_optional& CaliperType::
    MinMeasurement ()
    {
      return this->MinMeasurement_;
    }

    void CaliperType::
    MinMeasurement (const MinMeasurement_type& x)
    {
      this->MinMeasurement_.set (x);
    }

    void CaliperType::
    MinMeasurement (const MinMeasurement_optional& x)
    {
      this->MinMeasurement_ = x;
    }

    void CaliperType::
    MinMeasurement (::std::auto_ptr< MinMeasurement_type > x)
    {
      this->MinMeasurement_.set (x);
    }

    const CaliperType::MaxMeasurement_optional& CaliperType::
    MaxMeasurement () const
    {
      return this->MaxMeasurement_;
    }

    CaliperType::MaxMeasurement_optional& CaliperType::
    MaxMeasurement ()
    {
      return this->MaxMeasurement_;
    }

    void CaliperType::
    MaxMeasurement (const MaxMeasurement_type& x)
    {
      this->MaxMeasurement_.set (x);
    }

    void CaliperType::
    MaxMeasurement (const MaxMeasurement_optional& x)
    {
      this->MaxMeasurement_ = x;
    }

    void CaliperType::
    MaxMeasurement (::std::auto_ptr< MaxMeasurement_type > x)
    {
      this->MaxMeasurement_.set (x);
    }

    const CaliperType::CanMeasureInnerD_optional& CaliperType::
    CanMeasureInnerD () const
    {
      return this->CanMeasureInnerD_;
    }

    CaliperType::CanMeasureInnerD_optional& CaliperType::
    CanMeasureInnerD ()
    {
      return this->CanMeasureInnerD_;
    }

    void CaliperType::
    CanMeasureInnerD (const CanMeasureInnerD_type& x)
    {
      this->CanMeasureInnerD_.set (x);
    }

    void CaliperType::
    CanMeasureInnerD (const CanMeasureInnerD_optional& x)
    {
      this->CanMeasureInnerD_ = x;
    }

    const CaliperType::CanMeasureOuterD_optional& CaliperType::
    CanMeasureOuterD () const
    {
      return this->CanMeasureOuterD_;
    }

    CaliperType::CanMeasureOuterD_optional& CaliperType::
    CanMeasureOuterD ()
    {
      return this->CanMeasureOuterD_;
    }

    void CaliperType::
    CanMeasureOuterD (const CanMeasureOuterD_type& x)
    {
      this->CanMeasureOuterD_.set (x);
    }

    void CaliperType::
    CanMeasureOuterD (const CanMeasureOuterD_optional& x)
    {
      this->CanMeasureOuterD_ = x;
    }

    const CaliperType::CanMeasureDepth_optional& CaliperType::
    CanMeasureDepth () const
    {
      return this->CanMeasureDepth_;
    }

    CaliperType::CanMeasureDepth_optional& CaliperType::
    CanMeasureDepth ()
    {
      return this->CanMeasureDepth_;
    }

    void CaliperType::
    CanMeasureDepth (const CanMeasureDepth_type& x)
    {
      this->CanMeasureDepth_.set (x);
    }

    void CaliperType::
    CanMeasureDepth (const CanMeasureDepth_optional& x)
    {
      this->CanMeasureDepth_ = x;
    }


    // CMMDirectionEnumType
    // 

    CMMDirectionEnumType::
    CMMDirectionEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CMMDirectionEnumType_literals_[v])
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const CMMDirectionEnumType& v,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CMMDirectionEnumType& CMMDirectionEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CMMDirectionEnumType_literals_[v]);

      return *this;
    }


    // CMMGeometryType
    // 

    const CMMGeometryType::CMMGeometryEnum_optional& CMMGeometryType::
    CMMGeometryEnum () const
    {
      return this->CMMGeometryEnum_;
    }

    CMMGeometryType::CMMGeometryEnum_optional& CMMGeometryType::
    CMMGeometryEnum ()
    {
      return this->CMMGeometryEnum_;
    }

    void CMMGeometryType::
    CMMGeometryEnum (const CMMGeometryEnum_type& x)
    {
      this->CMMGeometryEnum_.set (x);
    }

    void CMMGeometryType::
    CMMGeometryEnum (const CMMGeometryEnum_optional& x)
    {
      this->CMMGeometryEnum_ = x;
    }

    void CMMGeometryType::
    CMMGeometryEnum (::std::auto_ptr< CMMGeometryEnum_type > x)
    {
      this->CMMGeometryEnum_.set (x);
    }

    const CMMGeometryType::OtherCMMGeometry_optional& CMMGeometryType::
    OtherCMMGeometry () const
    {
      return this->OtherCMMGeometry_;
    }

    CMMGeometryType::OtherCMMGeometry_optional& CMMGeometryType::
    OtherCMMGeometry ()
    {
      return this->OtherCMMGeometry_;
    }

    void CMMGeometryType::
    OtherCMMGeometry (const OtherCMMGeometry_type& x)
    {
      this->OtherCMMGeometry_.set (x);
    }

    void CMMGeometryType::
    OtherCMMGeometry (const OtherCMMGeometry_optional& x)
    {
      this->OtherCMMGeometry_ = x;
    }

    void CMMGeometryType::
    OtherCMMGeometry (::std::auto_ptr< OtherCMMGeometry_type > x)
    {
      this->OtherCMMGeometry_.set (x);
    }


    // CMMGeometryEnumType
    // 

    CMMGeometryEnumType::
    CMMGeometryEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_CMMGeometryEnumType_literals_[v])
    {
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const CMMGeometryEnumType& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    CMMGeometryEnumType& CMMGeometryEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_CMMGeometryEnumType_literals_[v]);

      return *this;
    }


    // CMMAxisDirectionsType
    // 

    const CMMAxisDirectionsType::XAxisDirection_type& CMMAxisDirectionsType::
    XAxisDirection () const
    {
      return this->XAxisDirection_.get ();
    }

    CMMAxisDirectionsType::XAxisDirection_type& CMMAxisDirectionsType::
    XAxisDirection ()
    {
      return this->XAxisDirection_.get ();
    }

    void CMMAxisDirectionsType::
    XAxisDirection (const XAxisDirection_type& x)
    {
      this->XAxisDirection_.set (x);
    }

    void CMMAxisDirectionsType::
    XAxisDirection (::std::auto_ptr< XAxisDirection_type > x)
    {
      this->XAxisDirection_.set (x);
    }

    const CMMAxisDirectionsType::YAxisDirection_type& CMMAxisDirectionsType::
    YAxisDirection () const
    {
      return this->YAxisDirection_.get ();
    }

    CMMAxisDirectionsType::YAxisDirection_type& CMMAxisDirectionsType::
    YAxisDirection ()
    {
      return this->YAxisDirection_.get ();
    }

    void CMMAxisDirectionsType::
    YAxisDirection (const YAxisDirection_type& x)
    {
      this->YAxisDirection_.set (x);
    }

    void CMMAxisDirectionsType::
    YAxisDirection (::std::auto_ptr< YAxisDirection_type > x)
    {
      this->YAxisDirection_.set (x);
    }

    const CMMAxisDirectionsType::ZAxisDirection_type& CMMAxisDirectionsType::
    ZAxisDirection () const
    {
      return this->ZAxisDirection_.get ();
    }

    CMMAxisDirectionsType::ZAxisDirection_type& CMMAxisDirectionsType::
    ZAxisDirection ()
    {
      return this->ZAxisDirection_.get ();
    }

    void CMMAxisDirectionsType::
    ZAxisDirection (const ZAxisDirection_type& x)
    {
      this->ZAxisDirection_.set (x);
    }

    void CMMAxisDirectionsType::
    ZAxisDirection (::std::auto_ptr< ZAxisDirection_type > x)
    {
      this->ZAxisDirection_.set (x);
    }


    // WorkingVolumeType
    // 

    const WorkingVolumeType::XAxisLength_type& WorkingVolumeType::
    XAxisLength () const
    {
      return this->XAxisLength_.get ();
    }

    WorkingVolumeType::XAxisLength_type& WorkingVolumeType::
    XAxisLength ()
    {
      return this->XAxisLength_.get ();
    }

    void WorkingVolumeType::
    XAxisLength (const XAxisLength_type& x)
    {
      this->XAxisLength_.set (x);
    }

    void WorkingVolumeType::
    XAxisLength (::std::auto_ptr< XAxisLength_type > x)
    {
      this->XAxisLength_.set (x);
    }

    const WorkingVolumeType::YAxisLength_type& WorkingVolumeType::
    YAxisLength () const
    {
      return this->YAxisLength_.get ();
    }

    WorkingVolumeType::YAxisLength_type& WorkingVolumeType::
    YAxisLength ()
    {
      return this->YAxisLength_.get ();
    }

    void WorkingVolumeType::
    YAxisLength (const YAxisLength_type& x)
    {
      this->YAxisLength_.set (x);
    }

    void WorkingVolumeType::
    YAxisLength (::std::auto_ptr< YAxisLength_type > x)
    {
      this->YAxisLength_.set (x);
    }

    const WorkingVolumeType::ZAxisLength_type& WorkingVolumeType::
    ZAxisLength () const
    {
      return this->ZAxisLength_.get ();
    }

    WorkingVolumeType::ZAxisLength_type& WorkingVolumeType::
    ZAxisLength ()
    {
      return this->ZAxisLength_.get ();
    }

    void WorkingVolumeType::
    ZAxisLength (const ZAxisLength_type& x)
    {
      this->ZAxisLength_.set (x);
    }

    void WorkingVolumeType::
    ZAxisLength (::std::auto_ptr< ZAxisLength_type > x)
    {
      this->ZAxisLength_.set (x);
    }


    // EffectiveWorkingVolumeType
    // 

    const EffectiveWorkingVolumeType::MinPoint_type& EffectiveWorkingVolumeType::
    MinPoint () const
    {
      return this->MinPoint_.get ();
    }

    EffectiveWorkingVolumeType::MinPoint_type& EffectiveWorkingVolumeType::
    MinPoint ()
    {
      return this->MinPoint_.get ();
    }

    void EffectiveWorkingVolumeType::
    MinPoint (const MinPoint_type& x)
    {
      this->MinPoint_.set (x);
    }

    void EffectiveWorkingVolumeType::
    MinPoint (::std::auto_ptr< MinPoint_type > x)
    {
      this->MinPoint_.set (x);
    }

    const EffectiveWorkingVolumeType::MaxPoint_type& EffectiveWorkingVolumeType::
    MaxPoint () const
    {
      return this->MaxPoint_.get ();
    }

    EffectiveWorkingVolumeType::MaxPoint_type& EffectiveWorkingVolumeType::
    MaxPoint ()
    {
      return this->MaxPoint_.get ();
    }

    void EffectiveWorkingVolumeType::
    MaxPoint (const MaxPoint_type& x)
    {
      this->MaxPoint_.set (x);
    }

    void EffectiveWorkingVolumeType::
    MaxPoint (::std::auto_ptr< MaxPoint_type > x)
    {
      this->MaxPoint_.set (x);
    }


    // RotaryTableType
    // 

    const RotaryTableType::LocationOnCMM_type& RotaryTableType::
    LocationOnCMM () const
    {
      return this->LocationOnCMM_.get ();
    }

    RotaryTableType::LocationOnCMM_type& RotaryTableType::
    LocationOnCMM ()
    {
      return this->LocationOnCMM_.get ();
    }

    void RotaryTableType::
    LocationOnCMM (const LocationOnCMM_type& x)
    {
      this->LocationOnCMM_.set (x);
    }

    void RotaryTableType::
    LocationOnCMM (::std::auto_ptr< LocationOnCMM_type > x)
    {
      this->LocationOnCMM_.set (x);
    }

    const RotaryTableType::AxisDirection_type& RotaryTableType::
    AxisDirection () const
    {
      return this->AxisDirection_.get ();
    }

    RotaryTableType::AxisDirection_type& RotaryTableType::
    AxisDirection ()
    {
      return this->AxisDirection_.get ();
    }

    void RotaryTableType::
    AxisDirection (const AxisDirection_type& x)
    {
      this->AxisDirection_.set (x);
    }

    void RotaryTableType::
    AxisDirection (::std::auto_ptr< AxisDirection_type > x)
    {
      this->AxisDirection_.set (x);
    }

    const RotaryTableType::ZeroIndexDirection_type& RotaryTableType::
    ZeroIndexDirection () const
    {
      return this->ZeroIndexDirection_.get ();
    }

    RotaryTableType::ZeroIndexDirection_type& RotaryTableType::
    ZeroIndexDirection ()
    {
      return this->ZeroIndexDirection_.get ();
    }

    void RotaryTableType::
    ZeroIndexDirection (const ZeroIndexDirection_type& x)
    {
      this->ZeroIndexDirection_.set (x);
    }

    void RotaryTableType::
    ZeroIndexDirection (::std::auto_ptr< ZeroIndexDirection_type > x)
    {
      this->ZeroIndexDirection_.set (x);
    }

    const RotaryTableType::TableRadius_type& RotaryTableType::
    TableRadius () const
    {
      return this->TableRadius_.get ();
    }

    RotaryTableType::TableRadius_type& RotaryTableType::
    TableRadius ()
    {
      return this->TableRadius_.get ();
    }

    void RotaryTableType::
    TableRadius (const TableRadius_type& x)
    {
      this->TableRadius_.set (x);
    }

    void RotaryTableType::
    TableRadius (::std::auto_ptr< TableRadius_type > x)
    {
      this->TableRadius_.set (x);
    }

    const RotaryTableType::TableErrors_type& RotaryTableType::
    TableErrors () const
    {
      return this->TableErrors_.get ();
    }

    RotaryTableType::TableErrors_type& RotaryTableType::
    TableErrors ()
    {
      return this->TableErrors_.get ();
    }

    void RotaryTableType::
    TableErrors (const TableErrors_type& x)
    {
      this->TableErrors_.set (x);
    }

    void RotaryTableType::
    TableErrors (::std::auto_ptr< TableErrors_type > x)
    {
      this->TableErrors_.set (x);
    }


    // TableErrorsType
    // 

    const TableErrorsType::AxialError_type& TableErrorsType::
    AxialError () const
    {
      return this->AxialError_.get ();
    }

    TableErrorsType::AxialError_type& TableErrorsType::
    AxialError ()
    {
      return this->AxialError_.get ();
    }

    void TableErrorsType::
    AxialError (const AxialError_type& x)
    {
      this->AxialError_.set (x);
    }

    void TableErrorsType::
    AxialError (::std::auto_ptr< AxialError_type > x)
    {
      this->AxialError_.set (x);
    }

    const TableErrorsType::RadialError_type& TableErrorsType::
    RadialError () const
    {
      return this->RadialError_.get ();
    }

    TableErrorsType::RadialError_type& TableErrorsType::
    RadialError ()
    {
      return this->RadialError_.get ();
    }

    void TableErrorsType::
    RadialError (const RadialError_type& x)
    {
      this->RadialError_.set (x);
    }

    void TableErrorsType::
    RadialError (::std::auto_ptr< RadialError_type > x)
    {
      this->RadialError_.set (x);
    }

    const TableErrorsType::TangentialError_type& TableErrorsType::
    TangentialError () const
    {
      return this->TangentialError_.get ();
    }

    TableErrorsType::TangentialError_type& TableErrorsType::
    TangentialError ()
    {
      return this->TangentialError_.get ();
    }

    void TableErrorsType::
    TangentialError (const TangentialError_type& x)
    {
      this->TangentialError_.set (x);
    }

    void TableErrorsType::
    TangentialError (::std::auto_ptr< TangentialError_type > x)
    {
      this->TangentialError_.set (x);
    }


    // ResolutionType
    // 

    const ResolutionType::CombinedResolution_optional& ResolutionType::
    CombinedResolution () const
    {
      return this->CombinedResolution_;
    }

    ResolutionType::CombinedResolution_optional& ResolutionType::
    CombinedResolution ()
    {
      return this->CombinedResolution_;
    }

    void ResolutionType::
    CombinedResolution (const CombinedResolution_type& x)
    {
      this->CombinedResolution_.set (x);
    }

    void ResolutionType::
    CombinedResolution (const CombinedResolution_optional& x)
    {
      this->CombinedResolution_ = x;
    }

    void ResolutionType::
    CombinedResolution (::std::auto_ptr< CombinedResolution_type > x)
    {
      this->CombinedResolution_.set (x);
    }

    const ResolutionType::XYZResolution_optional& ResolutionType::
    XYZResolution () const
    {
      return this->XYZResolution_;
    }

    ResolutionType::XYZResolution_optional& ResolutionType::
    XYZResolution ()
    {
      return this->XYZResolution_;
    }

    void ResolutionType::
    XYZResolution (const XYZResolution_type& x)
    {
      this->XYZResolution_.set (x);
    }

    void ResolutionType::
    XYZResolution (const XYZResolution_optional& x)
    {
      this->XYZResolution_ = x;
    }

    void ResolutionType::
    XYZResolution (::std::auto_ptr< XYZResolution_type > x)
    {
      this->XYZResolution_.set (x);
    }


    // XYZResolutionType
    // 

    const XYZResolutionType::XResolution_type& XYZResolutionType::
    XResolution () const
    {
      return this->XResolution_.get ();
    }

    XYZResolutionType::XResolution_type& XYZResolutionType::
    XResolution ()
    {
      return this->XResolution_.get ();
    }

    void XYZResolutionType::
    XResolution (const XResolution_type& x)
    {
      this->XResolution_.set (x);
    }

    void XYZResolutionType::
    XResolution (::std::auto_ptr< XResolution_type > x)
    {
      this->XResolution_.set (x);
    }

    const XYZResolutionType::YResolution_type& XYZResolutionType::
    YResolution () const
    {
      return this->YResolution_.get ();
    }

    XYZResolutionType::YResolution_type& XYZResolutionType::
    YResolution ()
    {
      return this->YResolution_.get ();
    }

    void XYZResolutionType::
    YResolution (const YResolution_type& x)
    {
      this->YResolution_.set (x);
    }

    void XYZResolutionType::
    YResolution (::std::auto_ptr< YResolution_type > x)
    {
      this->YResolution_.set (x);
    }

    const XYZResolutionType::ZResolution_type& XYZResolutionType::
    ZResolution () const
    {
      return this->ZResolution_.get ();
    }

    XYZResolutionType::ZResolution_type& XYZResolutionType::
    ZResolution ()
    {
      return this->ZResolution_.get ();
    }

    void XYZResolutionType::
    ZResolution (const ZResolution_type& x)
    {
      this->ZResolution_.set (x);
    }

    void XYZResolutionType::
    ZResolution (::std::auto_ptr< ZResolution_type > x)
    {
      this->ZResolution_.set (x);
    }


    // CMMAccuracyTestBaseType
    // 


    // FPSTestType
    // 

    const FPSTestType::XLinearity_type& FPSTestType::
    XLinearity () const
    {
      return this->XLinearity_.get ();
    }

    FPSTestType::XLinearity_type& FPSTestType::
    XLinearity ()
    {
      return this->XLinearity_.get ();
    }

    void FPSTestType::
    XLinearity (const XLinearity_type& x)
    {
      this->XLinearity_.set (x);
    }

    void FPSTestType::
    XLinearity (::std::auto_ptr< XLinearity_type > x)
    {
      this->XLinearity_.set (x);
    }

    const FPSTestType::YLinearity_type& FPSTestType::
    YLinearity () const
    {
      return this->YLinearity_.get ();
    }

    FPSTestType::YLinearity_type& FPSTestType::
    YLinearity ()
    {
      return this->YLinearity_.get ();
    }

    void FPSTestType::
    YLinearity (const YLinearity_type& x)
    {
      this->YLinearity_.set (x);
    }

    void FPSTestType::
    YLinearity (::std::auto_ptr< YLinearity_type > x)
    {
      this->YLinearity_.set (x);
    }

    const FPSTestType::ZLinearity_type& FPSTestType::
    ZLinearity () const
    {
      return this->ZLinearity_.get ();
    }

    FPSTestType::ZLinearity_type& FPSTestType::
    ZLinearity ()
    {
      return this->ZLinearity_.get ();
    }

    void FPSTestType::
    ZLinearity (const ZLinearity_type& x)
    {
      this->ZLinearity_.set (x);
    }

    void FPSTestType::
    ZLinearity (::std::auto_ptr< ZLinearity_type > x)
    {
      this->ZLinearity_.set (x);
    }

    const FPSTestType::XAxisRoll_type& FPSTestType::
    XAxisRoll () const
    {
      return this->XAxisRoll_.get ();
    }

    FPSTestType::XAxisRoll_type& FPSTestType::
    XAxisRoll ()
    {
      return this->XAxisRoll_.get ();
    }

    void FPSTestType::
    XAxisRoll (const XAxisRoll_type& x)
    {
      this->XAxisRoll_.set (x);
    }

    void FPSTestType::
    XAxisRoll (::std::auto_ptr< XAxisRoll_type > x)
    {
      this->XAxisRoll_.set (x);
    }

    const FPSTestType::XAxisPitch_type& FPSTestType::
    XAxisPitch () const
    {
      return this->XAxisPitch_.get ();
    }

    FPSTestType::XAxisPitch_type& FPSTestType::
    XAxisPitch ()
    {
      return this->XAxisPitch_.get ();
    }

    void FPSTestType::
    XAxisPitch (const XAxisPitch_type& x)
    {
      this->XAxisPitch_.set (x);
    }

    void FPSTestType::
    XAxisPitch (::std::auto_ptr< XAxisPitch_type > x)
    {
      this->XAxisPitch_.set (x);
    }

    const FPSTestType::XAxisYaw_type& FPSTestType::
    XAxisYaw () const
    {
      return this->XAxisYaw_.get ();
    }

    FPSTestType::XAxisYaw_type& FPSTestType::
    XAxisYaw ()
    {
      return this->XAxisYaw_.get ();
    }

    void FPSTestType::
    XAxisYaw (const XAxisYaw_type& x)
    {
      this->XAxisYaw_.set (x);
    }

    void FPSTestType::
    XAxisYaw (::std::auto_ptr< XAxisYaw_type > x)
    {
      this->XAxisYaw_.set (x);
    }

    const FPSTestType::YAxisRoll_type& FPSTestType::
    YAxisRoll () const
    {
      return this->YAxisRoll_.get ();
    }

    FPSTestType::YAxisRoll_type& FPSTestType::
    YAxisRoll ()
    {
      return this->YAxisRoll_.get ();
    }

    void FPSTestType::
    YAxisRoll (const YAxisRoll_type& x)
    {
      this->YAxisRoll_.set (x);
    }

    void FPSTestType::
    YAxisRoll (::std::auto_ptr< YAxisRoll_type > x)
    {
      this->YAxisRoll_.set (x);
    }

    const FPSTestType::YAxisPitch_type& FPSTestType::
    YAxisPitch () const
    {
      return this->YAxisPitch_.get ();
    }

    FPSTestType::YAxisPitch_type& FPSTestType::
    YAxisPitch ()
    {
      return this->YAxisPitch_.get ();
    }

    void FPSTestType::
    YAxisPitch (const YAxisPitch_type& x)
    {
      this->YAxisPitch_.set (x);
    }

    void FPSTestType::
    YAxisPitch (::std::auto_ptr< YAxisPitch_type > x)
    {
      this->YAxisPitch_.set (x);
    }

    const FPSTestType::YAxisYaw_type& FPSTestType::
    YAxisYaw () const
    {
      return this->YAxisYaw_.get ();
    }

    FPSTestType::YAxisYaw_type& FPSTestType::
    YAxisYaw ()
    {
      return this->YAxisYaw_.get ();
    }

    void FPSTestType::
    YAxisYaw (const YAxisYaw_type& x)
    {
      this->YAxisYaw_.set (x);
    }

    void FPSTestType::
    YAxisYaw (::std::auto_ptr< YAxisYaw_type > x)
    {
      this->YAxisYaw_.set (x);
    }

    const FPSTestType::ZAxisRoll_type& FPSTestType::
    ZAxisRoll () const
    {
      return this->ZAxisRoll_.get ();
    }

    FPSTestType::ZAxisRoll_type& FPSTestType::
    ZAxisRoll ()
    {
      return this->ZAxisRoll_.get ();
    }

    void FPSTestType::
    ZAxisRoll (const ZAxisRoll_type& x)
    {
      this->ZAxisRoll_.set (x);
    }

    void FPSTestType::
    ZAxisRoll (::std::auto_ptr< ZAxisRoll_type > x)
    {
      this->ZAxisRoll_.set (x);
    }

    const FPSTestType::ZAxisPitch_type& FPSTestType::
    ZAxisPitch () const
    {
      return this->ZAxisPitch_.get ();
    }

    FPSTestType::ZAxisPitch_type& FPSTestType::
    ZAxisPitch ()
    {
      return this->ZAxisPitch_.get ();
    }

    void FPSTestType::
    ZAxisPitch (const ZAxisPitch_type& x)
    {
      this->ZAxisPitch_.set (x);
    }

    void FPSTestType::
    ZAxisPitch (::std::auto_ptr< ZAxisPitch_type > x)
    {
      this->ZAxisPitch_.set (x);
    }

    const FPSTestType::ZAxisYaw_type& FPSTestType::
    ZAxisYaw () const
    {
      return this->ZAxisYaw_.get ();
    }

    FPSTestType::ZAxisYaw_type& FPSTestType::
    ZAxisYaw ()
    {
      return this->ZAxisYaw_.get ();
    }

    void FPSTestType::
    ZAxisYaw (const ZAxisYaw_type& x)
    {
      this->ZAxisYaw_.set (x);
    }

    void FPSTestType::
    ZAxisYaw (::std::auto_ptr< ZAxisYaw_type > x)
    {
      this->ZAxisYaw_.set (x);
    }

    const FPSTestType::XAxisStraightnessY_type& FPSTestType::
    XAxisStraightnessY () const
    {
      return this->XAxisStraightnessY_.get ();
    }

    FPSTestType::XAxisStraightnessY_type& FPSTestType::
    XAxisStraightnessY ()
    {
      return this->XAxisStraightnessY_.get ();
    }

    void FPSTestType::
    XAxisStraightnessY (const XAxisStraightnessY_type& x)
    {
      this->XAxisStraightnessY_.set (x);
    }

    void FPSTestType::
    XAxisStraightnessY (::std::auto_ptr< XAxisStraightnessY_type > x)
    {
      this->XAxisStraightnessY_.set (x);
    }

    const FPSTestType::XAxisStraightnessZ_type& FPSTestType::
    XAxisStraightnessZ () const
    {
      return this->XAxisStraightnessZ_.get ();
    }

    FPSTestType::XAxisStraightnessZ_type& FPSTestType::
    XAxisStraightnessZ ()
    {
      return this->XAxisStraightnessZ_.get ();
    }

    void FPSTestType::
    XAxisStraightnessZ (const XAxisStraightnessZ_type& x)
    {
      this->XAxisStraightnessZ_.set (x);
    }

    void FPSTestType::
    XAxisStraightnessZ (::std::auto_ptr< XAxisStraightnessZ_type > x)
    {
      this->XAxisStraightnessZ_.set (x);
    }

    const FPSTestType::YAxisStraightnessX_type& FPSTestType::
    YAxisStraightnessX () const
    {
      return this->YAxisStraightnessX_.get ();
    }

    FPSTestType::YAxisStraightnessX_type& FPSTestType::
    YAxisStraightnessX ()
    {
      return this->YAxisStraightnessX_.get ();
    }

    void FPSTestType::
    YAxisStraightnessX (const YAxisStraightnessX_type& x)
    {
      this->YAxisStraightnessX_.set (x);
    }

    void FPSTestType::
    YAxisStraightnessX (::std::auto_ptr< YAxisStraightnessX_type > x)
    {
      this->YAxisStraightnessX_.set (x);
    }

    const FPSTestType::YAxisStraightnessZ_type& FPSTestType::
    YAxisStraightnessZ () const
    {
      return this->YAxisStraightnessZ_.get ();
    }

    FPSTestType::YAxisStraightnessZ_type& FPSTestType::
    YAxisStraightnessZ ()
    {
      return this->YAxisStraightnessZ_.get ();
    }

    void FPSTestType::
    YAxisStraightnessZ (const YAxisStraightnessZ_type& x)
    {
      this->YAxisStraightnessZ_.set (x);
    }

    void FPSTestType::
    YAxisStraightnessZ (::std::auto_ptr< YAxisStraightnessZ_type > x)
    {
      this->YAxisStraightnessZ_.set (x);
    }

    const FPSTestType::ZAxisStraightnessX_type& FPSTestType::
    ZAxisStraightnessX () const
    {
      return this->ZAxisStraightnessX_.get ();
    }

    FPSTestType::ZAxisStraightnessX_type& FPSTestType::
    ZAxisStraightnessX ()
    {
      return this->ZAxisStraightnessX_.get ();
    }

    void FPSTestType::
    ZAxisStraightnessX (const ZAxisStraightnessX_type& x)
    {
      this->ZAxisStraightnessX_.set (x);
    }

    void FPSTestType::
    ZAxisStraightnessX (::std::auto_ptr< ZAxisStraightnessX_type > x)
    {
      this->ZAxisStraightnessX_.set (x);
    }

    const FPSTestType::ZAxisStraightnessY_type& FPSTestType::
    ZAxisStraightnessY () const
    {
      return this->ZAxisStraightnessY_.get ();
    }

    FPSTestType::ZAxisStraightnessY_type& FPSTestType::
    ZAxisStraightnessY ()
    {
      return this->ZAxisStraightnessY_.get ();
    }

    void FPSTestType::
    ZAxisStraightnessY (const ZAxisStraightnessY_type& x)
    {
      this->ZAxisStraightnessY_.set (x);
    }

    void FPSTestType::
    ZAxisStraightnessY (::std::auto_ptr< ZAxisStraightnessY_type > x)
    {
      this->ZAxisStraightnessY_.set (x);
    }

    const FPSTestType::XYSquareness_type& FPSTestType::
    XYSquareness () const
    {
      return this->XYSquareness_.get ();
    }

    FPSTestType::XYSquareness_type& FPSTestType::
    XYSquareness ()
    {
      return this->XYSquareness_.get ();
    }

    void FPSTestType::
    XYSquareness (const XYSquareness_type& x)
    {
      this->XYSquareness_.set (x);
    }

    const FPSTestType::XZSquareness_type& FPSTestType::
    XZSquareness () const
    {
      return this->XZSquareness_.get ();
    }

    FPSTestType::XZSquareness_type& FPSTestType::
    XZSquareness ()
    {
      return this->XZSquareness_.get ();
    }

    void FPSTestType::
    XZSquareness (const XZSquareness_type& x)
    {
      this->XZSquareness_.set (x);
    }

    const FPSTestType::YZSquareness_type& FPSTestType::
    YZSquareness () const
    {
      return this->YZSquareness_.get ();
    }

    FPSTestType::YZSquareness_type& FPSTestType::
    YZSquareness ()
    {
      return this->YZSquareness_.get ();
    }

    void FPSTestType::
    YZSquareness (const YZSquareness_type& x)
    {
      this->YZSquareness_.set (x);
    }


    // FunctionDiscreteType
    // 

    const FunctionDiscreteType::DomainValues_type& FunctionDiscreteType::
    DomainValues () const
    {
      return this->DomainValues_.get ();
    }

    FunctionDiscreteType::DomainValues_type& FunctionDiscreteType::
    DomainValues ()
    {
      return this->DomainValues_.get ();
    }

    void FunctionDiscreteType::
    DomainValues (const DomainValues_type& x)
    {
      this->DomainValues_.set (x);
    }

    void FunctionDiscreteType::
    DomainValues (::std::auto_ptr< DomainValues_type > x)
    {
      this->DomainValues_.set (x);
    }

    const FunctionDiscreteType::RangeValues_type& FunctionDiscreteType::
    RangeValues () const
    {
      return this->RangeValues_.get ();
    }

    FunctionDiscreteType::RangeValues_type& FunctionDiscreteType::
    RangeValues ()
    {
      return this->RangeValues_.get ();
    }

    void FunctionDiscreteType::
    RangeValues (const RangeValues_type& x)
    {
      this->RangeValues_.set (x);
    }

    void FunctionDiscreteType::
    RangeValues (::std::auto_ptr< RangeValues_type > x)
    {
      this->RangeValues_.set (x);
    }

    const FunctionDiscreteType::N_type& FunctionDiscreteType::
    N () const
    {
      return this->N_.get ();
    }

    FunctionDiscreteType::N_type& FunctionDiscreteType::
    N ()
    {
      return this->N_.get ();
    }

    void FunctionDiscreteType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void FunctionDiscreteType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // LengthFunctionDiscreteType
    // 

    const LengthFunctionDiscreteType::DomainLinearUnit_type& LengthFunctionDiscreteType::
    DomainLinearUnit () const
    {
      return this->DomainLinearUnit_.get ();
    }

    LengthFunctionDiscreteType::DomainLinearUnit_type& LengthFunctionDiscreteType::
    DomainLinearUnit ()
    {
      return this->DomainLinearUnit_.get ();
    }

    void LengthFunctionDiscreteType::
    DomainLinearUnit (const DomainLinearUnit_type& x)
    {
      this->DomainLinearUnit_.set (x);
    }

    void LengthFunctionDiscreteType::
    DomainLinearUnit (::std::auto_ptr< DomainLinearUnit_type > x)
    {
      this->DomainLinearUnit_.set (x);
    }

    const LengthFunctionDiscreteType::RangeLinearUnit_type& LengthFunctionDiscreteType::
    RangeLinearUnit () const
    {
      return this->RangeLinearUnit_.get ();
    }

    LengthFunctionDiscreteType::RangeLinearUnit_type& LengthFunctionDiscreteType::
    RangeLinearUnit ()
    {
      return this->RangeLinearUnit_.get ();
    }

    void LengthFunctionDiscreteType::
    RangeLinearUnit (const RangeLinearUnit_type& x)
    {
      this->RangeLinearUnit_.set (x);
    }

    void LengthFunctionDiscreteType::
    RangeLinearUnit (::std::auto_ptr< RangeLinearUnit_type > x)
    {
      this->RangeLinearUnit_.set (x);
    }


    // AngleFunctionDiscreteType
    // 

    const AngleFunctionDiscreteType::DomainLinearUnit_type& AngleFunctionDiscreteType::
    DomainLinearUnit () const
    {
      return this->DomainLinearUnit_.get ();
    }

    AngleFunctionDiscreteType::DomainLinearUnit_type& AngleFunctionDiscreteType::
    DomainLinearUnit ()
    {
      return this->DomainLinearUnit_.get ();
    }

    void AngleFunctionDiscreteType::
    DomainLinearUnit (const DomainLinearUnit_type& x)
    {
      this->DomainLinearUnit_.set (x);
    }

    void AngleFunctionDiscreteType::
    DomainLinearUnit (::std::auto_ptr< DomainLinearUnit_type > x)
    {
      this->DomainLinearUnit_.set (x);
    }

    const AngleFunctionDiscreteType::RangeAngularUnit_type& AngleFunctionDiscreteType::
    RangeAngularUnit () const
    {
      return this->RangeAngularUnit_.get ();
    }

    AngleFunctionDiscreteType::RangeAngularUnit_type& AngleFunctionDiscreteType::
    RangeAngularUnit ()
    {
      return this->RangeAngularUnit_.get ();
    }

    void AngleFunctionDiscreteType::
    RangeAngularUnit (const RangeAngularUnit_type& x)
    {
      this->RangeAngularUnit_.set (x);
    }

    void AngleFunctionDiscreteType::
    RangeAngularUnit (::std::auto_ptr< RangeAngularUnit_type > x)
    {
      this->RangeAngularUnit_.set (x);
    }


    // B89TestType
    // 

    const B89TestType::XLinearAccuracy_type& B89TestType::
    XLinearAccuracy () const
    {
      return this->XLinearAccuracy_.get ();
    }

    B89TestType::XLinearAccuracy_type& B89TestType::
    XLinearAccuracy ()
    {
      return this->XLinearAccuracy_.get ();
    }

    void B89TestType::
    XLinearAccuracy (const XLinearAccuracy_type& x)
    {
      this->XLinearAccuracy_.set (x);
    }

    void B89TestType::
    XLinearAccuracy (::std::auto_ptr< XLinearAccuracy_type > x)
    {
      this->XLinearAccuracy_.set (x);
    }

    const B89TestType::YLinearAccuracy_type& B89TestType::
    YLinearAccuracy () const
    {
      return this->YLinearAccuracy_.get ();
    }

    B89TestType::YLinearAccuracy_type& B89TestType::
    YLinearAccuracy ()
    {
      return this->YLinearAccuracy_.get ();
    }

    void B89TestType::
    YLinearAccuracy (const YLinearAccuracy_type& x)
    {
      this->YLinearAccuracy_.set (x);
    }

    void B89TestType::
    YLinearAccuracy (::std::auto_ptr< YLinearAccuracy_type > x)
    {
      this->YLinearAccuracy_.set (x);
    }

    const B89TestType::ZLinearAccuracy_type& B89TestType::
    ZLinearAccuracy () const
    {
      return this->ZLinearAccuracy_.get ();
    }

    B89TestType::ZLinearAccuracy_type& B89TestType::
    ZLinearAccuracy ()
    {
      return this->ZLinearAccuracy_.get ();
    }

    void B89TestType::
    ZLinearAccuracy (const ZLinearAccuracy_type& x)
    {
      this->ZLinearAccuracy_.set (x);
    }

    void B89TestType::
    ZLinearAccuracy (::std::auto_ptr< ZLinearAccuracy_type > x)
    {
      this->ZLinearAccuracy_.set (x);
    }

    const B89TestType::OffsetVolumetricPerformance_type& B89TestType::
    OffsetVolumetricPerformance () const
    {
      return this->OffsetVolumetricPerformance_.get ();
    }

    B89TestType::OffsetVolumetricPerformance_type& B89TestType::
    OffsetVolumetricPerformance ()
    {
      return this->OffsetVolumetricPerformance_.get ();
    }

    void B89TestType::
    OffsetVolumetricPerformance (const OffsetVolumetricPerformance_type& x)
    {
      this->OffsetVolumetricPerformance_.set (x);
    }

    void B89TestType::
    OffsetVolumetricPerformance (::std::auto_ptr< OffsetVolumetricPerformance_type > x)
    {
      this->OffsetVolumetricPerformance_.set (x);
    }

    const B89TestType::VolumetricPerformance_type& B89TestType::
    VolumetricPerformance () const
    {
      return this->VolumetricPerformance_.get ();
    }

    B89TestType::VolumetricPerformance_type& B89TestType::
    VolumetricPerformance ()
    {
      return this->VolumetricPerformance_.get ();
    }

    void B89TestType::
    VolumetricPerformance (const VolumetricPerformance_type& x)
    {
      this->VolumetricPerformance_.set (x);
    }

    void B89TestType::
    VolumetricPerformance (::std::auto_ptr< VolumetricPerformance_type > x)
    {
      this->VolumetricPerformance_.set (x);
    }

    const B89TestType::Repeatability_type& B89TestType::
    Repeatability () const
    {
      return this->Repeatability_.get ();
    }

    B89TestType::Repeatability_type& B89TestType::
    Repeatability ()
    {
      return this->Repeatability_.get ();
    }

    void B89TestType::
    Repeatability (const Repeatability_type& x)
    {
      this->Repeatability_.set (x);
    }

    void B89TestType::
    Repeatability (::std::auto_ptr< Repeatability_type > x)
    {
      this->Repeatability_.set (x);
    }


    // ISO10360TestType
    // 

    const ISO10360TestType::MaxErrorConstant_optional& ISO10360TestType::
    MaxErrorConstant () const
    {
      return this->MaxErrorConstant_;
    }

    ISO10360TestType::MaxErrorConstant_optional& ISO10360TestType::
    MaxErrorConstant ()
    {
      return this->MaxErrorConstant_;
    }

    void ISO10360TestType::
    MaxErrorConstant (const MaxErrorConstant_type& x)
    {
      this->MaxErrorConstant_.set (x);
    }

    void ISO10360TestType::
    MaxErrorConstant (const MaxErrorConstant_optional& x)
    {
      this->MaxErrorConstant_ = x;
    }

    void ISO10360TestType::
    MaxErrorConstant (::std::auto_ptr< MaxErrorConstant_type > x)
    {
      this->MaxErrorConstant_.set (x);
    }

    const ISO10360TestType::LinearError_optional& ISO10360TestType::
    LinearError () const
    {
      return this->LinearError_;
    }

    ISO10360TestType::LinearError_optional& ISO10360TestType::
    LinearError ()
    {
      return this->LinearError_;
    }

    void ISO10360TestType::
    LinearError (const LinearError_type& x)
    {
      this->LinearError_.set (x);
    }

    void ISO10360TestType::
    LinearError (const LinearError_optional& x)
    {
      this->LinearError_ = x;
    }

    void ISO10360TestType::
    LinearError (::std::auto_ptr< LinearError_type > x)
    {
      this->LinearError_.set (x);
    }

    const ISO10360TestType::LesserError_optional& ISO10360TestType::
    LesserError () const
    {
      return this->LesserError_;
    }

    ISO10360TestType::LesserError_optional& ISO10360TestType::
    LesserError ()
    {
      return this->LesserError_;
    }

    void ISO10360TestType::
    LesserError (const LesserError_type& x)
    {
      this->LesserError_.set (x);
    }

    void ISO10360TestType::
    LesserError (const LesserError_optional& x)
    {
      this->LesserError_ = x;
    }

    void ISO10360TestType::
    LesserError (::std::auto_ptr< LesserError_type > x)
    {
      this->LesserError_.set (x);
    }


    // LinearErrorType
    // 

    const LinearErrorType::BaseError_type& LinearErrorType::
    BaseError () const
    {
      return this->BaseError_.get ();
    }

    LinearErrorType::BaseError_type& LinearErrorType::
    BaseError ()
    {
      return this->BaseError_.get ();
    }

    void LinearErrorType::
    BaseError (const BaseError_type& x)
    {
      this->BaseError_.set (x);
    }

    void LinearErrorType::
    BaseError (::std::auto_ptr< BaseError_type > x)
    {
      this->BaseError_.set (x);
    }

    const LinearErrorType::ErrorRate_type& LinearErrorType::
    ErrorRate () const
    {
      return this->ErrorRate_.get ();
    }

    LinearErrorType::ErrorRate_type& LinearErrorType::
    ErrorRate ()
    {
      return this->ErrorRate_.get ();
    }

    void LinearErrorType::
    ErrorRate (const ErrorRate_type& x)
    {
      this->ErrorRate_.set (x);
    }


    // LesserErrorType
    // 

    const LesserErrorType::MaxErrorConstant_type& LesserErrorType::
    MaxErrorConstant () const
    {
      return this->MaxErrorConstant_.get ();
    }

    LesserErrorType::MaxErrorConstant_type& LesserErrorType::
    MaxErrorConstant ()
    {
      return this->MaxErrorConstant_.get ();
    }

    void LesserErrorType::
    MaxErrorConstant (const MaxErrorConstant_type& x)
    {
      this->MaxErrorConstant_.set (x);
    }

    void LesserErrorType::
    MaxErrorConstant (::std::auto_ptr< MaxErrorConstant_type > x)
    {
      this->MaxErrorConstant_.set (x);
    }

    const LesserErrorType::LinearError_type& LesserErrorType::
    LinearError () const
    {
      return this->LinearError_.get ();
    }

    LesserErrorType::LinearError_type& LesserErrorType::
    LinearError ()
    {
      return this->LinearError_.get ();
    }

    void LesserErrorType::
    LinearError (const LinearError_type& x)
    {
      this->LinearError_.set (x);
    }

    void LesserErrorType::
    LinearError (::std::auto_ptr< LinearError_type > x)
    {
      this->LinearError_.set (x);
    }


    // PointAccuracyTestType
    // 

    const PointAccuracyTestType::Accuracy_type& PointAccuracyTestType::
    Accuracy () const
    {
      return this->Accuracy_.get ();
    }

    PointAccuracyTestType::Accuracy_type& PointAccuracyTestType::
    Accuracy ()
    {
      return this->Accuracy_.get ();
    }

    void PointAccuracyTestType::
    Accuracy (const Accuracy_type& x)
    {
      this->Accuracy_.set (x);
    }

    void PointAccuracyTestType::
    Accuracy (::std::auto_ptr< Accuracy_type > x)
    {
      this->Accuracy_.set (x);
    }


    // CMMAccuracyType
    // 

    const CMMAccuracyType::MinTemperature_type& CMMAccuracyType::
    MinTemperature () const
    {
      return this->MinTemperature_.get ();
    }

    CMMAccuracyType::MinTemperature_type& CMMAccuracyType::
    MinTemperature ()
    {
      return this->MinTemperature_.get ();
    }

    void CMMAccuracyType::
    MinTemperature (const MinTemperature_type& x)
    {
      this->MinTemperature_.set (x);
    }

    void CMMAccuracyType::
    MinTemperature (::std::auto_ptr< MinTemperature_type > x)
    {
      this->MinTemperature_.set (x);
    }

    const CMMAccuracyType::MaxTemperature_type& CMMAccuracyType::
    MaxTemperature () const
    {
      return this->MaxTemperature_.get ();
    }

    CMMAccuracyType::MaxTemperature_type& CMMAccuracyType::
    MaxTemperature ()
    {
      return this->MaxTemperature_.get ();
    }

    void CMMAccuracyType::
    MaxTemperature (const MaxTemperature_type& x)
    {
      this->MaxTemperature_.set (x);
    }

    void CMMAccuracyType::
    MaxTemperature (::std::auto_ptr< MaxTemperature_type > x)
    {
      this->MaxTemperature_.set (x);
    }

    const CMMAccuracyType::CMMAccuracyTest_type& CMMAccuracyType::
    CMMAccuracyTest () const
    {
      return this->CMMAccuracyTest_.get ();
    }

    CMMAccuracyType::CMMAccuracyTest_type& CMMAccuracyType::
    CMMAccuracyTest ()
    {
      return this->CMMAccuracyTest_.get ();
    }

    void CMMAccuracyType::
    CMMAccuracyTest (const CMMAccuracyTest_type& x)
    {
      this->CMMAccuracyTest_.set (x);
    }

    void CMMAccuracyType::
    CMMAccuracyTest (::std::auto_ptr< CMMAccuracyTest_type > x)
    {
      this->CMMAccuracyTest_.set (x);
    }


    // ComparatorType
    // 
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace xsd
{
  namespace qif2
  {
    // MeasurementResourcesType
    //

    MeasurementResourcesType::
    MeasurementResourcesType ()
    : ::xml_schema::type (),
      Version_ (::xml_schema::flags (), this),
      Carriages_ (::xml_schema::flags (), this),
      Fixtures_ (::xml_schema::flags (), this),
      MeasurementDevices_ (::xml_schema::flags (), this),
      Sensors_ (::xml_schema::flags (), this),
      Tools_ (::xml_schema::flags (), this)
    {
    }

    MeasurementResourcesType::
    MeasurementResourcesType (const MeasurementResourcesType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Version_ (x.Version_, f, this),
      Carriages_ (x.Carriages_, f, this),
      Fixtures_ (x.Fixtures_, f, this),
      MeasurementDevices_ (x.MeasurementDevices_, f, this),
      Sensors_ (x.Sensors_, f, this),
      Tools_ (x.Tools_, f, this)
    {
    }

    MeasurementResourcesType::
    MeasurementResourcesType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Version_ (f, this),
      Carriages_ (f, this),
      Fixtures_ (f, this),
      MeasurementDevices_ (f, this),
      Sensors_ (f, this),
      Tools_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void MeasurementResourcesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Version
        //
        if (n.name () == "Version" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (r);
            continue;
          }
        }

        // Carriages
        //
        if (n.name () == "Carriages" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Carriages_type > r (
            Carriages_traits::create (i, f, this));

          if (!this->Carriages_)
          {
            this->Carriages_.set (r);
            continue;
          }
        }

        // Fixtures
        //
        if (n.name () == "Fixtures" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Fixtures_type > r (
            Fixtures_traits::create (i, f, this));

          if (!this->Fixtures_)
          {
            this->Fixtures_.set (r);
            continue;
          }
        }

        // MeasurementDevices
        //
        if (n.name () == "MeasurementDevices" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurementDevices_type > r (
            MeasurementDevices_traits::create (i, f, this));

          if (!this->MeasurementDevices_)
          {
            this->MeasurementDevices_.set (r);
            continue;
          }
        }

        // Sensors
        //
        if (n.name () == "Sensors" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sensors_type > r (
            Sensors_traits::create (i, f, this));

          if (!this->Sensors_)
          {
            this->Sensors_.set (r);
            continue;
          }
        }

        // Tools
        //
        if (n.name () == "Tools" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Tools_type > r (
            Tools_traits::create (i, f, this));

          if (!this->Tools_)
          {
            this->Tools_.set (r);
            continue;
          }
        }

        break;
      }
    }

    MeasurementResourcesType* MeasurementResourcesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementResourcesType (*this, f, c);
    }

    MeasurementResourcesType::
    ~MeasurementResourcesType ()
    {
    }

    // CarriagesType
    //

    CarriagesType::
    CarriagesType ()
    : ::xml_schema::type (),
      Carriage_ (::xml_schema::flags (), this)
    {
    }

    CarriagesType::
    CarriagesType (const CarriagesType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Carriage_ (x.Carriage_, f, this)
    {
    }

    CarriagesType::
    CarriagesType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Carriage_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CarriagesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Carriage
        //
        if (n.name () == "Carriage" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Carriage_type > r (
            Carriage_traits::create (i, f, this));

          this->Carriage_.push_back (r);
          continue;
        }

        break;
      }
    }

    CarriagesType* CarriagesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CarriagesType (*this, f, c);
    }

    CarriagesType::
    ~CarriagesType ()
    {
    }

    // FixturesType
    //

    FixturesType::
    FixturesType ()
    : ::xml_schema::type (),
      Fixture_ (::xml_schema::flags (), this)
    {
    }

    FixturesType::
    FixturesType (const FixturesType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Fixture_ (x.Fixture_, f, this)
    {
    }

    FixturesType::
    FixturesType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Fixture_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void FixturesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Fixture
        //
        if (n.name () == "Fixture" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Fixture_type > r (
            Fixture_traits::create (i, f, this));

          this->Fixture_.push_back (r);
          continue;
        }

        break;
      }
    }

    FixturesType* FixturesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FixturesType (*this, f, c);
    }

    FixturesType::
    ~FixturesType ()
    {
    }

    // SensorsType
    //

    SensorsType::
    SensorsType ()
    : ::xml_schema::type (),
      Sensor_ (::xml_schema::flags (), this)
    {
    }

    SensorsType::
    SensorsType (const SensorsType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Sensor_ (x.Sensor_, f, this)
    {
    }

    SensorsType::
    SensorsType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Sensor_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SensorsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Sensor
        //
        if (n.name () == "Sensor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sensor_type > r (
            Sensor_traits::create (i, f, this));

          this->Sensor_.push_back (r);
          continue;
        }

        break;
      }
    }

    SensorsType* SensorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SensorsType (*this, f, c);
    }

    SensorsType::
    ~SensorsType ()
    {
    }

    // ToolsType
    //

    ToolsType::
    ToolsType ()
    : ::xml_schema::type (),
      Tool_ (::xml_schema::flags (), this)
    {
    }

    ToolsType::
    ToolsType (const ToolsType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Tool_ (x.Tool_, f, this)
    {
    }

    ToolsType::
    ToolsType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Tool_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ToolsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Tool
        //
        if (n.name () == "Tool" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Tool_type > r (
            Tool_traits::create (i, f, this));

          this->Tool_.push_back (r);
          continue;
        }

        break;
      }
    }

    ToolsType* ToolsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolsType (*this, f, c);
    }

    ToolsType::
    ~ToolsType ()
    {
    }

    // MeasurementDevicesType
    //

    MeasurementDevicesType::
    MeasurementDevicesType ()
    : ::xml_schema::type (),
      MeasurementDevice_ (::xml_schema::flags (), this)
    {
    }

    MeasurementDevicesType::
    MeasurementDevicesType (const MeasurementDevicesType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasurementDevice_ (x.MeasurementDevice_, f, this)
    {
    }

    MeasurementDevicesType::
    MeasurementDevicesType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasurementDevice_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void MeasurementDevicesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MeasurementDevice
        //
        if (n.name () == "MeasurementDevice" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurementDevice_type > r (
            MeasurementDevice_traits::create (i, f, this));

          this->MeasurementDevice_.push_back (r);
          continue;
        }

        break;
      }
    }

    MeasurementDevicesType* MeasurementDevicesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDevicesType (*this, f, c);
    }

    MeasurementDevicesType::
    ~MeasurementDevicesType ()
    {
    }

    // MeasurementResourceBaseType
    //

    MeasurementResourceBaseType::
    MeasurementResourceBaseType (const Name_type& Name,
                                 const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, ::xml_schema::flags (), this),
      Description_ (::xml_schema::flags (), this),
      Manufacturer_ (::xml_schema::flags (), this),
      ModelNumber_ (::xml_schema::flags (), this),
      SerialNumber_ (::xml_schema::flags (), this),
      LocationId_ (::xml_schema::flags (), this),
      Location_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    MeasurementResourceBaseType::
    MeasurementResourceBaseType (const MeasurementResourceBaseType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Description_ (x.Description_, f, this),
      Manufacturer_ (x.Manufacturer_, f, this),
      ModelNumber_ (x.ModelNumber_, f, this),
      SerialNumber_ (x.SerialNumber_, f, this),
      LocationId_ (x.LocationId_, f, this),
      Location_ (x.Location_, f, this),
      id_ (x.id_, f, this)
    {
    }

    MeasurementResourceBaseType::
    MeasurementResourceBaseType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (f, this),
      Description_ (f, this),
      Manufacturer_ (f, this),
      ModelNumber_ (f, this),
      SerialNumber_ (f, this),
      LocationId_ (f, this),
      Location_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void MeasurementResourceBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // Manufacturer
        //
        if (n.name () == "Manufacturer" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Manufacturer_type > r (
            Manufacturer_traits::create (i, f, this));

          if (!this->Manufacturer_)
          {
            this->Manufacturer_.set (r);
            continue;
          }
        }

        // ModelNumber
        //
        if (n.name () == "ModelNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ModelNumber_type > r (
            ModelNumber_traits::create (i, f, this));

          if (!this->ModelNumber_)
          {
            this->ModelNumber_.set (r);
            continue;
          }
        }

        // SerialNumber
        //
        if (n.name () == "SerialNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SerialNumber_type > r (
            SerialNumber_traits::create (i, f, this));

          if (!this->SerialNumber_)
          {
            this->SerialNumber_.set (r);
            continue;
          }
        }

        // LocationId
        //
        if (n.name () == "LocationId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LocationId_type > r (
            LocationId_traits::create (i, f, this));

          if (!this->LocationId_)
          {
            this->LocationId_.set (r);
            continue;
          }
        }

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    MeasurementResourceBaseType* MeasurementResourceBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementResourceBaseType (*this, f, c);
    }

    MeasurementResourceBaseType::
    ~MeasurementResourceBaseType ()
    {
    }

    // FixtureType
    //

    FixtureType::
    FixtureType (const Name_type& Name,
                 const id_type& id)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id)
    {
    }

    FixtureType::
    FixtureType (const FixtureType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (x, f, c)
    {
    }

    FixtureType::
    FixtureType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (e, f, c)
    {
    }

    FixtureType* FixtureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FixtureType (*this, f, c);
    }

    FixtureType::
    ~FixtureType ()
    {
    }

    // MeasurementDeviceAccuracyBaseType
    //

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType ()
    : ::xml_schema::type ()
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (const MeasurementDeviceAccuracyBaseType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    MeasurementDeviceAccuracyBaseType::
    MeasurementDeviceAccuracyBaseType (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    MeasurementDeviceAccuracyBaseType* MeasurementDeviceAccuracyBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDeviceAccuracyBaseType (*this, f, c);
    }

    MeasurementDeviceAccuracyBaseType::
    ~MeasurementDeviceAccuracyBaseType ()
    {
    }

    // NumericalLengthAccuracyType
    //

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (const AccuracyValue_type& AccuracyValue)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (),
      AccuracyValue_ (AccuracyValue, ::xml_schema::flags (), this)
    {
    }

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (::std::auto_ptr< AccuracyValue_type >& AccuracyValue)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (),
      AccuracyValue_ (AccuracyValue, ::xml_schema::flags (), this)
    {
    }

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (const NumericalLengthAccuracyType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (x, f, c),
      AccuracyValue_ (x.AccuracyValue_, f, this)
    {
    }

    NumericalLengthAccuracyType::
    NumericalLengthAccuracyType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (e, f | ::xml_schema::flags::base, c),
      AccuracyValue_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void NumericalLengthAccuracyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AccuracyValue
        //
        if (n.name () == "AccuracyValue" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AccuracyValue_type > r (
            AccuracyValue_traits::create (i, f, this));

          if (!AccuracyValue_.present ())
          {
            this->AccuracyValue_.set (r);
            continue;
          }
        }

        break;
      }

      if (!AccuracyValue_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AccuracyValue",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    NumericalLengthAccuracyType* NumericalLengthAccuracyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NumericalLengthAccuracyType (*this, f, c);
    }

    NumericalLengthAccuracyType::
    ~NumericalLengthAccuracyType ()
    {
    }

    // MeasurementDeviceType
    //

    MeasurementDeviceType::
    MeasurementDeviceType (const Name_type& Name,
                           const id_type& id)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id),
      Calibrations_ (::xml_schema::flags (), this),
      InspectionTemperatures_ (::xml_schema::flags (), this)
    {
    }

    MeasurementDeviceType::
    MeasurementDeviceType (const MeasurementDeviceType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (x, f, c),
      Calibrations_ (x.Calibrations_, f, this),
      InspectionTemperatures_ (x.InspectionTemperatures_, f, this)
    {
    }

    MeasurementDeviceType::
    MeasurementDeviceType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      Calibrations_ (f, this),
      InspectionTemperatures_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void MeasurementDeviceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Calibrations
        //
        if (n.name () == "Calibrations" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Calibrations_type > r (
            Calibrations_traits::create (i, f, this));

          if (!this->Calibrations_)
          {
            this->Calibrations_.set (r);
            continue;
          }
        }

        // InspectionTemperatures
        //
        if (n.name () == "InspectionTemperatures" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InspectionTemperatures_type > r (
            InspectionTemperatures_traits::create (i, f, this));

          if (!this->InspectionTemperatures_)
          {
            this->InspectionTemperatures_.set (r);
            continue;
          }
        }

        break;
      }
    }

    MeasurementDeviceType* MeasurementDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasurementDeviceType (*this, f, c);
    }

    MeasurementDeviceType::
    ~MeasurementDeviceType ()
    {
    }

    // CalibrationMasterType
    //

    CalibrationMasterType::
    CalibrationMasterType (const SerialNumber_type& SerialNumber)
    : ::xml_schema::type (),
      SerialNumber_ (SerialNumber, ::xml_schema::flags (), this),
      description_ (::xml_schema::flags (), this)
    {
    }

    CalibrationMasterType::
    CalibrationMasterType (const CalibrationMasterType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SerialNumber_ (x.SerialNumber_, f, this),
      description_ (x.description_, f, this)
    {
    }

    CalibrationMasterType::
    CalibrationMasterType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SerialNumber_ (f, this),
      description_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CalibrationMasterType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SerialNumber
        //
        if (n.name () == "SerialNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SerialNumber_type > r (
            SerialNumber_traits::create (i, f, this));

          if (!SerialNumber_.present ())
          {
            this->SerialNumber_.set (r);
            continue;
          }
        }

        // description
        //
        if (n.name () == "description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< description_type > r (
            description_traits::create (i, f, this));

          if (!this->description_)
          {
            this->description_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SerialNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SerialNumber",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CalibrationMasterType* CalibrationMasterType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CalibrationMasterType (*this, f, c);
    }

    CalibrationMasterType::
    ~CalibrationMasterType ()
    {
    }

    // CalibrationType
    //

    CalibrationType::
    CalibrationType (const Temperatures_type& Temperatures,
                     const TimeStamp_type& TimeStamp)
    : ::xml_schema::type (),
      CalibrationMaster_ (::xml_schema::flags (), this),
      Temperatures_ (Temperatures, ::xml_schema::flags (), this),
      TimeStamp_ (TimeStamp, ::xml_schema::flags (), this)
    {
    }

    CalibrationType::
    CalibrationType (::std::auto_ptr< Temperatures_type >& Temperatures,
                     const TimeStamp_type& TimeStamp)
    : ::xml_schema::type (),
      CalibrationMaster_ (::xml_schema::flags (), this),
      Temperatures_ (Temperatures, ::xml_schema::flags (), this),
      TimeStamp_ (TimeStamp, ::xml_schema::flags (), this)
    {
    }

    CalibrationType::
    CalibrationType (const CalibrationType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CalibrationMaster_ (x.CalibrationMaster_, f, this),
      Temperatures_ (x.Temperatures_, f, this),
      TimeStamp_ (x.TimeStamp_, f, this)
    {
    }

    CalibrationType::
    CalibrationType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CalibrationMaster_ (f, this),
      Temperatures_ (f, this),
      TimeStamp_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CalibrationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CalibrationMaster
        //
        if (n.name () == "CalibrationMaster" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CalibrationMaster_type > r (
            CalibrationMaster_traits::create (i, f, this));

          if (!this->CalibrationMaster_)
          {
            this->CalibrationMaster_.set (r);
            continue;
          }
        }

        // Temperatures
        //
        if (n.name () == "Temperatures" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Temperatures_type > r (
            Temperatures_traits::create (i, f, this));

          if (!Temperatures_.present ())
          {
            this->Temperatures_.set (r);
            continue;
          }
        }

        // TimeStamp
        //
        if (n.name () == "TimeStamp" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TimeStamp_type > r (
            TimeStamp_traits::create (i, f, this));

          if (!TimeStamp_.present ())
          {
            this->TimeStamp_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Temperatures_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Temperatures",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TimeStamp_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TimeStamp",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CalibrationType* CalibrationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CalibrationType (*this, f, c);
    }

    CalibrationType::
    ~CalibrationType ()
    {
    }

    // CalibrationsType
    //

    CalibrationsType::
    CalibrationsType ()
    : ::xml_schema::type (),
      Calibration_ (::xml_schema::flags (), this)
    {
    }

    CalibrationsType::
    CalibrationsType (const CalibrationsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Calibration_ (x.Calibration_, f, this)
    {
    }

    CalibrationsType::
    CalibrationsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Calibration_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CalibrationsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Calibration
        //
        if (n.name () == "Calibration" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Calibration_type > r (
            Calibration_traits::create (i, f, this));

          this->Calibration_.push_back (r);
          continue;
        }

        break;
      }
    }

    CalibrationsType* CalibrationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CalibrationsType (*this, f, c);
    }

    CalibrationsType::
    ~CalibrationsType ()
    {
    }

    // TemperaturesType
    //

    TemperaturesType::
    TemperaturesType ()
    : ::xml_schema::type (),
      Temperature_ (::xml_schema::flags (), this)
    {
    }

    TemperaturesType::
    TemperaturesType (const TemperaturesType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Temperature_ (x.Temperature_, f, this)
    {
    }

    TemperaturesType::
    TemperaturesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Temperature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TemperaturesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Temperature
        //
        if (n.name () == "Temperature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Temperature_type > r (
            Temperature_traits::create (i, f, this));

          this->Temperature_.push_back (r);
          continue;
        }

        break;
      }
    }

    TemperaturesType* TemperaturesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperaturesType (*this, f, c);
    }

    TemperaturesType::
    ~TemperaturesType ()
    {
    }

    // TemperatureType
    //

    TemperatureType::
    TemperatureType (const Temperature_type& Temperature,
                     const TimeStamp_type& TimeStamp)
    : ::xml_schema::type (),
      Attributes_ (::xml_schema::flags (), this),
      Temperature_ (Temperature, ::xml_schema::flags (), this),
      TimeStamp_ (TimeStamp, ::xml_schema::flags (), this)
    {
    }

    TemperatureType::
    TemperatureType (::std::auto_ptr< Temperature_type >& Temperature,
                     const TimeStamp_type& TimeStamp)
    : ::xml_schema::type (),
      Attributes_ (::xml_schema::flags (), this),
      Temperature_ (Temperature, ::xml_schema::flags (), this),
      TimeStamp_ (TimeStamp, ::xml_schema::flags (), this)
    {
    }

    TemperatureType::
    TemperatureType (const TemperatureType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Temperature_ (x.Temperature_, f, this),
      TimeStamp_ (x.TimeStamp_, f, this)
    {
    }

    TemperatureType::
    TemperatureType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (f, this),
      Temperature_ (f, this),
      TimeStamp_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TemperatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // Temperature
        //
        if (n.name () == "Temperature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Temperature_type > r (
            Temperature_traits::create (i, f, this));

          if (!Temperature_.present ())
          {
            this->Temperature_.set (r);
            continue;
          }
        }

        // TimeStamp
        //
        if (n.name () == "TimeStamp" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TimeStamp_type > r (
            TimeStamp_traits::create (i, f, this));

          if (!TimeStamp_.present ())
          {
            this->TimeStamp_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Temperature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Temperature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TimeStamp_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TimeStamp",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TemperatureType* TemperatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureType (*this, f, c);
    }

    TemperatureType::
    ~TemperatureType ()
    {
    }

    // QualificationsType
    //

    QualificationsType::
    QualificationsType ()
    : ::xml_schema::type (),
      Qualification_ (::xml_schema::flags (), this)
    {
    }

    QualificationsType::
    QualificationsType (const QualificationsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Qualification_ (x.Qualification_, f, this)
    {
    }

    QualificationsType::
    QualificationsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Qualification_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void QualificationsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Qualification
        //
        if (n.name () == "Qualification" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Qualification_type > r (
            Qualification_traits::create (i, f, this));

          this->Qualification_.push_back (r);
          continue;
        }

        break;
      }
    }

    QualificationsType* QualificationsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QualificationsType (*this, f, c);
    }

    QualificationsType::
    ~QualificationsType ()
    {
    }

    // QualificationType
    //

    QualificationType::
    QualificationType (const Description_type& Description)
    : ::xml_schema::type (),
      Attributes_ (::xml_schema::flags (), this),
      Description_ (Description, ::xml_schema::flags (), this)
    {
    }

    QualificationType::
    QualificationType (const QualificationType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Description_ (x.Description_, f, this)
    {
    }

    QualificationType::
    QualificationType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (f, this),
      Description_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void QualificationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!Description_.present ())
          {
            this->Description_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Description_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Description",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    QualificationType* QualificationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QualificationType (*this, f, c);
    }

    QualificationType::
    ~QualificationType ()
    {
    }

    // SensorType
    //

    SensorType::
    SensorType (const Name_type& Name,
                const id_type& id,
                const Qualifications_type& Qualifications)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id),
      Qualifications_ (Qualifications, ::xml_schema::flags (), this),
      AAngle_ (::xml_schema::flags (), this),
      BAngle_ (::xml_schema::flags (), this)
    {
    }

    SensorType::
    SensorType (const Name_type& Name,
                const id_type& id,
                ::std::auto_ptr< Qualifications_type >& Qualifications)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id),
      Qualifications_ (Qualifications, ::xml_schema::flags (), this),
      AAngle_ (::xml_schema::flags (), this),
      BAngle_ (::xml_schema::flags (), this)
    {
    }

    SensorType::
    SensorType (const SensorType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (x, f, c),
      Qualifications_ (x.Qualifications_, f, this),
      AAngle_ (x.AAngle_, f, this),
      BAngle_ (x.BAngle_, f, this)
    {
    }

    SensorType::
    SensorType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      Qualifications_ (f, this),
      AAngle_ (f, this),
      BAngle_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SensorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Qualifications
        //
        if (n.name () == "Qualifications" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Qualifications_type > r (
            Qualifications_traits::create (i, f, this));

          if (!Qualifications_.present ())
          {
            this->Qualifications_.set (r);
            continue;
          }
        }

        // AAngle
        //
        if (n.name () == "AAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AAngle_type > r (
            AAngle_traits::create (i, f, this));

          if (!this->AAngle_)
          {
            this->AAngle_.set (r);
            continue;
          }
        }

        // BAngle
        //
        if (n.name () == "BAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BAngle_type > r (
            BAngle_traits::create (i, f, this));

          if (!this->BAngle_)
          {
            this->BAngle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Qualifications_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Qualifications",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SensorType* SensorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SensorType (*this, f, c);
    }

    SensorType::
    ~SensorType ()
    {
    }

    // TouchProbeType
    //

    TouchProbeType::
    TouchProbeType (const Name_type& Name,
                    const id_type& id,
                    const Qualifications_type& Qualifications,
                    const TipDiameter_type& TipDiameter)
    : ::xsd::qif2::SensorType (Name,
                               id,
                               Qualifications),
      TipDiameter_ (TipDiameter, ::xml_schema::flags (), this)
    {
    }

    TouchProbeType::
    TouchProbeType (const Name_type& Name,
                    const id_type& id,
                    ::std::auto_ptr< Qualifications_type >& Qualifications,
                    ::std::auto_ptr< TipDiameter_type >& TipDiameter)
    : ::xsd::qif2::SensorType (Name,
                               id,
                               Qualifications),
      TipDiameter_ (TipDiameter, ::xml_schema::flags (), this)
    {
    }

    TouchProbeType::
    TouchProbeType (const TouchProbeType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SensorType (x, f, c),
      TipDiameter_ (x.TipDiameter_, f, this)
    {
    }

    TouchProbeType::
    TouchProbeType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SensorType (e, f | ::xml_schema::flags::base, c),
      TipDiameter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void TouchProbeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SensorType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TipDiameter
        //
        if (n.name () == "TipDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TipDiameter_type > r (
            TipDiameter_traits::create (i, f, this));

          if (!TipDiameter_.present ())
          {
            this->TipDiameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!TipDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TipDiameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TouchProbeType* TouchProbeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TouchProbeType (*this, f, c);
    }

    TouchProbeType::
    ~TouchProbeType ()
    {
    }

    // ToolType
    //

    ToolType::
    ToolType (const Name_type& Name,
              const id_type& id)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id),
      SensorIds_ (::xml_schema::flags (), this)
    {
    }

    ToolType::
    ToolType (const ToolType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (x, f, c),
      SensorIds_ (x.SensorIds_, f, this)
    {
    }

    ToolType::
    ToolType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      SensorIds_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ToolType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SensorIds
        //
        if (n.name () == "SensorIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SensorIds_type > r (
            SensorIds_traits::create (i, f, this));

          if (!this->SensorIds_)
          {
            this->SensorIds_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToolType* ToolType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToolType (*this, f, c);
    }

    ToolType::
    ~ToolType ()
    {
    }

    // CarriageType
    //

    CarriageType::
    CarriageType (const Name_type& Name,
                  const id_type& id)
    : ::xsd::qif2::MeasurementResourceBaseType (Name,
                                                id),
      ToolIds_ (::xml_schema::flags (), this)
    {
    }

    CarriageType::
    CarriageType (const CarriageType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (x, f, c),
      ToolIds_ (x.ToolIds_, f, this)
    {
    }

    CarriageType::
    CarriageType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementResourceBaseType (e, f | ::xml_schema::flags::base, c),
      ToolIds_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CarriageType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurementResourceBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ToolIds
        //
        if (n.name () == "ToolIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ToolIds_type > r (
            ToolIds_traits::create (i, f, this));

          if (!this->ToolIds_)
          {
            this->ToolIds_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CarriageType* CarriageType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CarriageType (*this, f, c);
    }

    CarriageType::
    ~CarriageType ()
    {
    }

    // ProbingDeviceType
    //

    ProbingDeviceType::
    ProbingDeviceType (const Name_type& Name,
                       const id_type& id)
    : ::xsd::qif2::MeasurementDeviceType (Name,
                                          id),
      WorkingVolume_ (::xml_schema::flags (), this),
      EffectiveWorkingVolume_ (::xml_schema::flags (), this),
      Resolution_ (::xml_schema::flags (), this)
    {
    }

    ProbingDeviceType::
    ProbingDeviceType (const ProbingDeviceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (x, f, c),
      WorkingVolume_ (x.WorkingVolume_, f, this),
      EffectiveWorkingVolume_ (x.EffectiveWorkingVolume_, f, this),
      Resolution_ (x.Resolution_, f, this)
    {
    }

    ProbingDeviceType::
    ProbingDeviceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (e, f | ::xml_schema::flags::base, c),
      WorkingVolume_ (f, this),
      EffectiveWorkingVolume_ (f, this),
      Resolution_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ProbingDeviceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::MeasurementDeviceType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // WorkingVolume
        //
        if (n.name () == "WorkingVolume" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WorkingVolume_type > r (
            WorkingVolume_traits::create (i, f, this));

          if (!this->WorkingVolume_)
          {
            this->WorkingVolume_.set (r);
            continue;
          }
        }

        // EffectiveWorkingVolume
        //
        if (n.name () == "EffectiveWorkingVolume" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EffectiveWorkingVolume_type > r (
            EffectiveWorkingVolume_traits::create (i, f, this));

          if (!this->EffectiveWorkingVolume_)
          {
            this->EffectiveWorkingVolume_.set (r);
            continue;
          }
        }

        // Resolution
        //
        if (n.name () == "Resolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Resolution_type > r (
            Resolution_traits::create (i, f, this));

          if (!this->Resolution_)
          {
            this->Resolution_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ProbingDeviceType* ProbingDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProbingDeviceType (*this, f, c);
    }

    ProbingDeviceType::
    ~ProbingDeviceType ()
    {
    }

    // CMMType
    //

    CMMType::
    CMMType (const Name_type& Name,
             const id_type& id)
    : ::xsd::qif2::ProbingDeviceType (Name,
                                      id),
      HomeLocation_ (::xml_schema::flags (), this),
      MachineGeometry_ (::xml_schema::flags (), this),
      AxisOrientation_ (::xml_schema::flags (), this),
      CMMScales_ (::xml_schema::flags (), this),
      MaxWorkpieceHeight_ (::xml_schema::flags (), this),
      MaxWorkpieceMass_ (::xml_schema::flags (), this),
      JoystickSpeeds_ (::xml_schema::flags (), this),
      CNCSpeeds_ (::xml_schema::flags (), this),
      RotaryTable_ (::xml_schema::flags (), this),
      NominalAccuracy_ (::xml_schema::flags (), this),
      ActualAccuracy_ (::xml_schema::flags (), this),
      CarriageIds_ (::xml_schema::flags (), this),
      ToolIds_ (::xml_schema::flags (), this)
    {
    }

    CMMType::
    CMMType (const CMMType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::ProbingDeviceType (x, f, c),
      HomeLocation_ (x.HomeLocation_, f, this),
      MachineGeometry_ (x.MachineGeometry_, f, this),
      AxisOrientation_ (x.AxisOrientation_, f, this),
      CMMScales_ (x.CMMScales_, f, this),
      MaxWorkpieceHeight_ (x.MaxWorkpieceHeight_, f, this),
      MaxWorkpieceMass_ (x.MaxWorkpieceMass_, f, this),
      JoystickSpeeds_ (x.JoystickSpeeds_, f, this),
      CNCSpeeds_ (x.CNCSpeeds_, f, this),
      RotaryTable_ (x.RotaryTable_, f, this),
      NominalAccuracy_ (x.NominalAccuracy_, f, this),
      ActualAccuracy_ (x.ActualAccuracy_, f, this),
      CarriageIds_ (x.CarriageIds_, f, this),
      ToolIds_ (x.ToolIds_, f, this)
    {
    }

    CMMType::
    CMMType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::ProbingDeviceType (e, f | ::xml_schema::flags::base, c),
      HomeLocation_ (f, this),
      MachineGeometry_ (f, this),
      AxisOrientation_ (f, this),
      CMMScales_ (f, this),
      MaxWorkpieceHeight_ (f, this),
      MaxWorkpieceMass_ (f, this),
      JoystickSpeeds_ (f, this),
      CNCSpeeds_ (f, this),
      RotaryTable_ (f, this),
      NominalAccuracy_ (f, this),
      ActualAccuracy_ (f, this),
      CarriageIds_ (f, this),
      ToolIds_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CMMType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ProbingDeviceType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // HomeLocation
        //
        if (n.name () == "HomeLocation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HomeLocation_type > r (
            HomeLocation_traits::create (i, f, this));

          if (!this->HomeLocation_)
          {
            this->HomeLocation_.set (r);
            continue;
          }
        }

        // MachineGeometry
        //
        if (n.name () == "MachineGeometry" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MachineGeometry_type > r (
            MachineGeometry_traits::create (i, f, this));

          if (!this->MachineGeometry_)
          {
            this->MachineGeometry_.set (r);
            continue;
          }
        }

        // AxisOrientation
        //
        if (n.name () == "AxisOrientation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisOrientation_type > r (
            AxisOrientation_traits::create (i, f, this));

          if (!this->AxisOrientation_)
          {
            this->AxisOrientation_.set (r);
            continue;
          }
        }

        // CMMScales
        //
        if (n.name () == "CMMScales" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CMMScales_type > r (
            CMMScales_traits::create (i, f, this));

          if (!this->CMMScales_)
          {
            this->CMMScales_.set (r);
            continue;
          }
        }

        // MaxWorkpieceHeight
        //
        if (n.name () == "MaxWorkpieceHeight" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxWorkpieceHeight_type > r (
            MaxWorkpieceHeight_traits::create (i, f, this));

          if (!this->MaxWorkpieceHeight_)
          {
            this->MaxWorkpieceHeight_.set (r);
            continue;
          }
        }

        // MaxWorkpieceMass
        //
        if (n.name () == "MaxWorkpieceMass" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxWorkpieceMass_type > r (
            MaxWorkpieceMass_traits::create (i, f, this));

          if (!this->MaxWorkpieceMass_)
          {
            this->MaxWorkpieceMass_.set (r);
            continue;
          }
        }

        // JoystickSpeeds
        //
        if (n.name () == "JoystickSpeeds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< JoystickSpeeds_type > r (
            JoystickSpeeds_traits::create (i, f, this));

          if (!this->JoystickSpeeds_)
          {
            this->JoystickSpeeds_.set (r);
            continue;
          }
        }

        // CNCSpeeds
        //
        if (n.name () == "CNCSpeeds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CNCSpeeds_type > r (
            CNCSpeeds_traits::create (i, f, this));

          if (!this->CNCSpeeds_)
          {
            this->CNCSpeeds_.set (r);
            continue;
          }
        }

        // RotaryTable
        //
        if (n.name () == "RotaryTable" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RotaryTable_type > r (
            RotaryTable_traits::create (i, f, this));

          if (!this->RotaryTable_)
          {
            this->RotaryTable_.set (r);
            continue;
          }
        }

        // NominalAccuracy
        //
        if (n.name () == "NominalAccuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NominalAccuracy_type > r (
            NominalAccuracy_traits::create (i, f, this));

          if (!this->NominalAccuracy_)
          {
            this->NominalAccuracy_.set (r);
            continue;
          }
        }

        // ActualAccuracy
        //
        if (n.name () == "ActualAccuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ActualAccuracy_type > r (
            ActualAccuracy_traits::create (i, f, this));

          if (!this->ActualAccuracy_)
          {
            this->ActualAccuracy_.set (r);
            continue;
          }
        }

        // CarriageIds
        //
        if (n.name () == "CarriageIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CarriageIds_type > r (
            CarriageIds_traits::create (i, f, this));

          if (!this->CarriageIds_)
          {
            this->CarriageIds_.set (r);
            continue;
          }
        }

        // ToolIds
        //
        if (n.name () == "ToolIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ToolIds_type > r (
            ToolIds_traits::create (i, f, this));

          if (!this->ToolIds_)
          {
            this->ToolIds_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CMMType* CMMType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMType (*this, f, c);
    }

    CMMType::
    ~CMMType ()
    {
    }

    // CMMScalesType
    //

    CMMScalesType::
    CMMScalesType (const XScale_type& XScale,
                   const YScale_type& YScale,
                   const ZScale_type& ZScale)
    : ::xml_schema::type (),
      XScale_ (XScale, ::xml_schema::flags (), this),
      YScale_ (YScale, ::xml_schema::flags (), this),
      ZScale_ (ZScale, ::xml_schema::flags (), this)
    {
    }

    CMMScalesType::
    CMMScalesType (::std::auto_ptr< XScale_type >& XScale,
                   ::std::auto_ptr< YScale_type >& YScale,
                   ::std::auto_ptr< ZScale_type >& ZScale)
    : ::xml_schema::type (),
      XScale_ (XScale, ::xml_schema::flags (), this),
      YScale_ (YScale, ::xml_schema::flags (), this),
      ZScale_ (ZScale, ::xml_schema::flags (), this)
    {
    }

    CMMScalesType::
    CMMScalesType (const CMMScalesType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XScale_ (x.XScale_, f, this),
      YScale_ (x.YScale_, f, this),
      ZScale_ (x.ZScale_, f, this)
    {
    }

    CMMScalesType::
    CMMScalesType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XScale_ (f, this),
      YScale_ (f, this),
      ZScale_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CMMScalesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XScale
        //
        if (n.name () == "XScale" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XScale_type > r (
            XScale_traits::create (i, f, this));

          if (!XScale_.present ())
          {
            this->XScale_.set (r);
            continue;
          }
        }

        // YScale
        //
        if (n.name () == "YScale" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YScale_type > r (
            YScale_traits::create (i, f, this));

          if (!YScale_.present ())
          {
            this->YScale_.set (r);
            continue;
          }
        }

        // ZScale
        //
        if (n.name () == "ZScale" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZScale_type > r (
            ZScale_traits::create (i, f, this));

          if (!ZScale_.present ())
          {
            this->ZScale_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XScale",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YScale",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZScale",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CMMScalesType* CMMScalesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMScalesType (*this, f, c);
    }

    CMMScalesType::
    ~CMMScalesType ()
    {
    }

    // CMMScaleType
    //

    CMMScaleType::
    CMMScaleType (const ScaleMaterial_type& ScaleMaterial,
                  const ScaleCoefficientOfExpansion_type& ScaleCoefficientOfExpansion,
                  const ScaleCoefficientOfExpansionUncertainty_type& ScaleCoefficientOfExpansionUncertainty,
                  const TypeOfScale_type& TypeOfScale,
                  const ScaleResolution_type& ScaleResolution)
    : ::xml_schema::type (),
      ScaleMaterial_ (ScaleMaterial, ::xml_schema::flags (), this),
      ScaleCoefficientOfExpansion_ (ScaleCoefficientOfExpansion, ::xml_schema::flags (), this),
      ScaleCoefficientOfExpansionUncertainty_ (ScaleCoefficientOfExpansionUncertainty, ::xml_schema::flags (), this),
      TypeOfScale_ (TypeOfScale, ::xml_schema::flags (), this),
      ScaleResolution_ (ScaleResolution, ::xml_schema::flags (), this)
    {
    }

    CMMScaleType::
    CMMScaleType (const ScaleMaterial_type& ScaleMaterial,
                  const ScaleCoefficientOfExpansion_type& ScaleCoefficientOfExpansion,
                  const ScaleCoefficientOfExpansionUncertainty_type& ScaleCoefficientOfExpansionUncertainty,
                  const TypeOfScale_type& TypeOfScale,
                  ::std::auto_ptr< ScaleResolution_type >& ScaleResolution)
    : ::xml_schema::type (),
      ScaleMaterial_ (ScaleMaterial, ::xml_schema::flags (), this),
      ScaleCoefficientOfExpansion_ (ScaleCoefficientOfExpansion, ::xml_schema::flags (), this),
      ScaleCoefficientOfExpansionUncertainty_ (ScaleCoefficientOfExpansionUncertainty, ::xml_schema::flags (), this),
      TypeOfScale_ (TypeOfScale, ::xml_schema::flags (), this),
      ScaleResolution_ (ScaleResolution, ::xml_schema::flags (), this)
    {
    }

    CMMScaleType::
    CMMScaleType (const CMMScaleType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ScaleMaterial_ (x.ScaleMaterial_, f, this),
      ScaleCoefficientOfExpansion_ (x.ScaleCoefficientOfExpansion_, f, this),
      ScaleCoefficientOfExpansionUncertainty_ (x.ScaleCoefficientOfExpansionUncertainty_, f, this),
      TypeOfScale_ (x.TypeOfScale_, f, this),
      ScaleResolution_ (x.ScaleResolution_, f, this)
    {
    }

    CMMScaleType::
    CMMScaleType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ScaleMaterial_ (f, this),
      ScaleCoefficientOfExpansion_ (f, this),
      ScaleCoefficientOfExpansionUncertainty_ (f, this),
      TypeOfScale_ (f, this),
      ScaleResolution_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CMMScaleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ScaleMaterial
        //
        if (n.name () == "ScaleMaterial" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ScaleMaterial_type > r (
            ScaleMaterial_traits::create (i, f, this));

          if (!ScaleMaterial_.present ())
          {
            this->ScaleMaterial_.set (r);
            continue;
          }
        }

        // ScaleCoefficientOfExpansion
        //
        if (n.name () == "ScaleCoefficientOfExpansion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!ScaleCoefficientOfExpansion_.present ())
          {
            this->ScaleCoefficientOfExpansion_.set (ScaleCoefficientOfExpansion_traits::create (i, f, this));
            continue;
          }
        }

        // ScaleCoefficientOfExpansionUncertainty
        //
        if (n.name () == "ScaleCoefficientOfExpansionUncertainty" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!ScaleCoefficientOfExpansionUncertainty_.present ())
          {
            this->ScaleCoefficientOfExpansionUncertainty_.set (ScaleCoefficientOfExpansionUncertainty_traits::create (i, f, this));
            continue;
          }
        }

        // TypeOfScale
        //
        if (n.name () == "TypeOfScale" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TypeOfScale_type > r (
            TypeOfScale_traits::create (i, f, this));

          if (!TypeOfScale_.present ())
          {
            this->TypeOfScale_.set (r);
            continue;
          }
        }

        // ScaleResolution
        //
        if (n.name () == "ScaleResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ScaleResolution_type > r (
            ScaleResolution_traits::create (i, f, this));

          if (!ScaleResolution_.present ())
          {
            this->ScaleResolution_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ScaleMaterial_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleMaterial",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ScaleCoefficientOfExpansion_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleCoefficientOfExpansion",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ScaleCoefficientOfExpansionUncertainty_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleCoefficientOfExpansionUncertainty",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TypeOfScale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TypeOfScale",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ScaleResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ScaleResolution",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CMMScaleType* CMMScaleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMScaleType (*this, f, c);
    }

    CMMScaleType::
    ~CMMScaleType ()
    {
    }

    // CMMSpeedsType
    //

    CMMSpeedsType::
    CMMSpeedsType (const MaxXTraverseSpeed_type& MaxXTraverseSpeed,
                   const MaxYTraverseSpeed_type& MaxYTraverseSpeed,
                   const MaxZTraverseSpeed_type& MaxZTraverseSpeed,
                   const MaxXProbingSpeed_type& MaxXProbingSpeed,
                   const MaxYProbingSpeed_type& MaxYProbingSpeed,
                   const MaxZProbingSpeed_type& MaxZProbingSpeed)
    : ::xml_schema::type (),
      MaxXTraverseSpeed_ (MaxXTraverseSpeed, ::xml_schema::flags (), this),
      MaxYTraverseSpeed_ (MaxYTraverseSpeed, ::xml_schema::flags (), this),
      MaxZTraverseSpeed_ (MaxZTraverseSpeed, ::xml_schema::flags (), this),
      MaxXProbingSpeed_ (MaxXProbingSpeed, ::xml_schema::flags (), this),
      MaxYProbingSpeed_ (MaxYProbingSpeed, ::xml_schema::flags (), this),
      MaxZProbingSpeed_ (MaxZProbingSpeed, ::xml_schema::flags (), this)
    {
    }

    CMMSpeedsType::
    CMMSpeedsType (::std::auto_ptr< MaxXTraverseSpeed_type >& MaxXTraverseSpeed,
                   ::std::auto_ptr< MaxYTraverseSpeed_type >& MaxYTraverseSpeed,
                   ::std::auto_ptr< MaxZTraverseSpeed_type >& MaxZTraverseSpeed,
                   ::std::auto_ptr< MaxXProbingSpeed_type >& MaxXProbingSpeed,
                   ::std::auto_ptr< MaxYProbingSpeed_type >& MaxYProbingSpeed,
                   ::std::auto_ptr< MaxZProbingSpeed_type >& MaxZProbingSpeed)
    : ::xml_schema::type (),
      MaxXTraverseSpeed_ (MaxXTraverseSpeed, ::xml_schema::flags (), this),
      MaxYTraverseSpeed_ (MaxYTraverseSpeed, ::xml_schema::flags (), this),
      MaxZTraverseSpeed_ (MaxZTraverseSpeed, ::xml_schema::flags (), this),
      MaxXProbingSpeed_ (MaxXProbingSpeed, ::xml_schema::flags (), this),
      MaxYProbingSpeed_ (MaxYProbingSpeed, ::xml_schema::flags (), this),
      MaxZProbingSpeed_ (MaxZProbingSpeed, ::xml_schema::flags (), this)
    {
    }

    CMMSpeedsType::
    CMMSpeedsType (const CMMSpeedsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxXTraverseSpeed_ (x.MaxXTraverseSpeed_, f, this),
      MaxYTraverseSpeed_ (x.MaxYTraverseSpeed_, f, this),
      MaxZTraverseSpeed_ (x.MaxZTraverseSpeed_, f, this),
      MaxXProbingSpeed_ (x.MaxXProbingSpeed_, f, this),
      MaxYProbingSpeed_ (x.MaxYProbingSpeed_, f, this),
      MaxZProbingSpeed_ (x.MaxZProbingSpeed_, f, this)
    {
    }

    CMMSpeedsType::
    CMMSpeedsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxXTraverseSpeed_ (f, this),
      MaxYTraverseSpeed_ (f, this),
      MaxZTraverseSpeed_ (f, this),
      MaxXProbingSpeed_ (f, this),
      MaxYProbingSpeed_ (f, this),
      MaxZProbingSpeed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CMMSpeedsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxXTraverseSpeed
        //
        if (n.name () == "MaxXTraverseSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxXTraverseSpeed_type > r (
            MaxXTraverseSpeed_traits::create (i, f, this));

          if (!MaxXTraverseSpeed_.present ())
          {
            this->MaxXTraverseSpeed_.set (r);
            continue;
          }
        }

        // MaxYTraverseSpeed
        //
        if (n.name () == "MaxYTraverseSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxYTraverseSpeed_type > r (
            MaxYTraverseSpeed_traits::create (i, f, this));

          if (!MaxYTraverseSpeed_.present ())
          {
            this->MaxYTraverseSpeed_.set (r);
            continue;
          }
        }

        // MaxZTraverseSpeed
        //
        if (n.name () == "MaxZTraverseSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxZTraverseSpeed_type > r (
            MaxZTraverseSpeed_traits::create (i, f, this));

          if (!MaxZTraverseSpeed_.present ())
          {
            this->MaxZTraverseSpeed_.set (r);
            continue;
          }
        }

        // MaxXProbingSpeed
        //
        if (n.name () == "MaxXProbingSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxXProbingSpeed_type > r (
            MaxXProbingSpeed_traits::create (i, f, this));

          if (!MaxXProbingSpeed_.present ())
          {
            this->MaxXProbingSpeed_.set (r);
            continue;
          }
        }

        // MaxYProbingSpeed
        //
        if (n.name () == "MaxYProbingSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxYProbingSpeed_type > r (
            MaxYProbingSpeed_traits::create (i, f, this));

          if (!MaxYProbingSpeed_.present ())
          {
            this->MaxYProbingSpeed_.set (r);
            continue;
          }
        }

        // MaxZProbingSpeed
        //
        if (n.name () == "MaxZProbingSpeed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxZProbingSpeed_type > r (
            MaxZProbingSpeed_traits::create (i, f, this));

          if (!MaxZProbingSpeed_.present ())
          {
            this->MaxZProbingSpeed_.set (r);
            continue;
          }
        }

        break;
      }

      if (!MaxXTraverseSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxXTraverseSpeed",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxYTraverseSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxYTraverseSpeed",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxZTraverseSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxZTraverseSpeed",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxXProbingSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxXProbingSpeed",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxYProbingSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxYProbingSpeed",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxZProbingSpeed_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxZProbingSpeed",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CMMSpeedsType* CMMSpeedsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMSpeedsType (*this, f, c);
    }

    CMMSpeedsType::
    ~CMMSpeedsType ()
    {
    }

    // GageDeviceType
    //

    GageDeviceType::
    GageDeviceType (const Name_type& Name,
                    const id_type& id)
    : ::xsd::qif2::MeasurementDeviceType (Name,
                                          id)
    {
    }

    GageDeviceType::
    GageDeviceType (const GageDeviceType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (x, f, c)
    {
    }

    GageDeviceType::
    GageDeviceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (e, f, c)
    {
    }

    GageDeviceType* GageDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GageDeviceType (*this, f, c);
    }

    GageDeviceType::
    ~GageDeviceType ()
    {
    }

    // ManualDeviceType
    //

    ManualDeviceType::
    ManualDeviceType (const Name_type& Name,
                      const id_type& id)
    : ::xsd::qif2::MeasurementDeviceType (Name,
                                          id)
    {
    }

    ManualDeviceType::
    ManualDeviceType (const ManualDeviceType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (x, f, c)
    {
    }

    ManualDeviceType::
    ManualDeviceType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceType (e, f, c)
    {
    }

    ManualDeviceType* ManualDeviceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ManualDeviceType (*this, f, c);
    }

    ManualDeviceType::
    ~ManualDeviceType ()
    {
    }

    // CaliperType
    //

    CaliperType::
    CaliperType (const Name_type& Name,
                 const id_type& id)
    : ::xsd::qif2::ManualDeviceType (Name,
                                     id),
      Resolution_ (::xml_schema::flags (), this),
      Accuracy_ (::xml_schema::flags (), this),
      MinMeasurement_ (::xml_schema::flags (), this),
      MaxMeasurement_ (::xml_schema::flags (), this),
      CanMeasureInnerD_ (::xml_schema::flags (), this),
      CanMeasureOuterD_ (::xml_schema::flags (), this),
      CanMeasureDepth_ (::xml_schema::flags (), this)
    {
    }

    CaliperType::
    CaliperType (const CaliperType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ManualDeviceType (x, f, c),
      Resolution_ (x.Resolution_, f, this),
      Accuracy_ (x.Accuracy_, f, this),
      MinMeasurement_ (x.MinMeasurement_, f, this),
      MaxMeasurement_ (x.MaxMeasurement_, f, this),
      CanMeasureInnerD_ (x.CanMeasureInnerD_, f, this),
      CanMeasureOuterD_ (x.CanMeasureOuterD_, f, this),
      CanMeasureDepth_ (x.CanMeasureDepth_, f, this)
    {
    }

    CaliperType::
    CaliperType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ManualDeviceType (e, f | ::xml_schema::flags::base, c),
      Resolution_ (f, this),
      Accuracy_ (f, this),
      MinMeasurement_ (f, this),
      MaxMeasurement_ (f, this),
      CanMeasureInnerD_ (f, this),
      CanMeasureOuterD_ (f, this),
      CanMeasureDepth_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CaliperType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ManualDeviceType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Resolution
        //
        if (n.name () == "Resolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Resolution_type > r (
            Resolution_traits::create (i, f, this));

          if (!this->Resolution_)
          {
            this->Resolution_.set (r);
            continue;
          }
        }

        // Accuracy
        //
        if (n.name () == "Accuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Accuracy_type > r (
            Accuracy_traits::create (i, f, this));

          if (!this->Accuracy_)
          {
            this->Accuracy_.set (r);
            continue;
          }
        }

        // MinMeasurement
        //
        if (n.name () == "MinMeasurement" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinMeasurement_type > r (
            MinMeasurement_traits::create (i, f, this));

          if (!this->MinMeasurement_)
          {
            this->MinMeasurement_.set (r);
            continue;
          }
        }

        // MaxMeasurement
        //
        if (n.name () == "MaxMeasurement" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxMeasurement_type > r (
            MaxMeasurement_traits::create (i, f, this));

          if (!this->MaxMeasurement_)
          {
            this->MaxMeasurement_.set (r);
            continue;
          }
        }

        // CanMeasureInnerD
        //
        if (n.name () == "CanMeasureInnerD" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->CanMeasureInnerD_)
          {
            this->CanMeasureInnerD_.set (CanMeasureInnerD_traits::create (i, f, this));
            continue;
          }
        }

        // CanMeasureOuterD
        //
        if (n.name () == "CanMeasureOuterD" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->CanMeasureOuterD_)
          {
            this->CanMeasureOuterD_.set (CanMeasureOuterD_traits::create (i, f, this));
            continue;
          }
        }

        // CanMeasureDepth
        //
        if (n.name () == "CanMeasureDepth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->CanMeasureDepth_)
          {
            this->CanMeasureDepth_.set (CanMeasureDepth_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    CaliperType* CaliperType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CaliperType (*this, f, c);
    }

    CaliperType::
    ~CaliperType ()
    {
    }

    // CMMDirectionEnumType
    //

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CMMDirectionEnumType_convert ();
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CMMDirectionEnumType_convert ();
    }

    CMMDirectionEnumType::
    CMMDirectionEnumType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CMMDirectionEnumType_convert ();
    }

    CMMDirectionEnumType* CMMDirectionEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMDirectionEnumType (*this, f, c);
    }

    CMMDirectionEnumType::value CMMDirectionEnumType::
    _xsd_CMMDirectionEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CMMDirectionEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CMMDirectionEnumType_indexes_,
                        _xsd_CMMDirectionEnumType_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_CMMDirectionEnumType_indexes_ + 6 || _xsd_CMMDirectionEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const CMMDirectionEnumType::
    _xsd_CMMDirectionEnumType_literals_[6] =
    {
      "RIGHT",
      "LEFT",
      "FRONT",
      "BACK",
      "UP",
      "DOWN"
    };

    const CMMDirectionEnumType::value CMMDirectionEnumType::
    _xsd_CMMDirectionEnumType_indexes_[6] =
    {
      ::xsd::qif2::CMMDirectionEnumType::BACK,
      ::xsd::qif2::CMMDirectionEnumType::DOWN,
      ::xsd::qif2::CMMDirectionEnumType::FRONT,
      ::xsd::qif2::CMMDirectionEnumType::LEFT,
      ::xsd::qif2::CMMDirectionEnumType::RIGHT,
      ::xsd::qif2::CMMDirectionEnumType::UP
    };

    // CMMGeometryType
    //

    CMMGeometryType::
    CMMGeometryType ()
    : ::xml_schema::type (),
      CMMGeometryEnum_ (::xml_schema::flags (), this),
      OtherCMMGeometry_ (::xml_schema::flags (), this)
    {
    }

    CMMGeometryType::
    CMMGeometryType (const CMMGeometryType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CMMGeometryEnum_ (x.CMMGeometryEnum_, f, this),
      OtherCMMGeometry_ (x.OtherCMMGeometry_, f, this)
    {
    }

    CMMGeometryType::
    CMMGeometryType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CMMGeometryEnum_ (f, this),
      OtherCMMGeometry_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CMMGeometryType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CMMGeometryEnum
        //
        if (n.name () == "CMMGeometryEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CMMGeometryEnum_type > r (
            CMMGeometryEnum_traits::create (i, f, this));

          if (!this->CMMGeometryEnum_)
          {
            this->CMMGeometryEnum_.set (r);
            continue;
          }
        }

        // OtherCMMGeometry
        //
        if (n.name () == "OtherCMMGeometry" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherCMMGeometry_type > r (
            OtherCMMGeometry_traits::create (i, f, this));

          if (!this->OtherCMMGeometry_)
          {
            this->OtherCMMGeometry_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CMMGeometryType* CMMGeometryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMGeometryType (*this, f, c);
    }

    CMMGeometryType::
    ~CMMGeometryType ()
    {
    }

    // CMMGeometryEnumType
    //

    CMMGeometryEnumType::
    CMMGeometryEnumType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_CMMGeometryEnumType_convert ();
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_CMMGeometryEnumType_convert ();
    }

    CMMGeometryEnumType::
    CMMGeometryEnumType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_CMMGeometryEnumType_convert ();
    }

    CMMGeometryEnumType* CMMGeometryEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMGeometryEnumType (*this, f, c);
    }

    CMMGeometryEnumType::value CMMGeometryEnumType::
    _xsd_CMMGeometryEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CMMGeometryEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_CMMGeometryEnumType_indexes_,
                        _xsd_CMMGeometryEnumType_indexes_ + 8,
                        *this,
                        c));

      if (i == _xsd_CMMGeometryEnumType_indexes_ + 8 || _xsd_CMMGeometryEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const CMMGeometryEnumType::
    _xsd_CMMGeometryEnumType_literals_[8] =
    {
      "CANTILEVER",
      "BRIDGEMOVINGBRIDGE",
      "BRIDGEMOVINGTABLE",
      "COLUMN",
      "GANTRY",
      "HORIZONTALARMMOVINGARM",
      "HORIZONTALARMMOVINGTABLE",
      "ARTICULATEDARM"
    };

    const CMMGeometryEnumType::value CMMGeometryEnumType::
    _xsd_CMMGeometryEnumType_indexes_[8] =
    {
      ::xsd::qif2::CMMGeometryEnumType::ARTICULATEDARM,
      ::xsd::qif2::CMMGeometryEnumType::BRIDGEMOVINGBRIDGE,
      ::xsd::qif2::CMMGeometryEnumType::BRIDGEMOVINGTABLE,
      ::xsd::qif2::CMMGeometryEnumType::CANTILEVER,
      ::xsd::qif2::CMMGeometryEnumType::COLUMN,
      ::xsd::qif2::CMMGeometryEnumType::GANTRY,
      ::xsd::qif2::CMMGeometryEnumType::HORIZONTALARMMOVINGARM,
      ::xsd::qif2::CMMGeometryEnumType::HORIZONTALARMMOVINGTABLE
    };

    // CMMAxisDirectionsType
    //

    CMMAxisDirectionsType::
    CMMAxisDirectionsType (const XAxisDirection_type& XAxisDirection,
                           const YAxisDirection_type& YAxisDirection,
                           const ZAxisDirection_type& ZAxisDirection)
    : ::xml_schema::type (),
      XAxisDirection_ (XAxisDirection, ::xml_schema::flags (), this),
      YAxisDirection_ (YAxisDirection, ::xml_schema::flags (), this),
      ZAxisDirection_ (ZAxisDirection, ::xml_schema::flags (), this)
    {
    }

    CMMAxisDirectionsType::
    CMMAxisDirectionsType (const CMMAxisDirectionsType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XAxisDirection_ (x.XAxisDirection_, f, this),
      YAxisDirection_ (x.YAxisDirection_, f, this),
      ZAxisDirection_ (x.ZAxisDirection_, f, this)
    {
    }

    CMMAxisDirectionsType::
    CMMAxisDirectionsType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XAxisDirection_ (f, this),
      YAxisDirection_ (f, this),
      ZAxisDirection_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CMMAxisDirectionsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XAxisDirection
        //
        if (n.name () == "XAxisDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisDirection_type > r (
            XAxisDirection_traits::create (i, f, this));

          if (!XAxisDirection_.present ())
          {
            this->XAxisDirection_.set (r);
            continue;
          }
        }

        // YAxisDirection
        //
        if (n.name () == "YAxisDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisDirection_type > r (
            YAxisDirection_traits::create (i, f, this));

          if (!YAxisDirection_.present ())
          {
            this->YAxisDirection_.set (r);
            continue;
          }
        }

        // ZAxisDirection
        //
        if (n.name () == "ZAxisDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisDirection_type > r (
            ZAxisDirection_traits::create (i, f, this));

          if (!ZAxisDirection_.present ())
          {
            this->ZAxisDirection_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XAxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisDirection",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CMMAxisDirectionsType* CMMAxisDirectionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMAxisDirectionsType (*this, f, c);
    }

    CMMAxisDirectionsType::
    ~CMMAxisDirectionsType ()
    {
    }

    // WorkingVolumeType
    //

    WorkingVolumeType::
    WorkingVolumeType (const XAxisLength_type& XAxisLength,
                       const YAxisLength_type& YAxisLength,
                       const ZAxisLength_type& ZAxisLength)
    : ::xml_schema::type (),
      XAxisLength_ (XAxisLength, ::xml_schema::flags (), this),
      YAxisLength_ (YAxisLength, ::xml_schema::flags (), this),
      ZAxisLength_ (ZAxisLength, ::xml_schema::flags (), this)
    {
    }

    WorkingVolumeType::
    WorkingVolumeType (::std::auto_ptr< XAxisLength_type >& XAxisLength,
                       ::std::auto_ptr< YAxisLength_type >& YAxisLength,
                       ::std::auto_ptr< ZAxisLength_type >& ZAxisLength)
    : ::xml_schema::type (),
      XAxisLength_ (XAxisLength, ::xml_schema::flags (), this),
      YAxisLength_ (YAxisLength, ::xml_schema::flags (), this),
      ZAxisLength_ (ZAxisLength, ::xml_schema::flags (), this)
    {
    }

    WorkingVolumeType::
    WorkingVolumeType (const WorkingVolumeType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XAxisLength_ (x.XAxisLength_, f, this),
      YAxisLength_ (x.YAxisLength_, f, this),
      ZAxisLength_ (x.ZAxisLength_, f, this)
    {
    }

    WorkingVolumeType::
    WorkingVolumeType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XAxisLength_ (f, this),
      YAxisLength_ (f, this),
      ZAxisLength_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void WorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XAxisLength
        //
        if (n.name () == "XAxisLength" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisLength_type > r (
            XAxisLength_traits::create (i, f, this));

          if (!XAxisLength_.present ())
          {
            this->XAxisLength_.set (r);
            continue;
          }
        }

        // YAxisLength
        //
        if (n.name () == "YAxisLength" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisLength_type > r (
            YAxisLength_traits::create (i, f, this));

          if (!YAxisLength_.present ())
          {
            this->YAxisLength_.set (r);
            continue;
          }
        }

        // ZAxisLength
        //
        if (n.name () == "ZAxisLength" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisLength_type > r (
            ZAxisLength_traits::create (i, f, this));

          if (!ZAxisLength_.present ())
          {
            this->ZAxisLength_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XAxisLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisLength",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisLength",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisLength_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisLength",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    WorkingVolumeType* WorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class WorkingVolumeType (*this, f, c);
    }

    WorkingVolumeType::
    ~WorkingVolumeType ()
    {
    }

    // EffectiveWorkingVolumeType
    //

    EffectiveWorkingVolumeType::
    EffectiveWorkingVolumeType (const MinPoint_type& MinPoint,
                                const MaxPoint_type& MaxPoint)
    : ::xml_schema::type (),
      MinPoint_ (MinPoint, ::xml_schema::flags (), this),
      MaxPoint_ (MaxPoint, ::xml_schema::flags (), this)
    {
    }

    EffectiveWorkingVolumeType::
    EffectiveWorkingVolumeType (::std::auto_ptr< MinPoint_type >& MinPoint,
                                ::std::auto_ptr< MaxPoint_type >& MaxPoint)
    : ::xml_schema::type (),
      MinPoint_ (MinPoint, ::xml_schema::flags (), this),
      MaxPoint_ (MaxPoint, ::xml_schema::flags (), this)
    {
    }

    EffectiveWorkingVolumeType::
    EffectiveWorkingVolumeType (const EffectiveWorkingVolumeType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MinPoint_ (x.MinPoint_, f, this),
      MaxPoint_ (x.MaxPoint_, f, this)
    {
    }

    EffectiveWorkingVolumeType::
    EffectiveWorkingVolumeType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MinPoint_ (f, this),
      MaxPoint_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EffectiveWorkingVolumeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MinPoint
        //
        if (n.name () == "MinPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinPoint_type > r (
            MinPoint_traits::create (i, f, this));

          if (!MinPoint_.present ())
          {
            this->MinPoint_.set (r);
            continue;
          }
        }

        // MaxPoint
        //
        if (n.name () == "MaxPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxPoint_type > r (
            MaxPoint_traits::create (i, f, this));

          if (!MaxPoint_.present ())
          {
            this->MaxPoint_.set (r);
            continue;
          }
        }

        break;
      }

      if (!MinPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MinPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxPoint",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EffectiveWorkingVolumeType* EffectiveWorkingVolumeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EffectiveWorkingVolumeType (*this, f, c);
    }

    EffectiveWorkingVolumeType::
    ~EffectiveWorkingVolumeType ()
    {
    }

    // RotaryTableType
    //

    RotaryTableType::
    RotaryTableType (const LocationOnCMM_type& LocationOnCMM,
                     const AxisDirection_type& AxisDirection,
                     const ZeroIndexDirection_type& ZeroIndexDirection,
                     const TableRadius_type& TableRadius,
                     const TableErrors_type& TableErrors)
    : ::xml_schema::type (),
      LocationOnCMM_ (LocationOnCMM, ::xml_schema::flags (), this),
      AxisDirection_ (AxisDirection, ::xml_schema::flags (), this),
      ZeroIndexDirection_ (ZeroIndexDirection, ::xml_schema::flags (), this),
      TableRadius_ (TableRadius, ::xml_schema::flags (), this),
      TableErrors_ (TableErrors, ::xml_schema::flags (), this)
    {
    }

    RotaryTableType::
    RotaryTableType (::std::auto_ptr< LocationOnCMM_type >& LocationOnCMM,
                     ::std::auto_ptr< AxisDirection_type >& AxisDirection,
                     ::std::auto_ptr< ZeroIndexDirection_type >& ZeroIndexDirection,
                     ::std::auto_ptr< TableRadius_type >& TableRadius,
                     ::std::auto_ptr< TableErrors_type >& TableErrors)
    : ::xml_schema::type (),
      LocationOnCMM_ (LocationOnCMM, ::xml_schema::flags (), this),
      AxisDirection_ (AxisDirection, ::xml_schema::flags (), this),
      ZeroIndexDirection_ (ZeroIndexDirection, ::xml_schema::flags (), this),
      TableRadius_ (TableRadius, ::xml_schema::flags (), this),
      TableErrors_ (TableErrors, ::xml_schema::flags (), this)
    {
    }

    RotaryTableType::
    RotaryTableType (const RotaryTableType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LocationOnCMM_ (x.LocationOnCMM_, f, this),
      AxisDirection_ (x.AxisDirection_, f, this),
      ZeroIndexDirection_ (x.ZeroIndexDirection_, f, this),
      TableRadius_ (x.TableRadius_, f, this),
      TableErrors_ (x.TableErrors_, f, this)
    {
    }

    RotaryTableType::
    RotaryTableType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LocationOnCMM_ (f, this),
      AxisDirection_ (f, this),
      ZeroIndexDirection_ (f, this),
      TableRadius_ (f, this),
      TableErrors_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void RotaryTableType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // LocationOnCMM
        //
        if (n.name () == "LocationOnCMM" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LocationOnCMM_type > r (
            LocationOnCMM_traits::create (i, f, this));

          if (!LocationOnCMM_.present ())
          {
            this->LocationOnCMM_.set (r);
            continue;
          }
        }

        // AxisDirection
        //
        if (n.name () == "AxisDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisDirection_type > r (
            AxisDirection_traits::create (i, f, this));

          if (!AxisDirection_.present ())
          {
            this->AxisDirection_.set (r);
            continue;
          }
        }

        // ZeroIndexDirection
        //
        if (n.name () == "ZeroIndexDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZeroIndexDirection_type > r (
            ZeroIndexDirection_traits::create (i, f, this));

          if (!ZeroIndexDirection_.present ())
          {
            this->ZeroIndexDirection_.set (r);
            continue;
          }
        }

        // TableRadius
        //
        if (n.name () == "TableRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TableRadius_type > r (
            TableRadius_traits::create (i, f, this));

          if (!TableRadius_.present ())
          {
            this->TableRadius_.set (r);
            continue;
          }
        }

        // TableErrors
        //
        if (n.name () == "TableErrors" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TableErrors_type > r (
            TableErrors_traits::create (i, f, this));

          if (!TableErrors_.present ())
          {
            this->TableErrors_.set (r);
            continue;
          }
        }

        break;
      }

      if (!LocationOnCMM_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LocationOnCMM",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!AxisDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AxisDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZeroIndexDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZeroIndexDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TableRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TableRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TableErrors_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TableErrors",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    RotaryTableType* RotaryTableType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RotaryTableType (*this, f, c);
    }

    RotaryTableType::
    ~RotaryTableType ()
    {
    }

    // TableErrorsType
    //

    TableErrorsType::
    TableErrorsType (const AxialError_type& AxialError,
                     const RadialError_type& RadialError,
                     const TangentialError_type& TangentialError)
    : ::xml_schema::type (),
      AxialError_ (AxialError, ::xml_schema::flags (), this),
      RadialError_ (RadialError, ::xml_schema::flags (), this),
      TangentialError_ (TangentialError, ::xml_schema::flags (), this)
    {
    }

    TableErrorsType::
    TableErrorsType (::std::auto_ptr< AxialError_type >& AxialError,
                     ::std::auto_ptr< RadialError_type >& RadialError,
                     ::std::auto_ptr< TangentialError_type >& TangentialError)
    : ::xml_schema::type (),
      AxialError_ (AxialError, ::xml_schema::flags (), this),
      RadialError_ (RadialError, ::xml_schema::flags (), this),
      TangentialError_ (TangentialError, ::xml_schema::flags (), this)
    {
    }

    TableErrorsType::
    TableErrorsType (const TableErrorsType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AxialError_ (x.AxialError_, f, this),
      RadialError_ (x.RadialError_, f, this),
      TangentialError_ (x.TangentialError_, f, this)
    {
    }

    TableErrorsType::
    TableErrorsType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AxialError_ (f, this),
      RadialError_ (f, this),
      TangentialError_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TableErrorsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AxialError
        //
        if (n.name () == "AxialError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxialError_type > r (
            AxialError_traits::create (i, f, this));

          if (!AxialError_.present ())
          {
            this->AxialError_.set (r);
            continue;
          }
        }

        // RadialError
        //
        if (n.name () == "RadialError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RadialError_type > r (
            RadialError_traits::create (i, f, this));

          if (!RadialError_.present ())
          {
            this->RadialError_.set (r);
            continue;
          }
        }

        // TangentialError
        //
        if (n.name () == "TangentialError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentialError_type > r (
            TangentialError_traits::create (i, f, this));

          if (!TangentialError_.present ())
          {
            this->TangentialError_.set (r);
            continue;
          }
        }

        break;
      }

      if (!AxialError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AxialError",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RadialError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RadialError",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!TangentialError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TangentialError",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TableErrorsType* TableErrorsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TableErrorsType (*this, f, c);
    }

    TableErrorsType::
    ~TableErrorsType ()
    {
    }

    // ResolutionType
    //

    ResolutionType::
    ResolutionType ()
    : ::xml_schema::type (),
      CombinedResolution_ (::xml_schema::flags (), this),
      XYZResolution_ (::xml_schema::flags (), this)
    {
    }

    ResolutionType::
    ResolutionType (const ResolutionType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CombinedResolution_ (x.CombinedResolution_, f, this),
      XYZResolution_ (x.XYZResolution_, f, this)
    {
    }

    ResolutionType::
    ResolutionType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CombinedResolution_ (f, this),
      XYZResolution_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ResolutionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CombinedResolution
        //
        if (n.name () == "CombinedResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CombinedResolution_type > r (
            CombinedResolution_traits::create (i, f, this));

          if (!this->CombinedResolution_)
          {
            this->CombinedResolution_.set (r);
            continue;
          }
        }

        // XYZResolution
        //
        if (n.name () == "XYZResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XYZResolution_type > r (
            XYZResolution_traits::create (i, f, this));

          if (!this->XYZResolution_)
          {
            this->XYZResolution_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ResolutionType* ResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ResolutionType (*this, f, c);
    }

    ResolutionType::
    ~ResolutionType ()
    {
    }

    // XYZResolutionType
    //

    XYZResolutionType::
    XYZResolutionType (const XResolution_type& XResolution,
                       const YResolution_type& YResolution,
                       const ZResolution_type& ZResolution)
    : ::xml_schema::type (),
      XResolution_ (XResolution, ::xml_schema::flags (), this),
      YResolution_ (YResolution, ::xml_schema::flags (), this),
      ZResolution_ (ZResolution, ::xml_schema::flags (), this)
    {
    }

    XYZResolutionType::
    XYZResolutionType (::std::auto_ptr< XResolution_type >& XResolution,
                       ::std::auto_ptr< YResolution_type >& YResolution,
                       ::std::auto_ptr< ZResolution_type >& ZResolution)
    : ::xml_schema::type (),
      XResolution_ (XResolution, ::xml_schema::flags (), this),
      YResolution_ (YResolution, ::xml_schema::flags (), this),
      ZResolution_ (ZResolution, ::xml_schema::flags (), this)
    {
    }

    XYZResolutionType::
    XYZResolutionType (const XYZResolutionType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XResolution_ (x.XResolution_, f, this),
      YResolution_ (x.YResolution_, f, this),
      ZResolution_ (x.ZResolution_, f, this)
    {
    }

    XYZResolutionType::
    XYZResolutionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XResolution_ (f, this),
      YResolution_ (f, this),
      ZResolution_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void XYZResolutionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XResolution
        //
        if (n.name () == "XResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XResolution_type > r (
            XResolution_traits::create (i, f, this));

          if (!XResolution_.present ())
          {
            this->XResolution_.set (r);
            continue;
          }
        }

        // YResolution
        //
        if (n.name () == "YResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YResolution_type > r (
            YResolution_traits::create (i, f, this));

          if (!YResolution_.present ())
          {
            this->YResolution_.set (r);
            continue;
          }
        }

        // ZResolution
        //
        if (n.name () == "ZResolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZResolution_type > r (
            ZResolution_traits::create (i, f, this));

          if (!ZResolution_.present ())
          {
            this->ZResolution_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XResolution",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YResolution",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZResolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZResolution",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    XYZResolutionType* XYZResolutionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class XYZResolutionType (*this, f, c);
    }

    XYZResolutionType::
    ~XYZResolutionType ()
    {
    }

    // CMMAccuracyTestBaseType
    //

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType ()
    : ::xml_schema::type ()
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const CMMAccuracyTestBaseType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    CMMAccuracyTestBaseType::
    CMMAccuracyTestBaseType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    CMMAccuracyTestBaseType* CMMAccuracyTestBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMAccuracyTestBaseType (*this, f, c);
    }

    CMMAccuracyTestBaseType::
    ~CMMAccuracyTestBaseType ()
    {
    }

    // FPSTestType
    //

    FPSTestType::
    FPSTestType (const XLinearity_type& XLinearity,
                 const YLinearity_type& YLinearity,
                 const ZLinearity_type& ZLinearity,
                 const XAxisRoll_type& XAxisRoll,
                 const XAxisPitch_type& XAxisPitch,
                 const XAxisYaw_type& XAxisYaw,
                 const YAxisRoll_type& YAxisRoll,
                 const YAxisPitch_type& YAxisPitch,
                 const YAxisYaw_type& YAxisYaw,
                 const ZAxisRoll_type& ZAxisRoll,
                 const ZAxisPitch_type& ZAxisPitch,
                 const ZAxisYaw_type& ZAxisYaw,
                 const XAxisStraightnessY_type& XAxisStraightnessY,
                 const XAxisStraightnessZ_type& XAxisStraightnessZ,
                 const YAxisStraightnessX_type& YAxisStraightnessX,
                 const YAxisStraightnessZ_type& YAxisStraightnessZ,
                 const ZAxisStraightnessX_type& ZAxisStraightnessX,
                 const ZAxisStraightnessY_type& ZAxisStraightnessY,
                 const XYSquareness_type& XYSquareness,
                 const XZSquareness_type& XZSquareness,
                 const YZSquareness_type& YZSquareness)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      XLinearity_ (XLinearity, ::xml_schema::flags (), this),
      YLinearity_ (YLinearity, ::xml_schema::flags (), this),
      ZLinearity_ (ZLinearity, ::xml_schema::flags (), this),
      XAxisRoll_ (XAxisRoll, ::xml_schema::flags (), this),
      XAxisPitch_ (XAxisPitch, ::xml_schema::flags (), this),
      XAxisYaw_ (XAxisYaw, ::xml_schema::flags (), this),
      YAxisRoll_ (YAxisRoll, ::xml_schema::flags (), this),
      YAxisPitch_ (YAxisPitch, ::xml_schema::flags (), this),
      YAxisYaw_ (YAxisYaw, ::xml_schema::flags (), this),
      ZAxisRoll_ (ZAxisRoll, ::xml_schema::flags (), this),
      ZAxisPitch_ (ZAxisPitch, ::xml_schema::flags (), this),
      ZAxisYaw_ (ZAxisYaw, ::xml_schema::flags (), this),
      XAxisStraightnessY_ (XAxisStraightnessY, ::xml_schema::flags (), this),
      XAxisStraightnessZ_ (XAxisStraightnessZ, ::xml_schema::flags (), this),
      YAxisStraightnessX_ (YAxisStraightnessX, ::xml_schema::flags (), this),
      YAxisStraightnessZ_ (YAxisStraightnessZ, ::xml_schema::flags (), this),
      ZAxisStraightnessX_ (ZAxisStraightnessX, ::xml_schema::flags (), this),
      ZAxisStraightnessY_ (ZAxisStraightnessY, ::xml_schema::flags (), this),
      XYSquareness_ (XYSquareness, ::xml_schema::flags (), this),
      XZSquareness_ (XZSquareness, ::xml_schema::flags (), this),
      YZSquareness_ (YZSquareness, ::xml_schema::flags (), this)
    {
    }

    FPSTestType::
    FPSTestType (::std::auto_ptr< XLinearity_type >& XLinearity,
                 ::std::auto_ptr< YLinearity_type >& YLinearity,
                 ::std::auto_ptr< ZLinearity_type >& ZLinearity,
                 ::std::auto_ptr< XAxisRoll_type >& XAxisRoll,
                 ::std::auto_ptr< XAxisPitch_type >& XAxisPitch,
                 ::std::auto_ptr< XAxisYaw_type >& XAxisYaw,
                 ::std::auto_ptr< YAxisRoll_type >& YAxisRoll,
                 ::std::auto_ptr< YAxisPitch_type >& YAxisPitch,
                 ::std::auto_ptr< YAxisYaw_type >& YAxisYaw,
                 ::std::auto_ptr< ZAxisRoll_type >& ZAxisRoll,
                 ::std::auto_ptr< ZAxisPitch_type >& ZAxisPitch,
                 ::std::auto_ptr< ZAxisYaw_type >& ZAxisYaw,
                 ::std::auto_ptr< XAxisStraightnessY_type >& XAxisStraightnessY,
                 ::std::auto_ptr< XAxisStraightnessZ_type >& XAxisStraightnessZ,
                 ::std::auto_ptr< YAxisStraightnessX_type >& YAxisStraightnessX,
                 ::std::auto_ptr< YAxisStraightnessZ_type >& YAxisStraightnessZ,
                 ::std::auto_ptr< ZAxisStraightnessX_type >& ZAxisStraightnessX,
                 ::std::auto_ptr< ZAxisStraightnessY_type >& ZAxisStraightnessY,
                 const XYSquareness_type& XYSquareness,
                 const XZSquareness_type& XZSquareness,
                 const YZSquareness_type& YZSquareness)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      XLinearity_ (XLinearity, ::xml_schema::flags (), this),
      YLinearity_ (YLinearity, ::xml_schema::flags (), this),
      ZLinearity_ (ZLinearity, ::xml_schema::flags (), this),
      XAxisRoll_ (XAxisRoll, ::xml_schema::flags (), this),
      XAxisPitch_ (XAxisPitch, ::xml_schema::flags (), this),
      XAxisYaw_ (XAxisYaw, ::xml_schema::flags (), this),
      YAxisRoll_ (YAxisRoll, ::xml_schema::flags (), this),
      YAxisPitch_ (YAxisPitch, ::xml_schema::flags (), this),
      YAxisYaw_ (YAxisYaw, ::xml_schema::flags (), this),
      ZAxisRoll_ (ZAxisRoll, ::xml_schema::flags (), this),
      ZAxisPitch_ (ZAxisPitch, ::xml_schema::flags (), this),
      ZAxisYaw_ (ZAxisYaw, ::xml_schema::flags (), this),
      XAxisStraightnessY_ (XAxisStraightnessY, ::xml_schema::flags (), this),
      XAxisStraightnessZ_ (XAxisStraightnessZ, ::xml_schema::flags (), this),
      YAxisStraightnessX_ (YAxisStraightnessX, ::xml_schema::flags (), this),
      YAxisStraightnessZ_ (YAxisStraightnessZ, ::xml_schema::flags (), this),
      ZAxisStraightnessX_ (ZAxisStraightnessX, ::xml_schema::flags (), this),
      ZAxisStraightnessY_ (ZAxisStraightnessY, ::xml_schema::flags (), this),
      XYSquareness_ (XYSquareness, ::xml_schema::flags (), this),
      XZSquareness_ (XZSquareness, ::xml_schema::flags (), this),
      YZSquareness_ (YZSquareness, ::xml_schema::flags (), this)
    {
    }

    FPSTestType::
    FPSTestType (const FPSTestType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (x, f, c),
      XLinearity_ (x.XLinearity_, f, this),
      YLinearity_ (x.YLinearity_, f, this),
      ZLinearity_ (x.ZLinearity_, f, this),
      XAxisRoll_ (x.XAxisRoll_, f, this),
      XAxisPitch_ (x.XAxisPitch_, f, this),
      XAxisYaw_ (x.XAxisYaw_, f, this),
      YAxisRoll_ (x.YAxisRoll_, f, this),
      YAxisPitch_ (x.YAxisPitch_, f, this),
      YAxisYaw_ (x.YAxisYaw_, f, this),
      ZAxisRoll_ (x.ZAxisRoll_, f, this),
      ZAxisPitch_ (x.ZAxisPitch_, f, this),
      ZAxisYaw_ (x.ZAxisYaw_, f, this),
      XAxisStraightnessY_ (x.XAxisStraightnessY_, f, this),
      XAxisStraightnessZ_ (x.XAxisStraightnessZ_, f, this),
      YAxisStraightnessX_ (x.YAxisStraightnessX_, f, this),
      YAxisStraightnessZ_ (x.YAxisStraightnessZ_, f, this),
      ZAxisStraightnessX_ (x.ZAxisStraightnessX_, f, this),
      ZAxisStraightnessY_ (x.ZAxisStraightnessY_, f, this),
      XYSquareness_ (x.XYSquareness_, f, this),
      XZSquareness_ (x.XZSquareness_, f, this),
      YZSquareness_ (x.YZSquareness_, f, this)
    {
    }

    FPSTestType::
    FPSTestType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      XLinearity_ (f, this),
      YLinearity_ (f, this),
      ZLinearity_ (f, this),
      XAxisRoll_ (f, this),
      XAxisPitch_ (f, this),
      XAxisYaw_ (f, this),
      YAxisRoll_ (f, this),
      YAxisPitch_ (f, this),
      YAxisYaw_ (f, this),
      ZAxisRoll_ (f, this),
      ZAxisPitch_ (f, this),
      ZAxisYaw_ (f, this),
      XAxisStraightnessY_ (f, this),
      XAxisStraightnessZ_ (f, this),
      YAxisStraightnessX_ (f, this),
      YAxisStraightnessZ_ (f, this),
      ZAxisStraightnessX_ (f, this),
      ZAxisStraightnessY_ (f, this),
      XYSquareness_ (f, this),
      XZSquareness_ (f, this),
      YZSquareness_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void FPSTestType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XLinearity
        //
        if (n.name () == "XLinearity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XLinearity_type > r (
            XLinearity_traits::create (i, f, this));

          if (!XLinearity_.present ())
          {
            this->XLinearity_.set (r);
            continue;
          }
        }

        // YLinearity
        //
        if (n.name () == "YLinearity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YLinearity_type > r (
            YLinearity_traits::create (i, f, this));

          if (!YLinearity_.present ())
          {
            this->YLinearity_.set (r);
            continue;
          }
        }

        // ZLinearity
        //
        if (n.name () == "ZLinearity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZLinearity_type > r (
            ZLinearity_traits::create (i, f, this));

          if (!ZLinearity_.present ())
          {
            this->ZLinearity_.set (r);
            continue;
          }
        }

        // XAxisRoll
        //
        if (n.name () == "XAxisRoll" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisRoll_type > r (
            XAxisRoll_traits::create (i, f, this));

          if (!XAxisRoll_.present ())
          {
            this->XAxisRoll_.set (r);
            continue;
          }
        }

        // XAxisPitch
        //
        if (n.name () == "XAxisPitch" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisPitch_type > r (
            XAxisPitch_traits::create (i, f, this));

          if (!XAxisPitch_.present ())
          {
            this->XAxisPitch_.set (r);
            continue;
          }
        }

        // XAxisYaw
        //
        if (n.name () == "XAxisYaw" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisYaw_type > r (
            XAxisYaw_traits::create (i, f, this));

          if (!XAxisYaw_.present ())
          {
            this->XAxisYaw_.set (r);
            continue;
          }
        }

        // YAxisRoll
        //
        if (n.name () == "YAxisRoll" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisRoll_type > r (
            YAxisRoll_traits::create (i, f, this));

          if (!YAxisRoll_.present ())
          {
            this->YAxisRoll_.set (r);
            continue;
          }
        }

        // YAxisPitch
        //
        if (n.name () == "YAxisPitch" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisPitch_type > r (
            YAxisPitch_traits::create (i, f, this));

          if (!YAxisPitch_.present ())
          {
            this->YAxisPitch_.set (r);
            continue;
          }
        }

        // YAxisYaw
        //
        if (n.name () == "YAxisYaw" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisYaw_type > r (
            YAxisYaw_traits::create (i, f, this));

          if (!YAxisYaw_.present ())
          {
            this->YAxisYaw_.set (r);
            continue;
          }
        }

        // ZAxisRoll
        //
        if (n.name () == "ZAxisRoll" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisRoll_type > r (
            ZAxisRoll_traits::create (i, f, this));

          if (!ZAxisRoll_.present ())
          {
            this->ZAxisRoll_.set (r);
            continue;
          }
        }

        // ZAxisPitch
        //
        if (n.name () == "ZAxisPitch" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisPitch_type > r (
            ZAxisPitch_traits::create (i, f, this));

          if (!ZAxisPitch_.present ())
          {
            this->ZAxisPitch_.set (r);
            continue;
          }
        }

        // ZAxisYaw
        //
        if (n.name () == "ZAxisYaw" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisYaw_type > r (
            ZAxisYaw_traits::create (i, f, this));

          if (!ZAxisYaw_.present ())
          {
            this->ZAxisYaw_.set (r);
            continue;
          }
        }

        // XAxisStraightnessY
        //
        if (n.name () == "XAxisStraightnessY" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisStraightnessY_type > r (
            XAxisStraightnessY_traits::create (i, f, this));

          if (!XAxisStraightnessY_.present ())
          {
            this->XAxisStraightnessY_.set (r);
            continue;
          }
        }

        // XAxisStraightnessZ
        //
        if (n.name () == "XAxisStraightnessZ" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XAxisStraightnessZ_type > r (
            XAxisStraightnessZ_traits::create (i, f, this));

          if (!XAxisStraightnessZ_.present ())
          {
            this->XAxisStraightnessZ_.set (r);
            continue;
          }
        }

        // YAxisStraightnessX
        //
        if (n.name () == "YAxisStraightnessX" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisStraightnessX_type > r (
            YAxisStraightnessX_traits::create (i, f, this));

          if (!YAxisStraightnessX_.present ())
          {
            this->YAxisStraightnessX_.set (r);
            continue;
          }
        }

        // YAxisStraightnessZ
        //
        if (n.name () == "YAxisStraightnessZ" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YAxisStraightnessZ_type > r (
            YAxisStraightnessZ_traits::create (i, f, this));

          if (!YAxisStraightnessZ_.present ())
          {
            this->YAxisStraightnessZ_.set (r);
            continue;
          }
        }

        // ZAxisStraightnessX
        //
        if (n.name () == "ZAxisStraightnessX" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisStraightnessX_type > r (
            ZAxisStraightnessX_traits::create (i, f, this));

          if (!ZAxisStraightnessX_.present ())
          {
            this->ZAxisStraightnessX_.set (r);
            continue;
          }
        }

        // ZAxisStraightnessY
        //
        if (n.name () == "ZAxisStraightnessY" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZAxisStraightnessY_type > r (
            ZAxisStraightnessY_traits::create (i, f, this));

          if (!ZAxisStraightnessY_.present ())
          {
            this->ZAxisStraightnessY_.set (r);
            continue;
          }
        }

        // XYSquareness
        //
        if (n.name () == "XYSquareness" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!XYSquareness_.present ())
          {
            this->XYSquareness_.set (XYSquareness_traits::create (i, f, this));
            continue;
          }
        }

        // XZSquareness
        //
        if (n.name () == "XZSquareness" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!XZSquareness_.present ())
          {
            this->XZSquareness_.set (XZSquareness_traits::create (i, f, this));
            continue;
          }
        }

        // YZSquareness
        //
        if (n.name () == "YZSquareness" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!YZSquareness_.present ())
          {
            this->YZSquareness_.set (YZSquareness_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!XLinearity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XLinearity",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YLinearity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YLinearity",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZLinearity_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZLinearity",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XAxisRoll_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisRoll",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XAxisPitch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisPitch",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XAxisYaw_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisYaw",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisRoll_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisRoll",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisPitch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisPitch",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisYaw_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisYaw",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisRoll_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisRoll",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisPitch_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisPitch",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisYaw_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisYaw",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XAxisStraightnessY_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisStraightnessY",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XAxisStraightnessZ_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XAxisStraightnessZ",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisStraightnessX_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisStraightnessX",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YAxisStraightnessZ_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YAxisStraightnessZ",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisStraightnessX_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisStraightnessX",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZAxisStraightnessY_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZAxisStraightnessY",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XYSquareness_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XYSquareness",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!XZSquareness_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XZSquareness",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YZSquareness_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YZSquareness",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FPSTestType* FPSTestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FPSTestType (*this, f, c);
    }

    FPSTestType::
    ~FPSTestType ()
    {
    }

    // FunctionDiscreteType
    //

    FunctionDiscreteType::
    FunctionDiscreteType (const DomainValues_type& DomainValues,
                          const RangeValues_type& RangeValues,
                          const N_type& N)
    : ::xml_schema::type (),
      DomainValues_ (DomainValues, ::xml_schema::flags (), this),
      RangeValues_ (RangeValues, ::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    FunctionDiscreteType::
    FunctionDiscreteType (const FunctionDiscreteType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DomainValues_ (x.DomainValues_, f, this),
      RangeValues_ (x.RangeValues_, f, this),
      N_ (x.N_, f, this)
    {
    }

    FunctionDiscreteType::
    FunctionDiscreteType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DomainValues_ (f, this),
      RangeValues_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void FunctionDiscreteType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DomainValues
        //
        if (n.name () == "DomainValues" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DomainValues_type > r (
            DomainValues_traits::create (i, f, this));

          if (!DomainValues_.present ())
          {
            this->DomainValues_.set (r);
            continue;
          }
        }

        // RangeValues
        //
        if (n.name () == "RangeValues" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RangeValues_type > r (
            RangeValues_traits::create (i, f, this));

          if (!RangeValues_.present ())
          {
            this->RangeValues_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DomainValues_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DomainValues",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RangeValues_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RangeValues",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    FunctionDiscreteType* FunctionDiscreteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FunctionDiscreteType (*this, f, c);
    }

    FunctionDiscreteType::
    ~FunctionDiscreteType ()
    {
    }

    // LengthFunctionDiscreteType
    //

    LengthFunctionDiscreteType::
    LengthFunctionDiscreteType (const DomainValues_type& DomainValues,
                                const RangeValues_type& RangeValues,
                                const N_type& N,
                                const DomainLinearUnit_type& DomainLinearUnit,
                                const RangeLinearUnit_type& RangeLinearUnit)
    : ::xsd::qif2::FunctionDiscreteType (DomainValues,
                                         RangeValues,
                                         N),
      DomainLinearUnit_ (DomainLinearUnit, ::xml_schema::flags (), this),
      RangeLinearUnit_ (RangeLinearUnit, ::xml_schema::flags (), this)
    {
    }

    LengthFunctionDiscreteType::
    LengthFunctionDiscreteType (const LengthFunctionDiscreteType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FunctionDiscreteType (x, f, c),
      DomainLinearUnit_ (x.DomainLinearUnit_, f, this),
      RangeLinearUnit_ (x.RangeLinearUnit_, f, this)
    {
    }

    LengthFunctionDiscreteType::
    LengthFunctionDiscreteType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FunctionDiscreteType (e, f | ::xml_schema::flags::base, c),
      DomainLinearUnit_ (f, this),
      RangeLinearUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void LengthFunctionDiscreteType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FunctionDiscreteType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DomainLinearUnit
        //
        if (n.name () == "DomainLinearUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DomainLinearUnit_type > r (
            DomainLinearUnit_traits::create (i, f, this));

          if (!DomainLinearUnit_.present ())
          {
            this->DomainLinearUnit_.set (r);
            continue;
          }
        }

        // RangeLinearUnit
        //
        if (n.name () == "RangeLinearUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RangeLinearUnit_type > r (
            RangeLinearUnit_traits::create (i, f, this));

          if (!RangeLinearUnit_.present ())
          {
            this->RangeLinearUnit_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DomainLinearUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DomainLinearUnit",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RangeLinearUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RangeLinearUnit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LengthFunctionDiscreteType* LengthFunctionDiscreteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LengthFunctionDiscreteType (*this, f, c);
    }

    LengthFunctionDiscreteType::
    ~LengthFunctionDiscreteType ()
    {
    }

    // AngleFunctionDiscreteType
    //

    AngleFunctionDiscreteType::
    AngleFunctionDiscreteType (const DomainValues_type& DomainValues,
                               const RangeValues_type& RangeValues,
                               const N_type& N,
                               const DomainLinearUnit_type& DomainLinearUnit,
                               const RangeAngularUnit_type& RangeAngularUnit)
    : ::xsd::qif2::FunctionDiscreteType (DomainValues,
                                         RangeValues,
                                         N),
      DomainLinearUnit_ (DomainLinearUnit, ::xml_schema::flags (), this),
      RangeAngularUnit_ (RangeAngularUnit, ::xml_schema::flags (), this)
    {
    }

    AngleFunctionDiscreteType::
    AngleFunctionDiscreteType (const AngleFunctionDiscreteType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FunctionDiscreteType (x, f, c),
      DomainLinearUnit_ (x.DomainLinearUnit_, f, this),
      RangeAngularUnit_ (x.RangeAngularUnit_, f, this)
    {
    }

    AngleFunctionDiscreteType::
    AngleFunctionDiscreteType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FunctionDiscreteType (e, f | ::xml_schema::flags::base, c),
      DomainLinearUnit_ (f, this),
      RangeAngularUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void AngleFunctionDiscreteType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FunctionDiscreteType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DomainLinearUnit
        //
        if (n.name () == "DomainLinearUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DomainLinearUnit_type > r (
            DomainLinearUnit_traits::create (i, f, this));

          if (!DomainLinearUnit_.present ())
          {
            this->DomainLinearUnit_.set (r);
            continue;
          }
        }

        // RangeAngularUnit
        //
        if (n.name () == "RangeAngularUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RangeAngularUnit_type > r (
            RangeAngularUnit_traits::create (i, f, this));

          if (!RangeAngularUnit_.present ())
          {
            this->RangeAngularUnit_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DomainLinearUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DomainLinearUnit",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RangeAngularUnit_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RangeAngularUnit",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AngleFunctionDiscreteType* AngleFunctionDiscreteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngleFunctionDiscreteType (*this, f, c);
    }

    AngleFunctionDiscreteType::
    ~AngleFunctionDiscreteType ()
    {
    }

    // B89TestType
    //

    B89TestType::
    B89TestType (const XLinearAccuracy_type& XLinearAccuracy,
                 const YLinearAccuracy_type& YLinearAccuracy,
                 const ZLinearAccuracy_type& ZLinearAccuracy,
                 const OffsetVolumetricPerformance_type& OffsetVolumetricPerformance,
                 const VolumetricPerformance_type& VolumetricPerformance,
                 const Repeatability_type& Repeatability)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      XLinearAccuracy_ (XLinearAccuracy, ::xml_schema::flags (), this),
      YLinearAccuracy_ (YLinearAccuracy, ::xml_schema::flags (), this),
      ZLinearAccuracy_ (ZLinearAccuracy, ::xml_schema::flags (), this),
      OffsetVolumetricPerformance_ (OffsetVolumetricPerformance, ::xml_schema::flags (), this),
      VolumetricPerformance_ (VolumetricPerformance, ::xml_schema::flags (), this),
      Repeatability_ (Repeatability, ::xml_schema::flags (), this)
    {
    }

    B89TestType::
    B89TestType (::std::auto_ptr< XLinearAccuracy_type >& XLinearAccuracy,
                 ::std::auto_ptr< YLinearAccuracy_type >& YLinearAccuracy,
                 ::std::auto_ptr< ZLinearAccuracy_type >& ZLinearAccuracy,
                 ::std::auto_ptr< OffsetVolumetricPerformance_type >& OffsetVolumetricPerformance,
                 ::std::auto_ptr< VolumetricPerformance_type >& VolumetricPerformance,
                 ::std::auto_ptr< Repeatability_type >& Repeatability)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      XLinearAccuracy_ (XLinearAccuracy, ::xml_schema::flags (), this),
      YLinearAccuracy_ (YLinearAccuracy, ::xml_schema::flags (), this),
      ZLinearAccuracy_ (ZLinearAccuracy, ::xml_schema::flags (), this),
      OffsetVolumetricPerformance_ (OffsetVolumetricPerformance, ::xml_schema::flags (), this),
      VolumetricPerformance_ (VolumetricPerformance, ::xml_schema::flags (), this),
      Repeatability_ (Repeatability, ::xml_schema::flags (), this)
    {
    }

    B89TestType::
    B89TestType (const B89TestType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (x, f, c),
      XLinearAccuracy_ (x.XLinearAccuracy_, f, this),
      YLinearAccuracy_ (x.YLinearAccuracy_, f, this),
      ZLinearAccuracy_ (x.ZLinearAccuracy_, f, this),
      OffsetVolumetricPerformance_ (x.OffsetVolumetricPerformance_, f, this),
      VolumetricPerformance_ (x.VolumetricPerformance_, f, this),
      Repeatability_ (x.Repeatability_, f, this)
    {
    }

    B89TestType::
    B89TestType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      XLinearAccuracy_ (f, this),
      YLinearAccuracy_ (f, this),
      ZLinearAccuracy_ (f, this),
      OffsetVolumetricPerformance_ (f, this),
      VolumetricPerformance_ (f, this),
      Repeatability_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void B89TestType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XLinearAccuracy
        //
        if (n.name () == "XLinearAccuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XLinearAccuracy_type > r (
            XLinearAccuracy_traits::create (i, f, this));

          if (!XLinearAccuracy_.present ())
          {
            this->XLinearAccuracy_.set (r);
            continue;
          }
        }

        // YLinearAccuracy
        //
        if (n.name () == "YLinearAccuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YLinearAccuracy_type > r (
            YLinearAccuracy_traits::create (i, f, this));

          if (!YLinearAccuracy_.present ())
          {
            this->YLinearAccuracy_.set (r);
            continue;
          }
        }

        // ZLinearAccuracy
        //
        if (n.name () == "ZLinearAccuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZLinearAccuracy_type > r (
            ZLinearAccuracy_traits::create (i, f, this));

          if (!ZLinearAccuracy_.present ())
          {
            this->ZLinearAccuracy_.set (r);
            continue;
          }
        }

        // OffsetVolumetricPerformance
        //
        if (n.name () == "OffsetVolumetricPerformance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OffsetVolumetricPerformance_type > r (
            OffsetVolumetricPerformance_traits::create (i, f, this));

          if (!OffsetVolumetricPerformance_.present ())
          {
            this->OffsetVolumetricPerformance_.set (r);
            continue;
          }
        }

        // VolumetricPerformance
        //
        if (n.name () == "VolumetricPerformance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VolumetricPerformance_type > r (
            VolumetricPerformance_traits::create (i, f, this));

          if (!VolumetricPerformance_.present ())
          {
            this->VolumetricPerformance_.set (r);
            continue;
          }
        }

        // Repeatability
        //
        if (n.name () == "Repeatability" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Repeatability_type > r (
            Repeatability_traits::create (i, f, this));

          if (!Repeatability_.present ())
          {
            this->Repeatability_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XLinearAccuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XLinearAccuracy",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YLinearAccuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YLinearAccuracy",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZLinearAccuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZLinearAccuracy",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!OffsetVolumetricPerformance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "OffsetVolumetricPerformance",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!VolumetricPerformance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "VolumetricPerformance",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Repeatability_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Repeatability",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    B89TestType* B89TestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class B89TestType (*this, f, c);
    }

    B89TestType::
    ~B89TestType ()
    {
    }

    // ISO10360TestType
    //

    ISO10360TestType::
    ISO10360TestType ()
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      MaxErrorConstant_ (::xml_schema::flags (), this),
      LinearError_ (::xml_schema::flags (), this),
      LesserError_ (::xml_schema::flags (), this)
    {
    }

    ISO10360TestType::
    ISO10360TestType (const ISO10360TestType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (x, f, c),
      MaxErrorConstant_ (x.MaxErrorConstant_, f, this),
      LinearError_ (x.LinearError_, f, this),
      LesserError_ (x.LesserError_, f, this)
    {
    }

    ISO10360TestType::
    ISO10360TestType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      MaxErrorConstant_ (f, this),
      LinearError_ (f, this),
      LesserError_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ISO10360TestType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxErrorConstant
        //
        if (n.name () == "MaxErrorConstant" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxErrorConstant_type > r (
            MaxErrorConstant_traits::create (i, f, this));

          if (!this->MaxErrorConstant_)
          {
            this->MaxErrorConstant_.set (r);
            continue;
          }
        }

        // LinearError
        //
        if (n.name () == "LinearError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LinearError_type > r (
            LinearError_traits::create (i, f, this));

          if (!this->LinearError_)
          {
            this->LinearError_.set (r);
            continue;
          }
        }

        // LesserError
        //
        if (n.name () == "LesserError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LesserError_type > r (
            LesserError_traits::create (i, f, this));

          if (!this->LesserError_)
          {
            this->LesserError_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ISO10360TestType* ISO10360TestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ISO10360TestType (*this, f, c);
    }

    ISO10360TestType::
    ~ISO10360TestType ()
    {
    }

    // LinearErrorType
    //

    LinearErrorType::
    LinearErrorType (const BaseError_type& BaseError,
                     const ErrorRate_type& ErrorRate)
    : ::xml_schema::type (),
      BaseError_ (BaseError, ::xml_schema::flags (), this),
      ErrorRate_ (ErrorRate, ::xml_schema::flags (), this)
    {
    }

    LinearErrorType::
    LinearErrorType (::std::auto_ptr< BaseError_type >& BaseError,
                     const ErrorRate_type& ErrorRate)
    : ::xml_schema::type (),
      BaseError_ (BaseError, ::xml_schema::flags (), this),
      ErrorRate_ (ErrorRate, ::xml_schema::flags (), this)
    {
    }

    LinearErrorType::
    LinearErrorType (const LinearErrorType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BaseError_ (x.BaseError_, f, this),
      ErrorRate_ (x.ErrorRate_, f, this)
    {
    }

    LinearErrorType::
    LinearErrorType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BaseError_ (f, this),
      ErrorRate_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LinearErrorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseError
        //
        if (n.name () == "BaseError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseError_type > r (
            BaseError_traits::create (i, f, this));

          if (!BaseError_.present ())
          {
            this->BaseError_.set (r);
            continue;
          }
        }

        // ErrorRate
        //
        if (n.name () == "ErrorRate" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!ErrorRate_.present ())
          {
            this->ErrorRate_.set (ErrorRate_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!BaseError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseError",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ErrorRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ErrorRate",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LinearErrorType* LinearErrorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearErrorType (*this, f, c);
    }

    LinearErrorType::
    ~LinearErrorType ()
    {
    }

    // LesserErrorType
    //

    LesserErrorType::
    LesserErrorType (const MaxErrorConstant_type& MaxErrorConstant,
                     const LinearError_type& LinearError)
    : ::xml_schema::type (),
      MaxErrorConstant_ (MaxErrorConstant, ::xml_schema::flags (), this),
      LinearError_ (LinearError, ::xml_schema::flags (), this)
    {
    }

    LesserErrorType::
    LesserErrorType (::std::auto_ptr< MaxErrorConstant_type >& MaxErrorConstant,
                     ::std::auto_ptr< LinearError_type >& LinearError)
    : ::xml_schema::type (),
      MaxErrorConstant_ (MaxErrorConstant, ::xml_schema::flags (), this),
      LinearError_ (LinearError, ::xml_schema::flags (), this)
    {
    }

    LesserErrorType::
    LesserErrorType (const LesserErrorType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MaxErrorConstant_ (x.MaxErrorConstant_, f, this),
      LinearError_ (x.LinearError_, f, this)
    {
    }

    LesserErrorType::
    LesserErrorType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MaxErrorConstant_ (f, this),
      LinearError_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LesserErrorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MaxErrorConstant
        //
        if (n.name () == "MaxErrorConstant" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxErrorConstant_type > r (
            MaxErrorConstant_traits::create (i, f, this));

          if (!MaxErrorConstant_.present ())
          {
            this->MaxErrorConstant_.set (r);
            continue;
          }
        }

        // LinearError
        //
        if (n.name () == "LinearError" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LinearError_type > r (
            LinearError_traits::create (i, f, this));

          if (!LinearError_.present ())
          {
            this->LinearError_.set (r);
            continue;
          }
        }

        break;
      }

      if (!MaxErrorConstant_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxErrorConstant",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!LinearError_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LinearError",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LesserErrorType* LesserErrorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LesserErrorType (*this, f, c);
    }

    LesserErrorType::
    ~LesserErrorType ()
    {
    }

    // PointAccuracyTestType
    //

    PointAccuracyTestType::
    PointAccuracyTestType (const Accuracy_type& Accuracy)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      Accuracy_ (Accuracy, ::xml_schema::flags (), this)
    {
    }

    PointAccuracyTestType::
    PointAccuracyTestType (::std::auto_ptr< Accuracy_type >& Accuracy)
    : ::xsd::qif2::CMMAccuracyTestBaseType (),
      Accuracy_ (Accuracy, ::xml_schema::flags (), this)
    {
    }

    PointAccuracyTestType::
    PointAccuracyTestType (const PointAccuracyTestType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (x, f, c),
      Accuracy_ (x.Accuracy_, f, this)
    {
    }

    PointAccuracyTestType::
    PointAccuracyTestType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::CMMAccuracyTestBaseType (e, f | ::xml_schema::flags::base, c),
      Accuracy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointAccuracyTestType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Accuracy
        //
        if (n.name () == "Accuracy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Accuracy_type > r (
            Accuracy_traits::create (i, f, this));

          if (!Accuracy_.present ())
          {
            this->Accuracy_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Accuracy_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Accuracy",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointAccuracyTestType* PointAccuracyTestType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointAccuracyTestType (*this, f, c);
    }

    PointAccuracyTestType::
    ~PointAccuracyTestType ()
    {
    }

    // CMMAccuracyType
    //

    CMMAccuracyType::
    CMMAccuracyType (const MinTemperature_type& MinTemperature,
                     const MaxTemperature_type& MaxTemperature,
                     const CMMAccuracyTest_type& CMMAccuracyTest)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (),
      MinTemperature_ (MinTemperature, ::xml_schema::flags (), this),
      MaxTemperature_ (MaxTemperature, ::xml_schema::flags (), this),
      CMMAccuracyTest_ (CMMAccuracyTest, ::xml_schema::flags (), this)
    {
    }

    CMMAccuracyType::
    CMMAccuracyType (::std::auto_ptr< MinTemperature_type >& MinTemperature,
                     ::std::auto_ptr< MaxTemperature_type >& MaxTemperature,
                     const CMMAccuracyTest_type& CMMAccuracyTest)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (),
      MinTemperature_ (MinTemperature, ::xml_schema::flags (), this),
      MaxTemperature_ (MaxTemperature, ::xml_schema::flags (), this),
      CMMAccuracyTest_ (CMMAccuracyTest, ::xml_schema::flags (), this)
    {
    }

    CMMAccuracyType::
    CMMAccuracyType (const CMMAccuracyType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (x, f, c),
      MinTemperature_ (x.MinTemperature_, f, this),
      MaxTemperature_ (x.MaxTemperature_, f, this),
      CMMAccuracyTest_ (x.CMMAccuracyTest_, f, this)
    {
    }

    CMMAccuracyType::
    CMMAccuracyType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::MeasurementDeviceAccuracyBaseType (e, f | ::xml_schema::flags::base, c),
      MinTemperature_ (f, this),
      MaxTemperature_ (f, this),
      CMMAccuracyTest_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CMMAccuracyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MinTemperature
        //
        if (n.name () == "MinTemperature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinTemperature_type > r (
            MinTemperature_traits::create (i, f, this));

          if (!MinTemperature_.present ())
          {
            this->MinTemperature_.set (r);
            continue;
          }
        }

        // MaxTemperature
        //
        if (n.name () == "MaxTemperature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxTemperature_type > r (
            MaxTemperature_traits::create (i, f, this));

          if (!MaxTemperature_.present ())
          {
            this->MaxTemperature_.set (r);
            continue;
          }
        }

        // CMMAccuracyTest
        //
        if (n.name () == "CMMAccuracyTest" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CMMAccuracyTest_type > r (
            CMMAccuracyTest_traits::create (i, f, this));

          if (!CMMAccuracyTest_.present ())
          {
            this->CMMAccuracyTest_.set (r);
            continue;
          }
        }

        break;
      }

      if (!MinTemperature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MinTemperature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MaxTemperature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MaxTemperature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CMMAccuracyTest_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CMMAccuracyTest",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CMMAccuracyType* CMMAccuracyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CMMAccuracyType (*this, f, c);
    }

    CMMAccuracyType::
    ~CMMAccuracyType ()
    {
    }

    // ComparatorType
    //

    ComparatorType::
    ComparatorType (const Name_type& Name,
                    const id_type& id)
    : ::xsd::qif2::ProbingDeviceType (Name,
                                      id)
    {
    }

    ComparatorType::
    ComparatorType (const ComparatorType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ProbingDeviceType (x, f, c)
    {
    }

    ComparatorType::
    ComparatorType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ProbingDeviceType (e, f, c)
    {
    }

    ComparatorType* ComparatorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComparatorType (*this, f, c);
    }

    ComparatorType::
    ~ComparatorType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > r (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > r (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > r (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementResources (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementResources (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementResources (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementResources (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementResources (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementResources (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > r (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > r (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > r (
        ::xsd::qif2::MeasurementResources (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > r (
          ::xsd::qif2::MeasurementResources (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "MeasurementResources" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::MeasurementResourcesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MeasurementResources",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType >
    MeasurementResources (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "MeasurementResources" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::MeasurementResourcesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::MeasurementResourcesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MeasurementResources",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > r (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > r (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > r (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementDevice (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasurementDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementDevice (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasurementDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > r (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > r (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > r (
        ::xsd::qif2::MeasurementDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > r (
          ::xsd::qif2::MeasurementDevice (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "MeasurementDevice" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::MeasurementDeviceType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MeasurementDevice",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType >
    MeasurementDevice (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "MeasurementDevice" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::MeasurementDeviceType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::MeasurementDeviceType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MeasurementDevice",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CMMType > r (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CMMType > r (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CMMType > r (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMM (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMM (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMM (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMM (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMM (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMM (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CMMType > r (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CMMType > r (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CMMType > r (
        ::xsd::qif2::CMM (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CMMType > r (
          ::xsd::qif2::CMM (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CMM" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CMMType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CMMType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CMM",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CMMType >
    CMM (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CMM" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CMMType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CMMType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CMM",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CaliperType > r (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CaliperType > r (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CaliperType > r (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Caliper (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Caliper (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Caliper (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Caliper (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Caliper (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Caliper (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CaliperType > r (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CaliperType > r (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CaliperType > r (
        ::xsd::qif2::Caliper (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CaliperType > r (
          ::xsd::qif2::Caliper (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Caliper" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CaliperType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CaliperType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Caliper",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CaliperType >
    Caliper (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Caliper" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CaliperType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CaliperType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Caliper",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::GageDeviceType > r (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GageDeviceType > r (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GageDeviceType > r (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GageDevice (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GageDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GageDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GageDevice (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GageDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GageDevice (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::GageDeviceType > r (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GageDeviceType > r (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GageDeviceType > r (
        ::xsd::qif2::GageDevice (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::GageDeviceType > r (
          ::xsd::qif2::GageDevice (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "GageDevice" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::GageDeviceType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::GageDeviceType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GageDevice",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GageDeviceType >
    GageDevice (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "GageDevice" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::GageDeviceType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::GageDeviceType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GageDevice",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ComparatorType > r (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComparatorType > r (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComparatorType > r (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Comparator (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Comparator (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Comparator (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Comparator (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Comparator (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Comparator (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ComparatorType > r (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComparatorType > r (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComparatorType > r (
        ::xsd::qif2::Comparator (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ComparatorType > r (
          ::xsd::qif2::Comparator (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Comparator" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ComparatorType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ComparatorType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Comparator",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ComparatorType >
    Comparator (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Comparator" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ComparatorType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ComparatorType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Comparator",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > r (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > r (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > r (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMMAccuracyTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMMAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CMMAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMMAccuracyTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMMAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CMMAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > r (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > r (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > r (
        ::xsd::qif2::CMMAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > r (
          ::xsd::qif2::CMMAccuracyTest (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CMMAccuracyTest" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CMMAccuracyTestBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CMMAccuracyTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType >
    CMMAccuracyTest (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CMMAccuracyTest" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CMMAccuracyTestBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CMMAccuracyTestBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CMMAccuracyTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FPSTestType > r (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FPSTestType > r (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FPSTestType > r (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FPSTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FPSTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FPSTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FPSTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FPSTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FPSTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FPSTestType > r (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FPSTestType > r (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FPSTestType > r (
        ::xsd::qif2::FPSTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::FPSTestType > r (
          ::xsd::qif2::FPSTest (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FPSTest" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FPSTestType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FPSTestType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FPSTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FPSTestType >
    FPSTest (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "FPSTest" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FPSTestType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FPSTestType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FPSTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::B89TestType > r (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::B89TestType > r (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::B89TestType > r (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::B89Test (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::B89Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::B89Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::B89Test (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::B89Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::B89Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::B89TestType > r (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::B89TestType > r (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::B89TestType > r (
        ::xsd::qif2::B89Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::B89TestType > r (
          ::xsd::qif2::B89Test (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "B89Test" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::B89TestType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::B89TestType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "B89Test",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::B89TestType >
    B89Test (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "B89Test" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::B89TestType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::B89TestType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "B89Test",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > r (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > r (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > r (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ISO10360Test (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ISO10360Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ISO10360Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ISO10360Test (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ISO10360Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ISO10360Test (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > r (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > r (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > r (
        ::xsd::qif2::ISO10360Test (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > r (
          ::xsd::qif2::ISO10360Test (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ISO10360Test" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ISO10360TestType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ISO10360Test",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ISO10360TestType >
    ISO10360Test (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ISO10360Test" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ISO10360TestType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ISO10360TestType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ISO10360Test",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > r (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > r (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > r (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointAccuracyTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointAccuracyTest (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointAccuracyTest (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > r (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > r (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > r (
        ::xsd::qif2::PointAccuracyTest (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > r (
          ::xsd::qif2::PointAccuracyTest (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointAccuracyTest" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointAccuracyTestType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointAccuracyTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType >
    PointAccuracyTest (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointAccuracyTest" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointAccuracyTestType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointAccuracyTestType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointAccuracyTest",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SensorType > r (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SensorType > r (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SensorType > r (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Sensor (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Sensor (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Sensor (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Sensor (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Sensor (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Sensor (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SensorType > r (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SensorType > r (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SensorType > r (
        ::xsd::qif2::Sensor (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SensorType > r (
          ::xsd::qif2::Sensor (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Sensor" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SensorType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SensorType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Sensor",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SensorType >
    Sensor (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Sensor" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SensorType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SensorType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Sensor",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TouchProbeType > r (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TouchProbeType > r (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TouchProbeType > r (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TouchProbe (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TouchProbe (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TouchProbe (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TouchProbe (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TouchProbe (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TouchProbe (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TouchProbeType > r (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TouchProbeType > r (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TouchProbeType > r (
        ::xsd::qif2::TouchProbe (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::TouchProbeType > r (
          ::xsd::qif2::TouchProbe (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "TouchProbe" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TouchProbeType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TouchProbeType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TouchProbe",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TouchProbeType >
    TouchProbe (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "TouchProbe" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TouchProbeType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TouchProbeType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TouchProbe",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

