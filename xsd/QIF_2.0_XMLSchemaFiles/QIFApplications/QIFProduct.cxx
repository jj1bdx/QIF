// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "QIFProduct.hxx"

namespace xsd
{
  namespace qif2
  {
    // ProductType
    // 

    const ProductType::Header_optional& ProductType::
    Header () const
    {
      return this->Header_;
    }

    ProductType::Header_optional& ProductType::
    Header ()
    {
      return this->Header_;
    }

    void ProductType::
    Header (const Header_type& x)
    {
      this->Header_.set (x);
    }

    void ProductType::
    Header (const Header_optional& x)
    {
      this->Header_ = x;
    }

    void ProductType::
    Header (::std::auto_ptr< Header_type > x)
    {
      this->Header_.set (x);
    }

    const ProductType::GeometrySet_optional& ProductType::
    GeometrySet () const
    {
      return this->GeometrySet_;
    }

    ProductType::GeometrySet_optional& ProductType::
    GeometrySet ()
    {
      return this->GeometrySet_;
    }

    void ProductType::
    GeometrySet (const GeometrySet_type& x)
    {
      this->GeometrySet_.set (x);
    }

    void ProductType::
    GeometrySet (const GeometrySet_optional& x)
    {
      this->GeometrySet_ = x;
    }

    void ProductType::
    GeometrySet (::std::auto_ptr< GeometrySet_type > x)
    {
      this->GeometrySet_.set (x);
    }

    const ProductType::TopologySet_optional& ProductType::
    TopologySet () const
    {
      return this->TopologySet_;
    }

    ProductType::TopologySet_optional& ProductType::
    TopologySet ()
    {
      return this->TopologySet_;
    }

    void ProductType::
    TopologySet (const TopologySet_type& x)
    {
      this->TopologySet_.set (x);
    }

    void ProductType::
    TopologySet (const TopologySet_optional& x)
    {
      this->TopologySet_ = x;
    }

    void ProductType::
    TopologySet (::std::auto_ptr< TopologySet_type > x)
    {
      this->TopologySet_.set (x);
    }

    const ProductType::NoteSet_optional& ProductType::
    NoteSet () const
    {
      return this->NoteSet_;
    }

    ProductType::NoteSet_optional& ProductType::
    NoteSet ()
    {
      return this->NoteSet_;
    }

    void ProductType::
    NoteSet (const NoteSet_type& x)
    {
      this->NoteSet_.set (x);
    }

    void ProductType::
    NoteSet (const NoteSet_optional& x)
    {
      this->NoteSet_ = x;
    }

    void ProductType::
    NoteSet (::std::auto_ptr< NoteSet_type > x)
    {
      this->NoteSet_.set (x);
    }

    const ProductType::NoteFlagSet_optional& ProductType::
    NoteFlagSet () const
    {
      return this->NoteFlagSet_;
    }

    ProductType::NoteFlagSet_optional& ProductType::
    NoteFlagSet ()
    {
      return this->NoteFlagSet_;
    }

    void ProductType::
    NoteFlagSet (const NoteFlagSet_type& x)
    {
      this->NoteFlagSet_.set (x);
    }

    void ProductType::
    NoteFlagSet (const NoteFlagSet_optional& x)
    {
      this->NoteFlagSet_ = x;
    }

    void ProductType::
    NoteFlagSet (::std::auto_ptr< NoteFlagSet_type > x)
    {
      this->NoteFlagSet_.set (x);
    }

    const ProductType::PartNoteSet_optional& ProductType::
    PartNoteSet () const
    {
      return this->PartNoteSet_;
    }

    ProductType::PartNoteSet_optional& ProductType::
    PartNoteSet ()
    {
      return this->PartNoteSet_;
    }

    void ProductType::
    PartNoteSet (const PartNoteSet_type& x)
    {
      this->PartNoteSet_.set (x);
    }

    void ProductType::
    PartNoteSet (const PartNoteSet_optional& x)
    {
      this->PartNoteSet_ = x;
    }

    void ProductType::
    PartNoteSet (::std::auto_ptr< PartNoteSet_type > x)
    {
      this->PartNoteSet_.set (x);
    }

    const ProductType::ViewSet_optional& ProductType::
    ViewSet () const
    {
      return this->ViewSet_;
    }

    ProductType::ViewSet_optional& ProductType::
    ViewSet ()
    {
      return this->ViewSet_;
    }

    void ProductType::
    ViewSet (const ViewSet_type& x)
    {
      this->ViewSet_.set (x);
    }

    void ProductType::
    ViewSet (const ViewSet_optional& x)
    {
      this->ViewSet_ = x;
    }

    void ProductType::
    ViewSet (::std::auto_ptr< ViewSet_type > x)
    {
      this->ViewSet_.set (x);
    }

    const ProductType::LayerSet_optional& ProductType::
    LayerSet () const
    {
      return this->LayerSet_;
    }

    ProductType::LayerSet_optional& ProductType::
    LayerSet ()
    {
      return this->LayerSet_;
    }

    void ProductType::
    LayerSet (const LayerSet_type& x)
    {
      this->LayerSet_.set (x);
    }

    void ProductType::
    LayerSet (const LayerSet_optional& x)
    {
      this->LayerSet_ = x;
    }

    void ProductType::
    LayerSet (::std::auto_ptr< LayerSet_type > x)
    {
      this->LayerSet_.set (x);
    }

    const ProductType::CoordinateSystemSet_optional& ProductType::
    CoordinateSystemSet () const
    {
      return this->CoordinateSystemSet_;
    }

    ProductType::CoordinateSystemSet_optional& ProductType::
    CoordinateSystemSet ()
    {
      return this->CoordinateSystemSet_;
    }

    void ProductType::
    CoordinateSystemSet (const CoordinateSystemSet_type& x)
    {
      this->CoordinateSystemSet_.set (x);
    }

    void ProductType::
    CoordinateSystemSet (const CoordinateSystemSet_optional& x)
    {
      this->CoordinateSystemSet_ = x;
    }

    void ProductType::
    CoordinateSystemSet (::std::auto_ptr< CoordinateSystemSet_type > x)
    {
      this->CoordinateSystemSet_.set (x);
    }

    const ProductType::VisualizationSet_optional& ProductType::
    VisualizationSet () const
    {
      return this->VisualizationSet_;
    }

    ProductType::VisualizationSet_optional& ProductType::
    VisualizationSet ()
    {
      return this->VisualizationSet_;
    }

    void ProductType::
    VisualizationSet (const VisualizationSet_type& x)
    {
      this->VisualizationSet_.set (x);
    }

    void ProductType::
    VisualizationSet (const VisualizationSet_optional& x)
    {
      this->VisualizationSet_ = x;
    }

    void ProductType::
    VisualizationSet (::std::auto_ptr< VisualizationSet_type > x)
    {
      this->VisualizationSet_.set (x);
    }

    const ProductType::AuxiliarySet_optional& ProductType::
    AuxiliarySet () const
    {
      return this->AuxiliarySet_;
    }

    ProductType::AuxiliarySet_optional& ProductType::
    AuxiliarySet ()
    {
      return this->AuxiliarySet_;
    }

    void ProductType::
    AuxiliarySet (const AuxiliarySet_type& x)
    {
      this->AuxiliarySet_.set (x);
    }

    void ProductType::
    AuxiliarySet (const AuxiliarySet_optional& x)
    {
      this->AuxiliarySet_ = x;
    }

    void ProductType::
    AuxiliarySet (::std::auto_ptr< AuxiliarySet_type > x)
    {
      this->AuxiliarySet_.set (x);
    }

    const ProductType::PartSet_optional& ProductType::
    PartSet () const
    {
      return this->PartSet_;
    }

    ProductType::PartSet_optional& ProductType::
    PartSet ()
    {
      return this->PartSet_;
    }

    void ProductType::
    PartSet (const PartSet_type& x)
    {
      this->PartSet_.set (x);
    }

    void ProductType::
    PartSet (const PartSet_optional& x)
    {
      this->PartSet_ = x;
    }

    void ProductType::
    PartSet (::std::auto_ptr< PartSet_type > x)
    {
      this->PartSet_.set (x);
    }

    const ProductType::AssemblySet_optional& ProductType::
    AssemblySet () const
    {
      return this->AssemblySet_;
    }

    ProductType::AssemblySet_optional& ProductType::
    AssemblySet ()
    {
      return this->AssemblySet_;
    }

    void ProductType::
    AssemblySet (const AssemblySet_type& x)
    {
      this->AssemblySet_.set (x);
    }

    void ProductType::
    AssemblySet (const AssemblySet_optional& x)
    {
      this->AssemblySet_ = x;
    }

    void ProductType::
    AssemblySet (::std::auto_ptr< AssemblySet_type > x)
    {
      this->AssemblySet_.set (x);
    }

    const ProductType::ComponentSet_optional& ProductType::
    ComponentSet () const
    {
      return this->ComponentSet_;
    }

    ProductType::ComponentSet_optional& ProductType::
    ComponentSet ()
    {
      return this->ComponentSet_;
    }

    void ProductType::
    ComponentSet (const ComponentSet_type& x)
    {
      this->ComponentSet_.set (x);
    }

    void ProductType::
    ComponentSet (const ComponentSet_optional& x)
    {
      this->ComponentSet_ = x;
    }

    void ProductType::
    ComponentSet (::std::auto_ptr< ComponentSet_type > x)
    {
      this->ComponentSet_.set (x);
    }

    const ProductType::RootPart_optional& ProductType::
    RootPart () const
    {
      return this->RootPart_;
    }

    ProductType::RootPart_optional& ProductType::
    RootPart ()
    {
      return this->RootPart_;
    }

    void ProductType::
    RootPart (const RootPart_type& x)
    {
      this->RootPart_.set (x);
    }

    void ProductType::
    RootPart (const RootPart_optional& x)
    {
      this->RootPart_ = x;
    }

    void ProductType::
    RootPart (::std::auto_ptr< RootPart_type > x)
    {
      this->RootPart_.set (x);
    }

    const ProductType::RootAssembly_optional& ProductType::
    RootAssembly () const
    {
      return this->RootAssembly_;
    }

    ProductType::RootAssembly_optional& ProductType::
    RootAssembly ()
    {
      return this->RootAssembly_;
    }

    void ProductType::
    RootAssembly (const RootAssembly_type& x)
    {
      this->RootAssembly_.set (x);
    }

    void ProductType::
    RootAssembly (const RootAssembly_optional& x)
    {
      this->RootAssembly_ = x;
    }

    void ProductType::
    RootAssembly (::std::auto_ptr< RootAssembly_type > x)
    {
      this->RootAssembly_.set (x);
    }

    const ProductType::RootComponent_optional& ProductType::
    RootComponent () const
    {
      return this->RootComponent_;
    }

    ProductType::RootComponent_optional& ProductType::
    RootComponent ()
    {
      return this->RootComponent_;
    }

    void ProductType::
    RootComponent (const RootComponent_type& x)
    {
      this->RootComponent_.set (x);
    }

    void ProductType::
    RootComponent (const RootComponent_optional& x)
    {
      this->RootComponent_ = x;
    }

    void ProductType::
    RootComponent (::std::auto_ptr< RootComponent_type > x)
    {
      this->RootComponent_.set (x);
    }

    const ProductType::AsmPaths_optional& ProductType::
    AsmPaths () const
    {
      return this->AsmPaths_;
    }

    ProductType::AsmPaths_optional& ProductType::
    AsmPaths ()
    {
      return this->AsmPaths_;
    }

    void ProductType::
    AsmPaths (const AsmPaths_type& x)
    {
      this->AsmPaths_.set (x);
    }

    void ProductType::
    AsmPaths (const AsmPaths_optional& x)
    {
      this->AsmPaths_ = x;
    }

    void ProductType::
    AsmPaths (::std::auto_ptr< AsmPaths_type > x)
    {
      this->AsmPaths_.set (x);
    }


    // AsmPathType
    // 

    const AsmPathType::ComponentIds_optional& AsmPathType::
    ComponentIds () const
    {
      return this->ComponentIds_;
    }

    AsmPathType::ComponentIds_optional& AsmPathType::
    ComponentIds ()
    {
      return this->ComponentIds_;
    }

    void AsmPathType::
    ComponentIds (const ComponentIds_type& x)
    {
      this->ComponentIds_.set (x);
    }

    void AsmPathType::
    ComponentIds (const ComponentIds_optional& x)
    {
      this->ComponentIds_ = x;
    }

    void AsmPathType::
    ComponentIds (::std::auto_ptr< ComponentIds_type > x)
    {
      this->ComponentIds_.set (x);
    }

    const AsmPathType::id_type& AsmPathType::
    id () const
    {
      return this->id_.get ();
    }

    AsmPathType::id_type& AsmPathType::
    id ()
    {
      return this->id_.get ();
    }

    void AsmPathType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void AsmPathType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // AsmPathsType
    // 

    const AsmPathsType::AsmPath_sequence& AsmPathsType::
    AsmPath () const
    {
      return this->AsmPath_;
    }

    AsmPathsType::AsmPath_sequence& AsmPathsType::
    AsmPath ()
    {
      return this->AsmPath_;
    }

    void AsmPathsType::
    AsmPath (const AsmPath_sequence& s)
    {
      this->AsmPath_ = s;
    }

    const AsmPathsType::N_type& AsmPathsType::
    N () const
    {
      return this->N_.get ();
    }

    AsmPathsType::N_type& AsmPathsType::
    N ()
    {
      return this->N_.get ();
    }

    void AsmPathsType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void AsmPathsType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // ProductDefinitionBaseType
    // 

    const ProductDefinitionBaseType::Attributes_optional& ProductDefinitionBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    ProductDefinitionBaseType::Attributes_optional& ProductDefinitionBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void ProductDefinitionBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void ProductDefinitionBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void ProductDefinitionBaseType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const ProductDefinitionBaseType::Name_optional& ProductDefinitionBaseType::
    Name () const
    {
      return this->Name_;
    }

    ProductDefinitionBaseType::Name_optional& ProductDefinitionBaseType::
    Name ()
    {
      return this->Name_;
    }

    void ProductDefinitionBaseType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void ProductDefinitionBaseType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void ProductDefinitionBaseType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const ProductDefinitionBaseType::QPId_optional& ProductDefinitionBaseType::
    QPId () const
    {
      return this->QPId_;
    }

    ProductDefinitionBaseType::QPId_optional& ProductDefinitionBaseType::
    QPId ()
    {
      return this->QPId_;
    }

    void ProductDefinitionBaseType::
    QPId (const QPId_type& x)
    {
      this->QPId_.set (x);
    }

    void ProductDefinitionBaseType::
    QPId (const QPId_optional& x)
    {
      this->QPId_ = x;
    }

    void ProductDefinitionBaseType::
    QPId (::std::auto_ptr< QPId_type > x)
    {
      this->QPId_.set (x);
    }

    const ProductDefinitionBaseType::ModelNumber_optional& ProductDefinitionBaseType::
    ModelNumber () const
    {
      return this->ModelNumber_;
    }

    ProductDefinitionBaseType::ModelNumber_optional& ProductDefinitionBaseType::
    ModelNumber ()
    {
      return this->ModelNumber_;
    }

    void ProductDefinitionBaseType::
    ModelNumber (const ModelNumber_type& x)
    {
      this->ModelNumber_.set (x);
    }

    void ProductDefinitionBaseType::
    ModelNumber (const ModelNumber_optional& x)
    {
      this->ModelNumber_ = x;
    }

    void ProductDefinitionBaseType::
    ModelNumber (::std::auto_ptr< ModelNumber_type > x)
    {
      this->ModelNumber_.set (x);
    }

    const ProductDefinitionBaseType::Description_optional& ProductDefinitionBaseType::
    Description () const
    {
      return this->Description_;
    }

    ProductDefinitionBaseType::Description_optional& ProductDefinitionBaseType::
    Description ()
    {
      return this->Description_;
    }

    void ProductDefinitionBaseType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void ProductDefinitionBaseType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void ProductDefinitionBaseType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const ProductDefinitionBaseType::Version_optional& ProductDefinitionBaseType::
    Version () const
    {
      return this->Version_;
    }

    ProductDefinitionBaseType::Version_optional& ProductDefinitionBaseType::
    Version ()
    {
      return this->Version_;
    }

    void ProductDefinitionBaseType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void ProductDefinitionBaseType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void ProductDefinitionBaseType::
    Version (::std::auto_ptr< Version_type > x)
    {
      this->Version_.set (x);
    }

    const ProductDefinitionBaseType::Material_sequence& ProductDefinitionBaseType::
    Material () const
    {
      return this->Material_;
    }

    ProductDefinitionBaseType::Material_sequence& ProductDefinitionBaseType::
    Material ()
    {
      return this->Material_;
    }

    void ProductDefinitionBaseType::
    Material (const Material_sequence& s)
    {
      this->Material_ = s;
    }

    const ProductDefinitionBaseType::SecurityClassification_optional& ProductDefinitionBaseType::
    SecurityClassification () const
    {
      return this->SecurityClassification_;
    }

    ProductDefinitionBaseType::SecurityClassification_optional& ProductDefinitionBaseType::
    SecurityClassification ()
    {
      return this->SecurityClassification_;
    }

    void ProductDefinitionBaseType::
    SecurityClassification (const SecurityClassification_type& x)
    {
      this->SecurityClassification_.set (x);
    }

    void ProductDefinitionBaseType::
    SecurityClassification (const SecurityClassification_optional& x)
    {
      this->SecurityClassification_ = x;
    }

    void ProductDefinitionBaseType::
    SecurityClassification (::std::auto_ptr< SecurityClassification_type > x)
    {
      this->SecurityClassification_.set (x);
    }

    const ProductDefinitionBaseType::ExportControlClassification_optional& ProductDefinitionBaseType::
    ExportControlClassification () const
    {
      return this->ExportControlClassification_;
    }

    ProductDefinitionBaseType::ExportControlClassification_optional& ProductDefinitionBaseType::
    ExportControlClassification ()
    {
      return this->ExportControlClassification_;
    }

    void ProductDefinitionBaseType::
    ExportControlClassification (const ExportControlClassification_type& x)
    {
      this->ExportControlClassification_.set (x);
    }

    void ProductDefinitionBaseType::
    ExportControlClassification (const ExportControlClassification_optional& x)
    {
      this->ExportControlClassification_ = x;
    }

    void ProductDefinitionBaseType::
    ExportControlClassification (::std::auto_ptr< ExportControlClassification_type > x)
    {
      this->ExportControlClassification_.set (x);
    }

    const ProductDefinitionBaseType::FeatureNominalIds_optional& ProductDefinitionBaseType::
    FeatureNominalIds () const
    {
      return this->FeatureNominalIds_;
    }

    ProductDefinitionBaseType::FeatureNominalIds_optional& ProductDefinitionBaseType::
    FeatureNominalIds ()
    {
      return this->FeatureNominalIds_;
    }

    void ProductDefinitionBaseType::
    FeatureNominalIds (const FeatureNominalIds_type& x)
    {
      this->FeatureNominalIds_.set (x);
    }

    void ProductDefinitionBaseType::
    FeatureNominalIds (const FeatureNominalIds_optional& x)
    {
      this->FeatureNominalIds_ = x;
    }

    void ProductDefinitionBaseType::
    FeatureNominalIds (::std::auto_ptr< FeatureNominalIds_type > x)
    {
      this->FeatureNominalIds_.set (x);
    }

    const ProductDefinitionBaseType::CharacteristicNominalIds_optional& ProductDefinitionBaseType::
    CharacteristicNominalIds () const
    {
      return this->CharacteristicNominalIds_;
    }

    ProductDefinitionBaseType::CharacteristicNominalIds_optional& ProductDefinitionBaseType::
    CharacteristicNominalIds ()
    {
      return this->CharacteristicNominalIds_;
    }

    void ProductDefinitionBaseType::
    CharacteristicNominalIds (const CharacteristicNominalIds_type& x)
    {
      this->CharacteristicNominalIds_.set (x);
    }

    void ProductDefinitionBaseType::
    CharacteristicNominalIds (const CharacteristicNominalIds_optional& x)
    {
      this->CharacteristicNominalIds_ = x;
    }

    void ProductDefinitionBaseType::
    CharacteristicNominalIds (::std::auto_ptr< CharacteristicNominalIds_type > x)
    {
      this->CharacteristicNominalIds_.set (x);
    }

    const ProductDefinitionBaseType::NoteIds_optional& ProductDefinitionBaseType::
    NoteIds () const
    {
      return this->NoteIds_;
    }

    ProductDefinitionBaseType::NoteIds_optional& ProductDefinitionBaseType::
    NoteIds ()
    {
      return this->NoteIds_;
    }

    void ProductDefinitionBaseType::
    NoteIds (const NoteIds_type& x)
    {
      this->NoteIds_.set (x);
    }

    void ProductDefinitionBaseType::
    NoteIds (const NoteIds_optional& x)
    {
      this->NoteIds_ = x;
    }

    void ProductDefinitionBaseType::
    NoteIds (::std::auto_ptr< NoteIds_type > x)
    {
      this->NoteIds_.set (x);
    }

    const ProductDefinitionBaseType::PartNoteIds_optional& ProductDefinitionBaseType::
    PartNoteIds () const
    {
      return this->PartNoteIds_;
    }

    ProductDefinitionBaseType::PartNoteIds_optional& ProductDefinitionBaseType::
    PartNoteIds ()
    {
      return this->PartNoteIds_;
    }

    void ProductDefinitionBaseType::
    PartNoteIds (const PartNoteIds_type& x)
    {
      this->PartNoteIds_.set (x);
    }

    void ProductDefinitionBaseType::
    PartNoteIds (const PartNoteIds_optional& x)
    {
      this->PartNoteIds_ = x;
    }

    void ProductDefinitionBaseType::
    PartNoteIds (::std::auto_ptr< PartNoteIds_type > x)
    {
      this->PartNoteIds_.set (x);
    }

    const ProductDefinitionBaseType::DatumDefinitionIds_optional& ProductDefinitionBaseType::
    DatumDefinitionIds () const
    {
      return this->DatumDefinitionIds_;
    }

    ProductDefinitionBaseType::DatumDefinitionIds_optional& ProductDefinitionBaseType::
    DatumDefinitionIds ()
    {
      return this->DatumDefinitionIds_;
    }

    void ProductDefinitionBaseType::
    DatumDefinitionIds (const DatumDefinitionIds_type& x)
    {
      this->DatumDefinitionIds_.set (x);
    }

    void ProductDefinitionBaseType::
    DatumDefinitionIds (const DatumDefinitionIds_optional& x)
    {
      this->DatumDefinitionIds_ = x;
    }

    void ProductDefinitionBaseType::
    DatumDefinitionIds (::std::auto_ptr< DatumDefinitionIds_type > x)
    {
      this->DatumDefinitionIds_.set (x);
    }

    const ProductDefinitionBaseType::DatumTargetDefinitionIds_optional& ProductDefinitionBaseType::
    DatumTargetDefinitionIds () const
    {
      return this->DatumTargetDefinitionIds_;
    }

    ProductDefinitionBaseType::DatumTargetDefinitionIds_optional& ProductDefinitionBaseType::
    DatumTargetDefinitionIds ()
    {
      return this->DatumTargetDefinitionIds_;
    }

    void ProductDefinitionBaseType::
    DatumTargetDefinitionIds (const DatumTargetDefinitionIds_type& x)
    {
      this->DatumTargetDefinitionIds_.set (x);
    }

    void ProductDefinitionBaseType::
    DatumTargetDefinitionIds (const DatumTargetDefinitionIds_optional& x)
    {
      this->DatumTargetDefinitionIds_ = x;
    }

    void ProductDefinitionBaseType::
    DatumTargetDefinitionIds (::std::auto_ptr< DatumTargetDefinitionIds_type > x)
    {
      this->DatumTargetDefinitionIds_.set (x);
    }

    const ProductDefinitionBaseType::DatumReferenceFrameIds_optional& ProductDefinitionBaseType::
    DatumReferenceFrameIds () const
    {
      return this->DatumReferenceFrameIds_;
    }

    ProductDefinitionBaseType::DatumReferenceFrameIds_optional& ProductDefinitionBaseType::
    DatumReferenceFrameIds ()
    {
      return this->DatumReferenceFrameIds_;
    }

    void ProductDefinitionBaseType::
    DatumReferenceFrameIds (const DatumReferenceFrameIds_type& x)
    {
      this->DatumReferenceFrameIds_.set (x);
    }

    void ProductDefinitionBaseType::
    DatumReferenceFrameIds (const DatumReferenceFrameIds_optional& x)
    {
      this->DatumReferenceFrameIds_ = x;
    }

    void ProductDefinitionBaseType::
    DatumReferenceFrameIds (::std::auto_ptr< DatumReferenceFrameIds_type > x)
    {
      this->DatumReferenceFrameIds_.set (x);
    }

    const ProductDefinitionBaseType::id_type& ProductDefinitionBaseType::
    id () const
    {
      return this->id_.get ();
    }

    ProductDefinitionBaseType::id_type& ProductDefinitionBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void ProductDefinitionBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ProductDefinitionBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // PartType
    // 

    const PartType::DefinitionInternal_optional& PartType::
    DefinitionInternal () const
    {
      return this->DefinitionInternal_;
    }

    PartType::DefinitionInternal_optional& PartType::
    DefinitionInternal ()
    {
      return this->DefinitionInternal_;
    }

    void PartType::
    DefinitionInternal (const DefinitionInternal_type& x)
    {
      this->DefinitionInternal_.set (x);
    }

    void PartType::
    DefinitionInternal (const DefinitionInternal_optional& x)
    {
      this->DefinitionInternal_ = x;
    }

    void PartType::
    DefinitionInternal (::std::auto_ptr< DefinitionInternal_type > x)
    {
      this->DefinitionInternal_.set (x);
    }

    const PartType::DefinitionExternal_optional& PartType::
    DefinitionExternal () const
    {
      return this->DefinitionExternal_;
    }

    PartType::DefinitionExternal_optional& PartType::
    DefinitionExternal ()
    {
      return this->DefinitionExternal_;
    }

    void PartType::
    DefinitionExternal (const DefinitionExternal_type& x)
    {
      this->DefinitionExternal_.set (x);
    }

    void PartType::
    DefinitionExternal (const DefinitionExternal_optional& x)
    {
      this->DefinitionExternal_ = x;
    }

    void PartType::
    DefinitionExternal (::std::auto_ptr< DefinitionExternal_type > x)
    {
      this->DefinitionExternal_.set (x);
    }

    const PartType::PartFamily_optional& PartType::
    PartFamily () const
    {
      return this->PartFamily_;
    }

    PartType::PartFamily_optional& PartType::
    PartFamily ()
    {
      return this->PartFamily_;
    }

    void PartType::
    PartFamily (const PartFamily_type& x)
    {
      this->PartFamily_.set (x);
    }

    void PartType::
    PartFamily (const PartFamily_optional& x)
    {
      this->PartFamily_ = x;
    }

    void PartType::
    PartFamily (::std::auto_ptr< PartFamily_type > x)
    {
      this->PartFamily_.set (x);
    }


    // AssemblyType
    // 

    const AssemblyType::ComponentIds_type& AssemblyType::
    ComponentIds () const
    {
      return this->ComponentIds_.get ();
    }

    AssemblyType::ComponentIds_type& AssemblyType::
    ComponentIds ()
    {
      return this->ComponentIds_.get ();
    }

    void AssemblyType::
    ComponentIds (const ComponentIds_type& x)
    {
      this->ComponentIds_.set (x);
    }

    void AssemblyType::
    ComponentIds (::std::auto_ptr< ComponentIds_type > x)
    {
      this->ComponentIds_.set (x);
    }

    const AssemblyType::DefinitionInternal_optional& AssemblyType::
    DefinitionInternal () const
    {
      return this->DefinitionInternal_;
    }

    AssemblyType::DefinitionInternal_optional& AssemblyType::
    DefinitionInternal ()
    {
      return this->DefinitionInternal_;
    }

    void AssemblyType::
    DefinitionInternal (const DefinitionInternal_type& x)
    {
      this->DefinitionInternal_.set (x);
    }

    void AssemblyType::
    DefinitionInternal (const DefinitionInternal_optional& x)
    {
      this->DefinitionInternal_ = x;
    }

    void AssemblyType::
    DefinitionInternal (::std::auto_ptr< DefinitionInternal_type > x)
    {
      this->DefinitionInternal_.set (x);
    }

    const AssemblyType::DefinitionExternal_optional& AssemblyType::
    DefinitionExternal () const
    {
      return this->DefinitionExternal_;
    }

    AssemblyType::DefinitionExternal_optional& AssemblyType::
    DefinitionExternal ()
    {
      return this->DefinitionExternal_;
    }

    void AssemblyType::
    DefinitionExternal (const DefinitionExternal_type& x)
    {
      this->DefinitionExternal_.set (x);
    }

    void AssemblyType::
    DefinitionExternal (const DefinitionExternal_optional& x)
    {
      this->DefinitionExternal_ = x;
    }

    void AssemblyType::
    DefinitionExternal (::std::auto_ptr< DefinitionExternal_type > x)
    {
      this->DefinitionExternal_.set (x);
    }


    // PartFamilyType
    // 

    const PartFamilyType::PrimaryShapeClass_optional& PartFamilyType::
    PrimaryShapeClass () const
    {
      return this->PrimaryShapeClass_;
    }

    PartFamilyType::PrimaryShapeClass_optional& PartFamilyType::
    PrimaryShapeClass ()
    {
      return this->PrimaryShapeClass_;
    }

    void PartFamilyType::
    PrimaryShapeClass (const PrimaryShapeClass_type& x)
    {
      this->PrimaryShapeClass_.set (x);
    }

    void PartFamilyType::
    PrimaryShapeClass (const PrimaryShapeClass_optional& x)
    {
      this->PrimaryShapeClass_ = x;
    }

    void PartFamilyType::
    PrimaryShapeClass (::std::auto_ptr< PrimaryShapeClass_type > x)
    {
      this->PrimaryShapeClass_.set (x);
    }

    const PartFamilyType::MinimumTolerance_optional& PartFamilyType::
    MinimumTolerance () const
    {
      return this->MinimumTolerance_;
    }

    PartFamilyType::MinimumTolerance_optional& PartFamilyType::
    MinimumTolerance ()
    {
      return this->MinimumTolerance_;
    }

    void PartFamilyType::
    MinimumTolerance (const MinimumTolerance_type& x)
    {
      this->MinimumTolerance_.set (x);
    }

    void PartFamilyType::
    MinimumTolerance (const MinimumTolerance_optional& x)
    {
      this->MinimumTolerance_ = x;
    }

    void PartFamilyType::
    MinimumTolerance (::std::auto_ptr< MinimumTolerance_type > x)
    {
      this->MinimumTolerance_.set (x);
    }

    const PartFamilyType::MinimumBoundingBox_optional& PartFamilyType::
    MinimumBoundingBox () const
    {
      return this->MinimumBoundingBox_;
    }

    PartFamilyType::MinimumBoundingBox_optional& PartFamilyType::
    MinimumBoundingBox ()
    {
      return this->MinimumBoundingBox_;
    }

    void PartFamilyType::
    MinimumBoundingBox (const MinimumBoundingBox_type& x)
    {
      this->MinimumBoundingBox_.set (x);
    }

    void PartFamilyType::
    MinimumBoundingBox (const MinimumBoundingBox_optional& x)
    {
      this->MinimumBoundingBox_ = x;
    }

    void PartFamilyType::
    MinimumBoundingBox (::std::auto_ptr< MinimumBoundingBox_type > x)
    {
      this->MinimumBoundingBox_.set (x);
    }

    const PartFamilyType::PrimaryManufacturingMethod_optional& PartFamilyType::
    PrimaryManufacturingMethod () const
    {
      return this->PrimaryManufacturingMethod_;
    }

    PartFamilyType::PrimaryManufacturingMethod_optional& PartFamilyType::
    PrimaryManufacturingMethod ()
    {
      return this->PrimaryManufacturingMethod_;
    }

    void PartFamilyType::
    PrimaryManufacturingMethod (const PrimaryManufacturingMethod_type& x)
    {
      this->PrimaryManufacturingMethod_.set (x);
    }

    void PartFamilyType::
    PrimaryManufacturingMethod (const PrimaryManufacturingMethod_optional& x)
    {
      this->PrimaryManufacturingMethod_ = x;
    }

    void PartFamilyType::
    PrimaryManufacturingMethod (::std::auto_ptr< PrimaryManufacturingMethod_type > x)
    {
      this->PrimaryManufacturingMethod_.set (x);
    }


    // PartSetType
    // 

    const PartSetType::Part_sequence& PartSetType::
    Part () const
    {
      return this->Part_;
    }

    PartSetType::Part_sequence& PartSetType::
    Part ()
    {
      return this->Part_;
    }

    void PartSetType::
    Part (const Part_sequence& s)
    {
      this->Part_ = s;
    }

    const PartSetType::N_type& PartSetType::
    N () const
    {
      return this->N_.get ();
    }

    PartSetType::N_type& PartSetType::
    N ()
    {
      return this->N_.get ();
    }

    void PartSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void PartSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // AssemblySetType
    // 

    const AssemblySetType::Assembly_sequence& AssemblySetType::
    Assembly () const
    {
      return this->Assembly_;
    }

    AssemblySetType::Assembly_sequence& AssemblySetType::
    Assembly ()
    {
      return this->Assembly_;
    }

    void AssemblySetType::
    Assembly (const Assembly_sequence& s)
    {
      this->Assembly_ = s;
    }

    const AssemblySetType::N_type& AssemblySetType::
    N () const
    {
      return this->N_.get ();
    }

    AssemblySetType::N_type& AssemblySetType::
    N ()
    {
      return this->N_.get ();
    }

    void AssemblySetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void AssemblySetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // ComponentType
    // 

    const ComponentType::Attributes_optional& ComponentType::
    Attributes () const
    {
      return this->Attributes_;
    }

    ComponentType::Attributes_optional& ComponentType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void ComponentType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void ComponentType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void ComponentType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const ComponentType::QPId_optional& ComponentType::
    QPId () const
    {
      return this->QPId_;
    }

    ComponentType::QPId_optional& ComponentType::
    QPId ()
    {
      return this->QPId_;
    }

    void ComponentType::
    QPId (const QPId_type& x)
    {
      this->QPId_.set (x);
    }

    void ComponentType::
    QPId (const QPId_optional& x)
    {
      this->QPId_ = x;
    }

    void ComponentType::
    QPId (::std::auto_ptr< QPId_type > x)
    {
      this->QPId_.set (x);
    }

    const ComponentType::Transform_optional& ComponentType::
    Transform () const
    {
      return this->Transform_;
    }

    ComponentType::Transform_optional& ComponentType::
    Transform ()
    {
      return this->Transform_;
    }

    void ComponentType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ComponentType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ComponentType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const ComponentType::Traceability_optional& ComponentType::
    Traceability () const
    {
      return this->Traceability_;
    }

    ComponentType::Traceability_optional& ComponentType::
    Traceability ()
    {
      return this->Traceability_;
    }

    void ComponentType::
    Traceability (const Traceability_type& x)
    {
      this->Traceability_.set (x);
    }

    void ComponentType::
    Traceability (const Traceability_optional& x)
    {
      this->Traceability_ = x;
    }

    void ComponentType::
    Traceability (::std::auto_ptr< Traceability_type > x)
    {
      this->Traceability_.set (x);
    }

    const ComponentType::Part_optional& ComponentType::
    Part () const
    {
      return this->Part_;
    }

    ComponentType::Part_optional& ComponentType::
    Part ()
    {
      return this->Part_;
    }

    void ComponentType::
    Part (const Part_type& x)
    {
      this->Part_.set (x);
    }

    void ComponentType::
    Part (const Part_optional& x)
    {
      this->Part_ = x;
    }

    void ComponentType::
    Part (::std::auto_ptr< Part_type > x)
    {
      this->Part_.set (x);
    }

    const ComponentType::Assembly_optional& ComponentType::
    Assembly () const
    {
      return this->Assembly_;
    }

    ComponentType::Assembly_optional& ComponentType::
    Assembly ()
    {
      return this->Assembly_;
    }

    void ComponentType::
    Assembly (const Assembly_type& x)
    {
      this->Assembly_.set (x);
    }

    void ComponentType::
    Assembly (const Assembly_optional& x)
    {
      this->Assembly_ = x;
    }

    void ComponentType::
    Assembly (::std::auto_ptr< Assembly_type > x)
    {
      this->Assembly_.set (x);
    }

    const ComponentType::DefinitionInternal_optional& ComponentType::
    DefinitionInternal () const
    {
      return this->DefinitionInternal_;
    }

    ComponentType::DefinitionInternal_optional& ComponentType::
    DefinitionInternal ()
    {
      return this->DefinitionInternal_;
    }

    void ComponentType::
    DefinitionInternal (const DefinitionInternal_type& x)
    {
      this->DefinitionInternal_.set (x);
    }

    void ComponentType::
    DefinitionInternal (const DefinitionInternal_optional& x)
    {
      this->DefinitionInternal_ = x;
    }

    void ComponentType::
    DefinitionInternal (::std::auto_ptr< DefinitionInternal_type > x)
    {
      this->DefinitionInternal_.set (x);
    }

    const ComponentType::id_type& ComponentType::
    id () const
    {
      return this->id_.get ();
    }

    ComponentType::id_type& ComponentType::
    id ()
    {
      return this->id_.get ();
    }

    void ComponentType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void ComponentType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // ComponentSetType
    // 

    const ComponentSetType::Component_sequence& ComponentSetType::
    Component () const
    {
      return this->Component_;
    }

    ComponentSetType::Component_sequence& ComponentSetType::
    Component ()
    {
      return this->Component_;
    }

    void ComponentSetType::
    Component (const Component_sequence& s)
    {
      this->Component_ = s;
    }

    const ComponentSetType::N_type& ComponentSetType::
    N () const
    {
      return this->N_.get ();
    }

    ComponentSetType::N_type& ComponentSetType::
    N ()
    {
      return this->N_.get ();
    }

    void ComponentSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void ComponentSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // PrintedDrawingType
    // 

    const PrintedDrawingType::Name_type& PrintedDrawingType::
    Name () const
    {
      return this->Name_.get ();
    }

    PrintedDrawingType::Name_type& PrintedDrawingType::
    Name ()
    {
      return this->Name_.get ();
    }

    void PrintedDrawingType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void PrintedDrawingType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const PrintedDrawingType::Version_optional& PrintedDrawingType::
    Version () const
    {
      return this->Version_;
    }

    PrintedDrawingType::Version_optional& PrintedDrawingType::
    Version ()
    {
      return this->Version_;
    }

    void PrintedDrawingType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void PrintedDrawingType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void PrintedDrawingType::
    Version (::std::auto_ptr< Version_type > x)
    {
      this->Version_.set (x);
    }

    const PrintedDrawingType::Description_optional& PrintedDrawingType::
    Description () const
    {
      return this->Description_;
    }

    PrintedDrawingType::Description_optional& PrintedDrawingType::
    Description ()
    {
      return this->Description_;
    }

    void PrintedDrawingType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void PrintedDrawingType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void PrintedDrawingType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const PrintedDrawingType::Author_optional& PrintedDrawingType::
    Author () const
    {
      return this->Author_;
    }

    PrintedDrawingType::Author_optional& PrintedDrawingType::
    Author ()
    {
      return this->Author_;
    }

    void PrintedDrawingType::
    Author (const Author_type& x)
    {
      this->Author_.set (x);
    }

    void PrintedDrawingType::
    Author (const Author_optional& x)
    {
      this->Author_ = x;
    }

    void PrintedDrawingType::
    Author (::std::auto_ptr< Author_type > x)
    {
      this->Author_.set (x);
    }

    const PrintedDrawingType::DrawingNumber_optional& PrintedDrawingType::
    DrawingNumber () const
    {
      return this->DrawingNumber_;
    }

    PrintedDrawingType::DrawingNumber_optional& PrintedDrawingType::
    DrawingNumber ()
    {
      return this->DrawingNumber_;
    }

    void PrintedDrawingType::
    DrawingNumber (const DrawingNumber_type& x)
    {
      this->DrawingNumber_.set (x);
    }

    void PrintedDrawingType::
    DrawingNumber (const DrawingNumber_optional& x)
    {
      this->DrawingNumber_ = x;
    }

    void PrintedDrawingType::
    DrawingNumber (::std::auto_ptr< DrawingNumber_type > x)
    {
      this->DrawingNumber_.set (x);
    }

    const PrintedDrawingType::AdditionalChanges_optional& PrintedDrawingType::
    AdditionalChanges () const
    {
      return this->AdditionalChanges_;
    }

    PrintedDrawingType::AdditionalChanges_optional& PrintedDrawingType::
    AdditionalChanges ()
    {
      return this->AdditionalChanges_;
    }

    void PrintedDrawingType::
    AdditionalChanges (const AdditionalChanges_type& x)
    {
      this->AdditionalChanges_.set (x);
    }

    void PrintedDrawingType::
    AdditionalChanges (const AdditionalChanges_optional& x)
    {
      this->AdditionalChanges_ = x;
    }

    void PrintedDrawingType::
    AdditionalChanges (::std::auto_ptr< AdditionalChanges_type > x)
    {
      this->AdditionalChanges_.set (x);
    }

    const PrintedDrawingType::Location_optional& PrintedDrawingType::
    Location () const
    {
      return this->Location_;
    }

    PrintedDrawingType::Location_optional& PrintedDrawingType::
    Location ()
    {
      return this->Location_;
    }

    void PrintedDrawingType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PrintedDrawingType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void PrintedDrawingType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const PrintedDrawingType::id_type& PrintedDrawingType::
    id () const
    {
      return this->id_.get ();
    }

    PrintedDrawingType::id_type& PrintedDrawingType::
    id ()
    {
      return this->id_.get ();
    }

    void PrintedDrawingType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void PrintedDrawingType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // GDTEnumType
    // 

    GDTEnumType::
    GDTEnumType (value v)
    : ::xml_schema::string (_xsd_GDTEnumType_literals_[v])
    {
    }

    GDTEnumType::
    GDTEnumType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    GDTEnumType::
    GDTEnumType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    GDTEnumType::
    GDTEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    GDTEnumType::
    GDTEnumType (const GDTEnumType& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    GDTEnumType& GDTEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_GDTEnumType_literals_[v]);

      return *this;
    }


    // TopologyEnumType
    // 

    TopologyEnumType::
    TopologyEnumType (value v)
    : ::xml_schema::string (_xsd_TopologyEnumType_literals_[v])
    {
    }

    TopologyEnumType::
    TopologyEnumType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    TopologyEnumType::
    TopologyEnumType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    TopologyEnumType::
    TopologyEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    TopologyEnumType::
    TopologyEnumType (const TopologyEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    TopologyEnumType& TopologyEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_TopologyEnumType_literals_[v]);

      return *this;
    }


    // DigitalModelType
    // 

    const DigitalModelType::Name_type& DigitalModelType::
    Name () const
    {
      return this->Name_.get ();
    }

    DigitalModelType::Name_type& DigitalModelType::
    Name ()
    {
      return this->Name_.get ();
    }

    void DigitalModelType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void DigitalModelType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const DigitalModelType::File_type& DigitalModelType::
    File () const
    {
      return this->File_.get ();
    }

    DigitalModelType::File_type& DigitalModelType::
    File ()
    {
      return this->File_.get ();
    }

    void DigitalModelType::
    File (const File_type& x)
    {
      this->File_.set (x);
    }

    void DigitalModelType::
    File (::std::auto_ptr< File_type > x)
    {
      this->File_.set (x);
    }

    const DigitalModelType::Application_optional& DigitalModelType::
    Application () const
    {
      return this->Application_;
    }

    DigitalModelType::Application_optional& DigitalModelType::
    Application ()
    {
      return this->Application_;
    }

    void DigitalModelType::
    Application (const Application_type& x)
    {
      this->Application_.set (x);
    }

    void DigitalModelType::
    Application (const Application_optional& x)
    {
      this->Application_ = x;
    }

    void DigitalModelType::
    Application (::std::auto_ptr< Application_type > x)
    {
      this->Application_.set (x);
    }

    const DigitalModelType::Author_optional& DigitalModelType::
    Author () const
    {
      return this->Author_;
    }

    DigitalModelType::Author_optional& DigitalModelType::
    Author ()
    {
      return this->Author_;
    }

    void DigitalModelType::
    Author (const Author_type& x)
    {
      this->Author_.set (x);
    }

    void DigitalModelType::
    Author (const Author_optional& x)
    {
      this->Author_ = x;
    }

    void DigitalModelType::
    Author (::std::auto_ptr< Author_type > x)
    {
      this->Author_.set (x);
    }

    const DigitalModelType::ApplicationSource_optional& DigitalModelType::
    ApplicationSource () const
    {
      return this->ApplicationSource_;
    }

    DigitalModelType::ApplicationSource_optional& DigitalModelType::
    ApplicationSource ()
    {
      return this->ApplicationSource_;
    }

    void DigitalModelType::
    ApplicationSource (const ApplicationSource_type& x)
    {
      this->ApplicationSource_.set (x);
    }

    void DigitalModelType::
    ApplicationSource (const ApplicationSource_optional& x)
    {
      this->ApplicationSource_ = x;
    }

    void DigitalModelType::
    ApplicationSource (::std::auto_ptr< ApplicationSource_type > x)
    {
      this->ApplicationSource_.set (x);
    }

    const DigitalModelType::Description_optional& DigitalModelType::
    Description () const
    {
      return this->Description_;
    }

    DigitalModelType::Description_optional& DigitalModelType::
    Description ()
    {
      return this->Description_;
    }

    void DigitalModelType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void DigitalModelType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void DigitalModelType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const DigitalModelType::Units_optional& DigitalModelType::
    Units () const
    {
      return this->Units_;
    }

    DigitalModelType::Units_optional& DigitalModelType::
    Units ()
    {
      return this->Units_;
    }

    void DigitalModelType::
    Units (const Units_type& x)
    {
      this->Units_.set (x);
    }

    void DigitalModelType::
    Units (const Units_optional& x)
    {
      this->Units_ = x;
    }

    void DigitalModelType::
    Units (::std::auto_ptr< Units_type > x)
    {
      this->Units_.set (x);
    }

    const DigitalModelType::GDT_optional& DigitalModelType::
    GDT () const
    {
      return this->GDT_;
    }

    DigitalModelType::GDT_optional& DigitalModelType::
    GDT ()
    {
      return this->GDT_;
    }

    void DigitalModelType::
    GDT (const GDT_type& x)
    {
      this->GDT_.set (x);
    }

    void DigitalModelType::
    GDT (const GDT_optional& x)
    {
      this->GDT_ = x;
    }

    void DigitalModelType::
    GDT (::std::auto_ptr< GDT_type > x)
    {
      this->GDT_.set (x);
    }

    const DigitalModelType::GDT_type& DigitalModelType::
    GDT_default_value ()
    {
      return GDT_default_value_;
    }

    const DigitalModelType::Topology_optional& DigitalModelType::
    Topology () const
    {
      return this->Topology_;
    }

    DigitalModelType::Topology_optional& DigitalModelType::
    Topology ()
    {
      return this->Topology_;
    }

    void DigitalModelType::
    Topology (const Topology_type& x)
    {
      this->Topology_.set (x);
    }

    void DigitalModelType::
    Topology (const Topology_optional& x)
    {
      this->Topology_ = x;
    }

    void DigitalModelType::
    Topology (::std::auto_ptr< Topology_type > x)
    {
      this->Topology_.set (x);
    }

    const DigitalModelType::Topology_type& DigitalModelType::
    Topology_default_value ()
    {
      return Topology_default_value_;
    }

    const DigitalModelType::Entities_optional& DigitalModelType::
    Entities () const
    {
      return this->Entities_;
    }

    DigitalModelType::Entities_optional& DigitalModelType::
    Entities ()
    {
      return this->Entities_;
    }

    void DigitalModelType::
    Entities (const Entities_type& x)
    {
      this->Entities_.set (x);
    }

    void DigitalModelType::
    Entities (const Entities_optional& x)
    {
      this->Entities_ = x;
    }

    void DigitalModelType::
    Entities (::std::auto_ptr< Entities_type > x)
    {
      this->Entities_.set (x);
    }

    const DigitalModelType::id_type& DigitalModelType::
    id () const
    {
      return this->id_.get ();
    }

    DigitalModelType::id_type& DigitalModelType::
    id ()
    {
      return this->id_.get ();
    }

    void DigitalModelType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DigitalModelType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // DefinitionExternalType
    // 

    const DefinitionExternalType::PrintedDrawing_sequence& DefinitionExternalType::
    PrintedDrawing () const
    {
      return this->PrintedDrawing_;
    }

    DefinitionExternalType::PrintedDrawing_sequence& DefinitionExternalType::
    PrintedDrawing ()
    {
      return this->PrintedDrawing_;
    }

    void DefinitionExternalType::
    PrintedDrawing (const PrintedDrawing_sequence& s)
    {
      this->PrintedDrawing_ = s;
    }

    const DefinitionExternalType::DigitalDrawing_sequence& DefinitionExternalType::
    DigitalDrawing () const
    {
      return this->DigitalDrawing_;
    }

    DefinitionExternalType::DigitalDrawing_sequence& DefinitionExternalType::
    DigitalDrawing ()
    {
      return this->DigitalDrawing_;
    }

    void DefinitionExternalType::
    DigitalDrawing (const DigitalDrawing_sequence& s)
    {
      this->DigitalDrawing_ = s;
    }

    const DefinitionExternalType::DigitalModel_sequence& DefinitionExternalType::
    DigitalModel () const
    {
      return this->DigitalModel_;
    }

    DefinitionExternalType::DigitalModel_sequence& DefinitionExternalType::
    DigitalModel ()
    {
      return this->DigitalModel_;
    }

    void DefinitionExternalType::
    DigitalModel (const DigitalModel_sequence& s)
    {
      this->DigitalModel_ = s;
    }

    const DefinitionExternalType::PhysicalModel_sequence& DefinitionExternalType::
    PhysicalModel () const
    {
      return this->PhysicalModel_;
    }

    DefinitionExternalType::PhysicalModel_sequence& DefinitionExternalType::
    PhysicalModel ()
    {
      return this->PhysicalModel_;
    }

    void DefinitionExternalType::
    PhysicalModel (const PhysicalModel_sequence& s)
    {
      this->PhysicalModel_ = s;
    }

    const DefinitionExternalType::id_type& DefinitionExternalType::
    id () const
    {
      return this->id_.get ();
    }

    DefinitionExternalType::id_type& DefinitionExternalType::
    id ()
    {
      return this->id_.get ();
    }

    void DefinitionExternalType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DefinitionExternalType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // DigitalDrawingType
    // 

    const DigitalDrawingType::Name_type& DigitalDrawingType::
    Name () const
    {
      return this->Name_.get ();
    }

    DigitalDrawingType::Name_type& DigitalDrawingType::
    Name ()
    {
      return this->Name_.get ();
    }

    void DigitalDrawingType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void DigitalDrawingType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const DigitalDrawingType::File_type& DigitalDrawingType::
    File () const
    {
      return this->File_.get ();
    }

    DigitalDrawingType::File_type& DigitalDrawingType::
    File ()
    {
      return this->File_.get ();
    }

    void DigitalDrawingType::
    File (const File_type& x)
    {
      this->File_.set (x);
    }

    void DigitalDrawingType::
    File (::std::auto_ptr< File_type > x)
    {
      this->File_.set (x);
    }

    const DigitalDrawingType::Application_optional& DigitalDrawingType::
    Application () const
    {
      return this->Application_;
    }

    DigitalDrawingType::Application_optional& DigitalDrawingType::
    Application ()
    {
      return this->Application_;
    }

    void DigitalDrawingType::
    Application (const Application_type& x)
    {
      this->Application_.set (x);
    }

    void DigitalDrawingType::
    Application (const Application_optional& x)
    {
      this->Application_ = x;
    }

    void DigitalDrawingType::
    Application (::std::auto_ptr< Application_type > x)
    {
      this->Application_.set (x);
    }

    const DigitalDrawingType::Author_optional& DigitalDrawingType::
    Author () const
    {
      return this->Author_;
    }

    DigitalDrawingType::Author_optional& DigitalDrawingType::
    Author ()
    {
      return this->Author_;
    }

    void DigitalDrawingType::
    Author (const Author_type& x)
    {
      this->Author_.set (x);
    }

    void DigitalDrawingType::
    Author (const Author_optional& x)
    {
      this->Author_ = x;
    }

    void DigitalDrawingType::
    Author (::std::auto_ptr< Author_type > x)
    {
      this->Author_.set (x);
    }

    const DigitalDrawingType::ApplicationSource_optional& DigitalDrawingType::
    ApplicationSource () const
    {
      return this->ApplicationSource_;
    }

    DigitalDrawingType::ApplicationSource_optional& DigitalDrawingType::
    ApplicationSource ()
    {
      return this->ApplicationSource_;
    }

    void DigitalDrawingType::
    ApplicationSource (const ApplicationSource_type& x)
    {
      this->ApplicationSource_.set (x);
    }

    void DigitalDrawingType::
    ApplicationSource (const ApplicationSource_optional& x)
    {
      this->ApplicationSource_ = x;
    }

    void DigitalDrawingType::
    ApplicationSource (::std::auto_ptr< ApplicationSource_type > x)
    {
      this->ApplicationSource_.set (x);
    }

    const DigitalDrawingType::Description_optional& DigitalDrawingType::
    Description () const
    {
      return this->Description_;
    }

    DigitalDrawingType::Description_optional& DigitalDrawingType::
    Description ()
    {
      return this->Description_;
    }

    void DigitalDrawingType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void DigitalDrawingType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void DigitalDrawingType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const DigitalDrawingType::Entities_optional& DigitalDrawingType::
    Entities () const
    {
      return this->Entities_;
    }

    DigitalDrawingType::Entities_optional& DigitalDrawingType::
    Entities ()
    {
      return this->Entities_;
    }

    void DigitalDrawingType::
    Entities (const Entities_type& x)
    {
      this->Entities_.set (x);
    }

    void DigitalDrawingType::
    Entities (const Entities_optional& x)
    {
      this->Entities_ = x;
    }

    void DigitalDrawingType::
    Entities (::std::auto_ptr< Entities_type > x)
    {
      this->Entities_.set (x);
    }

    const DigitalDrawingType::id_type& DigitalDrawingType::
    id () const
    {
      return this->id_.get ();
    }

    DigitalDrawingType::id_type& DigitalDrawingType::
    id ()
    {
      return this->id_.get ();
    }

    void DigitalDrawingType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void DigitalDrawingType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // PhysicalModelType
    // 

    const PhysicalModelType::Name_type& PhysicalModelType::
    Name () const
    {
      return this->Name_.get ();
    }

    PhysicalModelType::Name_type& PhysicalModelType::
    Name ()
    {
      return this->Name_.get ();
    }

    void PhysicalModelType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void PhysicalModelType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const PhysicalModelType::Version_optional& PhysicalModelType::
    Version () const
    {
      return this->Version_;
    }

    PhysicalModelType::Version_optional& PhysicalModelType::
    Version ()
    {
      return this->Version_;
    }

    void PhysicalModelType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void PhysicalModelType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void PhysicalModelType::
    Version (::std::auto_ptr< Version_type > x)
    {
      this->Version_.set (x);
    }

    const PhysicalModelType::Description_optional& PhysicalModelType::
    Description () const
    {
      return this->Description_;
    }

    PhysicalModelType::Description_optional& PhysicalModelType::
    Description ()
    {
      return this->Description_;
    }

    void PhysicalModelType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void PhysicalModelType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void PhysicalModelType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const PhysicalModelType::Author_optional& PhysicalModelType::
    Author () const
    {
      return this->Author_;
    }

    PhysicalModelType::Author_optional& PhysicalModelType::
    Author ()
    {
      return this->Author_;
    }

    void PhysicalModelType::
    Author (const Author_type& x)
    {
      this->Author_.set (x);
    }

    void PhysicalModelType::
    Author (const Author_optional& x)
    {
      this->Author_ = x;
    }

    void PhysicalModelType::
    Author (::std::auto_ptr< Author_type > x)
    {
      this->Author_.set (x);
    }

    const PhysicalModelType::Location_optional& PhysicalModelType::
    Location () const
    {
      return this->Location_;
    }

    PhysicalModelType::Location_optional& PhysicalModelType::
    Location ()
    {
      return this->Location_;
    }

    void PhysicalModelType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PhysicalModelType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void PhysicalModelType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const PhysicalModelType::ModelNumber_optional& PhysicalModelType::
    ModelNumber () const
    {
      return this->ModelNumber_;
    }

    PhysicalModelType::ModelNumber_optional& PhysicalModelType::
    ModelNumber ()
    {
      return this->ModelNumber_;
    }

    void PhysicalModelType::
    ModelNumber (const ModelNumber_type& x)
    {
      this->ModelNumber_.set (x);
    }

    void PhysicalModelType::
    ModelNumber (const ModelNumber_optional& x)
    {
      this->ModelNumber_ = x;
    }

    void PhysicalModelType::
    ModelNumber (::std::auto_ptr< ModelNumber_type > x)
    {
      this->ModelNumber_.set (x);
    }

    const PhysicalModelType::id_type& PhysicalModelType::
    id () const
    {
      return this->id_.get ();
    }

    PhysicalModelType::id_type& PhysicalModelType::
    id ()
    {
      return this->id_.get ();
    }

    void PhysicalModelType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void PhysicalModelType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // InternalHeaderType
    // 

    const InternalHeaderType::Name_optional& InternalHeaderType::
    Name () const
    {
      return this->Name_;
    }

    InternalHeaderType::Name_optional& InternalHeaderType::
    Name ()
    {
      return this->Name_;
    }

    void InternalHeaderType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void InternalHeaderType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void InternalHeaderType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const InternalHeaderType::File_optional& InternalHeaderType::
    File () const
    {
      return this->File_;
    }

    InternalHeaderType::File_optional& InternalHeaderType::
    File ()
    {
      return this->File_;
    }

    void InternalHeaderType::
    File (const File_type& x)
    {
      this->File_.set (x);
    }

    void InternalHeaderType::
    File (const File_optional& x)
    {
      this->File_ = x;
    }

    void InternalHeaderType::
    File (::std::auto_ptr< File_type > x)
    {
      this->File_.set (x);
    }

    const InternalHeaderType::Application_optional& InternalHeaderType::
    Application () const
    {
      return this->Application_;
    }

    InternalHeaderType::Application_optional& InternalHeaderType::
    Application ()
    {
      return this->Application_;
    }

    void InternalHeaderType::
    Application (const Application_type& x)
    {
      this->Application_.set (x);
    }

    void InternalHeaderType::
    Application (const Application_optional& x)
    {
      this->Application_ = x;
    }

    void InternalHeaderType::
    Application (::std::auto_ptr< Application_type > x)
    {
      this->Application_.set (x);
    }

    const InternalHeaderType::Author_optional& InternalHeaderType::
    Author () const
    {
      return this->Author_;
    }

    InternalHeaderType::Author_optional& InternalHeaderType::
    Author ()
    {
      return this->Author_;
    }

    void InternalHeaderType::
    Author (const Author_type& x)
    {
      this->Author_.set (x);
    }

    void InternalHeaderType::
    Author (const Author_optional& x)
    {
      this->Author_ = x;
    }

    void InternalHeaderType::
    Author (::std::auto_ptr< Author_type > x)
    {
      this->Author_.set (x);
    }

    const InternalHeaderType::ApplicationSource_optional& InternalHeaderType::
    ApplicationSource () const
    {
      return this->ApplicationSource_;
    }

    InternalHeaderType::ApplicationSource_optional& InternalHeaderType::
    ApplicationSource ()
    {
      return this->ApplicationSource_;
    }

    void InternalHeaderType::
    ApplicationSource (const ApplicationSource_type& x)
    {
      this->ApplicationSource_.set (x);
    }

    void InternalHeaderType::
    ApplicationSource (const ApplicationSource_optional& x)
    {
      this->ApplicationSource_ = x;
    }

    void InternalHeaderType::
    ApplicationSource (::std::auto_ptr< ApplicationSource_type > x)
    {
      this->ApplicationSource_.set (x);
    }

    const InternalHeaderType::Description_optional& InternalHeaderType::
    Description () const
    {
      return this->Description_;
    }

    InternalHeaderType::Description_optional& InternalHeaderType::
    Description ()
    {
      return this->Description_;
    }

    void InternalHeaderType::
    Description (const Description_type& x)
    {
      this->Description_.set (x);
    }

    void InternalHeaderType::
    Description (const Description_optional& x)
    {
      this->Description_ = x;
    }

    void InternalHeaderType::
    Description (::std::auto_ptr< Description_type > x)
    {
      this->Description_.set (x);
    }

    const InternalHeaderType::Units_optional& InternalHeaderType::
    Units () const
    {
      return this->Units_;
    }

    InternalHeaderType::Units_optional& InternalHeaderType::
    Units ()
    {
      return this->Units_;
    }

    void InternalHeaderType::
    Units (const Units_type& x)
    {
      this->Units_.set (x);
    }

    void InternalHeaderType::
    Units (const Units_optional& x)
    {
      this->Units_ = x;
    }

    void InternalHeaderType::
    Units (::std::auto_ptr< Units_type > x)
    {
      this->Units_.set (x);
    }

    const InternalHeaderType::ScaleCoefficient_optional& InternalHeaderType::
    ScaleCoefficient () const
    {
      return this->ScaleCoefficient_;
    }

    InternalHeaderType::ScaleCoefficient_optional& InternalHeaderType::
    ScaleCoefficient ()
    {
      return this->ScaleCoefficient_;
    }

    void InternalHeaderType::
    ScaleCoefficient (const ScaleCoefficient_type& x)
    {
      this->ScaleCoefficient_.set (x);
    }

    void InternalHeaderType::
    ScaleCoefficient (const ScaleCoefficient_optional& x)
    {
      this->ScaleCoefficient_ = x;
    }

    InternalHeaderType::ScaleCoefficient_type InternalHeaderType::
    ScaleCoefficient_default_value ()
    {
      return ScaleCoefficient_type (1.0);
    }

    const InternalHeaderType::ModelTolerance_optional& InternalHeaderType::
    ModelTolerance () const
    {
      return this->ModelTolerance_;
    }

    InternalHeaderType::ModelTolerance_optional& InternalHeaderType::
    ModelTolerance ()
    {
      return this->ModelTolerance_;
    }

    void InternalHeaderType::
    ModelTolerance (const ModelTolerance_type& x)
    {
      this->ModelTolerance_.set (x);
    }

    void InternalHeaderType::
    ModelTolerance (const ModelTolerance_optional& x)
    {
      this->ModelTolerance_ = x;
    }

    const InternalHeaderType::MassPropertyTolerance_optional& InternalHeaderType::
    MassPropertyTolerance () const
    {
      return this->MassPropertyTolerance_;
    }

    InternalHeaderType::MassPropertyTolerance_optional& InternalHeaderType::
    MassPropertyTolerance ()
    {
      return this->MassPropertyTolerance_;
    }

    void InternalHeaderType::
    MassPropertyTolerance (const MassPropertyTolerance_type& x)
    {
      this->MassPropertyTolerance_.set (x);
    }

    void InternalHeaderType::
    MassPropertyTolerance (const MassPropertyTolerance_optional& x)
    {
      this->MassPropertyTolerance_ = x;
    }


    // InternalPartAssemblyType
    // 

    const InternalPartAssemblyType::Header_optional& InternalPartAssemblyType::
    Header () const
    {
      return this->Header_;
    }

    InternalPartAssemblyType::Header_optional& InternalPartAssemblyType::
    Header ()
    {
      return this->Header_;
    }

    void InternalPartAssemblyType::
    Header (const Header_type& x)
    {
      this->Header_.set (x);
    }

    void InternalPartAssemblyType::
    Header (const Header_optional& x)
    {
      this->Header_ = x;
    }

    void InternalPartAssemblyType::
    Header (::std::auto_ptr< Header_type > x)
    {
      this->Header_.set (x);
    }

    const InternalPartAssemblyType::BodyIds_optional& InternalPartAssemblyType::
    BodyIds () const
    {
      return this->BodyIds_;
    }

    InternalPartAssemblyType::BodyIds_optional& InternalPartAssemblyType::
    BodyIds ()
    {
      return this->BodyIds_;
    }

    void InternalPartAssemblyType::
    BodyIds (const BodyIds_type& x)
    {
      this->BodyIds_.set (x);
    }

    void InternalPartAssemblyType::
    BodyIds (const BodyIds_optional& x)
    {
      this->BodyIds_ = x;
    }

    void InternalPartAssemblyType::
    BodyIds (::std::auto_ptr< BodyIds_type > x)
    {
      this->BodyIds_.set (x);
    }

    const InternalPartAssemblyType::CoordinateSystemIds_optional& InternalPartAssemblyType::
    CoordinateSystemIds () const
    {
      return this->CoordinateSystemIds_;
    }

    InternalPartAssemblyType::CoordinateSystemIds_optional& InternalPartAssemblyType::
    CoordinateSystemIds ()
    {
      return this->CoordinateSystemIds_;
    }

    void InternalPartAssemblyType::
    CoordinateSystemIds (const CoordinateSystemIds_type& x)
    {
      this->CoordinateSystemIds_.set (x);
    }

    void InternalPartAssemblyType::
    CoordinateSystemIds (const CoordinateSystemIds_optional& x)
    {
      this->CoordinateSystemIds_ = x;
    }

    void InternalPartAssemblyType::
    CoordinateSystemIds (::std::auto_ptr< CoordinateSystemIds_type > x)
    {
      this->CoordinateSystemIds_.set (x);
    }

    const InternalPartAssemblyType::AuxiliaryIds_optional& InternalPartAssemblyType::
    AuxiliaryIds () const
    {
      return this->AuxiliaryIds_;
    }

    InternalPartAssemblyType::AuxiliaryIds_optional& InternalPartAssemblyType::
    AuxiliaryIds ()
    {
      return this->AuxiliaryIds_;
    }

    void InternalPartAssemblyType::
    AuxiliaryIds (const AuxiliaryIds_type& x)
    {
      this->AuxiliaryIds_.set (x);
    }

    void InternalPartAssemblyType::
    AuxiliaryIds (const AuxiliaryIds_optional& x)
    {
      this->AuxiliaryIds_ = x;
    }

    void InternalPartAssemblyType::
    AuxiliaryIds (::std::auto_ptr< AuxiliaryIds_type > x)
    {
      this->AuxiliaryIds_.set (x);
    }

    const InternalPartAssemblyType::ViewIds_optional& InternalPartAssemblyType::
    ViewIds () const
    {
      return this->ViewIds_;
    }

    InternalPartAssemblyType::ViewIds_optional& InternalPartAssemblyType::
    ViewIds ()
    {
      return this->ViewIds_;
    }

    void InternalPartAssemblyType::
    ViewIds (const ViewIds_type& x)
    {
      this->ViewIds_.set (x);
    }

    void InternalPartAssemblyType::
    ViewIds (const ViewIds_optional& x)
    {
      this->ViewIds_ = x;
    }

    void InternalPartAssemblyType::
    ViewIds (::std::auto_ptr< ViewIds_type > x)
    {
      this->ViewIds_.set (x);
    }

    const InternalPartAssemblyType::PointCloudIds_optional& InternalPartAssemblyType::
    PointCloudIds () const
    {
      return this->PointCloudIds_;
    }

    InternalPartAssemblyType::PointCloudIds_optional& InternalPartAssemblyType::
    PointCloudIds ()
    {
      return this->PointCloudIds_;
    }

    void InternalPartAssemblyType::
    PointCloudIds (const PointCloudIds_type& x)
    {
      this->PointCloudIds_.set (x);
    }

    void InternalPartAssemblyType::
    PointCloudIds (const PointCloudIds_optional& x)
    {
      this->PointCloudIds_ = x;
    }

    void InternalPartAssemblyType::
    PointCloudIds (::std::auto_ptr< PointCloudIds_type > x)
    {
      this->PointCloudIds_.set (x);
    }

    const InternalPartAssemblyType::color_optional& InternalPartAssemblyType::
    color () const
    {
      return this->color_;
    }

    InternalPartAssemblyType::color_optional& InternalPartAssemblyType::
    color ()
    {
      return this->color_;
    }

    void InternalPartAssemblyType::
    color (const color_type& x)
    {
      this->color_.set (x);
    }

    void InternalPartAssemblyType::
    color (const color_optional& x)
    {
      this->color_ = x;
    }

    void InternalPartAssemblyType::
    color (::std::auto_ptr< color_type > x)
    {
      this->color_.set (x);
    }

    const InternalPartAssemblyType::transparency_type& InternalPartAssemblyType::
    transparency () const
    {
      return this->transparency_.get ();
    }

    InternalPartAssemblyType::transparency_type& InternalPartAssemblyType::
    transparency ()
    {
      return this->transparency_.get ();
    }

    void InternalPartAssemblyType::
    transparency (const transparency_type& x)
    {
      this->transparency_.set (x);
    }

    InternalPartAssemblyType::transparency_type InternalPartAssemblyType::
    transparency_default_value ()
    {
      return transparency_type (.0);
    }

    const InternalPartAssemblyType::hidden_type& InternalPartAssemblyType::
    hidden () const
    {
      return this->hidden_.get ();
    }

    InternalPartAssemblyType::hidden_type& InternalPartAssemblyType::
    hidden ()
    {
      return this->hidden_.get ();
    }

    void InternalPartAssemblyType::
    hidden (const hidden_type& x)
    {
      this->hidden_.set (x);
    }

    InternalPartAssemblyType::hidden_type InternalPartAssemblyType::
    hidden_default_value ()
    {
      return hidden_type (false);
    }

    const InternalPartAssemblyType::size_optional& InternalPartAssemblyType::
    size () const
    {
      return this->size_;
    }

    InternalPartAssemblyType::size_optional& InternalPartAssemblyType::
    size ()
    {
      return this->size_;
    }

    void InternalPartAssemblyType::
    size (const size_type& x)
    {
      this->size_.set (x);
    }

    void InternalPartAssemblyType::
    size (const size_optional& x)
    {
      this->size_ = x;
    }

    void InternalPartAssemblyType::
    size (::std::auto_ptr< size_type > x)
    {
      this->size_.set (x);
    }

    const InternalPartAssemblyType::originMassProperty_type& InternalPartAssemblyType::
    originMassProperty () const
    {
      return this->originMassProperty_.get ();
    }

    InternalPartAssemblyType::originMassProperty_type& InternalPartAssemblyType::
    originMassProperty ()
    {
      return this->originMassProperty_.get ();
    }

    void InternalPartAssemblyType::
    originMassProperty (const originMassProperty_type& x)
    {
      this->originMassProperty_.set (x);
    }

    void InternalPartAssemblyType::
    originMassProperty (::std::auto_ptr< originMassProperty_type > x)
    {
      this->originMassProperty_.set (x);
    }


    // InternalComponentType
    // 

    const InternalComponentType::color_optional& InternalComponentType::
    color () const
    {
      return this->color_;
    }

    InternalComponentType::color_optional& InternalComponentType::
    color ()
    {
      return this->color_;
    }

    void InternalComponentType::
    color (const color_type& x)
    {
      this->color_.set (x);
    }

    void InternalComponentType::
    color (const color_optional& x)
    {
      this->color_ = x;
    }

    void InternalComponentType::
    color (::std::auto_ptr< color_type > x)
    {
      this->color_.set (x);
    }

    const InternalComponentType::transparency_type& InternalComponentType::
    transparency () const
    {
      return this->transparency_.get ();
    }

    InternalComponentType::transparency_type& InternalComponentType::
    transparency ()
    {
      return this->transparency_.get ();
    }

    void InternalComponentType::
    transparency (const transparency_type& x)
    {
      this->transparency_.set (x);
    }

    InternalComponentType::transparency_type InternalComponentType::
    transparency_default_value ()
    {
      return transparency_type (.0);
    }

    const InternalComponentType::hidden_type& InternalComponentType::
    hidden () const
    {
      return this->hidden_.get ();
    }

    InternalComponentType::hidden_type& InternalComponentType::
    hidden ()
    {
      return this->hidden_.get ();
    }

    void InternalComponentType::
    hidden (const hidden_type& x)
    {
      this->hidden_.set (x);
    }

    InternalComponentType::hidden_type InternalComponentType::
    hidden_default_value ()
    {
      return hidden_type (false);
    }

    const InternalComponentType::size_optional& InternalComponentType::
    size () const
    {
      return this->size_;
    }

    InternalComponentType::size_optional& InternalComponentType::
    size ()
    {
      return this->size_;
    }

    void InternalComponentType::
    size (const size_type& x)
    {
      this->size_.set (x);
    }

    void InternalComponentType::
    size (const size_optional& x)
    {
      this->size_ = x;
    }

    void InternalComponentType::
    size (::std::auto_ptr< size_type > x)
    {
      this->size_.set (x);
    }


    // LayerType
    // 

    const LayerType::ElementIds_optional& LayerType::
    ElementIds () const
    {
      return this->ElementIds_;
    }

    LayerType::ElementIds_optional& LayerType::
    ElementIds ()
    {
      return this->ElementIds_;
    }

    void LayerType::
    ElementIds (const ElementIds_type& x)
    {
      this->ElementIds_.set (x);
    }

    void LayerType::
    ElementIds (const ElementIds_optional& x)
    {
      this->ElementIds_ = x;
    }

    void LayerType::
    ElementIds (::std::auto_ptr< ElementIds_type > x)
    {
      this->ElementIds_.set (x);
    }

    const LayerType::applyColor_type& LayerType::
    applyColor () const
    {
      return this->applyColor_.get ();
    }

    LayerType::applyColor_type& LayerType::
    applyColor ()
    {
      return this->applyColor_.get ();
    }

    void LayerType::
    applyColor (const applyColor_type& x)
    {
      this->applyColor_.set (x);
    }

    LayerType::applyColor_type LayerType::
    applyColor_default_value ()
    {
      return applyColor_type (false);
    }

    const LayerType::index_type& LayerType::
    index () const
    {
      return this->index_.get ();
    }

    LayerType::index_type& LayerType::
    index ()
    {
      return this->index_.get ();
    }

    void LayerType::
    index (const index_type& x)
    {
      this->index_.set (x);
    }


    // LayerSetType
    // 

    const LayerSetType::Layer_sequence& LayerSetType::
    Layer () const
    {
      return this->Layer_;
    }

    LayerSetType::Layer_sequence& LayerSetType::
    Layer ()
    {
      return this->Layer_;
    }

    void LayerSetType::
    Layer (const Layer_sequence& s)
    {
      this->Layer_ = s;
    }

    const LayerSetType::N_type& LayerSetType::
    N () const
    {
      return this->N_.get ();
    }

    LayerSetType::N_type& LayerSetType::
    N ()
    {
      return this->N_.get ();
    }

    void LayerSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void LayerSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // PartNoteSetType
    // 

    const PartNoteSetType::PartNote_sequence& PartNoteSetType::
    PartNote () const
    {
      return this->PartNote_;
    }

    PartNoteSetType::PartNote_sequence& PartNoteSetType::
    PartNote ()
    {
      return this->PartNote_;
    }

    void PartNoteSetType::
    PartNote (const PartNote_sequence& s)
    {
      this->PartNote_ = s;
    }

    const PartNoteSetType::N_type& PartNoteSetType::
    N () const
    {
      return this->N_.get ();
    }

    PartNoteSetType::N_type& PartNoteSetType::
    N ()
    {
      return this->N_.get ();
    }

    void PartNoteSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void PartNoteSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // PartNoteType
    // 

    const PartNoteType::Text_optional& PartNoteType::
    Text () const
    {
      return this->Text_;
    }

    PartNoteType::Text_optional& PartNoteType::
    Text ()
    {
      return this->Text_;
    }

    void PartNoteType::
    Text (const Text_type& x)
    {
      this->Text_.set (x);
    }

    void PartNoteType::
    Text (const Text_optional& x)
    {
      this->Text_ = x;
    }

    void PartNoteType::
    Text (::std::auto_ptr< Text_type > x)
    {
      this->Text_.set (x);
    }

    const PartNoteType::PartNoteIds_optional& PartNoteType::
    PartNoteIds () const
    {
      return this->PartNoteIds_;
    }

    PartNoteType::PartNoteIds_optional& PartNoteType::
    PartNoteIds ()
    {
      return this->PartNoteIds_;
    }

    void PartNoteType::
    PartNoteIds (const PartNoteIds_type& x)
    {
      this->PartNoteIds_.set (x);
    }

    void PartNoteType::
    PartNoteIds (const PartNoteIds_optional& x)
    {
      this->PartNoteIds_ = x;
    }

    void PartNoteType::
    PartNoteIds (::std::auto_ptr< PartNoteIds_type > x)
    {
      this->PartNoteIds_.set (x);
    }


    // NoteType
    // 

    const NoteType::EntityInternalIds_optional& NoteType::
    EntityInternalIds () const
    {
      return this->EntityInternalIds_;
    }

    NoteType::EntityInternalIds_optional& NoteType::
    EntityInternalIds ()
    {
      return this->EntityInternalIds_;
    }

    void NoteType::
    EntityInternalIds (const EntityInternalIds_type& x)
    {
      this->EntityInternalIds_.set (x);
    }

    void NoteType::
    EntityInternalIds (const EntityInternalIds_optional& x)
    {
      this->EntityInternalIds_ = x;
    }

    void NoteType::
    EntityInternalIds (::std::auto_ptr< EntityInternalIds_type > x)
    {
      this->EntityInternalIds_.set (x);
    }

    const NoteType::EntityExternalIds_optional& NoteType::
    EntityExternalIds () const
    {
      return this->EntityExternalIds_;
    }

    NoteType::EntityExternalIds_optional& NoteType::
    EntityExternalIds ()
    {
      return this->EntityExternalIds_;
    }

    void NoteType::
    EntityExternalIds (const EntityExternalIds_type& x)
    {
      this->EntityExternalIds_.set (x);
    }

    void NoteType::
    EntityExternalIds (const EntityExternalIds_optional& x)
    {
      this->EntityExternalIds_ = x;
    }

    void NoteType::
    EntityExternalIds (::std::auto_ptr< EntityExternalIds_type > x)
    {
      this->EntityExternalIds_.set (x);
    }

    const NoteType::Text_type& NoteType::
    Text () const
    {
      return this->Text_.get ();
    }

    NoteType::Text_type& NoteType::
    Text ()
    {
      return this->Text_.get ();
    }

    void NoteType::
    Text (const Text_type& x)
    {
      this->Text_.set (x);
    }

    void NoteType::
    Text (::std::auto_ptr< Text_type > x)
    {
      this->Text_.set (x);
    }

    const NoteType::form_type& NoteType::
    form () const
    {
      return this->form_.get ();
    }

    NoteType::form_type& NoteType::
    form ()
    {
      return this->form_.get ();
    }

    void NoteType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void NoteType::
    form (::std::auto_ptr< form_type > x)
    {
      this->form_.set (x);
    }

    const NoteType::form_type& NoteType::
    form_default_value ()
    {
      return form_default_value_;
    }


    // NoteFormEnumType
    // 

    NoteFormEnumType::
    NoteFormEnumType (value v)
    : ::xml_schema::string (_xsd_NoteFormEnumType_literals_[v])
    {
    }

    NoteFormEnumType::
    NoteFormEnumType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    NoteFormEnumType::
    NoteFormEnumType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    NoteFormEnumType::
    NoteFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    NoteFormEnumType::
    NoteFormEnumType (const NoteFormEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    NoteFormEnumType& NoteFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_NoteFormEnumType_literals_[v]);

      return *this;
    }


    // NoteSetType
    // 

    const NoteSetType::Note_sequence& NoteSetType::
    Note () const
    {
      return this->Note_;
    }

    NoteSetType::Note_sequence& NoteSetType::
    Note ()
    {
      return this->Note_;
    }

    void NoteSetType::
    Note (const Note_sequence& s)
    {
      this->Note_ = s;
    }

    const NoteSetType::N_type& NoteSetType::
    N () const
    {
      return this->N_.get ();
    }

    NoteSetType::N_type& NoteSetType::
    N ()
    {
      return this->N_.get ();
    }

    void NoteSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void NoteSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // NoteFlagType
    // 

    const NoteFlagType::TextHidden_optional& NoteFlagType::
    TextHidden () const
    {
      return this->TextHidden_;
    }

    NoteFlagType::TextHidden_optional& NoteFlagType::
    TextHidden ()
    {
      return this->TextHidden_;
    }

    void NoteFlagType::
    TextHidden (const TextHidden_type& x)
    {
      this->TextHidden_.set (x);
    }

    void NoteFlagType::
    TextHidden (const TextHidden_optional& x)
    {
      this->TextHidden_ = x;
    }

    void NoteFlagType::
    TextHidden (::std::auto_ptr< TextHidden_type > x)
    {
      this->TextHidden_.set (x);
    }

    const NoteFlagType::URI_optional& NoteFlagType::
    URI () const
    {
      return this->URI_;
    }

    NoteFlagType::URI_optional& NoteFlagType::
    URI ()
    {
      return this->URI_;
    }

    void NoteFlagType::
    URI (const URI_type& x)
    {
      this->URI_.set (x);
    }

    void NoteFlagType::
    URI (const URI_optional& x)
    {
      this->URI_ = x;
    }

    void NoteFlagType::
    URI (::std::auto_ptr< URI_type > x)
    {
      this->URI_.set (x);
    }


    // NoteFlagSetType
    // 

    const NoteFlagSetType::NoteFlag_sequence& NoteFlagSetType::
    NoteFlag () const
    {
      return this->NoteFlag_;
    }

    NoteFlagSetType::NoteFlag_sequence& NoteFlagSetType::
    NoteFlag ()
    {
      return this->NoteFlag_;
    }

    void NoteFlagSetType::
    NoteFlag (const NoteFlag_sequence& s)
    {
      this->NoteFlag_ = s;
    }

    const NoteFlagSetType::N_type& NoteFlagSetType::
    N () const
    {
      return this->N_.get ();
    }

    NoteFlagSetType::N_type& NoteFlagSetType::
    N ()
    {
      return this->N_.get ();
    }

    void NoteFlagSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void NoteFlagSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // FileInternalType
    // 

    const FileInternalType::Name_type& FileInternalType::
    Name () const
    {
      return this->Name_.get ();
    }

    FileInternalType::Name_type& FileInternalType::
    Name ()
    {
      return this->Name_.get ();
    }

    void FileInternalType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void FileInternalType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const FileInternalType::Version_optional& FileInternalType::
    Version () const
    {
      return this->Version_;
    }

    FileInternalType::Version_optional& FileInternalType::
    Version ()
    {
      return this->Version_;
    }

    void FileInternalType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void FileInternalType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void FileInternalType::
    Version (::std::auto_ptr< Version_type > x)
    {
      this->Version_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace xsd
{
  namespace qif2
  {
    // ProductType
    //

    ProductType::
    ProductType ()
    : ::xml_schema::type (),
      Header_ (::xml_schema::flags (), this),
      GeometrySet_ (::xml_schema::flags (), this),
      TopologySet_ (::xml_schema::flags (), this),
      NoteSet_ (::xml_schema::flags (), this),
      NoteFlagSet_ (::xml_schema::flags (), this),
      PartNoteSet_ (::xml_schema::flags (), this),
      ViewSet_ (::xml_schema::flags (), this),
      LayerSet_ (::xml_schema::flags (), this),
      CoordinateSystemSet_ (::xml_schema::flags (), this),
      VisualizationSet_ (::xml_schema::flags (), this),
      AuxiliarySet_ (::xml_schema::flags (), this),
      PartSet_ (::xml_schema::flags (), this),
      AssemblySet_ (::xml_schema::flags (), this),
      ComponentSet_ (::xml_schema::flags (), this),
      RootPart_ (::xml_schema::flags (), this),
      RootAssembly_ (::xml_schema::flags (), this),
      RootComponent_ (::xml_schema::flags (), this),
      AsmPaths_ (::xml_schema::flags (), this)
    {
    }

    ProductType::
    ProductType (const ProductType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Header_ (x.Header_, f, this),
      GeometrySet_ (x.GeometrySet_, f, this),
      TopologySet_ (x.TopologySet_, f, this),
      NoteSet_ (x.NoteSet_, f, this),
      NoteFlagSet_ (x.NoteFlagSet_, f, this),
      PartNoteSet_ (x.PartNoteSet_, f, this),
      ViewSet_ (x.ViewSet_, f, this),
      LayerSet_ (x.LayerSet_, f, this),
      CoordinateSystemSet_ (x.CoordinateSystemSet_, f, this),
      VisualizationSet_ (x.VisualizationSet_, f, this),
      AuxiliarySet_ (x.AuxiliarySet_, f, this),
      PartSet_ (x.PartSet_, f, this),
      AssemblySet_ (x.AssemblySet_, f, this),
      ComponentSet_ (x.ComponentSet_, f, this),
      RootPart_ (x.RootPart_, f, this),
      RootAssembly_ (x.RootAssembly_, f, this),
      RootComponent_ (x.RootComponent_, f, this),
      AsmPaths_ (x.AsmPaths_, f, this)
    {
    }

    ProductType::
    ProductType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Header_ (f, this),
      GeometrySet_ (f, this),
      TopologySet_ (f, this),
      NoteSet_ (f, this),
      NoteFlagSet_ (f, this),
      PartNoteSet_ (f, this),
      ViewSet_ (f, this),
      LayerSet_ (f, this),
      CoordinateSystemSet_ (f, this),
      VisualizationSet_ (f, this),
      AuxiliarySet_ (f, this),
      PartSet_ (f, this),
      AssemblySet_ (f, this),
      ComponentSet_ (f, this),
      RootPart_ (f, this),
      RootAssembly_ (f, this),
      RootComponent_ (f, this),
      AsmPaths_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ProductType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Header
        //
        if (n.name () == "Header" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Header_type > r (
            Header_traits::create (i, f, this));

          if (!this->Header_)
          {
            this->Header_.set (r);
            continue;
          }
        }

        // GeometrySet
        //
        if (n.name () == "GeometrySet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< GeometrySet_type > r (
            GeometrySet_traits::create (i, f, this));

          if (!this->GeometrySet_)
          {
            this->GeometrySet_.set (r);
            continue;
          }
        }

        // TopologySet
        //
        if (n.name () == "TopologySet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TopologySet_type > r (
            TopologySet_traits::create (i, f, this));

          if (!this->TopologySet_)
          {
            this->TopologySet_.set (r);
            continue;
          }
        }

        // NoteSet
        //
        if (n.name () == "NoteSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NoteSet_type > r (
            NoteSet_traits::create (i, f, this));

          if (!this->NoteSet_)
          {
            this->NoteSet_.set (r);
            continue;
          }
        }

        // NoteFlagSet
        //
        if (n.name () == "NoteFlagSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NoteFlagSet_type > r (
            NoteFlagSet_traits::create (i, f, this));

          if (!this->NoteFlagSet_)
          {
            this->NoteFlagSet_.set (r);
            continue;
          }
        }

        // PartNoteSet
        //
        if (n.name () == "PartNoteSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PartNoteSet_type > r (
            PartNoteSet_traits::create (i, f, this));

          if (!this->PartNoteSet_)
          {
            this->PartNoteSet_.set (r);
            continue;
          }
        }

        // ViewSet
        //
        if (n.name () == "ViewSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ViewSet_type > r (
            ViewSet_traits::create (i, f, this));

          if (!this->ViewSet_)
          {
            this->ViewSet_.set (r);
            continue;
          }
        }

        // LayerSet
        //
        if (n.name () == "LayerSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LayerSet_type > r (
            LayerSet_traits::create (i, f, this));

          if (!this->LayerSet_)
          {
            this->LayerSet_.set (r);
            continue;
          }
        }

        // CoordinateSystemSet
        //
        if (n.name () == "CoordinateSystemSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoordinateSystemSet_type > r (
            CoordinateSystemSet_traits::create (i, f, this));

          if (!this->CoordinateSystemSet_)
          {
            this->CoordinateSystemSet_.set (r);
            continue;
          }
        }

        // VisualizationSet
        //
        if (n.name () == "VisualizationSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VisualizationSet_type > r (
            VisualizationSet_traits::create (i, f, this));

          if (!this->VisualizationSet_)
          {
            this->VisualizationSet_.set (r);
            continue;
          }
        }

        // AuxiliarySet
        //
        if (n.name () == "AuxiliarySet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AuxiliarySet_type > r (
            AuxiliarySet_traits::create (i, f, this));

          if (!this->AuxiliarySet_)
          {
            this->AuxiliarySet_.set (r);
            continue;
          }
        }

        // PartSet
        //
        if (n.name () == "PartSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PartSet_type > r (
            PartSet_traits::create (i, f, this));

          if (!this->PartSet_)
          {
            this->PartSet_.set (r);
            continue;
          }
        }

        // AssemblySet
        //
        if (n.name () == "AssemblySet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AssemblySet_type > r (
            AssemblySet_traits::create (i, f, this));

          if (!this->AssemblySet_)
          {
            this->AssemblySet_.set (r);
            continue;
          }
        }

        // ComponentSet
        //
        if (n.name () == "ComponentSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ComponentSet_type > r (
            ComponentSet_traits::create (i, f, this));

          if (!this->ComponentSet_)
          {
            this->ComponentSet_.set (r);
            continue;
          }
        }

        // RootPart
        //
        if (n.name () == "RootPart" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RootPart_type > r (
            RootPart_traits::create (i, f, this));

          if (!this->RootPart_)
          {
            this->RootPart_.set (r);
            continue;
          }
        }

        // RootAssembly
        //
        if (n.name () == "RootAssembly" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RootAssembly_type > r (
            RootAssembly_traits::create (i, f, this));

          if (!this->RootAssembly_)
          {
            this->RootAssembly_.set (r);
            continue;
          }
        }

        // RootComponent
        //
        if (n.name () == "RootComponent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RootComponent_type > r (
            RootComponent_traits::create (i, f, this));

          if (!this->RootComponent_)
          {
            this->RootComponent_.set (r);
            continue;
          }
        }

        // AsmPaths
        //
        if (n.name () == "AsmPaths" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AsmPaths_type > r (
            AsmPaths_traits::create (i, f, this));

          if (!this->AsmPaths_)
          {
            this->AsmPaths_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ProductType* ProductType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProductType (*this, f, c);
    }

    ProductType::
    ~ProductType ()
    {
    }

    // AsmPathType
    //

    AsmPathType::
    AsmPathType (const id_type& id)
    : ::xml_schema::type (),
      ComponentIds_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    AsmPathType::
    AsmPathType (const AsmPathType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ComponentIds_ (x.ComponentIds_, f, this),
      id_ (x.id_, f, this)
    {
    }

    AsmPathType::
    AsmPathType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ComponentIds_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void AsmPathType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ComponentIds
        //
        if (n.name () == "ComponentIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ComponentIds_type > r (
            ComponentIds_traits::create (i, f, this));

          if (!this->ComponentIds_)
          {
            this->ComponentIds_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    AsmPathType* AsmPathType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AsmPathType (*this, f, c);
    }

    AsmPathType::
    ~AsmPathType ()
    {
    }

    // AsmPathsType
    //

    AsmPathsType::
    AsmPathsType (const N_type& N)
    : ::xml_schema::type (),
      AsmPath_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    AsmPathsType::
    AsmPathsType (const AsmPathsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AsmPath_ (x.AsmPath_, f, this),
      N_ (x.N_, f, this)
    {
    }

    AsmPathsType::
    AsmPathsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AsmPath_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void AsmPathsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AsmPath
        //
        if (n.name () == "AsmPath" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AsmPath_type > r (
            AsmPath_traits::create (i, f, this));

          this->AsmPath_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    AsmPathsType* AsmPathsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AsmPathsType (*this, f, c);
    }

    AsmPathsType::
    ~AsmPathsType ()
    {
    }

    // ProductDefinitionBaseType
    //

    ProductDefinitionBaseType::
    ProductDefinitionBaseType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (::xml_schema::flags (), this),
      Name_ (::xml_schema::flags (), this),
      QPId_ (::xml_schema::flags (), this),
      ModelNumber_ (::xml_schema::flags (), this),
      Description_ (::xml_schema::flags (), this),
      Version_ (::xml_schema::flags (), this),
      Material_ (::xml_schema::flags (), this),
      SecurityClassification_ (::xml_schema::flags (), this),
      ExportControlClassification_ (::xml_schema::flags (), this),
      FeatureNominalIds_ (::xml_schema::flags (), this),
      CharacteristicNominalIds_ (::xml_schema::flags (), this),
      NoteIds_ (::xml_schema::flags (), this),
      PartNoteIds_ (::xml_schema::flags (), this),
      DatumDefinitionIds_ (::xml_schema::flags (), this),
      DatumTargetDefinitionIds_ (::xml_schema::flags (), this),
      DatumReferenceFrameIds_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    ProductDefinitionBaseType::
    ProductDefinitionBaseType (const ProductDefinitionBaseType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      Name_ (x.Name_, f, this),
      QPId_ (x.QPId_, f, this),
      ModelNumber_ (x.ModelNumber_, f, this),
      Description_ (x.Description_, f, this),
      Version_ (x.Version_, f, this),
      Material_ (x.Material_, f, this),
      SecurityClassification_ (x.SecurityClassification_, f, this),
      ExportControlClassification_ (x.ExportControlClassification_, f, this),
      FeatureNominalIds_ (x.FeatureNominalIds_, f, this),
      CharacteristicNominalIds_ (x.CharacteristicNominalIds_, f, this),
      NoteIds_ (x.NoteIds_, f, this),
      PartNoteIds_ (x.PartNoteIds_, f, this),
      DatumDefinitionIds_ (x.DatumDefinitionIds_, f, this),
      DatumTargetDefinitionIds_ (x.DatumTargetDefinitionIds_, f, this),
      DatumReferenceFrameIds_ (x.DatumReferenceFrameIds_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ProductDefinitionBaseType::
    ProductDefinitionBaseType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (f, this),
      Name_ (f, this),
      QPId_ (f, this),
      ModelNumber_ (f, this),
      Description_ (f, this),
      Version_ (f, this),
      Material_ (f, this),
      SecurityClassification_ (f, this),
      ExportControlClassification_ (f, this),
      FeatureNominalIds_ (f, this),
      CharacteristicNominalIds_ (f, this),
      NoteIds_ (f, this),
      PartNoteIds_ (f, this),
      DatumDefinitionIds_ (f, this),
      DatumTargetDefinitionIds_ (f, this),
      DatumReferenceFrameIds_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ProductDefinitionBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (r);
            continue;
          }
        }

        // QPId
        //
        if (n.name () == "QPId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< QPId_type > r (
            QPId_traits::create (i, f, this));

          if (!this->QPId_)
          {
            this->QPId_.set (r);
            continue;
          }
        }

        // ModelNumber
        //
        if (n.name () == "ModelNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ModelNumber_type > r (
            ModelNumber_traits::create (i, f, this));

          if (!this->ModelNumber_)
          {
            this->ModelNumber_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // Version
        //
        if (n.name () == "Version" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (r);
            continue;
          }
        }

        // Material
        //
        if (n.name () == "Material" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Material_type > r (
            Material_traits::create (i, f, this));

          this->Material_.push_back (r);
          continue;
        }

        // SecurityClassification
        //
        if (n.name () == "SecurityClassification" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SecurityClassification_type > r (
            SecurityClassification_traits::create (i, f, this));

          if (!this->SecurityClassification_)
          {
            this->SecurityClassification_.set (r);
            continue;
          }
        }

        // ExportControlClassification
        //
        if (n.name () == "ExportControlClassification" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ExportControlClassification_type > r (
            ExportControlClassification_traits::create (i, f, this));

          if (!this->ExportControlClassification_)
          {
            this->ExportControlClassification_.set (r);
            continue;
          }
        }

        // FeatureNominalIds
        //
        if (n.name () == "FeatureNominalIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureNominalIds_type > r (
            FeatureNominalIds_traits::create (i, f, this));

          if (!this->FeatureNominalIds_)
          {
            this->FeatureNominalIds_.set (r);
            continue;
          }
        }

        // CharacteristicNominalIds
        //
        if (n.name () == "CharacteristicNominalIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CharacteristicNominalIds_type > r (
            CharacteristicNominalIds_traits::create (i, f, this));

          if (!this->CharacteristicNominalIds_)
          {
            this->CharacteristicNominalIds_.set (r);
            continue;
          }
        }

        // NoteIds
        //
        if (n.name () == "NoteIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NoteIds_type > r (
            NoteIds_traits::create (i, f, this));

          if (!this->NoteIds_)
          {
            this->NoteIds_.set (r);
            continue;
          }
        }

        // PartNoteIds
        //
        if (n.name () == "PartNoteIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PartNoteIds_type > r (
            PartNoteIds_traits::create (i, f, this));

          if (!this->PartNoteIds_)
          {
            this->PartNoteIds_.set (r);
            continue;
          }
        }

        // DatumDefinitionIds
        //
        if (n.name () == "DatumDefinitionIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumDefinitionIds_type > r (
            DatumDefinitionIds_traits::create (i, f, this));

          if (!this->DatumDefinitionIds_)
          {
            this->DatumDefinitionIds_.set (r);
            continue;
          }
        }

        // DatumTargetDefinitionIds
        //
        if (n.name () == "DatumTargetDefinitionIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumTargetDefinitionIds_type > r (
            DatumTargetDefinitionIds_traits::create (i, f, this));

          if (!this->DatumTargetDefinitionIds_)
          {
            this->DatumTargetDefinitionIds_.set (r);
            continue;
          }
        }

        // DatumReferenceFrameIds
        //
        if (n.name () == "DatumReferenceFrameIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DatumReferenceFrameIds_type > r (
            DatumReferenceFrameIds_traits::create (i, f, this));

          if (!this->DatumReferenceFrameIds_)
          {
            this->DatumReferenceFrameIds_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    ProductDefinitionBaseType* ProductDefinitionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProductDefinitionBaseType (*this, f, c);
    }

    ProductDefinitionBaseType::
    ~ProductDefinitionBaseType ()
    {
    }

    // PartType
    //

    PartType::
    PartType (const id_type& id)
    : ::xsd::qif2::ProductDefinitionBaseType (id),
      DefinitionInternal_ (::xml_schema::flags (), this),
      DefinitionExternal_ (::xml_schema::flags (), this),
      PartFamily_ (::xml_schema::flags (), this)
    {
    }

    PartType::
    PartType (const PartType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::ProductDefinitionBaseType (x, f, c),
      DefinitionInternal_ (x.DefinitionInternal_, f, this),
      DefinitionExternal_ (x.DefinitionExternal_, f, this),
      PartFamily_ (x.PartFamily_, f, this)
    {
    }

    PartType::
    PartType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::ProductDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      DefinitionInternal_ (f, this),
      DefinitionExternal_ (f, this),
      PartFamily_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PartType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ProductDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DefinitionInternal
        //
        if (n.name () == "DefinitionInternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefinitionInternal_type > r (
            DefinitionInternal_traits::create (i, f, this));

          if (!this->DefinitionInternal_)
          {
            this->DefinitionInternal_.set (r);
            continue;
          }
        }

        // DefinitionExternal
        //
        if (n.name () == "DefinitionExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefinitionExternal_type > r (
            DefinitionExternal_traits::create (i, f, this));

          if (!this->DefinitionExternal_)
          {
            this->DefinitionExternal_.set (r);
            continue;
          }
        }

        // PartFamily
        //
        if (n.name () == "PartFamily" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PartFamily_type > r (
            PartFamily_traits::create (i, f, this));

          if (!this->PartFamily_)
          {
            this->PartFamily_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PartType* PartType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartType (*this, f, c);
    }

    PartType::
    ~PartType ()
    {
    }

    // AssemblyType
    //

    AssemblyType::
    AssemblyType (const id_type& id,
                  const ComponentIds_type& ComponentIds)
    : ::xsd::qif2::ProductDefinitionBaseType (id),
      ComponentIds_ (ComponentIds, ::xml_schema::flags (), this),
      DefinitionInternal_ (::xml_schema::flags (), this),
      DefinitionExternal_ (::xml_schema::flags (), this)
    {
    }

    AssemblyType::
    AssemblyType (const id_type& id,
                  ::std::auto_ptr< ComponentIds_type >& ComponentIds)
    : ::xsd::qif2::ProductDefinitionBaseType (id),
      ComponentIds_ (ComponentIds, ::xml_schema::flags (), this),
      DefinitionInternal_ (::xml_schema::flags (), this),
      DefinitionExternal_ (::xml_schema::flags (), this)
    {
    }

    AssemblyType::
    AssemblyType (const AssemblyType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ProductDefinitionBaseType (x, f, c),
      ComponentIds_ (x.ComponentIds_, f, this),
      DefinitionInternal_ (x.DefinitionInternal_, f, this),
      DefinitionExternal_ (x.DefinitionExternal_, f, this)
    {
    }

    AssemblyType::
    AssemblyType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ProductDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      ComponentIds_ (f, this),
      DefinitionInternal_ (f, this),
      DefinitionExternal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void AssemblyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ProductDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ComponentIds
        //
        if (n.name () == "ComponentIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ComponentIds_type > r (
            ComponentIds_traits::create (i, f, this));

          if (!ComponentIds_.present ())
          {
            this->ComponentIds_.set (r);
            continue;
          }
        }

        // DefinitionInternal
        //
        if (n.name () == "DefinitionInternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefinitionInternal_type > r (
            DefinitionInternal_traits::create (i, f, this));

          if (!this->DefinitionInternal_)
          {
            this->DefinitionInternal_.set (r);
            continue;
          }
        }

        // DefinitionExternal
        //
        if (n.name () == "DefinitionExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefinitionExternal_type > r (
            DefinitionExternal_traits::create (i, f, this));

          if (!this->DefinitionExternal_)
          {
            this->DefinitionExternal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ComponentIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ComponentIds",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AssemblyType* AssemblyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AssemblyType (*this, f, c);
    }

    AssemblyType::
    ~AssemblyType ()
    {
    }

    // PartFamilyType
    //

    PartFamilyType::
    PartFamilyType ()
    : ::xml_schema::type (),
      PrimaryShapeClass_ (::xml_schema::flags (), this),
      MinimumTolerance_ (::xml_schema::flags (), this),
      MinimumBoundingBox_ (::xml_schema::flags (), this),
      PrimaryManufacturingMethod_ (::xml_schema::flags (), this)
    {
    }

    PartFamilyType::
    PartFamilyType (const PartFamilyType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PrimaryShapeClass_ (x.PrimaryShapeClass_, f, this),
      MinimumTolerance_ (x.MinimumTolerance_, f, this),
      MinimumBoundingBox_ (x.MinimumBoundingBox_, f, this),
      PrimaryManufacturingMethod_ (x.PrimaryManufacturingMethod_, f, this)
    {
    }

    PartFamilyType::
    PartFamilyType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PrimaryShapeClass_ (f, this),
      MinimumTolerance_ (f, this),
      MinimumBoundingBox_ (f, this),
      PrimaryManufacturingMethod_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PartFamilyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PrimaryShapeClass
        //
        if (n.name () == "PrimaryShapeClass" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PrimaryShapeClass_type > r (
            PrimaryShapeClass_traits::create (i, f, this));

          if (!this->PrimaryShapeClass_)
          {
            this->PrimaryShapeClass_.set (r);
            continue;
          }
        }

        // MinimumTolerance
        //
        if (n.name () == "MinimumTolerance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinimumTolerance_type > r (
            MinimumTolerance_traits::create (i, f, this));

          if (!this->MinimumTolerance_)
          {
            this->MinimumTolerance_.set (r);
            continue;
          }
        }

        // MinimumBoundingBox
        //
        if (n.name () == "MinimumBoundingBox" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinimumBoundingBox_type > r (
            MinimumBoundingBox_traits::create (i, f, this));

          if (!this->MinimumBoundingBox_)
          {
            this->MinimumBoundingBox_.set (r);
            continue;
          }
        }

        // PrimaryManufacturingMethod
        //
        if (n.name () == "PrimaryManufacturingMethod" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PrimaryManufacturingMethod_type > r (
            PrimaryManufacturingMethod_traits::create (i, f, this));

          if (!this->PrimaryManufacturingMethod_)
          {
            this->PrimaryManufacturingMethod_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PartFamilyType* PartFamilyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartFamilyType (*this, f, c);
    }

    PartFamilyType::
    ~PartFamilyType ()
    {
    }

    // PartSetType
    //

    PartSetType::
    PartSetType (const N_type& N)
    : ::xml_schema::type (),
      Part_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    PartSetType::
    PartSetType (const PartSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Part_ (x.Part_, f, this),
      N_ (x.N_, f, this)
    {
    }

    PartSetType::
    PartSetType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Part_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PartSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Part
        //
        if (n.name () == "Part" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Part_type > r (
            Part_traits::create (i, f, this));

          this->Part_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    PartSetType* PartSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartSetType (*this, f, c);
    }

    PartSetType::
    ~PartSetType ()
    {
    }

    // AssemblySetType
    //

    AssemblySetType::
    AssemblySetType (const N_type& N)
    : ::xml_schema::type (),
      Assembly_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    AssemblySetType::
    AssemblySetType (const AssemblySetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Assembly_ (x.Assembly_, f, this),
      N_ (x.N_, f, this)
    {
    }

    AssemblySetType::
    AssemblySetType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Assembly_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void AssemblySetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Assembly
        //
        if (n.name () == "Assembly" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Assembly_type > r (
            Assembly_traits::create (i, f, this));

          this->Assembly_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    AssemblySetType* AssemblySetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AssemblySetType (*this, f, c);
    }

    AssemblySetType::
    ~AssemblySetType ()
    {
    }

    // ComponentType
    //

    ComponentType::
    ComponentType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (::xml_schema::flags (), this),
      QPId_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      Traceability_ (::xml_schema::flags (), this),
      Part_ (::xml_schema::flags (), this),
      Assembly_ (::xml_schema::flags (), this),
      DefinitionInternal_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    ComponentType::
    ComponentType (const ComponentType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      QPId_ (x.QPId_, f, this),
      Transform_ (x.Transform_, f, this),
      Traceability_ (x.Traceability_, f, this),
      Part_ (x.Part_, f, this),
      Assembly_ (x.Assembly_, f, this),
      DefinitionInternal_ (x.DefinitionInternal_, f, this),
      id_ (x.id_, f, this)
    {
    }

    ComponentType::
    ComponentType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (f, this),
      QPId_ (f, this),
      Transform_ (f, this),
      Traceability_ (f, this),
      Part_ (f, this),
      Assembly_ (f, this),
      DefinitionInternal_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ComponentType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        // QPId
        //
        if (n.name () == "QPId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< QPId_type > r (
            QPId_traits::create (i, f, this));

          if (!this->QPId_)
          {
            this->QPId_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // Traceability
        //
        if (n.name () == "Traceability" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Traceability_type > r (
            Traceability_traits::create (i, f, this));

          if (!this->Traceability_)
          {
            this->Traceability_.set (r);
            continue;
          }
        }

        // Part
        //
        if (n.name () == "Part" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Part_type > r (
            Part_traits::create (i, f, this));

          if (!this->Part_)
          {
            this->Part_.set (r);
            continue;
          }
        }

        // Assembly
        //
        if (n.name () == "Assembly" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Assembly_type > r (
            Assembly_traits::create (i, f, this));

          if (!this->Assembly_)
          {
            this->Assembly_.set (r);
            continue;
          }
        }

        // DefinitionInternal
        //
        if (n.name () == "DefinitionInternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefinitionInternal_type > r (
            DefinitionInternal_traits::create (i, f, this));

          if (!this->DefinitionInternal_)
          {
            this->DefinitionInternal_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    ComponentType* ComponentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComponentType (*this, f, c);
    }

    ComponentType::
    ~ComponentType ()
    {
    }

    // ComponentSetType
    //

    ComponentSetType::
    ComponentSetType (const N_type& N)
    : ::xml_schema::type (),
      Component_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ComponentSetType::
    ComponentSetType (const ComponentSetType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Component_ (x.Component_, f, this),
      N_ (x.N_, f, this)
    {
    }

    ComponentSetType::
    ComponentSetType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Component_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ComponentSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Component
        //
        if (n.name () == "Component" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Component_type > r (
            Component_traits::create (i, f, this));

          this->Component_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ComponentSetType* ComponentSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ComponentSetType (*this, f, c);
    }

    ComponentSetType::
    ~ComponentSetType ()
    {
    }

    // PrintedDrawingType
    //

    PrintedDrawingType::
    PrintedDrawingType (const Name_type& Name,
                        const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, ::xml_schema::flags (), this),
      Version_ (::xml_schema::flags (), this),
      Description_ (::xml_schema::flags (), this),
      Author_ (::xml_schema::flags (), this),
      DrawingNumber_ (::xml_schema::flags (), this),
      AdditionalChanges_ (::xml_schema::flags (), this),
      Location_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    PrintedDrawingType::
    PrintedDrawingType (const PrintedDrawingType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Version_ (x.Version_, f, this),
      Description_ (x.Description_, f, this),
      Author_ (x.Author_, f, this),
      DrawingNumber_ (x.DrawingNumber_, f, this),
      AdditionalChanges_ (x.AdditionalChanges_, f, this),
      Location_ (x.Location_, f, this),
      id_ (x.id_, f, this)
    {
    }

    PrintedDrawingType::
    PrintedDrawingType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (f, this),
      Version_ (f, this),
      Description_ (f, this),
      Author_ (f, this),
      DrawingNumber_ (f, this),
      AdditionalChanges_ (f, this),
      Location_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PrintedDrawingType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (r);
            continue;
          }
        }

        // Version
        //
        if (n.name () == "Version" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // Author
        //
        if (n.name () == "Author" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Author_type > r (
            Author_traits::create (i, f, this));

          if (!this->Author_)
          {
            this->Author_.set (r);
            continue;
          }
        }

        // DrawingNumber
        //
        if (n.name () == "DrawingNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DrawingNumber_type > r (
            DrawingNumber_traits::create (i, f, this));

          if (!this->DrawingNumber_)
          {
            this->DrawingNumber_.set (r);
            continue;
          }
        }

        // AdditionalChanges
        //
        if (n.name () == "AdditionalChanges" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AdditionalChanges_type > r (
            AdditionalChanges_traits::create (i, f, this));

          if (!this->AdditionalChanges_)
          {
            this->AdditionalChanges_.set (r);
            continue;
          }
        }

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    PrintedDrawingType* PrintedDrawingType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrintedDrawingType (*this, f, c);
    }

    PrintedDrawingType::
    ~PrintedDrawingType ()
    {
    }

    // GDTEnumType
    //

    GDTEnumType::
    GDTEnumType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_GDTEnumType_convert ();
    }

    GDTEnumType::
    GDTEnumType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_GDTEnumType_convert ();
    }

    GDTEnumType::
    GDTEnumType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_GDTEnumType_convert ();
    }

    GDTEnumType* GDTEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GDTEnumType (*this, f, c);
    }

    GDTEnumType::value GDTEnumType::
    _xsd_GDTEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_GDTEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_GDTEnumType_indexes_,
                        _xsd_GDTEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_GDTEnumType_indexes_ + 4 || _xsd_GDTEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const GDTEnumType::
    _xsd_GDTEnumType_literals_[4] =
    {
      "UNKNOWN",
      "HUMANREAD",
      "MACHINEREAD",
      "ABSENT"
    };

    const GDTEnumType::value GDTEnumType::
    _xsd_GDTEnumType_indexes_[4] =
    {
      ::xsd::qif2::GDTEnumType::ABSENT,
      ::xsd::qif2::GDTEnumType::HUMANREAD,
      ::xsd::qif2::GDTEnumType::MACHINEREAD,
      ::xsd::qif2::GDTEnumType::UNKNOWN
    };

    // TopologyEnumType
    //

    TopologyEnumType::
    TopologyEnumType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_TopologyEnumType_convert ();
    }

    TopologyEnumType::
    TopologyEnumType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_TopologyEnumType_convert ();
    }

    TopologyEnumType::
    TopologyEnumType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_TopologyEnumType_convert ();
    }

    TopologyEnumType* TopologyEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TopologyEnumType (*this, f, c);
    }

    TopologyEnumType::value TopologyEnumType::
    _xsd_TopologyEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TopologyEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_TopologyEnumType_indexes_,
                        _xsd_TopologyEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_TopologyEnumType_indexes_ + 3 || _xsd_TopologyEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const TopologyEnumType::
    _xsd_TopologyEnumType_literals_[3] =
    {
      "UNKNOWN",
      "PRESENT",
      "ABSENT"
    };

    const TopologyEnumType::value TopologyEnumType::
    _xsd_TopologyEnumType_indexes_[3] =
    {
      ::xsd::qif2::TopologyEnumType::ABSENT,
      ::xsd::qif2::TopologyEnumType::PRESENT,
      ::xsd::qif2::TopologyEnumType::UNKNOWN
    };

    // DigitalModelType
    //

    const DigitalModelType::GDT_type DigitalModelType::GDT_default_value_ (
      "UNKNOWN");

    const DigitalModelType::Topology_type DigitalModelType::Topology_default_value_ (
      "UNKNOWN");

    DigitalModelType::
    DigitalModelType (const Name_type& Name,
                      const File_type& File,
                      const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, ::xml_schema::flags (), this),
      File_ (File, ::xml_schema::flags (), this),
      Application_ (::xml_schema::flags (), this),
      Author_ (::xml_schema::flags (), this),
      ApplicationSource_ (::xml_schema::flags (), this),
      Description_ (::xml_schema::flags (), this),
      Units_ (::xml_schema::flags (), this),
      GDT_ (::xml_schema::flags (), this),
      Topology_ (::xml_schema::flags (), this),
      Entities_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    DigitalModelType::
    DigitalModelType (const Name_type& Name,
                      ::std::auto_ptr< File_type >& File,
                      const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, ::xml_schema::flags (), this),
      File_ (File, ::xml_schema::flags (), this),
      Application_ (::xml_schema::flags (), this),
      Author_ (::xml_schema::flags (), this),
      ApplicationSource_ (::xml_schema::flags (), this),
      Description_ (::xml_schema::flags (), this),
      Units_ (::xml_schema::flags (), this),
      GDT_ (::xml_schema::flags (), this),
      Topology_ (::xml_schema::flags (), this),
      Entities_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    DigitalModelType::
    DigitalModelType (const DigitalModelType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      File_ (x.File_, f, this),
      Application_ (x.Application_, f, this),
      Author_ (x.Author_, f, this),
      ApplicationSource_ (x.ApplicationSource_, f, this),
      Description_ (x.Description_, f, this),
      Units_ (x.Units_, f, this),
      GDT_ (x.GDT_, f, this),
      Topology_ (x.Topology_, f, this),
      Entities_ (x.Entities_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DigitalModelType::
    DigitalModelType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (f, this),
      File_ (f, this),
      Application_ (f, this),
      Author_ (f, this),
      ApplicationSource_ (f, this),
      Description_ (f, this),
      Units_ (f, this),
      GDT_ (f, this),
      Topology_ (f, this),
      Entities_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void DigitalModelType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (r);
            continue;
          }
        }

        // File
        //
        if (n.name () == "File" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< File_type > r (
            File_traits::create (i, f, this));

          if (!File_.present ())
          {
            this->File_.set (r);
            continue;
          }
        }

        // Application
        //
        if (n.name () == "Application" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Application_type > r (
            Application_traits::create (i, f, this));

          if (!this->Application_)
          {
            this->Application_.set (r);
            continue;
          }
        }

        // Author
        //
        if (n.name () == "Author" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Author_type > r (
            Author_traits::create (i, f, this));

          if (!this->Author_)
          {
            this->Author_.set (r);
            continue;
          }
        }

        // ApplicationSource
        //
        if (n.name () == "ApplicationSource" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ApplicationSource_type > r (
            ApplicationSource_traits::create (i, f, this));

          if (!this->ApplicationSource_)
          {
            this->ApplicationSource_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // Units
        //
        if (n.name () == "Units" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Units_type > r (
            Units_traits::create (i, f, this));

          if (!this->Units_)
          {
            this->Units_.set (r);
            continue;
          }
        }

        // GDT
        //
        if (n.name () == "GDT" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< GDT_type > r (
            GDT_traits::create (i, f, this));

          if (!this->GDT_)
          {
            this->GDT_.set (r);
            continue;
          }
        }

        // Topology
        //
        if (n.name () == "Topology" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Topology_type > r (
            Topology_traits::create (i, f, this));

          if (!this->Topology_)
          {
            this->Topology_.set (r);
            continue;
          }
        }

        // Entities
        //
        if (n.name () == "Entities" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Entities_type > r (
            Entities_traits::create (i, f, this));

          if (!this->Entities_)
          {
            this->Entities_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!File_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "File",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    DigitalModelType* DigitalModelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DigitalModelType (*this, f, c);
    }

    DigitalModelType::
    ~DigitalModelType ()
    {
    }

    // DefinitionExternalType
    //

    DefinitionExternalType::
    DefinitionExternalType (const id_type& id)
    : ::xml_schema::type (),
      PrintedDrawing_ (::xml_schema::flags (), this),
      DigitalDrawing_ (::xml_schema::flags (), this),
      DigitalModel_ (::xml_schema::flags (), this),
      PhysicalModel_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    DefinitionExternalType::
    DefinitionExternalType (const DefinitionExternalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PrintedDrawing_ (x.PrintedDrawing_, f, this),
      DigitalDrawing_ (x.DigitalDrawing_, f, this),
      DigitalModel_ (x.DigitalModel_, f, this),
      PhysicalModel_ (x.PhysicalModel_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DefinitionExternalType::
    DefinitionExternalType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PrintedDrawing_ (f, this),
      DigitalDrawing_ (f, this),
      DigitalModel_ (f, this),
      PhysicalModel_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void DefinitionExternalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PrintedDrawing
        //
        if (n.name () == "PrintedDrawing" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PrintedDrawing_type > r (
            PrintedDrawing_traits::create (i, f, this));

          this->PrintedDrawing_.push_back (r);
          continue;
        }

        // DigitalDrawing
        //
        if (n.name () == "DigitalDrawing" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DigitalDrawing_type > r (
            DigitalDrawing_traits::create (i, f, this));

          this->DigitalDrawing_.push_back (r);
          continue;
        }

        // DigitalModel
        //
        if (n.name () == "DigitalModel" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DigitalModel_type > r (
            DigitalModel_traits::create (i, f, this));

          this->DigitalModel_.push_back (r);
          continue;
        }

        // PhysicalModel
        //
        if (n.name () == "PhysicalModel" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PhysicalModel_type > r (
            PhysicalModel_traits::create (i, f, this));

          this->PhysicalModel_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    DefinitionExternalType* DefinitionExternalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DefinitionExternalType (*this, f, c);
    }

    DefinitionExternalType::
    ~DefinitionExternalType ()
    {
    }

    // DigitalDrawingType
    //

    DigitalDrawingType::
    DigitalDrawingType (const Name_type& Name,
                        const File_type& File,
                        const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, ::xml_schema::flags (), this),
      File_ (File, ::xml_schema::flags (), this),
      Application_ (::xml_schema::flags (), this),
      Author_ (::xml_schema::flags (), this),
      ApplicationSource_ (::xml_schema::flags (), this),
      Description_ (::xml_schema::flags (), this),
      Entities_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    DigitalDrawingType::
    DigitalDrawingType (const Name_type& Name,
                        ::std::auto_ptr< File_type >& File,
                        const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, ::xml_schema::flags (), this),
      File_ (File, ::xml_schema::flags (), this),
      Application_ (::xml_schema::flags (), this),
      Author_ (::xml_schema::flags (), this),
      ApplicationSource_ (::xml_schema::flags (), this),
      Description_ (::xml_schema::flags (), this),
      Entities_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    DigitalDrawingType::
    DigitalDrawingType (const DigitalDrawingType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      File_ (x.File_, f, this),
      Application_ (x.Application_, f, this),
      Author_ (x.Author_, f, this),
      ApplicationSource_ (x.ApplicationSource_, f, this),
      Description_ (x.Description_, f, this),
      Entities_ (x.Entities_, f, this),
      id_ (x.id_, f, this)
    {
    }

    DigitalDrawingType::
    DigitalDrawingType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (f, this),
      File_ (f, this),
      Application_ (f, this),
      Author_ (f, this),
      ApplicationSource_ (f, this),
      Description_ (f, this),
      Entities_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void DigitalDrawingType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (r);
            continue;
          }
        }

        // File
        //
        if (n.name () == "File" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< File_type > r (
            File_traits::create (i, f, this));

          if (!File_.present ())
          {
            this->File_.set (r);
            continue;
          }
        }

        // Application
        //
        if (n.name () == "Application" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Application_type > r (
            Application_traits::create (i, f, this));

          if (!this->Application_)
          {
            this->Application_.set (r);
            continue;
          }
        }

        // Author
        //
        if (n.name () == "Author" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Author_type > r (
            Author_traits::create (i, f, this));

          if (!this->Author_)
          {
            this->Author_.set (r);
            continue;
          }
        }

        // ApplicationSource
        //
        if (n.name () == "ApplicationSource" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ApplicationSource_type > r (
            ApplicationSource_traits::create (i, f, this));

          if (!this->ApplicationSource_)
          {
            this->ApplicationSource_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // Entities
        //
        if (n.name () == "Entities" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Entities_type > r (
            Entities_traits::create (i, f, this));

          if (!this->Entities_)
          {
            this->Entities_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!File_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "File",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    DigitalDrawingType* DigitalDrawingType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DigitalDrawingType (*this, f, c);
    }

    DigitalDrawingType::
    ~DigitalDrawingType ()
    {
    }

    // PhysicalModelType
    //

    PhysicalModelType::
    PhysicalModelType (const Name_type& Name,
                       const id_type& id)
    : ::xml_schema::type (),
      Name_ (Name, ::xml_schema::flags (), this),
      Version_ (::xml_schema::flags (), this),
      Description_ (::xml_schema::flags (), this),
      Author_ (::xml_schema::flags (), this),
      Location_ (::xml_schema::flags (), this),
      ModelNumber_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    PhysicalModelType::
    PhysicalModelType (const PhysicalModelType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Version_ (x.Version_, f, this),
      Description_ (x.Description_, f, this),
      Author_ (x.Author_, f, this),
      Location_ (x.Location_, f, this),
      ModelNumber_ (x.ModelNumber_, f, this),
      id_ (x.id_, f, this)
    {
    }

    PhysicalModelType::
    PhysicalModelType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (f, this),
      Version_ (f, this),
      Description_ (f, this),
      Author_ (f, this),
      Location_ (f, this),
      ModelNumber_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PhysicalModelType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (r);
            continue;
          }
        }

        // Version
        //
        if (n.name () == "Version" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // Author
        //
        if (n.name () == "Author" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Author_type > r (
            Author_traits::create (i, f, this));

          if (!this->Author_)
          {
            this->Author_.set (r);
            continue;
          }
        }

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // ModelNumber
        //
        if (n.name () == "ModelNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ModelNumber_type > r (
            ModelNumber_traits::create (i, f, this));

          if (!this->ModelNumber_)
          {
            this->ModelNumber_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    PhysicalModelType* PhysicalModelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PhysicalModelType (*this, f, c);
    }

    PhysicalModelType::
    ~PhysicalModelType ()
    {
    }

    // InternalHeaderType
    //

    InternalHeaderType::
    InternalHeaderType ()
    : ::xml_schema::type (),
      Name_ (::xml_schema::flags (), this),
      File_ (::xml_schema::flags (), this),
      Application_ (::xml_schema::flags (), this),
      Author_ (::xml_schema::flags (), this),
      ApplicationSource_ (::xml_schema::flags (), this),
      Description_ (::xml_schema::flags (), this),
      Units_ (::xml_schema::flags (), this),
      ScaleCoefficient_ (::xml_schema::flags (), this),
      ModelTolerance_ (::xml_schema::flags (), this),
      MassPropertyTolerance_ (::xml_schema::flags (), this)
    {
    }

    InternalHeaderType::
    InternalHeaderType (const InternalHeaderType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      File_ (x.File_, f, this),
      Application_ (x.Application_, f, this),
      Author_ (x.Author_, f, this),
      ApplicationSource_ (x.ApplicationSource_, f, this),
      Description_ (x.Description_, f, this),
      Units_ (x.Units_, f, this),
      ScaleCoefficient_ (x.ScaleCoefficient_, f, this),
      ModelTolerance_ (x.ModelTolerance_, f, this),
      MassPropertyTolerance_ (x.MassPropertyTolerance_, f, this)
    {
    }

    InternalHeaderType::
    InternalHeaderType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (f, this),
      File_ (f, this),
      Application_ (f, this),
      Author_ (f, this),
      ApplicationSource_ (f, this),
      Description_ (f, this),
      Units_ (f, this),
      ScaleCoefficient_ (f, this),
      ModelTolerance_ (f, this),
      MassPropertyTolerance_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void InternalHeaderType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (r);
            continue;
          }
        }

        // File
        //
        if (n.name () == "File" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< File_type > r (
            File_traits::create (i, f, this));

          if (!this->File_)
          {
            this->File_.set (r);
            continue;
          }
        }

        // Application
        //
        if (n.name () == "Application" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Application_type > r (
            Application_traits::create (i, f, this));

          if (!this->Application_)
          {
            this->Application_.set (r);
            continue;
          }
        }

        // Author
        //
        if (n.name () == "Author" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Author_type > r (
            Author_traits::create (i, f, this));

          if (!this->Author_)
          {
            this->Author_.set (r);
            continue;
          }
        }

        // ApplicationSource
        //
        if (n.name () == "ApplicationSource" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ApplicationSource_type > r (
            ApplicationSource_traits::create (i, f, this));

          if (!this->ApplicationSource_)
          {
            this->ApplicationSource_.set (r);
            continue;
          }
        }

        // Description
        //
        if (n.name () == "Description" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Description_type > r (
            Description_traits::create (i, f, this));

          if (!this->Description_)
          {
            this->Description_.set (r);
            continue;
          }
        }

        // Units
        //
        if (n.name () == "Units" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Units_type > r (
            Units_traits::create (i, f, this));

          if (!this->Units_)
          {
            this->Units_.set (r);
            continue;
          }
        }

        // ScaleCoefficient
        //
        if (n.name () == "ScaleCoefficient" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->ScaleCoefficient_)
          {
            this->ScaleCoefficient_.set (ScaleCoefficient_traits::create (i, f, this));
            continue;
          }
        }

        // ModelTolerance
        //
        if (n.name () == "ModelTolerance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->ModelTolerance_)
          {
            this->ModelTolerance_.set (ModelTolerance_traits::create (i, f, this));
            continue;
          }
        }

        // MassPropertyTolerance
        //
        if (n.name () == "MassPropertyTolerance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->MassPropertyTolerance_)
          {
            this->MassPropertyTolerance_.set (MassPropertyTolerance_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    InternalHeaderType* InternalHeaderType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class InternalHeaderType (*this, f, c);
    }

    InternalHeaderType::
    ~InternalHeaderType ()
    {
    }

    // InternalPartAssemblyType
    //

    InternalPartAssemblyType::
    InternalPartAssemblyType (const originMassProperty_type& originMassProperty)
    : ::xsd::qif2::NodeBaseType (),
      Header_ (::xml_schema::flags (), this),
      BodyIds_ (::xml_schema::flags (), this),
      CoordinateSystemIds_ (::xml_schema::flags (), this),
      AuxiliaryIds_ (::xml_schema::flags (), this),
      ViewIds_ (::xml_schema::flags (), this),
      PointCloudIds_ (::xml_schema::flags (), this),
      color_ (::xml_schema::flags (), this),
      transparency_ (transparency_default_value (), ::xml_schema::flags (), this),
      hidden_ (hidden_default_value (), ::xml_schema::flags (), this),
      size_ (::xml_schema::flags (), this),
      originMassProperty_ (originMassProperty, ::xml_schema::flags (), this)
    {
    }

    InternalPartAssemblyType::
    InternalPartAssemblyType (const InternalPartAssemblyType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::NodeBaseType (x, f, c),
      Header_ (x.Header_, f, this),
      BodyIds_ (x.BodyIds_, f, this),
      CoordinateSystemIds_ (x.CoordinateSystemIds_, f, this),
      AuxiliaryIds_ (x.AuxiliaryIds_, f, this),
      ViewIds_ (x.ViewIds_, f, this),
      PointCloudIds_ (x.PointCloudIds_, f, this),
      color_ (x.color_, f, this),
      transparency_ (x.transparency_, f, this),
      hidden_ (x.hidden_, f, this),
      size_ (x.size_, f, this),
      originMassProperty_ (x.originMassProperty_, f, this)
    {
    }

    InternalPartAssemblyType::
    InternalPartAssemblyType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::NodeBaseType (e, f | ::xml_schema::flags::base, c),
      Header_ (f, this),
      BodyIds_ (f, this),
      CoordinateSystemIds_ (f, this),
      AuxiliaryIds_ (f, this),
      ViewIds_ (f, this),
      PointCloudIds_ (f, this),
      color_ (f, this),
      transparency_ (f, this),
      hidden_ (f, this),
      size_ (f, this),
      originMassProperty_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void InternalPartAssemblyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::NodeBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Header
        //
        if (n.name () == "Header" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Header_type > r (
            Header_traits::create (i, f, this));

          if (!this->Header_)
          {
            this->Header_.set (r);
            continue;
          }
        }

        // BodyIds
        //
        if (n.name () == "BodyIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BodyIds_type > r (
            BodyIds_traits::create (i, f, this));

          if (!this->BodyIds_)
          {
            this->BodyIds_.set (r);
            continue;
          }
        }

        // CoordinateSystemIds
        //
        if (n.name () == "CoordinateSystemIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoordinateSystemIds_type > r (
            CoordinateSystemIds_traits::create (i, f, this));

          if (!this->CoordinateSystemIds_)
          {
            this->CoordinateSystemIds_.set (r);
            continue;
          }
        }

        // AuxiliaryIds
        //
        if (n.name () == "AuxiliaryIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AuxiliaryIds_type > r (
            AuxiliaryIds_traits::create (i, f, this));

          if (!this->AuxiliaryIds_)
          {
            this->AuxiliaryIds_.set (r);
            continue;
          }
        }

        // ViewIds
        //
        if (n.name () == "ViewIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ViewIds_type > r (
            ViewIds_traits::create (i, f, this));

          if (!this->ViewIds_)
          {
            this->ViewIds_.set (r);
            continue;
          }
        }

        // PointCloudIds
        //
        if (n.name () == "PointCloudIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointCloudIds_type > r (
            PointCloudIds_traits::create (i, f, this));

          if (!this->PointCloudIds_)
          {
            this->PointCloudIds_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "color" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< color_type > r (
            color_traits::create (i, f, this));

          this->color_.set (r);
          continue;
        }

        if (n.name () == "transparency" && n.namespace_ ().empty ())
        {
          this->transparency_.set (transparency_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "hidden" && n.namespace_ ().empty ())
        {
          this->hidden_.set (hidden_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "size" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< size_type > r (
            size_traits::create (i, f, this));

          this->size_.set (r);
          continue;
        }

        if (n.name () == "originMassProperty" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< originMassProperty_type > r (
            originMassProperty_traits::create (i, f, this));

          this->originMassProperty_.set (r);
          continue;
        }
      }

      if (!transparency_.present ())
      {
        this->transparency_.set (transparency_default_value ());
      }

      if (!hidden_.present ())
      {
        this->hidden_.set (hidden_default_value ());
      }

      if (!originMassProperty_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "originMassProperty",
          "");
      }
    }

    InternalPartAssemblyType* InternalPartAssemblyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class InternalPartAssemblyType (*this, f, c);
    }

    InternalPartAssemblyType::
    ~InternalPartAssemblyType ()
    {
    }

    // InternalComponentType
    //

    InternalComponentType::
    InternalComponentType ()
    : ::xsd::qif2::NodeBaseType (),
      color_ (::xml_schema::flags (), this),
      transparency_ (transparency_default_value (), ::xml_schema::flags (), this),
      hidden_ (hidden_default_value (), ::xml_schema::flags (), this),
      size_ (::xml_schema::flags (), this)
    {
    }

    InternalComponentType::
    InternalComponentType (const InternalComponentType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::NodeBaseType (x, f, c),
      color_ (x.color_, f, this),
      transparency_ (x.transparency_, f, this),
      hidden_ (x.hidden_, f, this),
      size_ (x.size_, f, this)
    {
    }

    InternalComponentType::
    InternalComponentType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::NodeBaseType (e, f | ::xml_schema::flags::base, c),
      color_ (f, this),
      transparency_ (f, this),
      hidden_ (f, this),
      size_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void InternalComponentType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::NodeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "color" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< color_type > r (
            color_traits::create (i, f, this));

          this->color_.set (r);
          continue;
        }

        if (n.name () == "transparency" && n.namespace_ ().empty ())
        {
          this->transparency_.set (transparency_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "hidden" && n.namespace_ ().empty ())
        {
          this->hidden_.set (hidden_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "size" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< size_type > r (
            size_traits::create (i, f, this));

          this->size_.set (r);
          continue;
        }
      }

      if (!transparency_.present ())
      {
        this->transparency_.set (transparency_default_value ());
      }

      if (!hidden_.present ())
      {
        this->hidden_.set (hidden_default_value ());
      }
    }

    InternalComponentType* InternalComponentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class InternalComponentType (*this, f, c);
    }

    InternalComponentType::
    ~InternalComponentType ()
    {
    }

    // LayerType
    //

    LayerType::
    LayerType (const id_type& id,
               const index_type& index)
    : ::xsd::qif2::DrawableBaseType (id),
      ElementIds_ (::xml_schema::flags (), this),
      applyColor_ (applyColor_default_value (), ::xml_schema::flags (), this),
      index_ (index, ::xml_schema::flags (), this)
    {
    }

    LayerType::
    LayerType (const LayerType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::DrawableBaseType (x, f, c),
      ElementIds_ (x.ElementIds_, f, this),
      applyColor_ (x.applyColor_, f, this),
      index_ (x.index_, f, this)
    {
    }

    LayerType::
    LayerType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::DrawableBaseType (e, f | ::xml_schema::flags::base, c),
      ElementIds_ (f, this),
      applyColor_ (f, this),
      index_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void LayerType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DrawableBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ElementIds
        //
        if (n.name () == "ElementIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ElementIds_type > r (
            ElementIds_traits::create (i, f, this));

          if (!this->ElementIds_)
          {
            this->ElementIds_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "applyColor" && n.namespace_ ().empty ())
        {
          this->applyColor_.set (applyColor_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "index" && n.namespace_ ().empty ())
        {
          this->index_.set (index_traits::create (i, f, this));
          continue;
        }
      }

      if (!applyColor_.present ())
      {
        this->applyColor_.set (applyColor_default_value ());
      }

      if (!index_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "index",
          "");
      }
    }

    LayerType* LayerType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LayerType (*this, f, c);
    }

    LayerType::
    ~LayerType ()
    {
    }

    // LayerSetType
    //

    LayerSetType::
    LayerSetType (const N_type& N)
    : ::xml_schema::type (),
      Layer_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    LayerSetType::
    LayerSetType (const LayerSetType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Layer_ (x.Layer_, f, this),
      N_ (x.N_, f, this)
    {
    }

    LayerSetType::
    LayerSetType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Layer_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void LayerSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Layer
        //
        if (n.name () == "Layer" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Layer_type > r (
            Layer_traits::create (i, f, this));

          this->Layer_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    LayerSetType* LayerSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LayerSetType (*this, f, c);
    }

    LayerSetType::
    ~LayerSetType ()
    {
    }

    // PartNoteSetType
    //

    PartNoteSetType::
    PartNoteSetType (const N_type& N)
    : ::xml_schema::type (),
      PartNote_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    PartNoteSetType::
    PartNoteSetType (const PartNoteSetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PartNote_ (x.PartNote_, f, this),
      N_ (x.N_, f, this)
    {
    }

    PartNoteSetType::
    PartNoteSetType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PartNote_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PartNoteSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PartNote
        //
        if (n.name () == "PartNote" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PartNote_type > r (
            PartNote_traits::create (i, f, this));

          this->PartNote_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    PartNoteSetType* PartNoteSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartNoteSetType (*this, f, c);
    }

    PartNoteSetType::
    ~PartNoteSetType ()
    {
    }

    // PartNoteType
    //

    PartNoteType::
    PartNoteType (const id_type& id)
    : ::xsd::qif2::DrawableBaseType (id),
      Text_ (::xml_schema::flags (), this),
      PartNoteIds_ (::xml_schema::flags (), this)
    {
    }

    PartNoteType::
    PartNoteType (const PartNoteType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::DrawableBaseType (x, f, c),
      Text_ (x.Text_, f, this),
      PartNoteIds_ (x.PartNoteIds_, f, this)
    {
    }

    PartNoteType::
    PartNoteType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::DrawableBaseType (e, f | ::xml_schema::flags::base, c),
      Text_ (f, this),
      PartNoteIds_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PartNoteType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DrawableBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Text
        //
        if (n.name () == "Text" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Text_type > r (
            Text_traits::create (i, f, this));

          if (!this->Text_)
          {
            this->Text_.set (r);
            continue;
          }
        }

        // PartNoteIds
        //
        if (n.name () == "PartNoteIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PartNoteIds_type > r (
            PartNoteIds_traits::create (i, f, this));

          if (!this->PartNoteIds_)
          {
            this->PartNoteIds_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PartNoteType* PartNoteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PartNoteType (*this, f, c);
    }

    PartNoteType::
    ~PartNoteType ()
    {
    }

    // NoteType
    //

    const NoteType::form_type NoteType::form_default_value_ (
      "3D");

    NoteType::
    NoteType (const id_type& id,
              const Text_type& Text)
    : ::xsd::qif2::DrawableBaseType (id),
      EntityInternalIds_ (::xml_schema::flags (), this),
      EntityExternalIds_ (::xml_schema::flags (), this),
      Text_ (Text, ::xml_schema::flags (), this),
      form_ (form_default_value (), ::xml_schema::flags (), this)
    {
    }

    NoteType::
    NoteType (const NoteType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::DrawableBaseType (x, f, c),
      EntityInternalIds_ (x.EntityInternalIds_, f, this),
      EntityExternalIds_ (x.EntityExternalIds_, f, this),
      Text_ (x.Text_, f, this),
      form_ (x.form_, f, this)
    {
    }

    NoteType::
    NoteType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::DrawableBaseType (e, f | ::xml_schema::flags::base, c),
      EntityInternalIds_ (f, this),
      EntityExternalIds_ (f, this),
      Text_ (f, this),
      form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void NoteType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::DrawableBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EntityInternalIds
        //
        if (n.name () == "EntityInternalIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EntityInternalIds_type > r (
            EntityInternalIds_traits::create (i, f, this));

          if (!this->EntityInternalIds_)
          {
            this->EntityInternalIds_.set (r);
            continue;
          }
        }

        // EntityExternalIds
        //
        if (n.name () == "EntityExternalIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EntityExternalIds_type > r (
            EntityExternalIds_traits::create (i, f, this));

          if (!this->EntityExternalIds_)
          {
            this->EntityExternalIds_.set (r);
            continue;
          }
        }

        // Text
        //
        if (n.name () == "Text" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Text_type > r (
            Text_traits::create (i, f, this));

          if (!Text_.present ())
          {
            this->Text_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Text_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Text",
          "http://qifstandards.org/xsd/qif2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "form" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< form_type > r (
            form_traits::create (i, f, this));

          this->form_.set (r);
          continue;
        }
      }

      if (!form_.present ())
      {
        this->form_.set (form_default_value ());
      }
    }

    NoteType* NoteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NoteType (*this, f, c);
    }

    NoteType::
    ~NoteType ()
    {
    }

    // NoteFormEnumType
    //

    NoteFormEnumType::
    NoteFormEnumType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_NoteFormEnumType_convert ();
    }

    NoteFormEnumType::
    NoteFormEnumType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_NoteFormEnumType_convert ();
    }

    NoteFormEnumType::
    NoteFormEnumType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_NoteFormEnumType_convert ();
    }

    NoteFormEnumType* NoteFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NoteFormEnumType (*this, f, c);
    }

    NoteFormEnumType::value NoteFormEnumType::
    _xsd_NoteFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_NoteFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_NoteFormEnumType_indexes_,
                        _xsd_NoteFormEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_NoteFormEnumType_indexes_ + 2 || _xsd_NoteFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const NoteFormEnumType::
    _xsd_NoteFormEnumType_literals_[2] =
    {
      "3D",
      "SCREEN"
    };

    const NoteFormEnumType::value NoteFormEnumType::
    _xsd_NoteFormEnumType_indexes_[2] =
    {
      ::xsd::qif2::NoteFormEnumType::cxx_3D,
      ::xsd::qif2::NoteFormEnumType::SCREEN
    };

    // NoteSetType
    //

    NoteSetType::
    NoteSetType (const N_type& N)
    : ::xml_schema::type (),
      Note_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    NoteSetType::
    NoteSetType (const NoteSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Note_ (x.Note_, f, this),
      N_ (x.N_, f, this)
    {
    }

    NoteSetType::
    NoteSetType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Note_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void NoteSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Note
        //
        if (n.name () == "Note" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Note_type > r (
            Note_traits::create (i, f, this));

          this->Note_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    NoteSetType* NoteSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NoteSetType (*this, f, c);
    }

    NoteSetType::
    ~NoteSetType ()
    {
    }

    // NoteFlagType
    //

    NoteFlagType::
    NoteFlagType (const id_type& id,
                  const Text_type& Text)
    : ::xsd::qif2::NoteType (id,
                             Text),
      TextHidden_ (::xml_schema::flags (), this),
      URI_ (::xml_schema::flags (), this)
    {
    }

    NoteFlagType::
    NoteFlagType (const NoteFlagType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::NoteType (x, f, c),
      TextHidden_ (x.TextHidden_, f, this),
      URI_ (x.URI_, f, this)
    {
    }

    NoteFlagType::
    NoteFlagType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::NoteType (e, f | ::xml_schema::flags::base, c),
      TextHidden_ (f, this),
      URI_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void NoteFlagType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::NoteType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TextHidden
        //
        if (n.name () == "TextHidden" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TextHidden_type > r (
            TextHidden_traits::create (i, f, this));

          if (!this->TextHidden_)
          {
            this->TextHidden_.set (r);
            continue;
          }
        }

        // URI
        //
        if (n.name () == "URI" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< URI_type > r (
            URI_traits::create (i, f, this));

          if (!this->URI_)
          {
            this->URI_.set (r);
            continue;
          }
        }

        break;
      }
    }

    NoteFlagType* NoteFlagType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NoteFlagType (*this, f, c);
    }

    NoteFlagType::
    ~NoteFlagType ()
    {
    }

    // NoteFlagSetType
    //

    NoteFlagSetType::
    NoteFlagSetType (const N_type& N)
    : ::xml_schema::type (),
      NoteFlag_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    NoteFlagSetType::
    NoteFlagSetType (const NoteFlagSetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NoteFlag_ (x.NoteFlag_, f, this),
      N_ (x.N_, f, this)
    {
    }

    NoteFlagSetType::
    NoteFlagSetType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NoteFlag_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void NoteFlagSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // NoteFlag
        //
        if (n.name () == "NoteFlag" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NoteFlag_type > r (
            NoteFlag_traits::create (i, f, this));

          this->NoteFlag_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    NoteFlagSetType* NoteFlagSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NoteFlagSetType (*this, f, c);
    }

    NoteFlagSetType::
    ~NoteFlagSetType ()
    {
    }

    // FileInternalType
    //

    FileInternalType::
    FileInternalType (const Name_type& Name)
    : ::xml_schema::type (),
      Name_ (Name, ::xml_schema::flags (), this),
      Version_ (::xml_schema::flags (), this)
    {
    }

    FileInternalType::
    FileInternalType (const FileInternalType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Name_ (x.Name_, f, this),
      Version_ (x.Version_, f, this)
    {
    }

    FileInternalType::
    FileInternalType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Name_ (f, this),
      Version_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void FileInternalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!Name_.present ())
          {
            this->Name_.set (r);
            continue;
          }
        }

        // Version
        //
        if (n.name () == "Version" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Name_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Name",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FileInternalType* FileInternalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FileInternalType (*this, f, c);
    }

    FileInternalType::
    ~FileInternalType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ProductType > r (
        ::xsd::qif2::Product (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProductType > r (
        ::xsd::qif2::Product (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProductType > r (
        ::xsd::qif2::Product (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Product (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Product (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Product (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Product (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Product (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Product (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ProductType > r (
        ::xsd::qif2::Product (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProductType > r (
        ::xsd::qif2::Product (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProductType > r (
        ::xsd::qif2::Product (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ProductType > r (
          ::xsd::qif2::Product (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Product" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ProductType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ProductType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Product",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ProductType >
    Product (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Product" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ProductType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ProductType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Product",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AsmPathsType > r (
        ::xsd::qif2::AsmPaths (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AsmPathsType > r (
        ::xsd::qif2::AsmPaths (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AsmPathsType > r (
        ::xsd::qif2::AsmPaths (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AsmPaths (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AsmPaths (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AsmPaths (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AsmPaths (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AsmPaths (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AsmPaths (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AsmPathsType > r (
        ::xsd::qif2::AsmPaths (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AsmPathsType > r (
        ::xsd::qif2::AsmPaths (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AsmPathsType > r (
        ::xsd::qif2::AsmPaths (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AsmPathsType > r (
          ::xsd::qif2::AsmPaths (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "AsmPaths" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AsmPathsType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AsmPathsType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AsmPaths",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AsmPathsType >
    AsmPaths (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "AsmPaths" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AsmPathsType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AsmPathsType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AsmPaths",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PartType > r (
        ::xsd::qif2::Part (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartType > r (
        ::xsd::qif2::Part (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartType > r (
        ::xsd::qif2::Part (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Part (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Part (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Part (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Part (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Part (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Part (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PartType > r (
        ::xsd::qif2::Part (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartType > r (
        ::xsd::qif2::Part (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartType > r (
        ::xsd::qif2::Part (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PartType > r (
          ::xsd::qif2::Part (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Part" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PartType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PartType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Part",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PartType >
    Part (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Part" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PartType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PartType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Part",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblyType > r (
        ::xsd::qif2::Assembly (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblyType > r (
        ::xsd::qif2::Assembly (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblyType > r (
        ::xsd::qif2::Assembly (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Assembly (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Assembly (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Assembly (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Assembly (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Assembly (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Assembly (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblyType > r (
        ::xsd::qif2::Assembly (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblyType > r (
        ::xsd::qif2::Assembly (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblyType > r (
        ::xsd::qif2::Assembly (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AssemblyType > r (
          ::xsd::qif2::Assembly (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Assembly" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AssemblyType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AssemblyType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Assembly",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblyType >
    Assembly (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Assembly" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AssemblyType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AssemblyType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Assembly",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PartSetType > r (
        ::xsd::qif2::PartSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartSetType > r (
        ::xsd::qif2::PartSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartSetType > r (
        ::xsd::qif2::PartSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PartSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PartSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PartSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PartSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PartSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PartSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PartSetType > r (
        ::xsd::qif2::PartSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartSetType > r (
        ::xsd::qif2::PartSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartSetType > r (
        ::xsd::qif2::PartSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PartSetType > r (
          ::xsd::qif2::PartSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PartSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PartSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PartSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PartSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PartSetType >
    PartSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PartSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PartSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PartSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PartSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblySetType > r (
        ::xsd::qif2::AssemblySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblySetType > r (
        ::xsd::qif2::AssemblySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblySetType > r (
        ::xsd::qif2::AssemblySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AssemblySet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AssemblySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AssemblySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AssemblySet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AssemblySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AssemblySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblySetType > r (
        ::xsd::qif2::AssemblySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblySetType > r (
        ::xsd::qif2::AssemblySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AssemblySetType > r (
        ::xsd::qif2::AssemblySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AssemblySetType > r (
          ::xsd::qif2::AssemblySet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "AssemblySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AssemblySetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AssemblySetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AssemblySet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AssemblySetType >
    AssemblySet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "AssemblySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AssemblySetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AssemblySetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AssemblySet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentType > r (
        ::xsd::qif2::Component (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentType > r (
        ::xsd::qif2::Component (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentType > r (
        ::xsd::qif2::Component (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Component (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Component (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Component (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Component (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Component (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Component (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentType > r (
        ::xsd::qif2::Component (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentType > r (
        ::xsd::qif2::Component (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentType > r (
        ::xsd::qif2::Component (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ComponentType > r (
          ::xsd::qif2::Component (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Component" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ComponentType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ComponentType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Component",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentType >
    Component (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Component" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ComponentType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ComponentType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Component",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentSetType > r (
        ::xsd::qif2::ComponentSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentSetType > r (
        ::xsd::qif2::ComponentSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentSetType > r (
        ::xsd::qif2::ComponentSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ComponentSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ComponentSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ComponentSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ComponentSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ComponentSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ComponentSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentSetType > r (
        ::xsd::qif2::ComponentSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentSetType > r (
        ::xsd::qif2::ComponentSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ComponentSetType > r (
        ::xsd::qif2::ComponentSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ComponentSetType > r (
          ::xsd::qif2::ComponentSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ComponentSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ComponentSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ComponentSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ComponentSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ComponentSetType >
    ComponentSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ComponentSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ComponentSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ComponentSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ComponentSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LayerType > r (
        ::xsd::qif2::Layer (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LayerType > r (
        ::xsd::qif2::Layer (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LayerType > r (
        ::xsd::qif2::Layer (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Layer (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Layer (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Layer (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Layer (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Layer (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Layer (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LayerType > r (
        ::xsd::qif2::Layer (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LayerType > r (
        ::xsd::qif2::Layer (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LayerType > r (
        ::xsd::qif2::Layer (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::LayerType > r (
          ::xsd::qif2::Layer (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Layer" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LayerType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LayerType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Layer",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LayerType >
    Layer (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Layer" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LayerType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LayerType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Layer",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LayerSetType > r (
        ::xsd::qif2::LayerSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LayerSetType > r (
        ::xsd::qif2::LayerSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LayerSetType > r (
        ::xsd::qif2::LayerSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LayerSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LayerSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LayerSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LayerSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LayerSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LayerSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LayerSetType > r (
        ::xsd::qif2::LayerSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LayerSetType > r (
        ::xsd::qif2::LayerSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LayerSetType > r (
        ::xsd::qif2::LayerSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::LayerSetType > r (
          ::xsd::qif2::LayerSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "LayerSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LayerSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LayerSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LayerSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LayerSetType >
    LayerSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "LayerSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LayerSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LayerSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LayerSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteSetType > r (
        ::xsd::qif2::PartNoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteSetType > r (
        ::xsd::qif2::PartNoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteSetType > r (
        ::xsd::qif2::PartNoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PartNoteSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PartNoteSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PartNoteSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PartNoteSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PartNoteSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PartNoteSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteSetType > r (
        ::xsd::qif2::PartNoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteSetType > r (
        ::xsd::qif2::PartNoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteSetType > r (
        ::xsd::qif2::PartNoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PartNoteSetType > r (
          ::xsd::qif2::PartNoteSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PartNoteSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PartNoteSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PartNoteSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PartNoteSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteSetType >
    PartNoteSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PartNoteSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PartNoteSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PartNoteSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PartNoteSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteType > r (
        ::xsd::qif2::PartNote (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteType > r (
        ::xsd::qif2::PartNote (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteType > r (
        ::xsd::qif2::PartNote (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PartNote (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PartNote (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PartNote (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PartNote (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PartNote (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PartNote (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteType > r (
        ::xsd::qif2::PartNote (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteType > r (
        ::xsd::qif2::PartNote (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PartNoteType > r (
        ::xsd::qif2::PartNote (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PartNoteType > r (
          ::xsd::qif2::PartNote (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PartNote" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PartNoteType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PartNoteType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PartNote",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PartNoteType >
    PartNote (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PartNote" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PartNoteType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PartNoteType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PartNote",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::NoteSetType > r (
        ::xsd::qif2::NoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteSetType > r (
        ::xsd::qif2::NoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteSetType > r (
        ::xsd::qif2::NoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::NoteSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::NoteSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::NoteSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::NoteSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::NoteSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::NoteSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::NoteSetType > r (
        ::xsd::qif2::NoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteSetType > r (
        ::xsd::qif2::NoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteSetType > r (
        ::xsd::qif2::NoteSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::NoteSetType > r (
          ::xsd::qif2::NoteSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "NoteSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::NoteSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::NoteSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "NoteSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NoteSetType >
    NoteSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "NoteSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::NoteSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::NoteSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "NoteSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::NoteType > r (
        ::xsd::qif2::Note (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteType > r (
        ::xsd::qif2::Note (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteType > r (
        ::xsd::qif2::Note (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Note (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Note (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Note (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Note (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Note (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Note (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::NoteType > r (
        ::xsd::qif2::Note (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteType > r (
        ::xsd::qif2::Note (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteType > r (
        ::xsd::qif2::Note (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::NoteType > r (
          ::xsd::qif2::Note (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Note" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::NoteType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::NoteType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Note",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NoteType >
    Note (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Note" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::NoteType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::NoteType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Note",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType > r (
        ::xsd::qif2::NoteFlagSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType > r (
        ::xsd::qif2::NoteFlagSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType > r (
        ::xsd::qif2::NoteFlagSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::NoteFlagSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::NoteFlagSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::NoteFlagSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::NoteFlagSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::NoteFlagSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::NoteFlagSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType > r (
        ::xsd::qif2::NoteFlagSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType > r (
        ::xsd::qif2::NoteFlagSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType > r (
        ::xsd::qif2::NoteFlagSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType > r (
          ::xsd::qif2::NoteFlagSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "NoteFlagSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::NoteFlagSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "NoteFlagSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType >
    NoteFlagSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "NoteFlagSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::NoteFlagSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::NoteFlagSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "NoteFlagSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagType > r (
        ::xsd::qif2::NoteFlag (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagType > r (
        ::xsd::qif2::NoteFlag (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagType > r (
        ::xsd::qif2::NoteFlag (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::NoteFlag (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::NoteFlag (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::NoteFlag (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::NoteFlag (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::NoteFlag (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::NoteFlag (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagType > r (
        ::xsd::qif2::NoteFlag (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagType > r (
        ::xsd::qif2::NoteFlag (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::NoteFlagType > r (
        ::xsd::qif2::NoteFlag (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::NoteFlagType > r (
          ::xsd::qif2::NoteFlag (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "NoteFlag" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::NoteFlagType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::NoteFlagType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "NoteFlag",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::NoteFlagType >
    NoteFlag (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "NoteFlag" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::NoteFlagType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::NoteFlagType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "NoteFlag",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

