// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "QIFRules.hxx"

namespace xsd
{
  namespace qif2
  {
    // QIFRulesType
    // 

    const QIFRulesType::Version_optional& QIFRulesType::
    Version () const
    {
      return this->Version_;
    }

    QIFRulesType::Version_optional& QIFRulesType::
    Version ()
    {
      return this->Version_;
    }

    void QIFRulesType::
    Version (const Version_type& x)
    {
      this->Version_.set (x);
    }

    void QIFRulesType::
    Version (const Version_optional& x)
    {
      this->Version_ = x;
    }

    void QIFRulesType::
    Version (::std::auto_ptr< Version_type > x)
    {
      this->Version_.set (x);
    }

    const QIFRulesType::RulesUnits_optional& QIFRulesType::
    RulesUnits () const
    {
      return this->RulesUnits_;
    }

    QIFRulesType::RulesUnits_optional& QIFRulesType::
    RulesUnits ()
    {
      return this->RulesUnits_;
    }

    void QIFRulesType::
    RulesUnits (const RulesUnits_type& x)
    {
      this->RulesUnits_.set (x);
    }

    void QIFRulesType::
    RulesUnits (const RulesUnits_optional& x)
    {
      this->RulesUnits_ = x;
    }

    void QIFRulesType::
    RulesUnits (::std::auto_ptr< RulesUnits_type > x)
    {
      this->RulesUnits_.set (x);
    }

    const QIFRulesType::FeatureRules_optional& QIFRulesType::
    FeatureRules () const
    {
      return this->FeatureRules_;
    }

    QIFRulesType::FeatureRules_optional& QIFRulesType::
    FeatureRules ()
    {
      return this->FeatureRules_;
    }

    void QIFRulesType::
    FeatureRules (const FeatureRules_type& x)
    {
      this->FeatureRules_.set (x);
    }

    void QIFRulesType::
    FeatureRules (const FeatureRules_optional& x)
    {
      this->FeatureRules_ = x;
    }

    void QIFRulesType::
    FeatureRules (::std::auto_ptr< FeatureRules_type > x)
    {
      this->FeatureRules_.set (x);
    }

    const QIFRulesType::DMESelectionRules_optional& QIFRulesType::
    DMESelectionRules () const
    {
      return this->DMESelectionRules_;
    }

    QIFRulesType::DMESelectionRules_optional& QIFRulesType::
    DMESelectionRules ()
    {
      return this->DMESelectionRules_;
    }

    void QIFRulesType::
    DMESelectionRules (const DMESelectionRules_type& x)
    {
      this->DMESelectionRules_.set (x);
    }

    void QIFRulesType::
    DMESelectionRules (const DMESelectionRules_optional& x)
    {
      this->DMESelectionRules_ = x;
    }

    void QIFRulesType::
    DMESelectionRules (::std::auto_ptr< DMESelectionRules_type > x)
    {
      this->DMESelectionRules_.set (x);
    }


    // FeatureRulesType
    // 

    const FeatureRulesType::SamplingRigorMax_type& FeatureRulesType::
    SamplingRigorMax () const
    {
      return this->SamplingRigorMax_.get ();
    }

    FeatureRulesType::SamplingRigorMax_type& FeatureRulesType::
    SamplingRigorMax ()
    {
      return this->SamplingRigorMax_.get ();
    }

    void FeatureRulesType::
    SamplingRigorMax (const SamplingRigorMax_type& x)
    {
      this->SamplingRigorMax_.set (x);
    }

    const FeatureRulesType::IfThenElseFeatureRules_optional& FeatureRulesType::
    IfThenElseFeatureRules () const
    {
      return this->IfThenElseFeatureRules_;
    }

    FeatureRulesType::IfThenElseFeatureRules_optional& FeatureRulesType::
    IfThenElseFeatureRules ()
    {
      return this->IfThenElseFeatureRules_;
    }

    void FeatureRulesType::
    IfThenElseFeatureRules (const IfThenElseFeatureRules_type& x)
    {
      this->IfThenElseFeatureRules_.set (x);
    }

    void FeatureRulesType::
    IfThenElseFeatureRules (const IfThenElseFeatureRules_optional& x)
    {
      this->IfThenElseFeatureRules_ = x;
    }

    void FeatureRulesType::
    IfThenElseFeatureRules (::std::auto_ptr< IfThenElseFeatureRules_type > x)
    {
      this->IfThenElseFeatureRules_.set (x);
    }

    const FeatureRulesType::MaxFeatureRules_optional& FeatureRulesType::
    MaxFeatureRules () const
    {
      return this->MaxFeatureRules_;
    }

    FeatureRulesType::MaxFeatureRules_optional& FeatureRulesType::
    MaxFeatureRules ()
    {
      return this->MaxFeatureRules_;
    }

    void FeatureRulesType::
    MaxFeatureRules (const MaxFeatureRules_type& x)
    {
      this->MaxFeatureRules_.set (x);
    }

    void FeatureRulesType::
    MaxFeatureRules (const MaxFeatureRules_optional& x)
    {
      this->MaxFeatureRules_ = x;
    }

    void FeatureRulesType::
    MaxFeatureRules (::std::auto_ptr< MaxFeatureRules_type > x)
    {
      this->MaxFeatureRules_.set (x);
    }


    // QIFRuleBaseType
    // 

    const QIFRuleBaseType::name_optional& QIFRuleBaseType::
    name () const
    {
      return this->name_;
    }

    QIFRuleBaseType::name_optional& QIFRuleBaseType::
    name ()
    {
      return this->name_;
    }

    void QIFRuleBaseType::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void QIFRuleBaseType::
    name (const name_optional& x)
    {
      this->name_ = x;
    }

    void QIFRuleBaseType::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }


    // IfThenElseFeatureRulesType
    // 

    const IfThenElseFeatureRulesType::IfThenFeatureRule_sequence& IfThenElseFeatureRulesType::
    IfThenFeatureRule () const
    {
      return this->IfThenFeatureRule_;
    }

    IfThenElseFeatureRulesType::IfThenFeatureRule_sequence& IfThenElseFeatureRulesType::
    IfThenFeatureRule ()
    {
      return this->IfThenFeatureRule_;
    }

    void IfThenElseFeatureRulesType::
    IfThenFeatureRule (const IfThenFeatureRule_sequence& s)
    {
      this->IfThenFeatureRule_ = s;
    }

    const IfThenElseFeatureRulesType::Else_optional& IfThenElseFeatureRulesType::
    Else () const
    {
      return this->Else_;
    }

    IfThenElseFeatureRulesType::Else_optional& IfThenElseFeatureRulesType::
    Else ()
    {
      return this->Else_;
    }

    void IfThenElseFeatureRulesType::
    Else (const Else_type& x)
    {
      this->Else_.set (x);
    }

    void IfThenElseFeatureRulesType::
    Else (const Else_optional& x)
    {
      this->Else_ = x;
    }

    void IfThenElseFeatureRulesType::
    Else (::std::auto_ptr< Else_type > x)
    {
      this->Else_.set (x);
    }


    // MaxFeatureRulesType
    // 

    const MaxFeatureRulesType::IfThenFeatureRule_sequence& MaxFeatureRulesType::
    IfThenFeatureRule () const
    {
      return this->IfThenFeatureRule_;
    }

    MaxFeatureRulesType::IfThenFeatureRule_sequence& MaxFeatureRulesType::
    IfThenFeatureRule ()
    {
      return this->IfThenFeatureRule_;
    }

    void MaxFeatureRulesType::
    IfThenFeatureRule (const IfThenFeatureRule_sequence& s)
    {
      this->IfThenFeatureRule_ = s;
    }

    const MaxFeatureRulesType::Else_optional& MaxFeatureRulesType::
    Else () const
    {
      return this->Else_;
    }

    MaxFeatureRulesType::Else_optional& MaxFeatureRulesType::
    Else ()
    {
      return this->Else_;
    }

    void MaxFeatureRulesType::
    Else (const Else_type& x)
    {
      this->Else_.set (x);
    }

    void MaxFeatureRulesType::
    Else (const Else_optional& x)
    {
      this->Else_ = x;
    }

    void MaxFeatureRulesType::
    Else (::std::auto_ptr< Else_type > x)
    {
      this->Else_.set (x);
    }


    // DMESelectionRulesType
    // 

    const DMESelectionRulesType::DMESelectionRule_sequence& DMESelectionRulesType::
    DMESelectionRule () const
    {
      return this->DMESelectionRule_;
    }

    DMESelectionRulesType::DMESelectionRule_sequence& DMESelectionRulesType::
    DMESelectionRule ()
    {
      return this->DMESelectionRule_;
    }

    void DMESelectionRulesType::
    DMESelectionRule (const DMESelectionRule_sequence& s)
    {
      this->DMESelectionRule_ = s;
    }


    // PointRuleBaseType
    // 


    // IfThenFeatureRuleType
    // 

    const IfThenFeatureRuleType::BooleanExpression_optional& IfThenFeatureRuleType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    IfThenFeatureRuleType::BooleanExpression_optional& IfThenFeatureRuleType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void IfThenFeatureRuleType::
    BooleanExpression (const BooleanExpression_type& x)
    {
      this->BooleanExpression_.set (x);
    }

    void IfThenFeatureRuleType::
    BooleanExpression (const BooleanExpression_optional& x)
    {
      this->BooleanExpression_ = x;
    }

    void IfThenFeatureRuleType::
    BooleanExpression (::std::auto_ptr< BooleanExpression_type > x)
    {
      this->BooleanExpression_.set (x);
    }

    const IfThenFeatureRuleType::ThenPoints_optional& IfThenFeatureRuleType::
    ThenPoints () const
    {
      return this->ThenPoints_;
    }

    IfThenFeatureRuleType::ThenPoints_optional& IfThenFeatureRuleType::
    ThenPoints ()
    {
      return this->ThenPoints_;
    }

    void IfThenFeatureRuleType::
    ThenPoints (const ThenPoints_type& x)
    {
      this->ThenPoints_.set (x);
    }

    void IfThenFeatureRuleType::
    ThenPoints (const ThenPoints_optional& x)
    {
      this->ThenPoints_ = x;
    }

    void IfThenFeatureRuleType::
    ThenPoints (::std::auto_ptr< ThenPoints_type > x)
    {
      this->ThenPoints_.set (x);
    }


    // ElseRuleType
    // 

    const ElseRuleType::ThenPoints_type& ElseRuleType::
    ThenPoints () const
    {
      return this->ThenPoints_.get ();
    }

    ElseRuleType::ThenPoints_type& ElseRuleType::
    ThenPoints ()
    {
      return this->ThenPoints_.get ();
    }

    void ElseRuleType::
    ThenPoints (const ThenPoints_type& x)
    {
      this->ThenPoints_.set (x);
    }

    void ElseRuleType::
    ThenPoints (::std::auto_ptr< ThenPoints_type > x)
    {
      this->ThenPoints_.set (x);
    }


    // ThenPointsType
    // 

    const ThenPointsType::NumberOfPoints_optional& ThenPointsType::
    NumberOfPoints () const
    {
      return this->NumberOfPoints_;
    }

    ThenPointsType::NumberOfPoints_optional& ThenPointsType::
    NumberOfPoints ()
    {
      return this->NumberOfPoints_;
    }

    void ThenPointsType::
    NumberOfPoints (const NumberOfPoints_type& x)
    {
      this->NumberOfPoints_.set (x);
    }

    void ThenPointsType::
    NumberOfPoints (const NumberOfPoints_optional& x)
    {
      this->NumberOfPoints_ = x;
    }

    const ThenPointsType::MinPoints_optional& ThenPointsType::
    MinPoints () const
    {
      return this->MinPoints_;
    }

    ThenPointsType::MinPoints_optional& ThenPointsType::
    MinPoints ()
    {
      return this->MinPoints_;
    }

    void ThenPointsType::
    MinPoints (const MinPoints_type& x)
    {
      this->MinPoints_.set (x);
    }

    void ThenPointsType::
    MinPoints (const MinPoints_optional& x)
    {
      this->MinPoints_ = x;
    }

    const ThenPointsType::PointDensity_optional& ThenPointsType::
    PointDensity () const
    {
      return this->PointDensity_;
    }

    ThenPointsType::PointDensity_optional& ThenPointsType::
    PointDensity ()
    {
      return this->PointDensity_;
    }

    void ThenPointsType::
    PointDensity (const PointDensity_type& x)
    {
      this->PointDensity_.set (x);
    }

    void ThenPointsType::
    PointDensity (const PointDensity_optional& x)
    {
      this->PointDensity_ = x;
    }

    void ThenPointsType::
    PointDensity (::std::auto_ptr< PointDensity_type > x)
    {
      this->PointDensity_.set (x);
    }

    const ThenPointsType::MinPointDensity_optional& ThenPointsType::
    MinPointDensity () const
    {
      return this->MinPointDensity_;
    }

    ThenPointsType::MinPointDensity_optional& ThenPointsType::
    MinPointDensity ()
    {
      return this->MinPointDensity_;
    }

    void ThenPointsType::
    MinPointDensity (const MinPointDensity_type& x)
    {
      this->MinPointDensity_.set (x);
    }

    void ThenPointsType::
    MinPointDensity (const MinPointDensity_optional& x)
    {
      this->MinPointDensity_ = x;
    }

    void ThenPointsType::
    MinPointDensity (::std::auto_ptr< MinPointDensity_type > x)
    {
      this->MinPointDensity_.set (x);
    }


    // IfThenArcRuleType
    // 

    const IfThenArcRuleType::ThenPointStrategy_optional& IfThenArcRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenArcRuleType::ThenPointStrategy_optional& IfThenArcRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenArcRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenArcRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenArcRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenArcRuleType::ThenFittingAlgorithm_optional& IfThenArcRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenArcRuleType::ThenFittingAlgorithm_optional& IfThenArcRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenArcRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenArcRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenArcRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ArcPointSamplingStrategyType
    // 

    const ArcPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ArcPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ArcPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ArcPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ArcPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ArcPointSamplingStrategyType::UserDefinedStrategy_optional& ArcPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ArcPointSamplingStrategyType::UserDefinedStrategy_optional& ArcPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ArcPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ArcPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ArcPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenCircleRuleType
    // 

    const IfThenCircleRuleType::ThenPointStrategy_optional& IfThenCircleRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCircleRuleType::ThenPointStrategy_optional& IfThenCircleRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCircleRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCircleRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCircleRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenCircleRuleType::ThenFittingAlgorithm_optional& IfThenCircleRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCircleRuleType::ThenFittingAlgorithm_optional& IfThenCircleRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCircleRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCircleRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCircleRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // CirclePointSamplingStrategyType
    // 

    const CirclePointSamplingStrategyType::PointSamplingStrategyEnum_optional& CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CirclePointSamplingStrategyType::PointSamplingStrategyEnum_optional& CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CirclePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const CirclePointSamplingStrategyType::UserDefinedStrategy_optional& CirclePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CirclePointSamplingStrategyType::UserDefinedStrategy_optional& CirclePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CirclePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CirclePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CirclePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenConeRuleType
    // 

    const IfThenConeRuleType::ThenPointStrategy_optional& IfThenConeRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenConeRuleType::ThenPointStrategy_optional& IfThenConeRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenConeRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenConeRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenConeRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenConeRuleType::ThenFittingAlgorithm_optional& IfThenConeRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenConeRuleType::ThenFittingAlgorithm_optional& IfThenConeRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenConeRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenConeRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenConeRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ConePointSamplingStrategyType
    // 

    const ConePointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ConePointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ConePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ConePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ConePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ConePointSamplingStrategyType::UserDefinedStrategy_optional& ConePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ConePointSamplingStrategyType::UserDefinedStrategy_optional& ConePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ConePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ConePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ConePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenConicalSegmentRuleType
    // 

    const IfThenConicalSegmentRuleType::ThenPointStrategy_optional& IfThenConicalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenConicalSegmentRuleType::ThenPointStrategy_optional& IfThenConicalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenConicalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenConicalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenConicalSegmentRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenConicalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenConicalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenConicalSegmentRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ConicalSegmentPointSamplingStrategyType
    // 

    const ConicalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ConicalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ConicalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ConicalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ConicalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ConicalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenCuboidRuleType
    // 

    const IfThenCuboidRuleType::ThenPointStrategy_optional& IfThenCuboidRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCuboidRuleType::ThenPointStrategy_optional& IfThenCuboidRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCuboidRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCuboidRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCuboidRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenCuboidRuleType::ThenFittingAlgorithm_optional& IfThenCuboidRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCuboidRuleType::ThenFittingAlgorithm_optional& IfThenCuboidRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCuboidRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCuboidRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCuboidRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // CuboidPointSamplingStrategyType
    // 

    const CuboidPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CuboidPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CuboidPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CuboidPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CuboidPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CuboidPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CuboidPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const CuboidPointSamplingStrategyType::UserDefinedStrategy_optional& CuboidPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CuboidPointSamplingStrategyType::UserDefinedStrategy_optional& CuboidPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CuboidPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CuboidPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CuboidPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenCylinderRuleType
    // 

    const IfThenCylinderRuleType::ThenPointStrategy_optional& IfThenCylinderRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCylinderRuleType::ThenPointStrategy_optional& IfThenCylinderRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCylinderRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenCylinderRuleType::ThenFittingAlgorithm_optional& IfThenCylinderRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCylinderRuleType::ThenFittingAlgorithm_optional& IfThenCylinderRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCylinderRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // CylinderPointSamplingStrategyType
    // 

    const CylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const CylinderPointSamplingStrategyType::UserDefinedStrategy_optional& CylinderPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CylinderPointSamplingStrategyType::UserDefinedStrategy_optional& CylinderPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CylinderPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenCylindricalSegmentRuleType
    // 

    const IfThenCylindricalSegmentRuleType::ThenPointStrategy_optional& IfThenCylindricalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenCylindricalSegmentRuleType::ThenPointStrategy_optional& IfThenCylindricalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenCylindricalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenCylindricalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenCylindricalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenCylindricalSegmentRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // CylindricalSegmentPointSamplingStrategyType
    // 

    const CylindricalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    CylindricalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const CylindricalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    CylindricalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void CylindricalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenEllipseRuleType
    // 

    const IfThenEllipseRuleType::ThenPointStrategy_optional& IfThenEllipseRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenEllipseRuleType::ThenPointStrategy_optional& IfThenEllipseRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenEllipseRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenEllipseRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenEllipseRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenEllipseRuleType::ThenFittingAlgorithm_optional& IfThenEllipseRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenEllipseRuleType::ThenFittingAlgorithm_optional& IfThenEllipseRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenEllipseRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenEllipseRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenEllipseRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // EllipsePointSamplingStrategyType
    // 

    const EllipsePointSamplingStrategyType::PointSamplingStrategyEnum_optional& EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    EllipsePointSamplingStrategyType::PointSamplingStrategyEnum_optional& EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void EllipsePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const EllipsePointSamplingStrategyType::UserDefinedStrategy_optional& EllipsePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    EllipsePointSamplingStrategyType::UserDefinedStrategy_optional& EllipsePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void EllipsePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void EllipsePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void EllipsePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenElongatedCylinderRuleType
    // 

    const IfThenElongatedCylinderRuleType::ThenPointStrategy_optional& IfThenElongatedCylinderRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenElongatedCylinderRuleType::ThenPointStrategy_optional& IfThenElongatedCylinderRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenElongatedCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenElongatedCylinderRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenElongatedCylinderRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenElongatedCylinderRuleType::ThenFittingAlgorithm_optional& IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenElongatedCylinderRuleType::ThenFittingAlgorithm_optional& IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenElongatedCylinderRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ElongatedCylinderPointSamplingStrategyType
    // 

    const ElongatedCylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ElongatedCylinderPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ElongatedCylinderPointSamplingStrategyType::UserDefinedStrategy_optional& ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ElongatedCylinderPointSamplingStrategyType::UserDefinedStrategy_optional& ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ElongatedCylinderPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenExtrudedCrossSectionRuleType
    // 

    const IfThenExtrudedCrossSectionRuleType::ThenPointStrategy_optional& IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenExtrudedCrossSectionRuleType::ThenPointStrategy_optional& IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenExtrudedCrossSectionRuleType::ThenFittingAlgorithm_optional& IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenExtrudedCrossSectionRuleType::ThenFittingAlgorithm_optional& IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenExtrudedCrossSectionRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ExtrudedCrossSectionPointSamplingStrategyType
    // 

    const ExtrudedCrossSectionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ExtrudedCrossSectionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ExtrudedCrossSectionPointSamplingStrategyType::UserDefinedStrategy_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ExtrudedCrossSectionPointSamplingStrategyType::UserDefinedStrategy_optional& ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenLineRuleType
    // 

    const IfThenLineRuleType::ThenPointStrategy_optional& IfThenLineRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenLineRuleType::ThenPointStrategy_optional& IfThenLineRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenLineRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenLineRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenLineRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenLineRuleType::ThenFittingAlgorithm_optional& IfThenLineRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenLineRuleType::ThenFittingAlgorithm_optional& IfThenLineRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenLineRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenLineRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenLineRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // LinePointSamplingStrategyType
    // 

    const LinePointSamplingStrategyType::PointSamplingStrategyEnum_optional& LinePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    LinePointSamplingStrategyType::PointSamplingStrategyEnum_optional& LinePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void LinePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void LinePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void LinePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const LinePointSamplingStrategyType::UserDefinedStrategy_optional& LinePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    LinePointSamplingStrategyType::UserDefinedStrategy_optional& LinePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void LinePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void LinePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void LinePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenOppositeLinesRuleType
    // 

    const IfThenOppositeLinesRuleType::ThenPointStrategy_optional& IfThenOppositeLinesRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenOppositeLinesRuleType::ThenPointStrategy_optional& IfThenOppositeLinesRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenOppositeLinesRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenOppositeLinesRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenOppositeLinesRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenOppositeLinesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeLinesRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenOppositeLinesRuleType::ThenFittingAlgorithm_optional& IfThenOppositeLinesRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenOppositeLinesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenOppositeLinesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenOppositeLinesRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // OppositeLinesPointSamplingStrategyType
    // 

    const OppositeLinesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    OppositeLinesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositeLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void OppositeLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void OppositeLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void OppositeLinesPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const OppositeLinesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeLinesPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    OppositeLinesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositeLinesPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void OppositeLinesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void OppositeLinesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void OppositeLinesPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenOppositePlanesRuleType
    // 

    const IfThenOppositePlanesRuleType::ThenPointStrategy_optional& IfThenOppositePlanesRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenOppositePlanesRuleType::ThenPointStrategy_optional& IfThenOppositePlanesRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenOppositePlanesRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenOppositePlanesRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenOppositePlanesRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenOppositePlanesRuleType::ThenFittingAlgorithm_optional& IfThenOppositePlanesRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenOppositePlanesRuleType::ThenFittingAlgorithm_optional& IfThenOppositePlanesRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenOppositePlanesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenOppositePlanesRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenOppositePlanesRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // OppositePlanesPointSamplingStrategyType
    // 

    const OppositePlanesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositePlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    OppositePlanesPointSamplingStrategyType::PointSamplingStrategyEnum_optional& OppositePlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void OppositePlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void OppositePlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void OppositePlanesPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const OppositePlanesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositePlanesPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    OppositePlanesPointSamplingStrategyType::UserDefinedStrategy_optional& OppositePlanesPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void OppositePlanesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void OppositePlanesPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void OppositePlanesPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenPlaneRuleType
    // 

    const IfThenPlaneRuleType::ThenPointStrategy_optional& IfThenPlaneRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPlaneRuleType::ThenPointStrategy_optional& IfThenPlaneRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPlaneRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPlaneRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPlaneRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenPlaneRuleType::ThenFittingAlgorithm_optional& IfThenPlaneRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenPlaneRuleType::ThenFittingAlgorithm_optional& IfThenPlaneRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenPlaneRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenPlaneRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenPlaneRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // PlanePointSamplingStrategyType
    // 

    const PlanePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PlanePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PlanePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const PlanePointSamplingStrategyType::UserDefinedStrategy_optional& PlanePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PlanePointSamplingStrategyType::UserDefinedStrategy_optional& PlanePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PlanePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PlanePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PlanePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenPointDefinedCurveRuleType
    // 

    const IfThenPointDefinedCurveRuleType::ThenPointStrategy_optional& IfThenPointDefinedCurveRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPointDefinedCurveRuleType::ThenPointStrategy_optional& IfThenPointDefinedCurveRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPointDefinedCurveRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenPointDefinedCurveRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenPointDefinedCurveRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenPointDefinedCurveRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // PointDefinedCurvePointSamplingStrategyType
    // 

    const PointDefinedCurvePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PointDefinedCurvePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const PointDefinedCurvePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PointDefinedCurvePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PointDefinedCurvePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenPointDefinedSurfaceRuleType
    // 

    const IfThenPointDefinedSurfaceRuleType::ThenPointStrategy_optional& IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPointDefinedSurfaceRuleType::ThenPointStrategy_optional& IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenPointDefinedSurfaceRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenPointDefinedSurfaceRuleType::ThenFittingAlgorithm_optional& IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenPointDefinedSurfaceRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // PointDefinedSurfacePointSamplingStrategyType
    // 

    const PointDefinedSurfacePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PointDefinedSurfacePointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const PointDefinedSurfacePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PointDefinedSurfacePointSamplingStrategyType::UserDefinedStrategy_optional& PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenPointRuleType
    // 

    const IfThenPointRuleType::ThenPointStrategy_optional& IfThenPointRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenPointRuleType::ThenPointStrategy_optional& IfThenPointRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenPointRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenPointRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenPointRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }


    // PointPointSamplingStrategyType
    // 

    const PointPointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    PointPointSamplingStrategyType::PointSamplingStrategyEnum_optional& PointPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void PointPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void PointPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void PointPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const PointPointSamplingStrategyType::UserDefinedStrategy_optional& PointPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    PointPointSamplingStrategyType::UserDefinedStrategy_optional& PointPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void PointPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void PointPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void PointPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenSphereRuleType
    // 

    const IfThenSphereRuleType::ThenPointStrategy_optional& IfThenSphereRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenSphereRuleType::ThenPointStrategy_optional& IfThenSphereRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenSphereRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenSphereRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenSphereRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenSphereRuleType::ThenFittingAlgorithm_optional& IfThenSphereRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenSphereRuleType::ThenFittingAlgorithm_optional& IfThenSphereRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenSphereRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenSphereRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenSphereRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // SpherePointSamplingStrategyType
    // 

    const SpherePointSamplingStrategyType::PointSamplingStrategyEnum_optional& SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    SpherePointSamplingStrategyType::PointSamplingStrategyEnum_optional& SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void SpherePointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const SpherePointSamplingStrategyType::UserDefinedStrategy_optional& SpherePointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    SpherePointSamplingStrategyType::UserDefinedStrategy_optional& SpherePointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void SpherePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void SpherePointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void SpherePointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenSphericalSegmentRuleType
    // 

    const IfThenSphericalSegmentRuleType::ThenPointStrategy_optional& IfThenSphericalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenSphericalSegmentRuleType::ThenPointStrategy_optional& IfThenSphericalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenSphericalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenSphericalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenSphericalSegmentRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenSphericalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenSphericalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenSphericalSegmentRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // SphericalSegmentPointSamplingStrategyType
    // 

    const SphericalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    SphericalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void SphericalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const SphericalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    SphericalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void SphericalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenSurfaceOfRevolutionRuleType
    // 

    const IfThenSurfaceOfRevolutionRuleType::ThenPointStrategy_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenSurfaceOfRevolutionRuleType::ThenPointStrategy_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenSurfaceOfRevolutionRuleType::ThenFittingAlgorithm_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenSurfaceOfRevolutionRuleType::ThenFittingAlgorithm_optional& IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenSurfaceOfRevolutionRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // SurfaceOfRevolutionPointSamplingStrategyType
    // 

    const SurfaceOfRevolutionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    SurfaceOfRevolutionPointSamplingStrategyType::PointSamplingStrategyEnum_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const SurfaceOfRevolutionPointSamplingStrategyType::UserDefinedStrategy_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    SurfaceOfRevolutionPointSamplingStrategyType::UserDefinedStrategy_optional& SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenToroidalSegmentRuleType
    // 

    const IfThenToroidalSegmentRuleType::ThenPointStrategy_optional& IfThenToroidalSegmentRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenToroidalSegmentRuleType::ThenPointStrategy_optional& IfThenToroidalSegmentRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenToroidalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenToroidalSegmentRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenToroidalSegmentRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenToroidalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenToroidalSegmentRuleType::ThenFittingAlgorithm_optional& IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenToroidalSegmentRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // ToroidalSegmentPointSamplingStrategyType
    // 

    const ToroidalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    ToroidalSegmentPointSamplingStrategyType::PointSamplingStrategyEnum_optional& ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const ToroidalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    ToroidalSegmentPointSamplingStrategyType::UserDefinedStrategy_optional& ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void ToroidalSegmentPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenTorusRuleType
    // 

    const IfThenTorusRuleType::ThenPointStrategy_optional& IfThenTorusRuleType::
    ThenPointStrategy () const
    {
      return this->ThenPointStrategy_;
    }

    IfThenTorusRuleType::ThenPointStrategy_optional& IfThenTorusRuleType::
    ThenPointStrategy ()
    {
      return this->ThenPointStrategy_;
    }

    void IfThenTorusRuleType::
    ThenPointStrategy (const ThenPointStrategy_type& x)
    {
      this->ThenPointStrategy_.set (x);
    }

    void IfThenTorusRuleType::
    ThenPointStrategy (const ThenPointStrategy_optional& x)
    {
      this->ThenPointStrategy_ = x;
    }

    void IfThenTorusRuleType::
    ThenPointStrategy (::std::auto_ptr< ThenPointStrategy_type > x)
    {
      this->ThenPointStrategy_.set (x);
    }

    const IfThenTorusRuleType::ThenFittingAlgorithm_optional& IfThenTorusRuleType::
    ThenFittingAlgorithm () const
    {
      return this->ThenFittingAlgorithm_;
    }

    IfThenTorusRuleType::ThenFittingAlgorithm_optional& IfThenTorusRuleType::
    ThenFittingAlgorithm ()
    {
      return this->ThenFittingAlgorithm_;
    }

    void IfThenTorusRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_type& x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }

    void IfThenTorusRuleType::
    ThenFittingAlgorithm (const ThenFittingAlgorithm_optional& x)
    {
      this->ThenFittingAlgorithm_ = x;
    }

    void IfThenTorusRuleType::
    ThenFittingAlgorithm (::std::auto_ptr< ThenFittingAlgorithm_type > x)
    {
      this->ThenFittingAlgorithm_.set (x);
    }


    // TorusPointSamplingStrategyType
    // 

    const TorusPointSamplingStrategyType::PointSamplingStrategyEnum_optional& TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum () const
    {
      return this->PointSamplingStrategyEnum_;
    }

    TorusPointSamplingStrategyType::PointSamplingStrategyEnum_optional& TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum ()
    {
      return this->PointSamplingStrategyEnum_;
    }

    void TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_type& x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    void TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum (const PointSamplingStrategyEnum_optional& x)
    {
      this->PointSamplingStrategyEnum_ = x;
    }

    void TorusPointSamplingStrategyType::
    PointSamplingStrategyEnum (::std::auto_ptr< PointSamplingStrategyEnum_type > x)
    {
      this->PointSamplingStrategyEnum_.set (x);
    }

    const TorusPointSamplingStrategyType::UserDefinedStrategy_optional& TorusPointSamplingStrategyType::
    UserDefinedStrategy () const
    {
      return this->UserDefinedStrategy_;
    }

    TorusPointSamplingStrategyType::UserDefinedStrategy_optional& TorusPointSamplingStrategyType::
    UserDefinedStrategy ()
    {
      return this->UserDefinedStrategy_;
    }

    void TorusPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_type& x)
    {
      this->UserDefinedStrategy_.set (x);
    }

    void TorusPointSamplingStrategyType::
    UserDefinedStrategy (const UserDefinedStrategy_optional& x)
    {
      this->UserDefinedStrategy_ = x;
    }

    void TorusPointSamplingStrategyType::
    UserDefinedStrategy (::std::auto_ptr< UserDefinedStrategy_type > x)
    {
      this->UserDefinedStrategy_.set (x);
    }


    // IfThenSurfaceRuleType
    // 


    // IfThenCurveRuleType
    // 


    // DMESelectionRuleType
    // 
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace xsd
{
  namespace qif2
  {
    // QIFRulesType
    //

    QIFRulesType::
    QIFRulesType ()
    : ::xml_schema::type (),
      Version_ (::xml_schema::flags (), this),
      RulesUnits_ (::xml_schema::flags (), this),
      FeatureRules_ (::xml_schema::flags (), this),
      DMESelectionRules_ (::xml_schema::flags (), this)
    {
    }

    QIFRulesType::
    QIFRulesType (const QIFRulesType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Version_ (x.Version_, f, this),
      RulesUnits_ (x.RulesUnits_, f, this),
      FeatureRules_ (x.FeatureRules_, f, this),
      DMESelectionRules_ (x.DMESelectionRules_, f, this)
    {
    }

    QIFRulesType::
    QIFRulesType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Version_ (f, this),
      RulesUnits_ (f, this),
      FeatureRules_ (f, this),
      DMESelectionRules_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void QIFRulesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Version
        //
        if (n.name () == "Version" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Version_type > r (
            Version_traits::create (i, f, this));

          if (!this->Version_)
          {
            this->Version_.set (r);
            continue;
          }
        }

        // RulesUnits
        //
        if (n.name () == "RulesUnits" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RulesUnits_type > r (
            RulesUnits_traits::create (i, f, this));

          if (!this->RulesUnits_)
          {
            this->RulesUnits_.set (r);
            continue;
          }
        }

        // FeatureRules
        //
        if (n.name () == "FeatureRules" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureRules_type > r (
            FeatureRules_traits::create (i, f, this));

          if (!this->FeatureRules_)
          {
            this->FeatureRules_.set (r);
            continue;
          }
        }

        // DMESelectionRules
        //
        if (n.name () == "DMESelectionRules" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DMESelectionRules_type > r (
            DMESelectionRules_traits::create (i, f, this));

          if (!this->DMESelectionRules_)
          {
            this->DMESelectionRules_.set (r);
            continue;
          }
        }

        break;
      }
    }

    QIFRulesType* QIFRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFRulesType (*this, f, c);
    }

    QIFRulesType::
    ~QIFRulesType ()
    {
    }

    // FeatureRulesType
    //

    FeatureRulesType::
    FeatureRulesType (const SamplingRigorMax_type& SamplingRigorMax)
    : ::xml_schema::type (),
      SamplingRigorMax_ (SamplingRigorMax, ::xml_schema::flags (), this),
      IfThenElseFeatureRules_ (::xml_schema::flags (), this),
      MaxFeatureRules_ (::xml_schema::flags (), this)
    {
    }

    FeatureRulesType::
    FeatureRulesType (const FeatureRulesType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SamplingRigorMax_ (x.SamplingRigorMax_, f, this),
      IfThenElseFeatureRules_ (x.IfThenElseFeatureRules_, f, this),
      MaxFeatureRules_ (x.MaxFeatureRules_, f, this)
    {
    }

    FeatureRulesType::
    FeatureRulesType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SamplingRigorMax_ (f, this),
      IfThenElseFeatureRules_ (f, this),
      MaxFeatureRules_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void FeatureRulesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SamplingRigorMax
        //
        if (n.name () == "SamplingRigorMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!SamplingRigorMax_.present ())
          {
            this->SamplingRigorMax_.set (SamplingRigorMax_traits::create (i, f, this));
            continue;
          }
        }

        // IfThenElseFeatureRules
        //
        if (n.name () == "IfThenElseFeatureRules" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IfThenElseFeatureRules_type > r (
            IfThenElseFeatureRules_traits::create (i, f, this));

          if (!this->IfThenElseFeatureRules_)
          {
            this->IfThenElseFeatureRules_.set (r);
            continue;
          }
        }

        // MaxFeatureRules
        //
        if (n.name () == "MaxFeatureRules" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MaxFeatureRules_type > r (
            MaxFeatureRules_traits::create (i, f, this));

          if (!this->MaxFeatureRules_)
          {
            this->MaxFeatureRules_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SamplingRigorMax_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SamplingRigorMax",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FeatureRulesType* FeatureRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureRulesType (*this, f, c);
    }

    FeatureRulesType::
    ~FeatureRulesType ()
    {
    }

    // QIFRuleBaseType
    //

    QIFRuleBaseType::
    QIFRuleBaseType ()
    : ::xml_schema::type (),
      name_ (::xml_schema::flags (), this)
    {
    }

    QIFRuleBaseType::
    QIFRuleBaseType (const QIFRuleBaseType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this)
    {
    }

    QIFRuleBaseType::
    QIFRuleBaseType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void QIFRuleBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          this->name_.set (r);
          continue;
        }
      }
    }

    QIFRuleBaseType* QIFRuleBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFRuleBaseType (*this, f, c);
    }

    QIFRuleBaseType::
    ~QIFRuleBaseType ()
    {
    }

    // IfThenElseFeatureRulesType
    //

    IfThenElseFeatureRulesType::
    IfThenElseFeatureRulesType ()
    : ::xml_schema::type (),
      IfThenFeatureRule_ (::xml_schema::flags (), this),
      Else_ (::xml_schema::flags (), this)
    {
    }

    IfThenElseFeatureRulesType::
    IfThenElseFeatureRulesType (const IfThenElseFeatureRulesType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IfThenFeatureRule_ (x.IfThenFeatureRule_, f, this),
      Else_ (x.Else_, f, this)
    {
    }

    IfThenElseFeatureRulesType::
    IfThenElseFeatureRulesType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IfThenFeatureRule_ (f, this),
      Else_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void IfThenElseFeatureRulesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IfThenFeatureRule
        //
        if (n.name () == "IfThenFeatureRule" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IfThenFeatureRule_type > r (
            IfThenFeatureRule_traits::create (i, f, this));

          this->IfThenFeatureRule_.push_back (r);
          continue;
        }

        // Else
        //
        if (n.name () == "Else" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Else_type > r (
            Else_traits::create (i, f, this));

          if (!this->Else_)
          {
            this->Else_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenElseFeatureRulesType* IfThenElseFeatureRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenElseFeatureRulesType (*this, f, c);
    }

    IfThenElseFeatureRulesType::
    ~IfThenElseFeatureRulesType ()
    {
    }

    // MaxFeatureRulesType
    //

    MaxFeatureRulesType::
    MaxFeatureRulesType ()
    : ::xml_schema::type (),
      IfThenFeatureRule_ (::xml_schema::flags (), this),
      Else_ (::xml_schema::flags (), this)
    {
    }

    MaxFeatureRulesType::
    MaxFeatureRulesType (const MaxFeatureRulesType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      IfThenFeatureRule_ (x.IfThenFeatureRule_, f, this),
      Else_ (x.Else_, f, this)
    {
    }

    MaxFeatureRulesType::
    MaxFeatureRulesType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      IfThenFeatureRule_ (f, this),
      Else_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void MaxFeatureRulesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IfThenFeatureRule
        //
        if (n.name () == "IfThenFeatureRule" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IfThenFeatureRule_type > r (
            IfThenFeatureRule_traits::create (i, f, this));

          this->IfThenFeatureRule_.push_back (r);
          continue;
        }

        // Else
        //
        if (n.name () == "Else" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Else_type > r (
            Else_traits::create (i, f, this));

          if (!this->Else_)
          {
            this->Else_.set (r);
            continue;
          }
        }

        break;
      }
    }

    MaxFeatureRulesType* MaxFeatureRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MaxFeatureRulesType (*this, f, c);
    }

    MaxFeatureRulesType::
    ~MaxFeatureRulesType ()
    {
    }

    // DMESelectionRulesType
    //

    DMESelectionRulesType::
    DMESelectionRulesType ()
    : ::xml_schema::type (),
      DMESelectionRule_ (::xml_schema::flags (), this)
    {
    }

    DMESelectionRulesType::
    DMESelectionRulesType (const DMESelectionRulesType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DMESelectionRule_ (x.DMESelectionRule_, f, this)
    {
    }

    DMESelectionRulesType::
    DMESelectionRulesType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DMESelectionRule_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void DMESelectionRulesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DMESelectionRule
        //
        if (n.name () == "DMESelectionRule" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DMESelectionRule_type > r (
            DMESelectionRule_traits::create (i, f, this));

          this->DMESelectionRule_.push_back (r);
          continue;
        }

        break;
      }
    }

    DMESelectionRulesType* DMESelectionRulesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMESelectionRulesType (*this, f, c);
    }

    DMESelectionRulesType::
    ~DMESelectionRulesType ()
    {
    }

    // PointRuleBaseType
    //

    PointRuleBaseType::
    PointRuleBaseType ()
    : ::xsd::qif2::QIFRuleBaseType ()
    {
    }

    PointRuleBaseType::
    PointRuleBaseType (const PointRuleBaseType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::QIFRuleBaseType (x, f, c)
    {
    }

    PointRuleBaseType::
    PointRuleBaseType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::QIFRuleBaseType (e, f, c)
    {
    }

    PointRuleBaseType* PointRuleBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointRuleBaseType (*this, f, c);
    }

    PointRuleBaseType::
    ~PointRuleBaseType ()
    {
    }

    // IfThenFeatureRuleType
    //

    IfThenFeatureRuleType::
    IfThenFeatureRuleType ()
    : ::xsd::qif2::PointRuleBaseType (),
      BooleanExpression_ (::xml_schema::flags (), this),
      ThenPoints_ (::xml_schema::flags (), this)
    {
    }

    IfThenFeatureRuleType::
    IfThenFeatureRuleType (const IfThenFeatureRuleType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::PointRuleBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this),
      ThenPoints_ (x.ThenPoints_, f, this)
    {
    }

    IfThenFeatureRuleType::
    IfThenFeatureRuleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::PointRuleBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (f, this),
      ThenPoints_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenFeatureRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::PointRuleBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BooleanExpression
        //
        if (n.name () == "BooleanExpression" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BooleanExpression_type > r (
            BooleanExpression_traits::create (i, f, this));

          if (!this->BooleanExpression_)
          {
            this->BooleanExpression_.set (r);
            continue;
          }
        }

        // ThenPoints
        //
        if (n.name () == "ThenPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPoints_type > r (
            ThenPoints_traits::create (i, f, this));

          if (!this->ThenPoints_)
          {
            this->ThenPoints_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenFeatureRuleType* IfThenFeatureRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenFeatureRuleType (*this, f, c);
    }

    IfThenFeatureRuleType::
    ~IfThenFeatureRuleType ()
    {
    }

    // ElseRuleType
    //

    ElseRuleType::
    ElseRuleType (const ThenPoints_type& ThenPoints)
    : ::xsd::qif2::PointRuleBaseType (),
      ThenPoints_ (ThenPoints, ::xml_schema::flags (), this)
    {
    }

    ElseRuleType::
    ElseRuleType (::std::auto_ptr< ThenPoints_type >& ThenPoints)
    : ::xsd::qif2::PointRuleBaseType (),
      ThenPoints_ (ThenPoints, ::xml_schema::flags (), this)
    {
    }

    ElseRuleType::
    ElseRuleType (const ElseRuleType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::PointRuleBaseType (x, f, c),
      ThenPoints_ (x.ThenPoints_, f, this)
    {
    }

    ElseRuleType::
    ElseRuleType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::PointRuleBaseType (e, f | ::xml_schema::flags::base, c),
      ThenPoints_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ElseRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::PointRuleBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPoints
        //
        if (n.name () == "ThenPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPoints_type > r (
            ThenPoints_traits::create (i, f, this));

          if (!ThenPoints_.present ())
          {
            this->ThenPoints_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ThenPoints_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ThenPoints",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElseRuleType* ElseRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElseRuleType (*this, f, c);
    }

    ElseRuleType::
    ~ElseRuleType ()
    {
    }

    // ThenPointsType
    //

    ThenPointsType::
    ThenPointsType ()
    : ::xml_schema::type (),
      NumberOfPoints_ (::xml_schema::flags (), this),
      MinPoints_ (::xml_schema::flags (), this),
      PointDensity_ (::xml_schema::flags (), this),
      MinPointDensity_ (::xml_schema::flags (), this)
    {
    }

    ThenPointsType::
    ThenPointsType (const ThenPointsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NumberOfPoints_ (x.NumberOfPoints_, f, this),
      MinPoints_ (x.MinPoints_, f, this),
      PointDensity_ (x.PointDensity_, f, this),
      MinPointDensity_ (x.MinPointDensity_, f, this)
    {
    }

    ThenPointsType::
    ThenPointsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NumberOfPoints_ (f, this),
      MinPoints_ (f, this),
      PointDensity_ (f, this),
      MinPointDensity_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThenPointsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // NumberOfPoints
        //
        if (n.name () == "NumberOfPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->NumberOfPoints_)
          {
            this->NumberOfPoints_.set (NumberOfPoints_traits::create (i, f, this));
            continue;
          }
        }

        // MinPoints
        //
        if (n.name () == "MinPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->MinPoints_)
          {
            this->MinPoints_.set (MinPoints_traits::create (i, f, this));
            continue;
          }
        }

        // PointDensity
        //
        if (n.name () == "PointDensity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointDensity_type > r (
            PointDensity_traits::create (i, f, this));

          if (!this->PointDensity_)
          {
            this->PointDensity_.set (r);
            continue;
          }
        }

        // MinPointDensity
        //
        if (n.name () == "MinPointDensity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinPointDensity_type > r (
            MinPointDensity_traits::create (i, f, this));

          if (!this->MinPointDensity_)
          {
            this->MinPointDensity_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThenPointsType* ThenPointsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThenPointsType (*this, f, c);
    }

    ThenPointsType::
    ~ThenPointsType ()
    {
    }

    // IfThenArcRuleType
    //

    IfThenArcRuleType::
    IfThenArcRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenArcRuleType::
    IfThenArcRuleType (const IfThenArcRuleType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenArcRuleType::
    IfThenArcRuleType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenArcRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenArcRuleType* IfThenArcRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenArcRuleType (*this, f, c);
    }

    IfThenArcRuleType::
    ~IfThenArcRuleType ()
    {
    }

    // ArcPointSamplingStrategyType
    //

    ArcPointSamplingStrategyType::
    ArcPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    ArcPointSamplingStrategyType::
    ArcPointSamplingStrategyType (const ArcPointSamplingStrategyType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ArcPointSamplingStrategyType::
    ArcPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcPointSamplingStrategyType* ArcPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcPointSamplingStrategyType (*this, f, c);
    }

    ArcPointSamplingStrategyType::
    ~ArcPointSamplingStrategyType ()
    {
    }

    // IfThenCircleRuleType
    //

    IfThenCircleRuleType::
    IfThenCircleRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenCircleRuleType::
    IfThenCircleRuleType (const IfThenCircleRuleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCircleRuleType::
    IfThenCircleRuleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenCircleRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenCircleRuleType* IfThenCircleRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCircleRuleType (*this, f, c);
    }

    IfThenCircleRuleType::
    ~IfThenCircleRuleType ()
    {
    }

    // CirclePointSamplingStrategyType
    //

    CirclePointSamplingStrategyType::
    CirclePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    CirclePointSamplingStrategyType::
    CirclePointSamplingStrategyType (const CirclePointSamplingStrategyType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CirclePointSamplingStrategyType::
    CirclePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CirclePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CirclePointSamplingStrategyType* CirclePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CirclePointSamplingStrategyType (*this, f, c);
    }

    CirclePointSamplingStrategyType::
    ~CirclePointSamplingStrategyType ()
    {
    }

    // IfThenConeRuleType
    //

    IfThenConeRuleType::
    IfThenConeRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenConeRuleType::
    IfThenConeRuleType (const IfThenConeRuleType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenConeRuleType::
    IfThenConeRuleType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenConeRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenConeRuleType* IfThenConeRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenConeRuleType (*this, f, c);
    }

    IfThenConeRuleType::
    ~IfThenConeRuleType ()
    {
    }

    // ConePointSamplingStrategyType
    //

    ConePointSamplingStrategyType::
    ConePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    ConePointSamplingStrategyType::
    ConePointSamplingStrategyType (const ConePointSamplingStrategyType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ConePointSamplingStrategyType::
    ConePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConePointSamplingStrategyType* ConePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConePointSamplingStrategyType (*this, f, c);
    }

    ConePointSamplingStrategyType::
    ~ConePointSamplingStrategyType ()
    {
    }

    // IfThenConicalSegmentRuleType
    //

    IfThenConicalSegmentRuleType::
    IfThenConicalSegmentRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenConicalSegmentRuleType::
    IfThenConicalSegmentRuleType (const IfThenConicalSegmentRuleType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenConicalSegmentRuleType::
    IfThenConicalSegmentRuleType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenConicalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenConicalSegmentRuleType* IfThenConicalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenConicalSegmentRuleType (*this, f, c);
    }

    IfThenConicalSegmentRuleType::
    ~IfThenConicalSegmentRuleType ()
    {
    }

    // ConicalSegmentPointSamplingStrategyType
    //

    ConicalSegmentPointSamplingStrategyType::
    ConicalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentPointSamplingStrategyType::
    ConicalSegmentPointSamplingStrategyType (const ConicalSegmentPointSamplingStrategyType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ConicalSegmentPointSamplingStrategyType::
    ConicalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentPointSamplingStrategyType* ConicalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentPointSamplingStrategyType (*this, f, c);
    }

    ConicalSegmentPointSamplingStrategyType::
    ~ConicalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenCuboidRuleType
    //

    IfThenCuboidRuleType::
    IfThenCuboidRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenCuboidRuleType::
    IfThenCuboidRuleType (const IfThenCuboidRuleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCuboidRuleType::
    IfThenCuboidRuleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenCuboidRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenCuboidRuleType* IfThenCuboidRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCuboidRuleType (*this, f, c);
    }

    IfThenCuboidRuleType::
    ~IfThenCuboidRuleType ()
    {
    }

    // CuboidPointSamplingStrategyType
    //

    CuboidPointSamplingStrategyType::
    CuboidPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    CuboidPointSamplingStrategyType::
    CuboidPointSamplingStrategyType (const CuboidPointSamplingStrategyType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CuboidPointSamplingStrategyType::
    CuboidPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CuboidPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidPointSamplingStrategyType* CuboidPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidPointSamplingStrategyType (*this, f, c);
    }

    CuboidPointSamplingStrategyType::
    ~CuboidPointSamplingStrategyType ()
    {
    }

    // IfThenCylinderRuleType
    //

    IfThenCylinderRuleType::
    IfThenCylinderRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenCylinderRuleType::
    IfThenCylinderRuleType (const IfThenCylinderRuleType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCylinderRuleType::
    IfThenCylinderRuleType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenCylinderRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenCylinderRuleType* IfThenCylinderRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCylinderRuleType (*this, f, c);
    }

    IfThenCylinderRuleType::
    ~IfThenCylinderRuleType ()
    {
    }

    // CylinderPointSamplingStrategyType
    //

    CylinderPointSamplingStrategyType::
    CylinderPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    CylinderPointSamplingStrategyType::
    CylinderPointSamplingStrategyType (const CylinderPointSamplingStrategyType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CylinderPointSamplingStrategyType::
    CylinderPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylinderPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderPointSamplingStrategyType* CylinderPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderPointSamplingStrategyType (*this, f, c);
    }

    CylinderPointSamplingStrategyType::
    ~CylinderPointSamplingStrategyType ()
    {
    }

    // IfThenCylindricalSegmentRuleType
    //

    IfThenCylindricalSegmentRuleType::
    IfThenCylindricalSegmentRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenCylindricalSegmentRuleType::
    IfThenCylindricalSegmentRuleType (const IfThenCylindricalSegmentRuleType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenCylindricalSegmentRuleType::
    IfThenCylindricalSegmentRuleType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenCylindricalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenCylindricalSegmentRuleType* IfThenCylindricalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCylindricalSegmentRuleType (*this, f, c);
    }

    IfThenCylindricalSegmentRuleType::
    ~IfThenCylindricalSegmentRuleType ()
    {
    }

    // CylindricalSegmentPointSamplingStrategyType
    //

    CylindricalSegmentPointSamplingStrategyType::
    CylindricalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentPointSamplingStrategyType::
    CylindricalSegmentPointSamplingStrategyType (const CylindricalSegmentPointSamplingStrategyType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    CylindricalSegmentPointSamplingStrategyType::
    CylindricalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentPointSamplingStrategyType* CylindricalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentPointSamplingStrategyType (*this, f, c);
    }

    CylindricalSegmentPointSamplingStrategyType::
    ~CylindricalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenEllipseRuleType
    //

    IfThenEllipseRuleType::
    IfThenEllipseRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenEllipseRuleType::
    IfThenEllipseRuleType (const IfThenEllipseRuleType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenEllipseRuleType::
    IfThenEllipseRuleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenEllipseRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenEllipseRuleType* IfThenEllipseRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenEllipseRuleType (*this, f, c);
    }

    IfThenEllipseRuleType::
    ~IfThenEllipseRuleType ()
    {
    }

    // EllipsePointSamplingStrategyType
    //

    EllipsePointSamplingStrategyType::
    EllipsePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    EllipsePointSamplingStrategyType::
    EllipsePointSamplingStrategyType (const EllipsePointSamplingStrategyType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    EllipsePointSamplingStrategyType::
    EllipsePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipsePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipsePointSamplingStrategyType* EllipsePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipsePointSamplingStrategyType (*this, f, c);
    }

    EllipsePointSamplingStrategyType::
    ~EllipsePointSamplingStrategyType ()
    {
    }

    // IfThenElongatedCylinderRuleType
    //

    IfThenElongatedCylinderRuleType::
    IfThenElongatedCylinderRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenElongatedCylinderRuleType::
    IfThenElongatedCylinderRuleType (const IfThenElongatedCylinderRuleType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenElongatedCylinderRuleType::
    IfThenElongatedCylinderRuleType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenElongatedCylinderRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenElongatedCylinderRuleType* IfThenElongatedCylinderRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenElongatedCylinderRuleType (*this, f, c);
    }

    IfThenElongatedCylinderRuleType::
    ~IfThenElongatedCylinderRuleType ()
    {
    }

    // ElongatedCylinderPointSamplingStrategyType
    //

    ElongatedCylinderPointSamplingStrategyType::
    ElongatedCylinderPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderPointSamplingStrategyType::
    ElongatedCylinderPointSamplingStrategyType (const ElongatedCylinderPointSamplingStrategyType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ElongatedCylinderPointSamplingStrategyType::
    ElongatedCylinderPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderPointSamplingStrategyType* ElongatedCylinderPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderPointSamplingStrategyType (*this, f, c);
    }

    ElongatedCylinderPointSamplingStrategyType::
    ~ElongatedCylinderPointSamplingStrategyType ()
    {
    }

    // IfThenExtrudedCrossSectionRuleType
    //

    IfThenExtrudedCrossSectionRuleType::
    IfThenExtrudedCrossSectionRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenExtrudedCrossSectionRuleType::
    IfThenExtrudedCrossSectionRuleType (const IfThenExtrudedCrossSectionRuleType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenExtrudedCrossSectionRuleType::
    IfThenExtrudedCrossSectionRuleType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenExtrudedCrossSectionRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenExtrudedCrossSectionRuleType* IfThenExtrudedCrossSectionRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenExtrudedCrossSectionRuleType (*this, f, c);
    }

    IfThenExtrudedCrossSectionRuleType::
    ~IfThenExtrudedCrossSectionRuleType ()
    {
    }

    // ExtrudedCrossSectionPointSamplingStrategyType
    //

    ExtrudedCrossSectionPointSamplingStrategyType::
    ExtrudedCrossSectionPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyType::
    ExtrudedCrossSectionPointSamplingStrategyType (const ExtrudedCrossSectionPointSamplingStrategyType& x,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ExtrudedCrossSectionPointSamplingStrategyType::
    ExtrudedCrossSectionPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::flags f,
                                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionPointSamplingStrategyType* ExtrudedCrossSectionPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionPointSamplingStrategyType (*this, f, c);
    }

    ExtrudedCrossSectionPointSamplingStrategyType::
    ~ExtrudedCrossSectionPointSamplingStrategyType ()
    {
    }

    // IfThenLineRuleType
    //

    IfThenLineRuleType::
    IfThenLineRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenLineRuleType::
    IfThenLineRuleType (const IfThenLineRuleType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenLineRuleType::
    IfThenLineRuleType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenLineRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenLineRuleType* IfThenLineRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenLineRuleType (*this, f, c);
    }

    IfThenLineRuleType::
    ~IfThenLineRuleType ()
    {
    }

    // LinePointSamplingStrategyType
    //

    LinePointSamplingStrategyType::
    LinePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    LinePointSamplingStrategyType::
    LinePointSamplingStrategyType (const LinePointSamplingStrategyType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    LinePointSamplingStrategyType::
    LinePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LinePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LinePointSamplingStrategyType* LinePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinePointSamplingStrategyType (*this, f, c);
    }

    LinePointSamplingStrategyType::
    ~LinePointSamplingStrategyType ()
    {
    }

    // IfThenOppositeLinesRuleType
    //

    IfThenOppositeLinesRuleType::
    IfThenOppositeLinesRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenOppositeLinesRuleType::
    IfThenOppositeLinesRuleType (const IfThenOppositeLinesRuleType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenOppositeLinesRuleType::
    IfThenOppositeLinesRuleType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenOppositeLinesRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenOppositeLinesRuleType* IfThenOppositeLinesRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenOppositeLinesRuleType (*this, f, c);
    }

    IfThenOppositeLinesRuleType::
    ~IfThenOppositeLinesRuleType ()
    {
    }

    // OppositeLinesPointSamplingStrategyType
    //

    OppositeLinesPointSamplingStrategyType::
    OppositeLinesPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesPointSamplingStrategyType::
    OppositeLinesPointSamplingStrategyType (const OppositeLinesPointSamplingStrategyType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    OppositeLinesPointSamplingStrategyType::
    OppositeLinesPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesPointSamplingStrategyType* OppositeLinesPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesPointSamplingStrategyType (*this, f, c);
    }

    OppositeLinesPointSamplingStrategyType::
    ~OppositeLinesPointSamplingStrategyType ()
    {
    }

    // IfThenOppositePlanesRuleType
    //

    IfThenOppositePlanesRuleType::
    IfThenOppositePlanesRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenOppositePlanesRuleType::
    IfThenOppositePlanesRuleType (const IfThenOppositePlanesRuleType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenOppositePlanesRuleType::
    IfThenOppositePlanesRuleType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenOppositePlanesRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenOppositePlanesRuleType* IfThenOppositePlanesRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenOppositePlanesRuleType (*this, f, c);
    }

    IfThenOppositePlanesRuleType::
    ~IfThenOppositePlanesRuleType ()
    {
    }

    // OppositePlanesPointSamplingStrategyType
    //

    OppositePlanesPointSamplingStrategyType::
    OppositePlanesPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesPointSamplingStrategyType::
    OppositePlanesPointSamplingStrategyType (const OppositePlanesPointSamplingStrategyType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    OppositePlanesPointSamplingStrategyType::
    OppositePlanesPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesPointSamplingStrategyType* OppositePlanesPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesPointSamplingStrategyType (*this, f, c);
    }

    OppositePlanesPointSamplingStrategyType::
    ~OppositePlanesPointSamplingStrategyType ()
    {
    }

    // IfThenPlaneRuleType
    //

    IfThenPlaneRuleType::
    IfThenPlaneRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenPlaneRuleType::
    IfThenPlaneRuleType (const IfThenPlaneRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenPlaneRuleType::
    IfThenPlaneRuleType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenPlaneRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenPlaneRuleType* IfThenPlaneRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPlaneRuleType (*this, f, c);
    }

    IfThenPlaneRuleType::
    ~IfThenPlaneRuleType ()
    {
    }

    // PlanePointSamplingStrategyType
    //

    PlanePointSamplingStrategyType::
    PlanePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    PlanePointSamplingStrategyType::
    PlanePointSamplingStrategyType (const PlanePointSamplingStrategyType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PlanePointSamplingStrategyType::
    PlanePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlanePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlanePointSamplingStrategyType* PlanePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlanePointSamplingStrategyType (*this, f, c);
    }

    PlanePointSamplingStrategyType::
    ~PlanePointSamplingStrategyType ()
    {
    }

    // IfThenPointDefinedCurveRuleType
    //

    IfThenPointDefinedCurveRuleType::
    IfThenPointDefinedCurveRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenPointDefinedCurveRuleType::
    IfThenPointDefinedCurveRuleType (const IfThenPointDefinedCurveRuleType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenPointDefinedCurveRuleType::
    IfThenPointDefinedCurveRuleType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenPointDefinedCurveRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenPointDefinedCurveRuleType* IfThenPointDefinedCurveRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPointDefinedCurveRuleType (*this, f, c);
    }

    IfThenPointDefinedCurveRuleType::
    ~IfThenPointDefinedCurveRuleType ()
    {
    }

    // PointDefinedCurvePointSamplingStrategyType
    //

    PointDefinedCurvePointSamplingStrategyType::
    PointDefinedCurvePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurvePointSamplingStrategyType::
    PointDefinedCurvePointSamplingStrategyType (const PointDefinedCurvePointSamplingStrategyType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PointDefinedCurvePointSamplingStrategyType::
    PointDefinedCurvePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurvePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurvePointSamplingStrategyType* PointDefinedCurvePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurvePointSamplingStrategyType (*this, f, c);
    }

    PointDefinedCurvePointSamplingStrategyType::
    ~PointDefinedCurvePointSamplingStrategyType ()
    {
    }

    // IfThenPointDefinedSurfaceRuleType
    //

    IfThenPointDefinedSurfaceRuleType::
    IfThenPointDefinedSurfaceRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenPointDefinedSurfaceRuleType::
    IfThenPointDefinedSurfaceRuleType (const IfThenPointDefinedSurfaceRuleType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenPointDefinedSurfaceRuleType::
    IfThenPointDefinedSurfaceRuleType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenPointDefinedSurfaceRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenPointDefinedSurfaceRuleType* IfThenPointDefinedSurfaceRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPointDefinedSurfaceRuleType (*this, f, c);
    }

    IfThenPointDefinedSurfaceRuleType::
    ~IfThenPointDefinedSurfaceRuleType ()
    {
    }

    // PointDefinedSurfacePointSamplingStrategyType
    //

    PointDefinedSurfacePointSamplingStrategyType::
    PointDefinedSurfacePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfacePointSamplingStrategyType::
    PointDefinedSurfacePointSamplingStrategyType (const PointDefinedSurfacePointSamplingStrategyType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PointDefinedSurfacePointSamplingStrategyType::
    PointDefinedSurfacePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfacePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfacePointSamplingStrategyType* PointDefinedSurfacePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfacePointSamplingStrategyType (*this, f, c);
    }

    PointDefinedSurfacePointSamplingStrategyType::
    ~PointDefinedSurfacePointSamplingStrategyType ()
    {
    }

    // IfThenPointRuleType
    //

    IfThenPointRuleType::
    IfThenPointRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this)
    {
    }

    IfThenPointRuleType::
    IfThenPointRuleType (const IfThenPointRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this)
    {
    }

    IfThenPointRuleType::
    IfThenPointRuleType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenPointRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenPointRuleType* IfThenPointRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenPointRuleType (*this, f, c);
    }

    IfThenPointRuleType::
    ~IfThenPointRuleType ()
    {
    }

    // PointPointSamplingStrategyType
    //

    PointPointSamplingStrategyType::
    PointPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    PointPointSamplingStrategyType::
    PointPointSamplingStrategyType (const PointPointSamplingStrategyType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    PointPointSamplingStrategyType::
    PointPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointPointSamplingStrategyType* PointPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointPointSamplingStrategyType (*this, f, c);
    }

    PointPointSamplingStrategyType::
    ~PointPointSamplingStrategyType ()
    {
    }

    // IfThenSphereRuleType
    //

    IfThenSphereRuleType::
    IfThenSphereRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenSphereRuleType::
    IfThenSphereRuleType (const IfThenSphereRuleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenSphereRuleType::
    IfThenSphereRuleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenSphereRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenSphereRuleType* IfThenSphereRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSphereRuleType (*this, f, c);
    }

    IfThenSphereRuleType::
    ~IfThenSphereRuleType ()
    {
    }

    // SpherePointSamplingStrategyType
    //

    SpherePointSamplingStrategyType::
    SpherePointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    SpherePointSamplingStrategyType::
    SpherePointSamplingStrategyType (const SpherePointSamplingStrategyType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    SpherePointSamplingStrategyType::
    SpherePointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SpherePointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SpherePointSamplingStrategyType* SpherePointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpherePointSamplingStrategyType (*this, f, c);
    }

    SpherePointSamplingStrategyType::
    ~SpherePointSamplingStrategyType ()
    {
    }

    // IfThenSphericalSegmentRuleType
    //

    IfThenSphericalSegmentRuleType::
    IfThenSphericalSegmentRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenSphericalSegmentRuleType::
    IfThenSphericalSegmentRuleType (const IfThenSphericalSegmentRuleType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenSphericalSegmentRuleType::
    IfThenSphericalSegmentRuleType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenSphericalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenSphericalSegmentRuleType* IfThenSphericalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSphericalSegmentRuleType (*this, f, c);
    }

    IfThenSphericalSegmentRuleType::
    ~IfThenSphericalSegmentRuleType ()
    {
    }

    // SphericalSegmentPointSamplingStrategyType
    //

    SphericalSegmentPointSamplingStrategyType::
    SphericalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    SphericalSegmentPointSamplingStrategyType::
    SphericalSegmentPointSamplingStrategyType (const SphericalSegmentPointSamplingStrategyType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    SphericalSegmentPointSamplingStrategyType::
    SphericalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentPointSamplingStrategyType* SphericalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentPointSamplingStrategyType (*this, f, c);
    }

    SphericalSegmentPointSamplingStrategyType::
    ~SphericalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenSurfaceOfRevolutionRuleType
    //

    IfThenSurfaceOfRevolutionRuleType::
    IfThenSurfaceOfRevolutionRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenSurfaceOfRevolutionRuleType::
    IfThenSurfaceOfRevolutionRuleType (const IfThenSurfaceOfRevolutionRuleType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenSurfaceOfRevolutionRuleType::
    IfThenSurfaceOfRevolutionRuleType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenSurfaceOfRevolutionRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenSurfaceOfRevolutionRuleType* IfThenSurfaceOfRevolutionRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSurfaceOfRevolutionRuleType (*this, f, c);
    }

    IfThenSurfaceOfRevolutionRuleType::
    ~IfThenSurfaceOfRevolutionRuleType ()
    {
    }

    // SurfaceOfRevolutionPointSamplingStrategyType
    //

    SurfaceOfRevolutionPointSamplingStrategyType::
    SurfaceOfRevolutionPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyType::
    SurfaceOfRevolutionPointSamplingStrategyType (const SurfaceOfRevolutionPointSamplingStrategyType& x,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    SurfaceOfRevolutionPointSamplingStrategyType::
    SurfaceOfRevolutionPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::flags f,
                                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionPointSamplingStrategyType* SurfaceOfRevolutionPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionPointSamplingStrategyType (*this, f, c);
    }

    SurfaceOfRevolutionPointSamplingStrategyType::
    ~SurfaceOfRevolutionPointSamplingStrategyType ()
    {
    }

    // IfThenToroidalSegmentRuleType
    //

    IfThenToroidalSegmentRuleType::
    IfThenToroidalSegmentRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenToroidalSegmentRuleType::
    IfThenToroidalSegmentRuleType (const IfThenToroidalSegmentRuleType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenToroidalSegmentRuleType::
    IfThenToroidalSegmentRuleType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenToroidalSegmentRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenToroidalSegmentRuleType* IfThenToroidalSegmentRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenToroidalSegmentRuleType (*this, f, c);
    }

    IfThenToroidalSegmentRuleType::
    ~IfThenToroidalSegmentRuleType ()
    {
    }

    // ToroidalSegmentPointSamplingStrategyType
    //

    ToroidalSegmentPointSamplingStrategyType::
    ToroidalSegmentPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentPointSamplingStrategyType::
    ToroidalSegmentPointSamplingStrategyType (const ToroidalSegmentPointSamplingStrategyType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    ToroidalSegmentPointSamplingStrategyType::
    ToroidalSegmentPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentPointSamplingStrategyType* ToroidalSegmentPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentPointSamplingStrategyType (*this, f, c);
    }

    ToroidalSegmentPointSamplingStrategyType::
    ~ToroidalSegmentPointSamplingStrategyType ()
    {
    }

    // IfThenTorusRuleType
    //

    IfThenTorusRuleType::
    IfThenTorusRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType (),
      ThenPointStrategy_ (::xml_schema::flags (), this),
      ThenFittingAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    IfThenTorusRuleType::
    IfThenTorusRuleType (const IfThenTorusRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c),
      ThenPointStrategy_ (x.ThenPointStrategy_, f, this),
      ThenFittingAlgorithm_ (x.ThenFittingAlgorithm_, f, this)
    {
    }

    IfThenTorusRuleType::
    IfThenTorusRuleType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f | ::xml_schema::flags::base, c),
      ThenPointStrategy_ (f, this),
      ThenFittingAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void IfThenTorusRuleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::IfThenFeatureRuleType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ThenPointStrategy
        //
        if (n.name () == "ThenPointStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenPointStrategy_type > r (
            ThenPointStrategy_traits::create (i, f, this));

          if (!this->ThenPointStrategy_)
          {
            this->ThenPointStrategy_.set (r);
            continue;
          }
        }

        // ThenFittingAlgorithm
        //
        if (n.name () == "ThenFittingAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThenFittingAlgorithm_type > r (
            ThenFittingAlgorithm_traits::create (i, f, this));

          if (!this->ThenFittingAlgorithm_)
          {
            this->ThenFittingAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    IfThenTorusRuleType* IfThenTorusRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenTorusRuleType (*this, f, c);
    }

    IfThenTorusRuleType::
    ~IfThenTorusRuleType ()
    {
    }

    // TorusPointSamplingStrategyType
    //

    TorusPointSamplingStrategyType::
    TorusPointSamplingStrategyType ()
    : ::xml_schema::type (),
      PointSamplingStrategyEnum_ (::xml_schema::flags (), this),
      UserDefinedStrategy_ (::xml_schema::flags (), this)
    {
    }

    TorusPointSamplingStrategyType::
    TorusPointSamplingStrategyType (const TorusPointSamplingStrategyType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointSamplingStrategyEnum_ (x.PointSamplingStrategyEnum_, f, this),
      UserDefinedStrategy_ (x.UserDefinedStrategy_, f, this)
    {
    }

    TorusPointSamplingStrategyType::
    TorusPointSamplingStrategyType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointSamplingStrategyEnum_ (f, this),
      UserDefinedStrategy_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TorusPointSamplingStrategyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointSamplingStrategyEnum
        //
        if (n.name () == "PointSamplingStrategyEnum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointSamplingStrategyEnum_type > r (
            PointSamplingStrategyEnum_traits::create (i, f, this));

          if (!this->PointSamplingStrategyEnum_)
          {
            this->PointSamplingStrategyEnum_.set (r);
            continue;
          }
        }

        // UserDefinedStrategy
        //
        if (n.name () == "UserDefinedStrategy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedStrategy_type > r (
            UserDefinedStrategy_traits::create (i, f, this));

          if (!this->UserDefinedStrategy_)
          {
            this->UserDefinedStrategy_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusPointSamplingStrategyType* TorusPointSamplingStrategyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusPointSamplingStrategyType (*this, f, c);
    }

    TorusPointSamplingStrategyType::
    ~TorusPointSamplingStrategyType ()
    {
    }

    // IfThenSurfaceRuleType
    //

    IfThenSurfaceRuleType::
    IfThenSurfaceRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType ()
    {
    }

    IfThenSurfaceRuleType::
    IfThenSurfaceRuleType (const IfThenSurfaceRuleType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c)
    {
    }

    IfThenSurfaceRuleType::
    IfThenSurfaceRuleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f, c)
    {
    }

    IfThenSurfaceRuleType* IfThenSurfaceRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenSurfaceRuleType (*this, f, c);
    }

    IfThenSurfaceRuleType::
    ~IfThenSurfaceRuleType ()
    {
    }

    // IfThenCurveRuleType
    //

    IfThenCurveRuleType::
    IfThenCurveRuleType ()
    : ::xsd::qif2::IfThenFeatureRuleType ()
    {
    }

    IfThenCurveRuleType::
    IfThenCurveRuleType (const IfThenCurveRuleType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (x, f, c)
    {
    }

    IfThenCurveRuleType::
    IfThenCurveRuleType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::IfThenFeatureRuleType (e, f, c)
    {
    }

    IfThenCurveRuleType* IfThenCurveRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class IfThenCurveRuleType (*this, f, c);
    }

    IfThenCurveRuleType::
    ~IfThenCurveRuleType ()
    {
    }

    // DMESelectionRuleType
    //

    DMESelectionRuleType::
    DMESelectionRuleType ()
    : ::xml_schema::type ()
    {
    }

    DMESelectionRuleType::
    DMESelectionRuleType (const DMESelectionRuleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    DMESelectionRuleType::
    DMESelectionRuleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    DMESelectionRuleType::
    DMESelectionRuleType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    DMESelectionRuleType::
    DMESelectionRuleType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    DMESelectionRuleType* DMESelectionRuleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DMESelectionRuleType (*this, f, c);
    }

    DMESelectionRuleType::
    ~DMESelectionRuleType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::QIFRulesType > r (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::QIFRulesType > r (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::QIFRulesType > r (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Rules (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Rules (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Rules (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Rules (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Rules (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Rules (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::QIFRulesType > r (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::QIFRulesType > r (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::QIFRulesType > r (
        ::xsd::qif2::Rules (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::QIFRulesType > r (
          ::xsd::qif2::Rules (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Rules" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::QIFRulesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::QIFRulesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Rules",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::QIFRulesType >
    Rules (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Rules" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::QIFRulesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::QIFRulesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Rules",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > r (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > r (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > r (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenFeatureRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenFeatureRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenFeatureRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenFeatureRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenFeatureRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenFeatureRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > r (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > r (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > r (
        ::xsd::qif2::IfThenFeatureRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > r (
          ::xsd::qif2::IfThenFeatureRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenFeatureRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenFeatureRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenFeatureRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType >
    IfThenFeatureRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenFeatureRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenFeatureRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenFeatureRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenFeatureRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > r (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > r (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > r (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCurveRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCurveRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > r (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > r (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > r (
        ::xsd::qif2::IfThenCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > r (
          ::xsd::qif2::IfThenCurveRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenCurveRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenCurveRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCurveRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType >
    IfThenCurveRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenCurveRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCurveRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenCurveRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCurveRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > r (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > r (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > r (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > r (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > r (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > r (
        ::xsd::qif2::IfThenSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > r (
          ::xsd::qif2::IfThenSurfaceRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenSurfaceRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenSurfaceRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSurfaceRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType >
    IfThenSurfaceRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenSurfaceRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenSurfaceRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSurfaceRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > r (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > r (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > r (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenArcRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenArcRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenArcRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenArcRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenArcRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenArcRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > r (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > r (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > r (
        ::xsd::qif2::IfThenArcRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > r (
          ::xsd::qif2::IfThenArcRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenArcRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenArcRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenArcRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType >
    IfThenArcRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenArcRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenArcRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenArcRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenArcRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > r (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > r (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > r (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCircleRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCircleRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCircleRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCircleRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCircleRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCircleRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > r (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > r (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > r (
        ::xsd::qif2::IfThenCircleRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > r (
          ::xsd::qif2::IfThenCircleRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenCircleRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenCircleRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCircleRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType >
    IfThenCircleRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenCircleRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCircleRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenCircleRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCircleRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > r (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > r (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > r (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConeRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConeRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConeRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConeRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConeRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConeRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > r (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > r (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > r (
        ::xsd::qif2::IfThenConeRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > r (
          ::xsd::qif2::IfThenConeRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenConeRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenConeRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenConeRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType >
    IfThenConeRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenConeRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenConeRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenConeRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenConeRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > r (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > r (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > r (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenConicalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > r (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > r (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > r (
        ::xsd::qif2::IfThenConicalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (const ::xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > r (
          ::xsd::qif2::IfThenConicalSegmentRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenConicalSegmentRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenConicalSegmentRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenConicalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType >
    IfThenConicalSegmentRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenConicalSegmentRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenConicalSegmentRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenConicalSegmentRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenConicalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > r (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > r (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > r (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCuboidRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCuboidRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCuboidRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCuboidRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCuboidRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCuboidRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > r (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > r (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > r (
        ::xsd::qif2::IfThenCuboidRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > r (
          ::xsd::qif2::IfThenCuboidRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenCuboidRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenCuboidRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCuboidRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType >
    IfThenCuboidRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenCuboidRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCuboidRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenCuboidRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCuboidRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > r (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > r (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > r (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylinderRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylinderRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > r (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > r (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > r (
        ::xsd::qif2::IfThenCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > r (
          ::xsd::qif2::IfThenCylinderRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenCylinderRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenCylinderRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCylinderRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType >
    IfThenCylinderRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenCylinderRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCylinderRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenCylinderRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCylinderRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > r (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > r (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > r (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenCylindricalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > r (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > r (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > r (
        ::xsd::qif2::IfThenCylindricalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (const ::xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > r (
          ::xsd::qif2::IfThenCylindricalSegmentRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenCylindricalSegmentRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenCylindricalSegmentRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCylindricalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType >
    IfThenCylindricalSegmentRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenCylindricalSegmentRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenCylindricalSegmentRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenCylindricalSegmentRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenCylindricalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > r (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > r (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > r (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenEllipseRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenEllipseRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenEllipseRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenEllipseRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenEllipseRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenEllipseRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > r (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > r (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > r (
        ::xsd::qif2::IfThenEllipseRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > r (
          ::xsd::qif2::IfThenEllipseRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenEllipseRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenEllipseRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenEllipseRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType >
    IfThenEllipseRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenEllipseRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenEllipseRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenEllipseRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenEllipseRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > r (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > r (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (const ::std::string& u,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > r (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenElongatedCylinderRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > r (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > r (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::xercesc::InputSource& i,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > r (
        ::xsd::qif2::IfThenElongatedCylinderRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (const ::xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > r (
          ::xsd::qif2::IfThenElongatedCylinderRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenElongatedCylinderRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenElongatedCylinderRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenElongatedCylinderRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType >
    IfThenElongatedCylinderRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenElongatedCylinderRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenElongatedCylinderRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenElongatedCylinderRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenElongatedCylinderRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > r (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > r (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (const ::std::string& u,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > r (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenExtrudedCrossSectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > r (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > r (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::xercesc::InputSource& i,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > r (
        ::xsd::qif2::IfThenExtrudedCrossSectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (const ::xercesc::DOMDocument& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > r (
          ::xsd::qif2::IfThenExtrudedCrossSectionRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenExtrudedCrossSectionRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenExtrudedCrossSectionRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType >
    IfThenExtrudedCrossSectionRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenExtrudedCrossSectionRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenExtrudedCrossSectionRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenExtrudedCrossSectionRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > r (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > r (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > r (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenLineRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenLineRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenLineRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenLineRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenLineRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenLineRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > r (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > r (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > r (
        ::xsd::qif2::IfThenLineRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > r (
          ::xsd::qif2::IfThenLineRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenLineRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenLineRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenLineRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType >
    IfThenLineRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenLineRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenLineRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenLineRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenLineRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (const ::std::string& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > r (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (const ::std::string& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > r (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > r (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositeLinesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::xercesc::InputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > r (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::xercesc::InputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > r (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > r (
        ::xsd::qif2::IfThenOppositeLinesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (const ::xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > r (
          ::xsd::qif2::IfThenOppositeLinesRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenOppositeLinesRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenOppositeLinesRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenOppositeLinesRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType >
    IfThenOppositeLinesRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenOppositeLinesRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenOppositeLinesRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenOppositeLinesRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenOppositeLinesRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > r (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > r (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > r (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenOppositePlanesRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > r (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > r (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > r (
        ::xsd::qif2::IfThenOppositePlanesRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (const ::xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > r (
          ::xsd::qif2::IfThenOppositePlanesRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenOppositePlanesRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenOppositePlanesRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenOppositePlanesRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType >
    IfThenOppositePlanesRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenOppositePlanesRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenOppositePlanesRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenOppositePlanesRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenOppositePlanesRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > r (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > r (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > r (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPlaneRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPlaneRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPlaneRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPlaneRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPlaneRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPlaneRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > r (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > r (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > r (
        ::xsd::qif2::IfThenPlaneRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > r (
          ::xsd::qif2::IfThenPlaneRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenPlaneRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenPlaneRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPlaneRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType >
    IfThenPlaneRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenPlaneRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPlaneRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenPlaneRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPlaneRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > r (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > r (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (const ::std::string& u,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > r (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedCurveRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > r (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > r (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::xercesc::InputSource& i,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > r (
        ::xsd::qif2::IfThenPointDefinedCurveRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (const ::xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > r (
          ::xsd::qif2::IfThenPointDefinedCurveRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenPointDefinedCurveRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenPointDefinedCurveRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointDefinedCurveRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType >
    IfThenPointDefinedCurveRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenPointDefinedCurveRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedCurveRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenPointDefinedCurveRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointDefinedCurveRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (const ::std::string& u,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > r (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (const ::std::string& u,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > r (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (const ::std::string& u,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > r (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointDefinedSurfaceRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::xercesc::InputSource& i,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > r (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::xercesc::InputSource& i,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > r (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::xercesc::InputSource& i,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > r (
        ::xsd::qif2::IfThenPointDefinedSurfaceRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (const ::xercesc::DOMDocument& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > r (
          ::xsd::qif2::IfThenPointDefinedSurfaceRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenPointDefinedSurfaceRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointDefinedSurfaceRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType >
    IfThenPointDefinedSurfaceRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenPointDefinedSurfaceRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenPointDefinedSurfaceRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointDefinedSurfaceRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > r (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > r (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > r (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenPointRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenPointRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > r (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > r (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > r (
        ::xsd::qif2::IfThenPointRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > r (
          ::xsd::qif2::IfThenPointRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenPointRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenPointRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType >
    IfThenPointRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenPointRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenPointRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenPointRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenPointRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > r (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > r (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > r (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphereRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphereRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphereRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphereRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphereRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphereRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > r (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > r (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > r (
        ::xsd::qif2::IfThenSphereRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > r (
          ::xsd::qif2::IfThenSphereRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenSphereRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenSphereRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSphereRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType >
    IfThenSphereRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenSphereRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSphereRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenSphereRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSphereRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > r (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > r (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (const ::std::string& u,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > r (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::std::istream& is,
                                const ::std::string& sid,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSphericalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > r (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > r (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::xercesc::InputSource& i,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > r (
        ::xsd::qif2::IfThenSphericalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (const ::xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > r (
          ::xsd::qif2::IfThenSphericalSegmentRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenSphericalSegmentRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenSphericalSegmentRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSphericalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType >
    IfThenSphericalSegmentRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenSphericalSegmentRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSphericalSegmentRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenSphericalSegmentRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSphericalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (const ::std::string& u,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > r (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (const ::std::string& u,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > r (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (const ::std::string& u,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > r (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenSurfaceOfRevolutionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::xercesc::InputSource& i,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > r (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::xercesc::InputSource& i,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > r (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::xercesc::InputSource& i,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > r (
        ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (const ::xercesc::DOMDocument& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > r (
          ::xsd::qif2::IfThenSurfaceOfRevolutionRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenSurfaceOfRevolutionRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSurfaceOfRevolutionRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType >
    IfThenSurfaceOfRevolutionRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenSurfaceOfRevolutionRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenSurfaceOfRevolutionRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenSurfaceOfRevolutionRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > r (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > r (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (const ::std::string& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > r (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::std::istream& is,
                               const ::std::string& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenToroidalSegmentRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > r (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > r (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::xercesc::InputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > r (
        ::xsd::qif2::IfThenToroidalSegmentRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (const ::xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > r (
          ::xsd::qif2::IfThenToroidalSegmentRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenToroidalSegmentRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenToroidalSegmentRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenToroidalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType >
    IfThenToroidalSegmentRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenToroidalSegmentRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenToroidalSegmentRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenToroidalSegmentRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenToroidalSegmentRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > r (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > r (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > r (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenTorusRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenTorusRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::IfThenTorusRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenTorusRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenTorusRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::IfThenTorusRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > r (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > r (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > r (
        ::xsd::qif2::IfThenTorusRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > r (
          ::xsd::qif2::IfThenTorusRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "IfThenTorusRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenTorusRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenTorusRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType >
    IfThenTorusRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "IfThenTorusRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::IfThenTorusRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::IfThenTorusRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "IfThenTorusRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > r (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > r (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > r (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::DMESelectionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::DMESelectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::DMESelectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::DMESelectionRule (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::DMESelectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::DMESelectionRule (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > r (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > r (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > r (
        ::xsd::qif2::DMESelectionRule (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > r (
          ::xsd::qif2::DMESelectionRule (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "DMESelectionRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::DMESelectionRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "DMESelectionRule",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType >
    DMESelectionRule (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "DMESelectionRule" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::DMESelectionRuleType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::DMESelectionRuleType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "DMESelectionRule",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

