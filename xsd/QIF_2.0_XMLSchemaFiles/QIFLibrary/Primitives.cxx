// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Primitives.hxx"

namespace xsd
{
  namespace qif2
  {
    // BinaryDataType
    // 

    const BinaryDataType::N_type& BinaryDataType::
    N () const
    {
      return this->N_.get ();
    }

    BinaryDataType::N_type& BinaryDataType::
    N ()
    {
      return this->N_.get ();
    }

    void BinaryDataType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }


    // ListIntType
    //

    ListIntType::
    ListIntType ()
    : ::xsd::cxx::tree::list< ::xml_schema::integer, char > ( ::xml_schema::flags (0), this)
    {
    }

    ListIntType::
    ListIntType (size_type n, const ::xml_schema::integer& x)
    : ::xsd::cxx::tree::list< ::xml_schema::integer, char > (n, x, this)
    {
    }

    ListIntType::
    ListIntType (const ListIntType& o,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::integer, char > (o, f, this)
    {
    }

    // I2Type
    // 


    // ListDoubleType
    //

    ListDoubleType::
    ListDoubleType ()
    : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > ( ::xml_schema::flags (0), this)
    {
    }

    ListDoubleType::
    ListDoubleType (size_type n, const ::xml_schema::double_& x)
    : ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (n, x, this)
    {
    }

    ListDoubleType::
    ListDoubleType (const ListDoubleType& o,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (o, f, this)
    {
    }

    // D3Type
    // 


    // D2Type
    // 


    // DoublePositiveType
    // 


    // Point2dSimpleType
    // 


    // UnitVector2dSimpleType
    // 


    // ParameterRangeType
    // 


    // PointSimpleType
    // 


    // VectorSimpleType
    // 


    // UnitVectorSimpleType
    // 


    // ValidityEnumType
    // 

    ValidityEnumType::
    ValidityEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_ValidityEnumType_literals_[v])
    {
    }

    ValidityEnumType::
    ValidityEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ValidityEnumType::
    ValidityEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ValidityEnumType::
    ValidityEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    ValidityEnumType::
    ValidityEnumType (const ValidityEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    ValidityEnumType& ValidityEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_ValidityEnumType_literals_[v]);

      return *this;
    }


    // PointType
    // 

    const PointType::linearUnit_optional& PointType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    PointType::linearUnit_optional& PointType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void PointType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void PointType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void PointType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const PointType::decimalPlaces_optional& PointType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    PointType::decimalPlaces_optional& PointType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void PointType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void PointType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const PointType::significantFigures_optional& PointType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    PointType::significantFigures_optional& PointType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void PointType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void PointType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const PointType::validity_optional& PointType::
    validity () const
    {
      return this->validity_;
    }

    PointType::validity_optional& PointType::
    validity ()
    {
      return this->validity_;
    }

    void PointType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void PointType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void PointType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const PointType::xDecimalPlaces_optional& PointType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    PointType::xDecimalPlaces_optional& PointType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void PointType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void PointType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const PointType::xSignificantFigures_optional& PointType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    PointType::xSignificantFigures_optional& PointType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void PointType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void PointType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const PointType::xValidity_optional& PointType::
    xValidity () const
    {
      return this->xValidity_;
    }

    PointType::xValidity_optional& PointType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void PointType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void PointType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void PointType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const PointType::yDecimalPlaces_optional& PointType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    PointType::yDecimalPlaces_optional& PointType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void PointType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void PointType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const PointType::ySignificantFigures_optional& PointType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    PointType::ySignificantFigures_optional& PointType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void PointType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void PointType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const PointType::yValidity_optional& PointType::
    yValidity () const
    {
      return this->yValidity_;
    }

    PointType::yValidity_optional& PointType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void PointType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void PointType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void PointType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const PointType::zDecimalPlaces_optional& PointType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    PointType::zDecimalPlaces_optional& PointType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void PointType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void PointType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const PointType::zSignificantFigures_optional& PointType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    PointType::zSignificantFigures_optional& PointType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void PointType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void PointType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const PointType::zValidity_optional& PointType::
    zValidity () const
    {
      return this->zValidity_;
    }

    PointType::zValidity_optional& PointType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void PointType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void PointType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void PointType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }


    // ActualPointType
    // 

    const ActualPointType::combinedUncertainty_optional& ActualPointType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    ActualPointType::combinedUncertainty_optional& ActualPointType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void ActualPointType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void ActualPointType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    const ActualPointType::meanError_optional& ActualPointType::
    meanError () const
    {
      return this->meanError_;
    }

    ActualPointType::meanError_optional& ActualPointType::
    meanError ()
    {
      return this->meanError_;
    }

    void ActualPointType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void ActualPointType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    const ActualPointType::xCombinedUncertainty_optional& ActualPointType::
    xCombinedUncertainty () const
    {
      return this->xCombinedUncertainty_;
    }

    ActualPointType::xCombinedUncertainty_optional& ActualPointType::
    xCombinedUncertainty ()
    {
      return this->xCombinedUncertainty_;
    }

    void ActualPointType::
    xCombinedUncertainty (const xCombinedUncertainty_type& x)
    {
      this->xCombinedUncertainty_.set (x);
    }

    void ActualPointType::
    xCombinedUncertainty (const xCombinedUncertainty_optional& x)
    {
      this->xCombinedUncertainty_ = x;
    }

    const ActualPointType::xMeanError_optional& ActualPointType::
    xMeanError () const
    {
      return this->xMeanError_;
    }

    ActualPointType::xMeanError_optional& ActualPointType::
    xMeanError ()
    {
      return this->xMeanError_;
    }

    void ActualPointType::
    xMeanError (const xMeanError_type& x)
    {
      this->xMeanError_.set (x);
    }

    void ActualPointType::
    xMeanError (const xMeanError_optional& x)
    {
      this->xMeanError_ = x;
    }

    const ActualPointType::yCombinedUncertainty_optional& ActualPointType::
    yCombinedUncertainty () const
    {
      return this->yCombinedUncertainty_;
    }

    ActualPointType::yCombinedUncertainty_optional& ActualPointType::
    yCombinedUncertainty ()
    {
      return this->yCombinedUncertainty_;
    }

    void ActualPointType::
    yCombinedUncertainty (const yCombinedUncertainty_type& x)
    {
      this->yCombinedUncertainty_.set (x);
    }

    void ActualPointType::
    yCombinedUncertainty (const yCombinedUncertainty_optional& x)
    {
      this->yCombinedUncertainty_ = x;
    }

    const ActualPointType::yMeanError_optional& ActualPointType::
    yMeanError () const
    {
      return this->yMeanError_;
    }

    ActualPointType::yMeanError_optional& ActualPointType::
    yMeanError ()
    {
      return this->yMeanError_;
    }

    void ActualPointType::
    yMeanError (const yMeanError_type& x)
    {
      this->yMeanError_.set (x);
    }

    void ActualPointType::
    yMeanError (const yMeanError_optional& x)
    {
      this->yMeanError_ = x;
    }

    const ActualPointType::zCombinedUncertainty_optional& ActualPointType::
    zCombinedUncertainty () const
    {
      return this->zCombinedUncertainty_;
    }

    ActualPointType::zCombinedUncertainty_optional& ActualPointType::
    zCombinedUncertainty ()
    {
      return this->zCombinedUncertainty_;
    }

    void ActualPointType::
    zCombinedUncertainty (const zCombinedUncertainty_type& x)
    {
      this->zCombinedUncertainty_.set (x);
    }

    void ActualPointType::
    zCombinedUncertainty (const zCombinedUncertainty_optional& x)
    {
      this->zCombinedUncertainty_ = x;
    }

    const ActualPointType::zMeanError_optional& ActualPointType::
    zMeanError () const
    {
      return this->zMeanError_;
    }

    ActualPointType::zMeanError_optional& ActualPointType::
    zMeanError ()
    {
      return this->zMeanError_;
    }

    void ActualPointType::
    zMeanError (const zMeanError_type& x)
    {
      this->zMeanError_.set (x);
    }

    void ActualPointType::
    zMeanError (const zMeanError_optional& x)
    {
      this->zMeanError_ = x;
    }


    // VectorType
    // 

    const VectorType::linearUnit_optional& VectorType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    VectorType::linearUnit_optional& VectorType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void VectorType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void VectorType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void VectorType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const VectorType::decimalPlaces_optional& VectorType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    VectorType::decimalPlaces_optional& VectorType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void VectorType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void VectorType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const VectorType::significantFigures_optional& VectorType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    VectorType::significantFigures_optional& VectorType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void VectorType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void VectorType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const VectorType::validity_optional& VectorType::
    validity () const
    {
      return this->validity_;
    }

    VectorType::validity_optional& VectorType::
    validity ()
    {
      return this->validity_;
    }

    void VectorType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void VectorType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void VectorType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const VectorType::xDecimalPlaces_optional& VectorType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    VectorType::xDecimalPlaces_optional& VectorType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void VectorType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void VectorType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const VectorType::xSignificantFigures_optional& VectorType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    VectorType::xSignificantFigures_optional& VectorType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void VectorType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void VectorType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const VectorType::xValidity_optional& VectorType::
    xValidity () const
    {
      return this->xValidity_;
    }

    VectorType::xValidity_optional& VectorType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void VectorType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void VectorType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void VectorType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const VectorType::yDecimalPlaces_optional& VectorType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    VectorType::yDecimalPlaces_optional& VectorType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void VectorType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void VectorType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const VectorType::ySignificantFigures_optional& VectorType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    VectorType::ySignificantFigures_optional& VectorType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void VectorType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void VectorType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const VectorType::yValidity_optional& VectorType::
    yValidity () const
    {
      return this->yValidity_;
    }

    VectorType::yValidity_optional& VectorType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void VectorType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void VectorType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void VectorType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const VectorType::zDecimalPlaces_optional& VectorType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    VectorType::zDecimalPlaces_optional& VectorType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void VectorType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void VectorType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const VectorType::zSignificantFigures_optional& VectorType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    VectorType::zSignificantFigures_optional& VectorType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void VectorType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void VectorType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const VectorType::zValidity_optional& VectorType::
    zValidity () const
    {
      return this->zValidity_;
    }

    VectorType::zValidity_optional& VectorType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void VectorType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void VectorType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void VectorType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }


    // UnitVectorType
    // 

    const UnitVectorType::linearUnit_optional& UnitVectorType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    UnitVectorType::linearUnit_optional& UnitVectorType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void UnitVectorType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void UnitVectorType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void UnitVectorType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const UnitVectorType::decimalPlaces_optional& UnitVectorType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    UnitVectorType::decimalPlaces_optional& UnitVectorType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void UnitVectorType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void UnitVectorType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const UnitVectorType::significantFigures_optional& UnitVectorType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    UnitVectorType::significantFigures_optional& UnitVectorType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void UnitVectorType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void UnitVectorType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const UnitVectorType::validity_optional& UnitVectorType::
    validity () const
    {
      return this->validity_;
    }

    UnitVectorType::validity_optional& UnitVectorType::
    validity ()
    {
      return this->validity_;
    }

    void UnitVectorType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void UnitVectorType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void UnitVectorType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const UnitVectorType::xDecimalPlaces_optional& UnitVectorType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    UnitVectorType::xDecimalPlaces_optional& UnitVectorType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void UnitVectorType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void UnitVectorType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const UnitVectorType::xSignificantFigures_optional& UnitVectorType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    UnitVectorType::xSignificantFigures_optional& UnitVectorType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void UnitVectorType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void UnitVectorType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const UnitVectorType::xValidity_optional& UnitVectorType::
    xValidity () const
    {
      return this->xValidity_;
    }

    UnitVectorType::xValidity_optional& UnitVectorType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void UnitVectorType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void UnitVectorType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void UnitVectorType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const UnitVectorType::yDecimalPlaces_optional& UnitVectorType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    UnitVectorType::yDecimalPlaces_optional& UnitVectorType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void UnitVectorType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void UnitVectorType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const UnitVectorType::ySignificantFigures_optional& UnitVectorType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    UnitVectorType::ySignificantFigures_optional& UnitVectorType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void UnitVectorType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void UnitVectorType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const UnitVectorType::yValidity_optional& UnitVectorType::
    yValidity () const
    {
      return this->yValidity_;
    }

    UnitVectorType::yValidity_optional& UnitVectorType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void UnitVectorType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void UnitVectorType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void UnitVectorType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const UnitVectorType::zDecimalPlaces_optional& UnitVectorType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    UnitVectorType::zDecimalPlaces_optional& UnitVectorType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void UnitVectorType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void UnitVectorType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const UnitVectorType::zSignificantFigures_optional& UnitVectorType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    UnitVectorType::zSignificantFigures_optional& UnitVectorType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void UnitVectorType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void UnitVectorType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const UnitVectorType::zValidity_optional& UnitVectorType::
    zValidity () const
    {
      return this->zValidity_;
    }

    UnitVectorType::zValidity_optional& UnitVectorType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void UnitVectorType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void UnitVectorType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void UnitVectorType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }


    // ActualUnitVectorType
    // 

    const ActualUnitVectorType::combinedUncertainty_optional& ActualUnitVectorType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    ActualUnitVectorType::combinedUncertainty_optional& ActualUnitVectorType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void ActualUnitVectorType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void ActualUnitVectorType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    const ActualUnitVectorType::meanError_optional& ActualUnitVectorType::
    meanError () const
    {
      return this->meanError_;
    }

    ActualUnitVectorType::meanError_optional& ActualUnitVectorType::
    meanError ()
    {
      return this->meanError_;
    }

    void ActualUnitVectorType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void ActualUnitVectorType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    const ActualUnitVectorType::xCombinedUncertainty_optional& ActualUnitVectorType::
    xCombinedUncertainty () const
    {
      return this->xCombinedUncertainty_;
    }

    ActualUnitVectorType::xCombinedUncertainty_optional& ActualUnitVectorType::
    xCombinedUncertainty ()
    {
      return this->xCombinedUncertainty_;
    }

    void ActualUnitVectorType::
    xCombinedUncertainty (const xCombinedUncertainty_type& x)
    {
      this->xCombinedUncertainty_.set (x);
    }

    void ActualUnitVectorType::
    xCombinedUncertainty (const xCombinedUncertainty_optional& x)
    {
      this->xCombinedUncertainty_ = x;
    }

    const ActualUnitVectorType::xMeanError_optional& ActualUnitVectorType::
    xMeanError () const
    {
      return this->xMeanError_;
    }

    ActualUnitVectorType::xMeanError_optional& ActualUnitVectorType::
    xMeanError ()
    {
      return this->xMeanError_;
    }

    void ActualUnitVectorType::
    xMeanError (const xMeanError_type& x)
    {
      this->xMeanError_.set (x);
    }

    void ActualUnitVectorType::
    xMeanError (const xMeanError_optional& x)
    {
      this->xMeanError_ = x;
    }

    const ActualUnitVectorType::yCombinedUncertainty_optional& ActualUnitVectorType::
    yCombinedUncertainty () const
    {
      return this->yCombinedUncertainty_;
    }

    ActualUnitVectorType::yCombinedUncertainty_optional& ActualUnitVectorType::
    yCombinedUncertainty ()
    {
      return this->yCombinedUncertainty_;
    }

    void ActualUnitVectorType::
    yCombinedUncertainty (const yCombinedUncertainty_type& x)
    {
      this->yCombinedUncertainty_.set (x);
    }

    void ActualUnitVectorType::
    yCombinedUncertainty (const yCombinedUncertainty_optional& x)
    {
      this->yCombinedUncertainty_ = x;
    }

    const ActualUnitVectorType::yMeanError_optional& ActualUnitVectorType::
    yMeanError () const
    {
      return this->yMeanError_;
    }

    ActualUnitVectorType::yMeanError_optional& ActualUnitVectorType::
    yMeanError ()
    {
      return this->yMeanError_;
    }

    void ActualUnitVectorType::
    yMeanError (const yMeanError_type& x)
    {
      this->yMeanError_.set (x);
    }

    void ActualUnitVectorType::
    yMeanError (const yMeanError_optional& x)
    {
      this->yMeanError_ = x;
    }

    const ActualUnitVectorType::zCombinedUncertainty_optional& ActualUnitVectorType::
    zCombinedUncertainty () const
    {
      return this->zCombinedUncertainty_;
    }

    ActualUnitVectorType::zCombinedUncertainty_optional& ActualUnitVectorType::
    zCombinedUncertainty ()
    {
      return this->zCombinedUncertainty_;
    }

    void ActualUnitVectorType::
    zCombinedUncertainty (const zCombinedUncertainty_type& x)
    {
      this->zCombinedUncertainty_.set (x);
    }

    void ActualUnitVectorType::
    zCombinedUncertainty (const zCombinedUncertainty_optional& x)
    {
      this->zCombinedUncertainty_ = x;
    }

    const ActualUnitVectorType::zMeanError_optional& ActualUnitVectorType::
    zMeanError () const
    {
      return this->zMeanError_;
    }

    ActualUnitVectorType::zMeanError_optional& ActualUnitVectorType::
    zMeanError ()
    {
      return this->zMeanError_;
    }

    void ActualUnitVectorType::
    zMeanError (const zMeanError_type& x)
    {
      this->zMeanError_.set (x);
    }

    void ActualUnitVectorType::
    zMeanError (const zMeanError_optional& x)
    {
      this->zMeanError_ = x;
    }


    // ArrayPoint2dType
    // 

    const ArrayPoint2dType::N_type& ArrayPoint2dType::
    N () const
    {
      return this->N_.get ();
    }

    ArrayPoint2dType::N_type& ArrayPoint2dType::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayPoint2dType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }


    // ArrayPointType
    // 

    const ArrayPointType::N_type& ArrayPointType::
    N () const
    {
      return this->N_.get ();
    }

    ArrayPointType::N_type& ArrayPointType::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayPointType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    const ArrayPointType::linearUnit_optional& ArrayPointType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    ArrayPointType::linearUnit_optional& ArrayPointType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void ArrayPointType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void ArrayPointType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void ArrayPointType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const ArrayPointType::decimalPlaces_optional& ArrayPointType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    ArrayPointType::decimalPlaces_optional& ArrayPointType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void ArrayPointType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void ArrayPointType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const ArrayPointType::significantFigures_optional& ArrayPointType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    ArrayPointType::significantFigures_optional& ArrayPointType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void ArrayPointType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void ArrayPointType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const ArrayPointType::validity_optional& ArrayPointType::
    validity () const
    {
      return this->validity_;
    }

    ArrayPointType::validity_optional& ArrayPointType::
    validity ()
    {
      return this->validity_;
    }

    void ArrayPointType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void ArrayPointType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void ArrayPointType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const ArrayPointType::xDecimalPlaces_optional& ArrayPointType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    ArrayPointType::xDecimalPlaces_optional& ArrayPointType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void ArrayPointType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void ArrayPointType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const ArrayPointType::xSignificantFigures_optional& ArrayPointType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    ArrayPointType::xSignificantFigures_optional& ArrayPointType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void ArrayPointType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void ArrayPointType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const ArrayPointType::xValidity_optional& ArrayPointType::
    xValidity () const
    {
      return this->xValidity_;
    }

    ArrayPointType::xValidity_optional& ArrayPointType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void ArrayPointType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void ArrayPointType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void ArrayPointType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const ArrayPointType::yDecimalPlaces_optional& ArrayPointType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    ArrayPointType::yDecimalPlaces_optional& ArrayPointType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void ArrayPointType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void ArrayPointType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const ArrayPointType::ySignificantFigures_optional& ArrayPointType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    ArrayPointType::ySignificantFigures_optional& ArrayPointType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void ArrayPointType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void ArrayPointType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const ArrayPointType::yValidity_optional& ArrayPointType::
    yValidity () const
    {
      return this->yValidity_;
    }

    ArrayPointType::yValidity_optional& ArrayPointType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void ArrayPointType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void ArrayPointType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void ArrayPointType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const ArrayPointType::zDecimalPlaces_optional& ArrayPointType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    ArrayPointType::zDecimalPlaces_optional& ArrayPointType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void ArrayPointType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void ArrayPointType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const ArrayPointType::zSignificantFigures_optional& ArrayPointType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    ArrayPointType::zSignificantFigures_optional& ArrayPointType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void ArrayPointType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void ArrayPointType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const ArrayPointType::zValidity_optional& ArrayPointType::
    zValidity () const
    {
      return this->zValidity_;
    }

    ArrayPointType::zValidity_optional& ArrayPointType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void ArrayPointType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void ArrayPointType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void ArrayPointType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }


    // ArrayUnitVectorType
    // 

    const ArrayUnitVectorType::N_type& ArrayUnitVectorType::
    N () const
    {
      return this->N_.get ();
    }

    ArrayUnitVectorType::N_type& ArrayUnitVectorType::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayUnitVectorType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    const ArrayUnitVectorType::linearUnit_optional& ArrayUnitVectorType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    ArrayUnitVectorType::linearUnit_optional& ArrayUnitVectorType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void ArrayUnitVectorType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void ArrayUnitVectorType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void ArrayUnitVectorType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const ArrayUnitVectorType::decimalPlaces_optional& ArrayUnitVectorType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    ArrayUnitVectorType::decimalPlaces_optional& ArrayUnitVectorType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void ArrayUnitVectorType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void ArrayUnitVectorType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const ArrayUnitVectorType::significantFigures_optional& ArrayUnitVectorType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    ArrayUnitVectorType::significantFigures_optional& ArrayUnitVectorType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void ArrayUnitVectorType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void ArrayUnitVectorType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const ArrayUnitVectorType::validity_optional& ArrayUnitVectorType::
    validity () const
    {
      return this->validity_;
    }

    ArrayUnitVectorType::validity_optional& ArrayUnitVectorType::
    validity ()
    {
      return this->validity_;
    }

    void ArrayUnitVectorType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void ArrayUnitVectorType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void ArrayUnitVectorType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const ArrayUnitVectorType::xDecimalPlaces_optional& ArrayUnitVectorType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    ArrayUnitVectorType::xDecimalPlaces_optional& ArrayUnitVectorType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void ArrayUnitVectorType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void ArrayUnitVectorType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const ArrayUnitVectorType::xSignificantFigures_optional& ArrayUnitVectorType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    ArrayUnitVectorType::xSignificantFigures_optional& ArrayUnitVectorType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void ArrayUnitVectorType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void ArrayUnitVectorType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const ArrayUnitVectorType::xValidity_optional& ArrayUnitVectorType::
    xValidity () const
    {
      return this->xValidity_;
    }

    ArrayUnitVectorType::xValidity_optional& ArrayUnitVectorType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void ArrayUnitVectorType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void ArrayUnitVectorType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void ArrayUnitVectorType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const ArrayUnitVectorType::yDecimalPlaces_optional& ArrayUnitVectorType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    ArrayUnitVectorType::yDecimalPlaces_optional& ArrayUnitVectorType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void ArrayUnitVectorType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void ArrayUnitVectorType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const ArrayUnitVectorType::ySignificantFigures_optional& ArrayUnitVectorType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    ArrayUnitVectorType::ySignificantFigures_optional& ArrayUnitVectorType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void ArrayUnitVectorType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void ArrayUnitVectorType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const ArrayUnitVectorType::yValidity_optional& ArrayUnitVectorType::
    yValidity () const
    {
      return this->yValidity_;
    }

    ArrayUnitVectorType::yValidity_optional& ArrayUnitVectorType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void ArrayUnitVectorType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void ArrayUnitVectorType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void ArrayUnitVectorType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const ArrayUnitVectorType::zDecimalPlaces_optional& ArrayUnitVectorType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    ArrayUnitVectorType::zDecimalPlaces_optional& ArrayUnitVectorType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void ArrayUnitVectorType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void ArrayUnitVectorType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const ArrayUnitVectorType::zSignificantFigures_optional& ArrayUnitVectorType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    ArrayUnitVectorType::zSignificantFigures_optional& ArrayUnitVectorType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void ArrayUnitVectorType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void ArrayUnitVectorType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const ArrayUnitVectorType::zValidity_optional& ArrayUnitVectorType::
    zValidity () const
    {
      return this->zValidity_;
    }

    ArrayUnitVectorType::zValidity_optional& ArrayUnitVectorType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void ArrayUnitVectorType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void ArrayUnitVectorType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void ArrayUnitVectorType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }


    // PolyLineType
    // 


    // PlaneType
    // 

    const PlaneType::Point_type& PlaneType::
    Point () const
    {
      return this->Point_.get ();
    }

    PlaneType::Point_type& PlaneType::
    Point ()
    {
      return this->Point_.get ();
    }

    void PlaneType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void PlaneType::
    Point (::std::auto_ptr< Point_type > x)
    {
      this->Point_.set (x);
    }

    const PlaneType::Normal_type& PlaneType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    PlaneType::Normal_type& PlaneType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void PlaneType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PlaneType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // ActualPlaneType
    // 

    const ActualPlaneType::Point_type& ActualPlaneType::
    Point () const
    {
      return this->Point_.get ();
    }

    ActualPlaneType::Point_type& ActualPlaneType::
    Point ()
    {
      return this->Point_.get ();
    }

    void ActualPlaneType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void ActualPlaneType::
    Point (::std::auto_ptr< Point_type > x)
    {
      this->Point_.set (x);
    }

    const ActualPlaneType::Normal_type& ActualPlaneType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    ActualPlaneType::Normal_type& ActualPlaneType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void ActualPlaneType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void ActualPlaneType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // PlaneXType
    // 

    const PlaneXType::Direction_type& PlaneXType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    PlaneXType::Direction_type& PlaneXType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void PlaneXType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void PlaneXType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }


    // AxisType
    // 

    const AxisType::AxisPoint_type& AxisType::
    AxisPoint () const
    {
      return this->AxisPoint_.get ();
    }

    AxisType::AxisPoint_type& AxisType::
    AxisPoint ()
    {
      return this->AxisPoint_.get ();
    }

    void AxisType::
    AxisPoint (const AxisPoint_type& x)
    {
      this->AxisPoint_.set (x);
    }

    void AxisType::
    AxisPoint (::std::auto_ptr< AxisPoint_type > x)
    {
      this->AxisPoint_.set (x);
    }

    const AxisType::Direction_type& AxisType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    AxisType::Direction_type& AxisType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void AxisType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void AxisType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }


    // ActualAxisType
    // 

    const ActualAxisType::AxisPoint_type& ActualAxisType::
    AxisPoint () const
    {
      return this->AxisPoint_.get ();
    }

    ActualAxisType::AxisPoint_type& ActualAxisType::
    AxisPoint ()
    {
      return this->AxisPoint_.get ();
    }

    void ActualAxisType::
    AxisPoint (const AxisPoint_type& x)
    {
      this->AxisPoint_.set (x);
    }

    void ActualAxisType::
    AxisPoint (::std::auto_ptr< AxisPoint_type > x)
    {
      this->AxisPoint_.set (x);
    }

    const ActualAxisType::Direction_type& ActualAxisType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    ActualAxisType::Direction_type& ActualAxisType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void ActualAxisType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void ActualAxisType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }


    // TransformRotationType
    // 

    const TransformRotationType::XDirection_type& TransformRotationType::
    XDirection () const
    {
      return this->XDirection_.get ();
    }

    TransformRotationType::XDirection_type& TransformRotationType::
    XDirection ()
    {
      return this->XDirection_.get ();
    }

    void TransformRotationType::
    XDirection (const XDirection_type& x)
    {
      this->XDirection_.set (x);
    }

    void TransformRotationType::
    XDirection (::std::auto_ptr< XDirection_type > x)
    {
      this->XDirection_.set (x);
    }

    const TransformRotationType::YDirection_type& TransformRotationType::
    YDirection () const
    {
      return this->YDirection_.get ();
    }

    TransformRotationType::YDirection_type& TransformRotationType::
    YDirection ()
    {
      return this->YDirection_.get ();
    }

    void TransformRotationType::
    YDirection (const YDirection_type& x)
    {
      this->YDirection_.set (x);
    }

    void TransformRotationType::
    YDirection (::std::auto_ptr< YDirection_type > x)
    {
      this->YDirection_.set (x);
    }

    const TransformRotationType::ZDirection_type& TransformRotationType::
    ZDirection () const
    {
      return this->ZDirection_.get ();
    }

    TransformRotationType::ZDirection_type& TransformRotationType::
    ZDirection ()
    {
      return this->ZDirection_.get ();
    }

    void TransformRotationType::
    ZDirection (const ZDirection_type& x)
    {
      this->ZDirection_.set (x);
    }

    void TransformRotationType::
    ZDirection (::std::auto_ptr< ZDirection_type > x)
    {
      this->ZDirection_.set (x);
    }


    // CoordinateSystemCoreType
    // 

    const CoordinateSystemCoreType::Rotation_optional& CoordinateSystemCoreType::
    Rotation () const
    {
      return this->Rotation_;
    }

    CoordinateSystemCoreType::Rotation_optional& CoordinateSystemCoreType::
    Rotation ()
    {
      return this->Rotation_;
    }

    void CoordinateSystemCoreType::
    Rotation (const Rotation_type& x)
    {
      this->Rotation_.set (x);
    }

    void CoordinateSystemCoreType::
    Rotation (const Rotation_optional& x)
    {
      this->Rotation_ = x;
    }

    void CoordinateSystemCoreType::
    Rotation (::std::auto_ptr< Rotation_type > x)
    {
      this->Rotation_.set (x);
    }

    const CoordinateSystemCoreType::Origin_optional& CoordinateSystemCoreType::
    Origin () const
    {
      return this->Origin_;
    }

    CoordinateSystemCoreType::Origin_optional& CoordinateSystemCoreType::
    Origin ()
    {
      return this->Origin_;
    }

    void CoordinateSystemCoreType::
    Origin (const Origin_type& x)
    {
      this->Origin_.set (x);
    }

    void CoordinateSystemCoreType::
    Origin (const Origin_optional& x)
    {
      this->Origin_ = x;
    }

    void CoordinateSystemCoreType::
    Origin (::std::auto_ptr< Origin_type > x)
    {
      this->Origin_.set (x);
    }


    // TransformMatrixType
    // 

    const TransformMatrixType::linearUnit_optional& TransformMatrixType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    TransformMatrixType::linearUnit_optional& TransformMatrixType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void TransformMatrixType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void TransformMatrixType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void TransformMatrixType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const TransformMatrixType::decimalPlaces_optional& TransformMatrixType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    TransformMatrixType::decimalPlaces_optional& TransformMatrixType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void TransformMatrixType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void TransformMatrixType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const TransformMatrixType::significantFigures_optional& TransformMatrixType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    TransformMatrixType::significantFigures_optional& TransformMatrixType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void TransformMatrixType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void TransformMatrixType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const TransformMatrixType::validity_optional& TransformMatrixType::
    validity () const
    {
      return this->validity_;
    }

    TransformMatrixType::validity_optional& TransformMatrixType::
    validity ()
    {
      return this->validity_;
    }

    void TransformMatrixType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void TransformMatrixType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void TransformMatrixType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const TransformMatrixType::xDecimalPlaces_optional& TransformMatrixType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    TransformMatrixType::xDecimalPlaces_optional& TransformMatrixType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void TransformMatrixType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void TransformMatrixType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const TransformMatrixType::xSignificantFigures_optional& TransformMatrixType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    TransformMatrixType::xSignificantFigures_optional& TransformMatrixType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void TransformMatrixType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void TransformMatrixType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const TransformMatrixType::xValidity_optional& TransformMatrixType::
    xValidity () const
    {
      return this->xValidity_;
    }

    TransformMatrixType::xValidity_optional& TransformMatrixType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void TransformMatrixType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void TransformMatrixType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void TransformMatrixType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const TransformMatrixType::yDecimalPlaces_optional& TransformMatrixType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    TransformMatrixType::yDecimalPlaces_optional& TransformMatrixType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void TransformMatrixType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void TransformMatrixType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const TransformMatrixType::ySignificantFigures_optional& TransformMatrixType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    TransformMatrixType::ySignificantFigures_optional& TransformMatrixType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void TransformMatrixType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void TransformMatrixType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const TransformMatrixType::yValidity_optional& TransformMatrixType::
    yValidity () const
    {
      return this->yValidity_;
    }

    TransformMatrixType::yValidity_optional& TransformMatrixType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void TransformMatrixType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void TransformMatrixType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void TransformMatrixType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const TransformMatrixType::zDecimalPlaces_optional& TransformMatrixType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    TransformMatrixType::zDecimalPlaces_optional& TransformMatrixType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void TransformMatrixType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void TransformMatrixType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const TransformMatrixType::zSignificantFigures_optional& TransformMatrixType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    TransformMatrixType::zSignificantFigures_optional& TransformMatrixType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void TransformMatrixType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void TransformMatrixType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const TransformMatrixType::zValidity_optional& TransformMatrixType::
    zValidity () const
    {
      return this->zValidity_;
    }

    TransformMatrixType::zValidity_optional& TransformMatrixType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void TransformMatrixType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void TransformMatrixType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void TransformMatrixType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }


    // LineSegmentType
    // 

    const LineSegmentType::StartPoint_type& LineSegmentType::
    StartPoint () const
    {
      return this->StartPoint_.get ();
    }

    LineSegmentType::StartPoint_type& LineSegmentType::
    StartPoint ()
    {
      return this->StartPoint_.get ();
    }

    void LineSegmentType::
    StartPoint (const StartPoint_type& x)
    {
      this->StartPoint_.set (x);
    }

    void LineSegmentType::
    StartPoint (::std::auto_ptr< StartPoint_type > x)
    {
      this->StartPoint_.set (x);
    }

    const LineSegmentType::EndPoint_type& LineSegmentType::
    EndPoint () const
    {
      return this->EndPoint_.get ();
    }

    LineSegmentType::EndPoint_type& LineSegmentType::
    EndPoint ()
    {
      return this->EndPoint_.get ();
    }

    void LineSegmentType::
    EndPoint (const EndPoint_type& x)
    {
      this->EndPoint_.set (x);
    }

    void LineSegmentType::
    EndPoint (::std::auto_ptr< EndPoint_type > x)
    {
      this->EndPoint_.set (x);
    }

    const LineSegmentType::linearUnit_optional& LineSegmentType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    LineSegmentType::linearUnit_optional& LineSegmentType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void LineSegmentType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void LineSegmentType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void LineSegmentType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const LineSegmentType::decimalPlaces_optional& LineSegmentType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    LineSegmentType::decimalPlaces_optional& LineSegmentType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void LineSegmentType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void LineSegmentType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const LineSegmentType::significantFigures_optional& LineSegmentType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    LineSegmentType::significantFigures_optional& LineSegmentType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void LineSegmentType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void LineSegmentType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const LineSegmentType::validity_optional& LineSegmentType::
    validity () const
    {
      return this->validity_;
    }

    LineSegmentType::validity_optional& LineSegmentType::
    validity ()
    {
      return this->validity_;
    }

    void LineSegmentType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void LineSegmentType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void LineSegmentType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const LineSegmentType::xDecimalPlaces_optional& LineSegmentType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    LineSegmentType::xDecimalPlaces_optional& LineSegmentType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void LineSegmentType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void LineSegmentType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const LineSegmentType::xSignificantFigures_optional& LineSegmentType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    LineSegmentType::xSignificantFigures_optional& LineSegmentType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void LineSegmentType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void LineSegmentType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const LineSegmentType::xValidity_optional& LineSegmentType::
    xValidity () const
    {
      return this->xValidity_;
    }

    LineSegmentType::xValidity_optional& LineSegmentType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void LineSegmentType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void LineSegmentType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void LineSegmentType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const LineSegmentType::yDecimalPlaces_optional& LineSegmentType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    LineSegmentType::yDecimalPlaces_optional& LineSegmentType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void LineSegmentType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void LineSegmentType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const LineSegmentType::ySignificantFigures_optional& LineSegmentType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    LineSegmentType::ySignificantFigures_optional& LineSegmentType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void LineSegmentType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void LineSegmentType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const LineSegmentType::yValidity_optional& LineSegmentType::
    yValidity () const
    {
      return this->yValidity_;
    }

    LineSegmentType::yValidity_optional& LineSegmentType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void LineSegmentType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void LineSegmentType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void LineSegmentType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const LineSegmentType::zDecimalPlaces_optional& LineSegmentType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    LineSegmentType::zDecimalPlaces_optional& LineSegmentType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void LineSegmentType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void LineSegmentType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const LineSegmentType::zSignificantFigures_optional& LineSegmentType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    LineSegmentType::zSignificantFigures_optional& LineSegmentType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void LineSegmentType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void LineSegmentType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const LineSegmentType::zValidity_optional& LineSegmentType::
    zValidity () const
    {
      return this->zValidity_;
    }

    LineSegmentType::zValidity_optional& LineSegmentType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void LineSegmentType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void LineSegmentType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void LineSegmentType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }


    // LineSegment2dType
    // 

    const LineSegment2dType::StartPoint_type& LineSegment2dType::
    StartPoint () const
    {
      return this->StartPoint_.get ();
    }

    LineSegment2dType::StartPoint_type& LineSegment2dType::
    StartPoint ()
    {
      return this->StartPoint_.get ();
    }

    void LineSegment2dType::
    StartPoint (const StartPoint_type& x)
    {
      this->StartPoint_.set (x);
    }

    void LineSegment2dType::
    StartPoint (::std::auto_ptr< StartPoint_type > x)
    {
      this->StartPoint_.set (x);
    }

    const LineSegment2dType::EndPoint_type& LineSegment2dType::
    EndPoint () const
    {
      return this->EndPoint_.get ();
    }

    LineSegment2dType::EndPoint_type& LineSegment2dType::
    EndPoint ()
    {
      return this->EndPoint_.get ();
    }

    void LineSegment2dType::
    EndPoint (const EndPoint_type& x)
    {
      this->EndPoint_.set (x);
    }

    void LineSegment2dType::
    EndPoint (::std::auto_ptr< EndPoint_type > x)
    {
      this->EndPoint_.set (x);
    }


    // LatitudeLongitudeSweepType
    // 

    const LatitudeLongitudeSweepType::DirMeridianPrime_type& LatitudeLongitudeSweepType::
    DirMeridianPrime () const
    {
      return this->DirMeridianPrime_.get ();
    }

    LatitudeLongitudeSweepType::DirMeridianPrime_type& LatitudeLongitudeSweepType::
    DirMeridianPrime ()
    {
      return this->DirMeridianPrime_.get ();
    }

    void LatitudeLongitudeSweepType::
    DirMeridianPrime (const DirMeridianPrime_type& x)
    {
      this->DirMeridianPrime_.set (x);
    }

    void LatitudeLongitudeSweepType::
    DirMeridianPrime (::std::auto_ptr< DirMeridianPrime_type > x)
    {
      this->DirMeridianPrime_.set (x);
    }

    const LatitudeLongitudeSweepType::DomainLatitude_type& LatitudeLongitudeSweepType::
    DomainLatitude () const
    {
      return this->DomainLatitude_.get ();
    }

    LatitudeLongitudeSweepType::DomainLatitude_type& LatitudeLongitudeSweepType::
    DomainLatitude ()
    {
      return this->DomainLatitude_.get ();
    }

    void LatitudeLongitudeSweepType::
    DomainLatitude (const DomainLatitude_type& x)
    {
      this->DomainLatitude_.set (x);
    }

    void LatitudeLongitudeSweepType::
    DomainLatitude (::std::auto_ptr< DomainLatitude_type > x)
    {
      this->DomainLatitude_.set (x);
    }

    const LatitudeLongitudeSweepType::DomainLongitude_type& LatitudeLongitudeSweepType::
    DomainLongitude () const
    {
      return this->DomainLongitude_.get ();
    }

    LatitudeLongitudeSweepType::DomainLongitude_type& LatitudeLongitudeSweepType::
    DomainLongitude ()
    {
      return this->DomainLongitude_.get ();
    }

    void LatitudeLongitudeSweepType::
    DomainLongitude (const DomainLongitude_type& x)
    {
      this->DomainLongitude_.set (x);
    }

    void LatitudeLongitudeSweepType::
    DomainLongitude (::std::auto_ptr< DomainLongitude_type > x)
    {
      this->DomainLongitude_.set (x);
    }


    // OrientedLatitudeLongitudeSweepType
    // 

    const OrientedLatitudeLongitudeSweepType::DirNorthPole_type& OrientedLatitudeLongitudeSweepType::
    DirNorthPole () const
    {
      return this->DirNorthPole_.get ();
    }

    OrientedLatitudeLongitudeSweepType::DirNorthPole_type& OrientedLatitudeLongitudeSweepType::
    DirNorthPole ()
    {
      return this->DirNorthPole_.get ();
    }

    void OrientedLatitudeLongitudeSweepType::
    DirNorthPole (const DirNorthPole_type& x)
    {
      this->DirNorthPole_.set (x);
    }

    void OrientedLatitudeLongitudeSweepType::
    DirNorthPole (::std::auto_ptr< DirNorthPole_type > x)
    {
      this->DirNorthPole_.set (x);
    }


    // SweepType
    // 

    const SweepType::DirBeg_type& SweepType::
    DirBeg () const
    {
      return this->DirBeg_.get ();
    }

    SweepType::DirBeg_type& SweepType::
    DirBeg ()
    {
      return this->DirBeg_.get ();
    }

    void SweepType::
    DirBeg (const DirBeg_type& x)
    {
      this->DirBeg_.set (x);
    }

    void SweepType::
    DirBeg (::std::auto_ptr< DirBeg_type > x)
    {
      this->DirBeg_.set (x);
    }

    const SweepType::DomainAngle_type& SweepType::
    DomainAngle () const
    {
      return this->DomainAngle_.get ();
    }

    SweepType::DomainAngle_type& SweepType::
    DomainAngle ()
    {
      return this->DomainAngle_.get ();
    }

    void SweepType::
    DomainAngle (const DomainAngle_type& x)
    {
      this->DomainAngle_.set (x);
    }

    void SweepType::
    DomainAngle (::std::auto_ptr< DomainAngle_type > x)
    {
      this->DomainAngle_.set (x);
    }


    // AngleRangeType
    // 

    const AngleRangeType::angularUnit_optional& AngleRangeType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    AngleRangeType::angularUnit_optional& AngleRangeType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void AngleRangeType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void AngleRangeType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void AngleRangeType::
    angularUnit (::std::auto_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (x);
    }


    // QIFIdType
    // 


    // QIFReferenceType
    // 


    // QIFReferenceFullType
    // 

    const QIFReferenceFullType::asmPath_optional& QIFReferenceFullType::
    asmPath () const
    {
      return this->asmPath_;
    }

    QIFReferenceFullType::asmPath_optional& QIFReferenceFullType::
    asmPath ()
    {
      return this->asmPath_;
    }

    void QIFReferenceFullType::
    asmPath (const asmPath_type& x)
    {
      this->asmPath_.set (x);
    }

    void QIFReferenceFullType::
    asmPath (const asmPath_optional& x)
    {
      this->asmPath_ = x;
    }

    void QIFReferenceFullType::
    asmPath (::std::auto_ptr< asmPath_type > x)
    {
      this->asmPath_.set (x);
    }


    // ElementReferenceType
    // 

    const ElementReferenceType::Id_type& ElementReferenceType::
    Id () const
    {
      return this->Id_.get ();
    }

    ElementReferenceType::Id_type& ElementReferenceType::
    Id ()
    {
      return this->Id_.get ();
    }

    void ElementReferenceType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void ElementReferenceType::
    Id (::std::auto_ptr< Id_type > x)
    {
      this->Id_.set (x);
    }


    // ElementReferenceFullType
    // 

    const ElementReferenceFullType::Id_type& ElementReferenceFullType::
    Id () const
    {
      return this->Id_.get ();
    }

    ElementReferenceFullType::Id_type& ElementReferenceFullType::
    Id ()
    {
      return this->Id_.get ();
    }

    void ElementReferenceFullType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void ElementReferenceFullType::
    Id (::std::auto_ptr< Id_type > x)
    {
      this->Id_.set (x);
    }


    // D4Type
    // 


    // NaturalType
    // 


    // ListNaturalType
    //

    ListNaturalType::
    ListNaturalType ()
    : ::xsd::cxx::tree::list< ::xsd::qif2::NaturalType, char > ( ::xml_schema::flags (0), this)
    {
    }

    ListNaturalType::
    ListNaturalType (size_type n, const ::xsd::qif2::NaturalType& x)
    : ::xsd::cxx::tree::list< ::xsd::qif2::NaturalType, char > (n, x, this)
    {
    }

    ListNaturalType::
    ListNaturalType (const ListNaturalType& o,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif2::NaturalType, char > (o, f, this)
    {
    }

    // ArrayNaturalType
    // 

    const ArrayNaturalType::N_type& ArrayNaturalType::
    N () const
    {
      return this->N_.get ();
    }

    ArrayNaturalType::N_type& ArrayNaturalType::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayNaturalType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }


    // ArrayReferenceType
    // 

    const ArrayReferenceType::Id_sequence& ArrayReferenceType::
    Id () const
    {
      return this->Id_;
    }

    ArrayReferenceType::Id_sequence& ArrayReferenceType::
    Id ()
    {
      return this->Id_;
    }

    void ArrayReferenceType::
    Id (const Id_sequence& s)
    {
      this->Id_ = s;
    }

    const ArrayReferenceType::N_type& ArrayReferenceType::
    N () const
    {
      return this->N_.get ();
    }

    ArrayReferenceType::N_type& ArrayReferenceType::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayReferenceType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void ArrayReferenceType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // ArrayReferenceFullType
    // 

    const ArrayReferenceFullType::Id_sequence& ArrayReferenceFullType::
    Id () const
    {
      return this->Id_;
    }

    ArrayReferenceFullType::Id_sequence& ArrayReferenceFullType::
    Id ()
    {
      return this->Id_;
    }

    void ArrayReferenceFullType::
    Id (const Id_sequence& s)
    {
      this->Id_ = s;
    }

    const ArrayReferenceFullType::N_type& ArrayReferenceFullType::
    N () const
    {
      return this->N_.get ();
    }

    ArrayReferenceFullType::N_type& ArrayReferenceFullType::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayReferenceFullType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void ArrayReferenceFullType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // ListBoolType
    //

    ListBoolType::
    ListBoolType ()
    : ::xsd::cxx::tree::list< ::xml_schema::boolean, char > ( ::xml_schema::flags (0), this)
    {
    }

    ListBoolType::
    ListBoolType (size_type n, const ::xml_schema::boolean& x)
    : ::xsd::cxx::tree::list< ::xml_schema::boolean, char > (n, x, this)
    {
    }

    ListBoolType::
    ListBoolType (const ListBoolType& o,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::boolean, char > (o, f, this)
    {
    }

    // ListUnsignedByteType
    //

    ListUnsignedByteType::
    ListUnsignedByteType ()
    : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > ( ::xml_schema::flags (0), this)
    {
    }

    ListUnsignedByteType::
    ListUnsignedByteType (size_type n, const ::xml_schema::unsigned_byte& x)
    : ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (n, x, this)
    {
    }

    ListUnsignedByteType::
    ListUnsignedByteType (const ListUnsignedByteType& o,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (o, f, this)
    {
    }

    // QPIdType
    // 


    // QPIdReferenceType
    // 


    // QPIdFullReferenceType
    // 

    const QPIdFullReferenceType::ItemQPId_type& QPIdFullReferenceType::
    ItemQPId () const
    {
      return this->ItemQPId_.get ();
    }

    QPIdFullReferenceType::ItemQPId_type& QPIdFullReferenceType::
    ItemQPId ()
    {
      return this->ItemQPId_.get ();
    }

    void QPIdFullReferenceType::
    ItemQPId (const ItemQPId_type& x)
    {
      this->ItemQPId_.set (x);
    }

    void QPIdFullReferenceType::
    ItemQPId (::std::auto_ptr< ItemQPId_type > x)
    {
      this->ItemQPId_.set (x);
    }

    const QPIdFullReferenceType::DocumentQPId_sequence& QPIdFullReferenceType::
    DocumentQPId () const
    {
      return this->DocumentQPId_;
    }

    QPIdFullReferenceType::DocumentQPId_sequence& QPIdFullReferenceType::
    DocumentQPId ()
    {
      return this->DocumentQPId_;
    }

    void QPIdFullReferenceType::
    DocumentQPId (const DocumentQPId_sequence& s)
    {
      this->DocumentQPId_ = s;
    }


    // ArrayUnsignedByteType
    // 

    const ArrayUnsignedByteType::N_type& ArrayUnsignedByteType::
    N () const
    {
      return this->N_.get ();
    }

    ArrayUnsignedByteType::N_type& ArrayUnsignedByteType::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayUnsignedByteType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }


    // ArrayIntType
    // 

    const ArrayIntType::N_type& ArrayIntType::
    N () const
    {
      return this->N_.get ();
    }

    ArrayIntType::N_type& ArrayIntType::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayIntType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }


    // ArrayI2Type
    // 

    const ArrayI2Type::N_type& ArrayI2Type::
    N () const
    {
      return this->N_.get ();
    }

    ArrayI2Type::N_type& ArrayI2Type::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayI2Type::
    N (const N_type& x)
    {
      this->N_.set (x);
    }


    // ArrayI3Type
    // 

    const ArrayI3Type::N_type& ArrayI3Type::
    N () const
    {
      return this->N_.get ();
    }

    ArrayI3Type::N_type& ArrayI3Type::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayI3Type::
    N (const N_type& x)
    {
      this->N_.set (x);
    }


    // ArrayDoubleType
    // 

    const ArrayDoubleType::N_type& ArrayDoubleType::
    N () const
    {
      return this->N_.get ();
    }

    ArrayDoubleType::N_type& ArrayDoubleType::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayDoubleType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }


    // ArrayBinaryType
    // 

    const ArrayBinaryType::N_type& ArrayBinaryType::
    N () const
    {
      return this->N_.get ();
    }

    ArrayBinaryType::N_type& ArrayBinaryType::
    N ()
    {
      return this->N_.get ();
    }

    void ArrayBinaryType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    const ArrayBinaryType::sizeElement_type& ArrayBinaryType::
    sizeElement () const
    {
      return this->sizeElement_.get ();
    }

    ArrayBinaryType::sizeElement_type& ArrayBinaryType::
    sizeElement ()
    {
      return this->sizeElement_.get ();
    }

    void ArrayBinaryType::
    sizeElement (const sizeElement_type& x)
    {
      this->sizeElement_.set (x);
    }


    // AttributesType
    // 

    const AttributesType::Attribute_sequence& AttributesType::
    Attribute () const
    {
      return this->Attribute_;
    }

    AttributesType::Attribute_sequence& AttributesType::
    Attribute ()
    {
      return this->Attribute_;
    }

    void AttributesType::
    Attribute (const Attribute_sequence& s)
    {
      this->Attribute_ = s;
    }

    const AttributesType::N_type& AttributesType::
    N () const
    {
      return this->N_.get ();
    }

    AttributesType::N_type& AttributesType::
    N ()
    {
      return this->N_.get ();
    }

    void AttributesType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void AttributesType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // AttributeBaseType
    // 

    const AttributeBaseType::name_type& AttributeBaseType::
    name () const
    {
      return this->name_.get ();
    }

    AttributeBaseType::name_type& AttributeBaseType::
    name ()
    {
      return this->name_.get ();
    }

    void AttributeBaseType::
    name (const name_type& x)
    {
      this->name_.set (x);
    }

    void AttributeBaseType::
    name (::std::auto_ptr< name_type > x)
    {
      this->name_.set (x);
    }


    // AttributeBoolType
    // 

    const AttributeBoolType::value_type& AttributeBoolType::
    value () const
    {
      return this->value_.get ();
    }

    AttributeBoolType::value_type& AttributeBoolType::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeBoolType::
    value (const value_type& x)
    {
      this->value_.set (x);
    }


    // AttributeStrType
    // 

    const AttributeStrType::value_type& AttributeStrType::
    value () const
    {
      return this->value_.get ();
    }

    AttributeStrType::value_type& AttributeStrType::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeStrType::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AttributeStrType::
    value (::std::auto_ptr< value_type > x)
    {
      this->value_.set (x);
    }


    // AttributeQPIdType
    // 

    const AttributeQPIdType::value_type& AttributeQPIdType::
    value () const
    {
      return this->value_.get ();
    }

    AttributeQPIdType::value_type& AttributeQPIdType::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeQPIdType::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AttributeQPIdType::
    value (::std::auto_ptr< value_type > x)
    {
      this->value_.set (x);
    }


    // AttributeI1Type
    // 

    const AttributeI1Type::value_type& AttributeI1Type::
    value () const
    {
      return this->value_.get ();
    }

    AttributeI1Type::value_type& AttributeI1Type::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeI1Type::
    value (const value_type& x)
    {
      this->value_.set (x);
    }


    // AttributeI2Type
    // 

    const AttributeI2Type::value_type& AttributeI2Type::
    value () const
    {
      return this->value_.get ();
    }

    AttributeI2Type::value_type& AttributeI2Type::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeI2Type::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AttributeI2Type::
    value (::std::auto_ptr< value_type > x)
    {
      this->value_.set (x);
    }


    // AttributeD1Type
    // 

    const AttributeD1Type::value_type& AttributeD1Type::
    value () const
    {
      return this->value_.get ();
    }

    AttributeD1Type::value_type& AttributeD1Type::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeD1Type::
    value (const value_type& x)
    {
      this->value_.set (x);
    }


    // AttributeD3Type
    // 

    const AttributeD3Type::value_type& AttributeD3Type::
    value () const
    {
      return this->value_.get ();
    }

    AttributeD3Type::value_type& AttributeD3Type::
    value ()
    {
      return this->value_.get ();
    }

    void AttributeD3Type::
    value (const value_type& x)
    {
      this->value_.set (x);
    }

    void AttributeD3Type::
    value (::std::auto_ptr< value_type > x)
    {
      this->value_.set (x);
    }


    // AttributeUserType
    // 

    const AttributeUserType::UserDataXML_optional& AttributeUserType::
    UserDataXML () const
    {
      return this->UserDataXML_;
    }

    AttributeUserType::UserDataXML_optional& AttributeUserType::
    UserDataXML ()
    {
      return this->UserDataXML_;
    }

    void AttributeUserType::
    UserDataXML (const UserDataXML_type& x)
    {
      this->UserDataXML_.set (x);
    }

    void AttributeUserType::
    UserDataXML (const UserDataXML_optional& x)
    {
      this->UserDataXML_ = x;
    }

    void AttributeUserType::
    UserDataXML (::std::auto_ptr< UserDataXML_type > x)
    {
      this->UserDataXML_.set (x);
    }

    const AttributeUserType::UserDataBinary_optional& AttributeUserType::
    UserDataBinary () const
    {
      return this->UserDataBinary_;
    }

    AttributeUserType::UserDataBinary_optional& AttributeUserType::
    UserDataBinary ()
    {
      return this->UserDataBinary_;
    }

    void AttributeUserType::
    UserDataBinary (const UserDataBinary_type& x)
    {
      this->UserDataBinary_.set (x);
    }

    void AttributeUserType::
    UserDataBinary (const UserDataBinary_optional& x)
    {
      this->UserDataBinary_ = x;
    }

    void AttributeUserType::
    UserDataBinary (::std::auto_ptr< UserDataBinary_type > x)
    {
      this->UserDataBinary_.set (x);
    }

    const AttributeUserType::nameUserAttribute_type& AttributeUserType::
    nameUserAttribute () const
    {
      return this->nameUserAttribute_.get ();
    }

    AttributeUserType::nameUserAttribute_type& AttributeUserType::
    nameUserAttribute ()
    {
      return this->nameUserAttribute_.get ();
    }

    void AttributeUserType::
    nameUserAttribute (const nameUserAttribute_type& x)
    {
      this->nameUserAttribute_.set (x);
    }

    void AttributeUserType::
    nameUserAttribute (::std::auto_ptr< nameUserAttribute_type > x)
    {
      this->nameUserAttribute_.set (x);
    }


    // UserDataXMLType
    // 
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace xsd
{
  namespace qif2
  {
    // BinaryDataType
    //

    BinaryDataType::
    BinaryDataType (const N_type& N)
    : ::xml_schema::base64_binary (),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    BinaryDataType::
    BinaryDataType (const ::xml_schema::base64_binary& _xsd_base64_binary_base,
                    const N_type& N)
    : ::xml_schema::base64_binary (_xsd_base64_binary_base),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    BinaryDataType::
    BinaryDataType (const BinaryDataType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::base64_binary (x, f, c),
      N_ (x.N_, f, this)
    {
    }

    BinaryDataType::
    BinaryDataType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::base64_binary (e, f | ::xml_schema::flags::base, c),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void BinaryDataType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    BinaryDataType* BinaryDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BinaryDataType (*this, f, c);
    }

    BinaryDataType::
    ~BinaryDataType ()
    {
    }

    // ListIntType
    //

    ListIntType::
    ListIntType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::integer, char > (e, f, this)
    {
    }

    ListIntType::
    ListIntType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::integer, char > (a, f, this)
    {
    }

    ListIntType::
    ListIntType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::integer, char > (s, e, f, this)
    {
    }

    ListIntType* ListIntType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListIntType (*this, f, c);
    }

    ListIntType::
    ~ListIntType ()
    {
    }

    // I2Type
    //

    I2Type::
    I2Type ()
    : ::xsd::qif2::ListIntType ()
    {
    }

    I2Type::
    I2Type (const ::xsd::qif2::ListIntType& _xsd_ListIntType_base)
    : ::xsd::qif2::ListIntType (_xsd_ListIntType_base)
    {
    }

    I2Type::
    I2Type (const I2Type& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListIntType (x, f, c)
    {
    }

    I2Type::
    I2Type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListIntType (e, f, c)
    {
    }

    I2Type::
    I2Type (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListIntType (a, f, c)
    {
    }

    I2Type::
    I2Type (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListIntType (s, e, f, c)
    {
    }

    I2Type* I2Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class I2Type (*this, f, c);
    }

    I2Type::
    ~I2Type ()
    {
    }

    // ListDoubleType
    //

    ListDoubleType::
    ListDoubleType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (e, f, this)
    {
    }

    ListDoubleType::
    ListDoubleType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (a, f, this)
    {
    }

    ListDoubleType::
    ListDoubleType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::double_, char, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, this)
    {
    }

    ListDoubleType* ListDoubleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListDoubleType (*this, f, c);
    }

    ListDoubleType::
    ~ListDoubleType ()
    {
    }

    // D3Type
    //

    D3Type::
    D3Type ()
    : ::xsd::qif2::ListDoubleType ()
    {
    }

    D3Type::
    D3Type (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    D3Type::
    D3Type (const D3Type& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c)
    {
    }

    D3Type::
    D3Type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f, c)
    {
    }

    D3Type::
    D3Type (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (a, f, c)
    {
    }

    D3Type::
    D3Type (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (s, e, f, c)
    {
    }

    D3Type* D3Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class D3Type (*this, f, c);
    }

    D3Type::
    ~D3Type ()
    {
    }

    // D2Type
    //

    D2Type::
    D2Type ()
    : ::xsd::qif2::ListDoubleType ()
    {
    }

    D2Type::
    D2Type (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    D2Type::
    D2Type (const D2Type& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c)
    {
    }

    D2Type::
    D2Type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f, c)
    {
    }

    D2Type::
    D2Type (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (a, f, c)
    {
    }

    D2Type::
    D2Type (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (s, e, f, c)
    {
    }

    D2Type* D2Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class D2Type (*this, f, c);
    }

    D2Type::
    ~D2Type ()
    {
    }

    // DoublePositiveType
    //

    DoublePositiveType::
    DoublePositiveType (const ::xml_schema::double_& _xsd_double__base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
    {
    }

    DoublePositiveType::
    DoublePositiveType (const DoublePositiveType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
    {
    }

    DoublePositiveType::
    DoublePositiveType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
    {
    }

    DoublePositiveType::
    DoublePositiveType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
    {
    }

    DoublePositiveType::
    DoublePositiveType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
    {
    }

    DoublePositiveType* DoublePositiveType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DoublePositiveType (*this, f, c);
    }

    DoublePositiveType::
    ~DoublePositiveType ()
    {
    }

    // Point2dSimpleType
    //

    Point2dSimpleType::
    Point2dSimpleType ()
    : ::xsd::qif2::ListDoubleType ()
    {
    }

    Point2dSimpleType::
    Point2dSimpleType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    Point2dSimpleType::
    Point2dSimpleType (const Point2dSimpleType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c)
    {
    }

    Point2dSimpleType::
    Point2dSimpleType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f, c)
    {
    }

    Point2dSimpleType::
    Point2dSimpleType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (a, f, c)
    {
    }

    Point2dSimpleType::
    Point2dSimpleType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (s, e, f, c)
    {
    }

    Point2dSimpleType* Point2dSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Point2dSimpleType (*this, f, c);
    }

    Point2dSimpleType::
    ~Point2dSimpleType ()
    {
    }

    // UnitVector2dSimpleType
    //

    UnitVector2dSimpleType::
    UnitVector2dSimpleType ()
    : ::xsd::qif2::ListDoubleType ()
    {
    }

    UnitVector2dSimpleType::
    UnitVector2dSimpleType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    UnitVector2dSimpleType::
    UnitVector2dSimpleType (const UnitVector2dSimpleType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c)
    {
    }

    UnitVector2dSimpleType::
    UnitVector2dSimpleType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f, c)
    {
    }

    UnitVector2dSimpleType::
    UnitVector2dSimpleType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (a, f, c)
    {
    }

    UnitVector2dSimpleType::
    UnitVector2dSimpleType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (s, e, f, c)
    {
    }

    UnitVector2dSimpleType* UnitVector2dSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnitVector2dSimpleType (*this, f, c);
    }

    UnitVector2dSimpleType::
    ~UnitVector2dSimpleType ()
    {
    }

    // ParameterRangeType
    //

    ParameterRangeType::
    ParameterRangeType ()
    : ::xsd::qif2::ListDoubleType ()
    {
    }

    ParameterRangeType::
    ParameterRangeType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    ParameterRangeType::
    ParameterRangeType (const ParameterRangeType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c)
    {
    }

    ParameterRangeType::
    ParameterRangeType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f, c)
    {
    }

    ParameterRangeType::
    ParameterRangeType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (a, f, c)
    {
    }

    ParameterRangeType::
    ParameterRangeType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (s, e, f, c)
    {
    }

    ParameterRangeType* ParameterRangeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ParameterRangeType (*this, f, c);
    }

    ParameterRangeType::
    ~ParameterRangeType ()
    {
    }

    // PointSimpleType
    //

    PointSimpleType::
    PointSimpleType ()
    : ::xsd::qif2::ListDoubleType ()
    {
    }

    PointSimpleType::
    PointSimpleType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    PointSimpleType::
    PointSimpleType (const PointSimpleType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c)
    {
    }

    PointSimpleType::
    PointSimpleType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f, c)
    {
    }

    PointSimpleType::
    PointSimpleType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (a, f, c)
    {
    }

    PointSimpleType::
    PointSimpleType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (s, e, f, c)
    {
    }

    PointSimpleType* PointSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointSimpleType (*this, f, c);
    }

    PointSimpleType::
    ~PointSimpleType ()
    {
    }

    // VectorSimpleType
    //

    VectorSimpleType::
    VectorSimpleType ()
    : ::xsd::qif2::ListDoubleType ()
    {
    }

    VectorSimpleType::
    VectorSimpleType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    VectorSimpleType::
    VectorSimpleType (const VectorSimpleType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c)
    {
    }

    VectorSimpleType::
    VectorSimpleType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f, c)
    {
    }

    VectorSimpleType::
    VectorSimpleType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (a, f, c)
    {
    }

    VectorSimpleType::
    VectorSimpleType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (s, e, f, c)
    {
    }

    VectorSimpleType* VectorSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VectorSimpleType (*this, f, c);
    }

    VectorSimpleType::
    ~VectorSimpleType ()
    {
    }

    // UnitVectorSimpleType
    //

    UnitVectorSimpleType::
    UnitVectorSimpleType ()
    : ::xsd::qif2::ListDoubleType ()
    {
    }

    UnitVectorSimpleType::
    UnitVectorSimpleType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    UnitVectorSimpleType::
    UnitVectorSimpleType (const UnitVectorSimpleType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c)
    {
    }

    UnitVectorSimpleType::
    UnitVectorSimpleType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f, c)
    {
    }

    UnitVectorSimpleType::
    UnitVectorSimpleType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (a, f, c)
    {
    }

    UnitVectorSimpleType::
    UnitVectorSimpleType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (s, e, f, c)
    {
    }

    UnitVectorSimpleType* UnitVectorSimpleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnitVectorSimpleType (*this, f, c);
    }

    UnitVectorSimpleType::
    ~UnitVectorSimpleType ()
    {
    }

    // ValidityEnumType
    //

    ValidityEnumType::
    ValidityEnumType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_ValidityEnumType_convert ();
    }

    ValidityEnumType::
    ValidityEnumType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_ValidityEnumType_convert ();
    }

    ValidityEnumType::
    ValidityEnumType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_ValidityEnumType_convert ();
    }

    ValidityEnumType* ValidityEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ValidityEnumType (*this, f, c);
    }

    ValidityEnumType::value ValidityEnumType::
    _xsd_ValidityEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ValidityEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ValidityEnumType_indexes_,
                        _xsd_ValidityEnumType_indexes_ + 5,
                        *this,
                        c));

      if (i == _xsd_ValidityEnumType_indexes_ + 5 || _xsd_ValidityEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ValidityEnumType::
    _xsd_ValidityEnumType_literals_[5] =
    {
      "REPORTED",
      "DUMMY",
      "MOOT",
      "DERIVED",
      "SET"
    };

    const ValidityEnumType::value ValidityEnumType::
    _xsd_ValidityEnumType_indexes_[5] =
    {
      ::xsd::qif2::ValidityEnumType::DERIVED,
      ::xsd::qif2::ValidityEnumType::DUMMY,
      ::xsd::qif2::ValidityEnumType::MOOT,
      ::xsd::qif2::ValidityEnumType::REPORTED,
      ::xsd::qif2::ValidityEnumType::SET
    };

    // PointType
    //

    PointType::
    PointType ()
    : ::xsd::qif2::PointSimpleType (),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    PointType::
    PointType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::PointSimpleType (_xsd_ListDoubleType_base),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    PointType::
    PointType (const PointType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::PointSimpleType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    PointType::
    PointType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::PointSimpleType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (f, this),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this),
      validity_ (f, this),
      xDecimalPlaces_ (f, this),
      xSignificantFigures_ (f, this),
      xValidity_ (f, this),
      yDecimalPlaces_ (f, this),
      ySignificantFigures_ (f, this),
      yValidity_ (f, this),
      zDecimalPlaces_ (f, this),
      zSignificantFigures_ (f, this),
      zValidity_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void PointType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validity_type > r (
            validity_traits::create (i, f, this));

          this->validity_.set (r);
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< xValidity_type > r (
            xValidity_traits::create (i, f, this));

          this->xValidity_.set (r);
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< yValidity_type > r (
            yValidity_traits::create (i, f, this));

          this->yValidity_.set (r);
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< zValidity_type > r (
            zValidity_traits::create (i, f, this));

          this->zValidity_.set (r);
          continue;
        }
      }
    }

    PointType* PointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointType (*this, f, c);
    }

    PointType::
    ~PointType ()
    {
    }

    // ActualPointType
    //

    ActualPointType::
    ActualPointType ()
    : ::xsd::qif2::PointType (),
      combinedUncertainty_ (::xml_schema::flags (), this),
      meanError_ (::xml_schema::flags (), this),
      xCombinedUncertainty_ (::xml_schema::flags (), this),
      xMeanError_ (::xml_schema::flags (), this),
      yCombinedUncertainty_ (::xml_schema::flags (), this),
      yMeanError_ (::xml_schema::flags (), this),
      zCombinedUncertainty_ (::xml_schema::flags (), this),
      zMeanError_ (::xml_schema::flags (), this)
    {
    }

    ActualPointType::
    ActualPointType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::PointType (_xsd_ListDoubleType_base),
      combinedUncertainty_ (::xml_schema::flags (), this),
      meanError_ (::xml_schema::flags (), this),
      xCombinedUncertainty_ (::xml_schema::flags (), this),
      xMeanError_ (::xml_schema::flags (), this),
      yCombinedUncertainty_ (::xml_schema::flags (), this),
      yMeanError_ (::xml_schema::flags (), this),
      zCombinedUncertainty_ (::xml_schema::flags (), this),
      zMeanError_ (::xml_schema::flags (), this)
    {
    }

    ActualPointType::
    ActualPointType (const ActualPointType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::PointType (x, f, c),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this),
      xCombinedUncertainty_ (x.xCombinedUncertainty_, f, this),
      xMeanError_ (x.xMeanError_, f, this),
      yCombinedUncertainty_ (x.yCombinedUncertainty_, f, this),
      yMeanError_ (x.yMeanError_, f, this),
      zCombinedUncertainty_ (x.zCombinedUncertainty_, f, this),
      zMeanError_ (x.zMeanError_, f, this)
    {
    }

    ActualPointType::
    ActualPointType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::PointType (e, f | ::xml_schema::flags::base, c),
      combinedUncertainty_ (f, this),
      meanError_ (f, this),
      xCombinedUncertainty_ (f, this),
      xMeanError_ (f, this),
      yCombinedUncertainty_ (f, this),
      yMeanError_ (f, this),
      zCombinedUncertainty_ (f, this),
      zMeanError_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualPointType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::PointType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->xCombinedUncertainty_.set (xCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xMeanError" && n.namespace_ ().empty ())
        {
          this->xMeanError_.set (xMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->yCombinedUncertainty_.set (yCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yMeanError" && n.namespace_ ().empty ())
        {
          this->yMeanError_.set (yMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->zCombinedUncertainty_.set (zCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zMeanError" && n.namespace_ ().empty ())
        {
          this->zMeanError_.set (zMeanError_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualPointType* ActualPointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualPointType (*this, f, c);
    }

    ActualPointType::
    ~ActualPointType ()
    {
    }

    // VectorType
    //

    VectorType::
    VectorType ()
    : ::xsd::qif2::VectorSimpleType (),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    VectorType::
    VectorType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::VectorSimpleType (_xsd_ListDoubleType_base),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    VectorType::
    VectorType (const VectorType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::VectorSimpleType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    VectorType::
    VectorType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::VectorSimpleType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (f, this),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this),
      validity_ (f, this),
      xDecimalPlaces_ (f, this),
      xSignificantFigures_ (f, this),
      xValidity_ (f, this),
      yDecimalPlaces_ (f, this),
      ySignificantFigures_ (f, this),
      yValidity_ (f, this),
      zDecimalPlaces_ (f, this),
      zSignificantFigures_ (f, this),
      zValidity_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void VectorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validity_type > r (
            validity_traits::create (i, f, this));

          this->validity_.set (r);
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< xValidity_type > r (
            xValidity_traits::create (i, f, this));

          this->xValidity_.set (r);
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< yValidity_type > r (
            yValidity_traits::create (i, f, this));

          this->yValidity_.set (r);
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< zValidity_type > r (
            zValidity_traits::create (i, f, this));

          this->zValidity_.set (r);
          continue;
        }
      }
    }

    VectorType* VectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VectorType (*this, f, c);
    }

    VectorType::
    ~VectorType ()
    {
    }

    // UnitVectorType
    //

    UnitVectorType::
    UnitVectorType ()
    : ::xsd::qif2::UnitVectorSimpleType (),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    UnitVectorType::
    UnitVectorType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::UnitVectorSimpleType (_xsd_ListDoubleType_base),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    UnitVectorType::
    UnitVectorType (const UnitVectorType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::UnitVectorSimpleType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    UnitVectorType::
    UnitVectorType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::UnitVectorSimpleType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (f, this),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this),
      validity_ (f, this),
      xDecimalPlaces_ (f, this),
      xSignificantFigures_ (f, this),
      xValidity_ (f, this),
      yDecimalPlaces_ (f, this),
      ySignificantFigures_ (f, this),
      yValidity_ (f, this),
      zDecimalPlaces_ (f, this),
      zSignificantFigures_ (f, this),
      zValidity_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void UnitVectorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validity_type > r (
            validity_traits::create (i, f, this));

          this->validity_.set (r);
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< xValidity_type > r (
            xValidity_traits::create (i, f, this));

          this->xValidity_.set (r);
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< yValidity_type > r (
            yValidity_traits::create (i, f, this));

          this->yValidity_.set (r);
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< zValidity_type > r (
            zValidity_traits::create (i, f, this));

          this->zValidity_.set (r);
          continue;
        }
      }
    }

    UnitVectorType* UnitVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnitVectorType (*this, f, c);
    }

    UnitVectorType::
    ~UnitVectorType ()
    {
    }

    // ActualUnitVectorType
    //

    ActualUnitVectorType::
    ActualUnitVectorType ()
    : ::xsd::qif2::UnitVectorType (),
      combinedUncertainty_ (::xml_schema::flags (), this),
      meanError_ (::xml_schema::flags (), this),
      xCombinedUncertainty_ (::xml_schema::flags (), this),
      xMeanError_ (::xml_schema::flags (), this),
      yCombinedUncertainty_ (::xml_schema::flags (), this),
      yMeanError_ (::xml_schema::flags (), this),
      zCombinedUncertainty_ (::xml_schema::flags (), this),
      zMeanError_ (::xml_schema::flags (), this)
    {
    }

    ActualUnitVectorType::
    ActualUnitVectorType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::UnitVectorType (_xsd_ListDoubleType_base),
      combinedUncertainty_ (::xml_schema::flags (), this),
      meanError_ (::xml_schema::flags (), this),
      xCombinedUncertainty_ (::xml_schema::flags (), this),
      xMeanError_ (::xml_schema::flags (), this),
      yCombinedUncertainty_ (::xml_schema::flags (), this),
      yMeanError_ (::xml_schema::flags (), this),
      zCombinedUncertainty_ (::xml_schema::flags (), this),
      zMeanError_ (::xml_schema::flags (), this)
    {
    }

    ActualUnitVectorType::
    ActualUnitVectorType (const ActualUnitVectorType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::UnitVectorType (x, f, c),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this),
      xCombinedUncertainty_ (x.xCombinedUncertainty_, f, this),
      xMeanError_ (x.xMeanError_, f, this),
      yCombinedUncertainty_ (x.yCombinedUncertainty_, f, this),
      yMeanError_ (x.yMeanError_, f, this),
      zCombinedUncertainty_ (x.zCombinedUncertainty_, f, this),
      zMeanError_ (x.zMeanError_, f, this)
    {
    }

    ActualUnitVectorType::
    ActualUnitVectorType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::UnitVectorType (e, f | ::xml_schema::flags::base, c),
      combinedUncertainty_ (f, this),
      meanError_ (f, this),
      xCombinedUncertainty_ (f, this),
      xMeanError_ (f, this),
      yCombinedUncertainty_ (f, this),
      yMeanError_ (f, this),
      zCombinedUncertainty_ (f, this),
      zMeanError_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualUnitVectorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::UnitVectorType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->xCombinedUncertainty_.set (xCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xMeanError" && n.namespace_ ().empty ())
        {
          this->xMeanError_.set (xMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->yCombinedUncertainty_.set (yCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yMeanError" && n.namespace_ ().empty ())
        {
          this->yMeanError_.set (yMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->zCombinedUncertainty_.set (zCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zMeanError" && n.namespace_ ().empty ())
        {
          this->zMeanError_.set (zMeanError_traits::create (i, f, this));
          continue;
        }
      }
    }

    ActualUnitVectorType* ActualUnitVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualUnitVectorType (*this, f, c);
    }

    ActualUnitVectorType::
    ~ActualUnitVectorType ()
    {
    }

    // ArrayPoint2dType
    //

    ArrayPoint2dType::
    ArrayPoint2dType (const N_type& N)
    : ::xsd::qif2::ListDoubleType (),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayPoint2dType::
    ArrayPoint2dType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base,
                      const N_type& N)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayPoint2dType::
    ArrayPoint2dType (const ArrayPoint2dType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c),
      N_ (x.N_, f, this)
    {
    }

    ArrayPoint2dType::
    ArrayPoint2dType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f | ::xml_schema::flags::base, c),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ArrayPoint2dType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ArrayPoint2dType* ArrayPoint2dType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayPoint2dType (*this, f, c);
    }

    ArrayPoint2dType::
    ~ArrayPoint2dType ()
    {
    }

    // ArrayPointType
    //

    ArrayPointType::
    ArrayPointType (const N_type& N)
    : ::xsd::qif2::ListDoubleType (),
      N_ (N, ::xml_schema::flags (), this),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    ArrayPointType::
    ArrayPointType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base,
                    const N_type& N)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base),
      N_ (N, ::xml_schema::flags (), this),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    ArrayPointType::
    ArrayPointType (const ArrayPointType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c),
      N_ (x.N_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    ArrayPointType::
    ArrayPointType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f | ::xml_schema::flags::base, c),
      N_ (f, this),
      linearUnit_ (f, this),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this),
      validity_ (f, this),
      xDecimalPlaces_ (f, this),
      xSignificantFigures_ (f, this),
      xValidity_ (f, this),
      yDecimalPlaces_ (f, this),
      ySignificantFigures_ (f, this),
      yValidity_ (f, this),
      zDecimalPlaces_ (f, this),
      zSignificantFigures_ (f, this),
      zValidity_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ArrayPointType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validity_type > r (
            validity_traits::create (i, f, this));

          this->validity_.set (r);
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< xValidity_type > r (
            xValidity_traits::create (i, f, this));

          this->xValidity_.set (r);
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< yValidity_type > r (
            yValidity_traits::create (i, f, this));

          this->yValidity_.set (r);
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< zValidity_type > r (
            zValidity_traits::create (i, f, this));

          this->zValidity_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ArrayPointType* ArrayPointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayPointType (*this, f, c);
    }

    ArrayPointType::
    ~ArrayPointType ()
    {
    }

    // ArrayUnitVectorType
    //

    ArrayUnitVectorType::
    ArrayUnitVectorType (const N_type& N)
    : ::xsd::qif2::ListDoubleType (),
      N_ (N, ::xml_schema::flags (), this),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    ArrayUnitVectorType::
    ArrayUnitVectorType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base,
                         const N_type& N)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base),
      N_ (N, ::xml_schema::flags (), this),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    ArrayUnitVectorType::
    ArrayUnitVectorType (const ArrayUnitVectorType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c),
      N_ (x.N_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    ArrayUnitVectorType::
    ArrayUnitVectorType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f | ::xml_schema::flags::base, c),
      N_ (f, this),
      linearUnit_ (f, this),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this),
      validity_ (f, this),
      xDecimalPlaces_ (f, this),
      xSignificantFigures_ (f, this),
      xValidity_ (f, this),
      yDecimalPlaces_ (f, this),
      ySignificantFigures_ (f, this),
      yValidity_ (f, this),
      zDecimalPlaces_ (f, this),
      zSignificantFigures_ (f, this),
      zValidity_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ArrayUnitVectorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validity_type > r (
            validity_traits::create (i, f, this));

          this->validity_.set (r);
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< xValidity_type > r (
            xValidity_traits::create (i, f, this));

          this->xValidity_.set (r);
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< yValidity_type > r (
            yValidity_traits::create (i, f, this));

          this->yValidity_.set (r);
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< zValidity_type > r (
            zValidity_traits::create (i, f, this));

          this->zValidity_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ArrayUnitVectorType* ArrayUnitVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayUnitVectorType (*this, f, c);
    }

    ArrayUnitVectorType::
    ~ArrayUnitVectorType ()
    {
    }

    // PolyLineType
    //

    PolyLineType::
    PolyLineType (const N_type& N)
    : ::xsd::qif2::ArrayPointType (N)
    {
    }

    PolyLineType::
    PolyLineType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base,
                  const N_type& N)
    : ::xsd::qif2::ArrayPointType (_xsd_ListDoubleType_base,
                                   N)
    {
    }

    PolyLineType::
    PolyLineType (const PolyLineType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ArrayPointType (x, f, c)
    {
    }

    PolyLineType::
    PolyLineType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ArrayPointType (e, f, c)
    {
    }

    PolyLineType* PolyLineType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PolyLineType (*this, f, c);
    }

    PolyLineType::
    ~PolyLineType ()
    {
    }

    // PlaneType
    //

    PlaneType::
    PlaneType (const Point_type& Point,
               const Normal_type& Normal)
    : ::xml_schema::type (),
      Point_ (Point, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    PlaneType::
    PlaneType (::std::auto_ptr< Point_type >& Point,
               ::std::auto_ptr< Normal_type >& Normal)
    : ::xml_schema::type (),
      Point_ (Point, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    PlaneType::
    PlaneType (const PlaneType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Point_ (x.Point_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    PlaneType::
    PlaneType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Point_ (f, this),
      Normal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Point
        //
        if (n.name () == "Point" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Point",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneType* PlaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneType (*this, f, c);
    }

    PlaneType::
    ~PlaneType ()
    {
    }

    // ActualPlaneType
    //

    ActualPlaneType::
    ActualPlaneType (const Point_type& Point,
                     const Normal_type& Normal)
    : ::xml_schema::type (),
      Point_ (Point, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    ActualPlaneType::
    ActualPlaneType (::std::auto_ptr< Point_type >& Point,
                     ::std::auto_ptr< Normal_type >& Normal)
    : ::xml_schema::type (),
      Point_ (Point, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    ActualPlaneType::
    ActualPlaneType (const ActualPlaneType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Point_ (x.Point_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    ActualPlaneType::
    ActualPlaneType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Point_ (f, this),
      Normal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ActualPlaneType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Point
        //
        if (n.name () == "Point" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Point",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ActualPlaneType* ActualPlaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualPlaneType (*this, f, c);
    }

    ActualPlaneType::
    ~ActualPlaneType ()
    {
    }

    // PlaneXType
    //

    PlaneXType::
    PlaneXType (const Point_type& Point,
                const Normal_type& Normal,
                const Direction_type& Direction)
    : ::xsd::qif2::PlaneType (Point,
                              Normal),
      Direction_ (Direction, ::xml_schema::flags (), this)
    {
    }

    PlaneXType::
    PlaneXType (::std::auto_ptr< Point_type >& Point,
                ::std::auto_ptr< Normal_type >& Normal,
                ::std::auto_ptr< Direction_type >& Direction)
    : ::xsd::qif2::PlaneType (Point,
                              Normal),
      Direction_ (Direction, ::xml_schema::flags (), this)
    {
    }

    PlaneXType::
    PlaneXType (const PlaneXType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::PlaneType (x, f, c),
      Direction_ (x.Direction_, f, this)
    {
    }

    PlaneXType::
    PlaneXType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::PlaneType (e, f | ::xml_schema::flags::base, c),
      Direction_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneXType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::PlaneType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Direction",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneXType* PlaneXType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneXType (*this, f, c);
    }

    PlaneXType::
    ~PlaneXType ()
    {
    }

    // AxisType
    //

    AxisType::
    AxisType (const AxisPoint_type& AxisPoint,
              const Direction_type& Direction)
    : ::xml_schema::type (),
      AxisPoint_ (AxisPoint, ::xml_schema::flags (), this),
      Direction_ (Direction, ::xml_schema::flags (), this)
    {
    }

    AxisType::
    AxisType (::std::auto_ptr< AxisPoint_type >& AxisPoint,
              ::std::auto_ptr< Direction_type >& Direction)
    : ::xml_schema::type (),
      AxisPoint_ (AxisPoint, ::xml_schema::flags (), this),
      Direction_ (Direction, ::xml_schema::flags (), this)
    {
    }

    AxisType::
    AxisType (const AxisType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AxisPoint_ (x.AxisPoint_, f, this),
      Direction_ (x.Direction_, f, this)
    {
    }

    AxisType::
    AxisType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AxisPoint_ (f, this),
      Direction_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void AxisType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AxisPoint
        //
        if (n.name () == "AxisPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisPoint_type > r (
            AxisPoint_traits::create (i, f, this));

          if (!AxisPoint_.present ())
          {
            this->AxisPoint_.set (r);
            continue;
          }
        }

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (r);
            continue;
          }
        }

        break;
      }

      if (!AxisPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AxisPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Direction",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AxisType* AxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AxisType (*this, f, c);
    }

    AxisType::
    ~AxisType ()
    {
    }

    // ActualAxisType
    //

    ActualAxisType::
    ActualAxisType (const AxisPoint_type& AxisPoint,
                    const Direction_type& Direction)
    : ::xml_schema::type (),
      AxisPoint_ (AxisPoint, ::xml_schema::flags (), this),
      Direction_ (Direction, ::xml_schema::flags (), this)
    {
    }

    ActualAxisType::
    ActualAxisType (::std::auto_ptr< AxisPoint_type >& AxisPoint,
                    ::std::auto_ptr< Direction_type >& Direction)
    : ::xml_schema::type (),
      AxisPoint_ (AxisPoint, ::xml_schema::flags (), this),
      Direction_ (Direction, ::xml_schema::flags (), this)
    {
    }

    ActualAxisType::
    ActualAxisType (const ActualAxisType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AxisPoint_ (x.AxisPoint_, f, this),
      Direction_ (x.Direction_, f, this)
    {
    }

    ActualAxisType::
    ActualAxisType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AxisPoint_ (f, this),
      Direction_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ActualAxisType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AxisPoint
        //
        if (n.name () == "AxisPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisPoint_type > r (
            AxisPoint_traits::create (i, f, this));

          if (!AxisPoint_.present ())
          {
            this->AxisPoint_.set (r);
            continue;
          }
        }

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (r);
            continue;
          }
        }

        break;
      }

      if (!AxisPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AxisPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Direction",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ActualAxisType* ActualAxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualAxisType (*this, f, c);
    }

    ActualAxisType::
    ~ActualAxisType ()
    {
    }

    // TransformRotationType
    //

    TransformRotationType::
    TransformRotationType (const XDirection_type& XDirection,
                           const YDirection_type& YDirection,
                           const ZDirection_type& ZDirection)
    : ::xml_schema::type (),
      XDirection_ (XDirection, ::xml_schema::flags (), this),
      YDirection_ (YDirection, ::xml_schema::flags (), this),
      ZDirection_ (ZDirection, ::xml_schema::flags (), this)
    {
    }

    TransformRotationType::
    TransformRotationType (const TransformRotationType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      XDirection_ (x.XDirection_, f, this),
      YDirection_ (x.YDirection_, f, this),
      ZDirection_ (x.ZDirection_, f, this)
    {
    }

    TransformRotationType::
    TransformRotationType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      XDirection_ (f, this),
      YDirection_ (f, this),
      ZDirection_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TransformRotationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // XDirection
        //
        if (n.name () == "XDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< XDirection_type > r (
            XDirection_traits::create (i, f, this));

          if (!XDirection_.present ())
          {
            this->XDirection_.set (r);
            continue;
          }
        }

        // YDirection
        //
        if (n.name () == "YDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< YDirection_type > r (
            YDirection_traits::create (i, f, this));

          if (!YDirection_.present ())
          {
            this->YDirection_.set (r);
            continue;
          }
        }

        // ZDirection
        //
        if (n.name () == "ZDirection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ZDirection_type > r (
            ZDirection_traits::create (i, f, this));

          if (!ZDirection_.present ())
          {
            this->ZDirection_.set (r);
            continue;
          }
        }

        break;
      }

      if (!XDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "XDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!YDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "YDirection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ZDirection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ZDirection",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TransformRotationType* TransformRotationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformRotationType (*this, f, c);
    }

    TransformRotationType::
    ~TransformRotationType ()
    {
    }

    // CoordinateSystemCoreType
    //

    CoordinateSystemCoreType::
    CoordinateSystemCoreType ()
    : ::xml_schema::type (),
      Rotation_ (::xml_schema::flags (), this),
      Origin_ (::xml_schema::flags (), this)
    {
    }

    CoordinateSystemCoreType::
    CoordinateSystemCoreType (const CoordinateSystemCoreType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Rotation_ (x.Rotation_, f, this),
      Origin_ (x.Origin_, f, this)
    {
    }

    CoordinateSystemCoreType::
    CoordinateSystemCoreType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Rotation_ (f, this),
      Origin_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CoordinateSystemCoreType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Rotation
        //
        if (n.name () == "Rotation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Rotation_type > r (
            Rotation_traits::create (i, f, this));

          if (!this->Rotation_)
          {
            this->Rotation_.set (r);
            continue;
          }
        }

        // Origin
        //
        if (n.name () == "Origin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Origin_type > r (
            Origin_traits::create (i, f, this));

          if (!this->Origin_)
          {
            this->Origin_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CoordinateSystemCoreType* CoordinateSystemCoreType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoordinateSystemCoreType (*this, f, c);
    }

    CoordinateSystemCoreType::
    ~CoordinateSystemCoreType ()
    {
    }

    // TransformMatrixType
    //

    TransformMatrixType::
    TransformMatrixType ()
    : ::xsd::qif2::CoordinateSystemCoreType (),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    TransformMatrixType::
    TransformMatrixType (const TransformMatrixType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::CoordinateSystemCoreType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    TransformMatrixType::
    TransformMatrixType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::CoordinateSystemCoreType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (f, this),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this),
      validity_ (f, this),
      xDecimalPlaces_ (f, this),
      xSignificantFigures_ (f, this),
      xValidity_ (f, this),
      yDecimalPlaces_ (f, this),
      ySignificantFigures_ (f, this),
      yValidity_ (f, this),
      zDecimalPlaces_ (f, this),
      zSignificantFigures_ (f, this),
      zValidity_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void TransformMatrixType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::CoordinateSystemCoreType::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validity_type > r (
            validity_traits::create (i, f, this));

          this->validity_.set (r);
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< xValidity_type > r (
            xValidity_traits::create (i, f, this));

          this->xValidity_.set (r);
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< yValidity_type > r (
            yValidity_traits::create (i, f, this));

          this->yValidity_.set (r);
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< zValidity_type > r (
            zValidity_traits::create (i, f, this));

          this->zValidity_.set (r);
          continue;
        }
      }
    }

    TransformMatrixType* TransformMatrixType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformMatrixType (*this, f, c);
    }

    TransformMatrixType::
    ~TransformMatrixType ()
    {
    }

    // LineSegmentType
    //

    LineSegmentType::
    LineSegmentType (const StartPoint_type& StartPoint,
                     const EndPoint_type& EndPoint)
    : ::xml_schema::type (),
      StartPoint_ (StartPoint, ::xml_schema::flags (), this),
      EndPoint_ (EndPoint, ::xml_schema::flags (), this),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    LineSegmentType::
    LineSegmentType (const LineSegmentType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StartPoint_ (x.StartPoint_, f, this),
      EndPoint_ (x.EndPoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    LineSegmentType::
    LineSegmentType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StartPoint_ (f, this),
      EndPoint_ (f, this),
      linearUnit_ (f, this),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this),
      validity_ (f, this),
      xDecimalPlaces_ (f, this),
      xSignificantFigures_ (f, this),
      xValidity_ (f, this),
      yDecimalPlaces_ (f, this),
      ySignificantFigures_ (f, this),
      yValidity_ (f, this),
      zDecimalPlaces_ (f, this),
      zSignificantFigures_ (f, this),
      zValidity_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void LineSegmentType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // StartPoint
        //
        if (n.name () == "StartPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< StartPoint_type > r (
            StartPoint_traits::create (i, f, this));

          if (!StartPoint_.present ())
          {
            this->StartPoint_.set (r);
            continue;
          }
        }

        // EndPoint
        //
        if (n.name () == "EndPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndPoint_type > r (
            EndPoint_traits::create (i, f, this));

          if (!EndPoint_.present ())
          {
            this->EndPoint_.set (r);
            continue;
          }
        }

        break;
      }

      if (!StartPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "StartPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!EndPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validity_type > r (
            validity_traits::create (i, f, this));

          this->validity_.set (r);
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< xValidity_type > r (
            xValidity_traits::create (i, f, this));

          this->xValidity_.set (r);
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< yValidity_type > r (
            yValidity_traits::create (i, f, this));

          this->yValidity_.set (r);
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< zValidity_type > r (
            zValidity_traits::create (i, f, this));

          this->zValidity_.set (r);
          continue;
        }
      }
    }

    LineSegmentType* LineSegmentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineSegmentType (*this, f, c);
    }

    LineSegmentType::
    ~LineSegmentType ()
    {
    }

    // LineSegment2dType
    //

    LineSegment2dType::
    LineSegment2dType (const StartPoint_type& StartPoint,
                       const EndPoint_type& EndPoint)
    : ::xml_schema::type (),
      StartPoint_ (StartPoint, ::xml_schema::flags (), this),
      EndPoint_ (EndPoint, ::xml_schema::flags (), this)
    {
    }

    LineSegment2dType::
    LineSegment2dType (const LineSegment2dType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      StartPoint_ (x.StartPoint_, f, this),
      EndPoint_ (x.EndPoint_, f, this)
    {
    }

    LineSegment2dType::
    LineSegment2dType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      StartPoint_ (f, this),
      EndPoint_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineSegment2dType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // StartPoint
        //
        if (n.name () == "StartPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< StartPoint_type > r (
            StartPoint_traits::create (i, f, this));

          if (!StartPoint_.present ())
          {
            this->StartPoint_.set (r);
            continue;
          }
        }

        // EndPoint
        //
        if (n.name () == "EndPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndPoint_type > r (
            EndPoint_traits::create (i, f, this));

          if (!EndPoint_.present ())
          {
            this->EndPoint_.set (r);
            continue;
          }
        }

        break;
      }

      if (!StartPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "StartPoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!EndPoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndPoint",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineSegment2dType* LineSegment2dType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineSegment2dType (*this, f, c);
    }

    LineSegment2dType::
    ~LineSegment2dType ()
    {
    }

    // LatitudeLongitudeSweepType
    //

    LatitudeLongitudeSweepType::
    LatitudeLongitudeSweepType (const DirMeridianPrime_type& DirMeridianPrime,
                                const DomainLatitude_type& DomainLatitude,
                                const DomainLongitude_type& DomainLongitude)
    : ::xml_schema::type (),
      DirMeridianPrime_ (DirMeridianPrime, ::xml_schema::flags (), this),
      DomainLatitude_ (DomainLatitude, ::xml_schema::flags (), this),
      DomainLongitude_ (DomainLongitude, ::xml_schema::flags (), this)
    {
    }

    LatitudeLongitudeSweepType::
    LatitudeLongitudeSweepType (::std::auto_ptr< DirMeridianPrime_type >& DirMeridianPrime,
                                ::std::auto_ptr< DomainLatitude_type >& DomainLatitude,
                                ::std::auto_ptr< DomainLongitude_type >& DomainLongitude)
    : ::xml_schema::type (),
      DirMeridianPrime_ (DirMeridianPrime, ::xml_schema::flags (), this),
      DomainLatitude_ (DomainLatitude, ::xml_schema::flags (), this),
      DomainLongitude_ (DomainLongitude, ::xml_schema::flags (), this)
    {
    }

    LatitudeLongitudeSweepType::
    LatitudeLongitudeSweepType (const LatitudeLongitudeSweepType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DirMeridianPrime_ (x.DirMeridianPrime_, f, this),
      DomainLatitude_ (x.DomainLatitude_, f, this),
      DomainLongitude_ (x.DomainLongitude_, f, this)
    {
    }

    LatitudeLongitudeSweepType::
    LatitudeLongitudeSweepType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DirMeridianPrime_ (f, this),
      DomainLatitude_ (f, this),
      DomainLongitude_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LatitudeLongitudeSweepType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DirMeridianPrime
        //
        if (n.name () == "DirMeridianPrime" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DirMeridianPrime_type > r (
            DirMeridianPrime_traits::create (i, f, this));

          if (!DirMeridianPrime_.present ())
          {
            this->DirMeridianPrime_.set (r);
            continue;
          }
        }

        // DomainLatitude
        //
        if (n.name () == "DomainLatitude" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DomainLatitude_type > r (
            DomainLatitude_traits::create (i, f, this));

          if (!DomainLatitude_.present ())
          {
            this->DomainLatitude_.set (r);
            continue;
          }
        }

        // DomainLongitude
        //
        if (n.name () == "DomainLongitude" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DomainLongitude_type > r (
            DomainLongitude_traits::create (i, f, this));

          if (!DomainLongitude_.present ())
          {
            this->DomainLongitude_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DirMeridianPrime_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DirMeridianPrime",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!DomainLatitude_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DomainLatitude",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!DomainLongitude_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DomainLongitude",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LatitudeLongitudeSweepType* LatitudeLongitudeSweepType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LatitudeLongitudeSweepType (*this, f, c);
    }

    LatitudeLongitudeSweepType::
    ~LatitudeLongitudeSweepType ()
    {
    }

    // OrientedLatitudeLongitudeSweepType
    //

    OrientedLatitudeLongitudeSweepType::
    OrientedLatitudeLongitudeSweepType (const DirMeridianPrime_type& DirMeridianPrime,
                                        const DomainLatitude_type& DomainLatitude,
                                        const DomainLongitude_type& DomainLongitude,
                                        const DirNorthPole_type& DirNorthPole)
    : ::xsd::qif2::LatitudeLongitudeSweepType (DirMeridianPrime,
                                               DomainLatitude,
                                               DomainLongitude),
      DirNorthPole_ (DirNorthPole, ::xml_schema::flags (), this)
    {
    }

    OrientedLatitudeLongitudeSweepType::
    OrientedLatitudeLongitudeSweepType (::std::auto_ptr< DirMeridianPrime_type >& DirMeridianPrime,
                                        ::std::auto_ptr< DomainLatitude_type >& DomainLatitude,
                                        ::std::auto_ptr< DomainLongitude_type >& DomainLongitude,
                                        ::std::auto_ptr< DirNorthPole_type >& DirNorthPole)
    : ::xsd::qif2::LatitudeLongitudeSweepType (DirMeridianPrime,
                                               DomainLatitude,
                                               DomainLongitude),
      DirNorthPole_ (DirNorthPole, ::xml_schema::flags (), this)
    {
    }

    OrientedLatitudeLongitudeSweepType::
    OrientedLatitudeLongitudeSweepType (const OrientedLatitudeLongitudeSweepType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::LatitudeLongitudeSweepType (x, f, c),
      DirNorthPole_ (x.DirNorthPole_, f, this)
    {
    }

    OrientedLatitudeLongitudeSweepType::
    OrientedLatitudeLongitudeSweepType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::LatitudeLongitudeSweepType (e, f | ::xml_schema::flags::base, c),
      DirNorthPole_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OrientedLatitudeLongitudeSweepType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::LatitudeLongitudeSweepType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DirNorthPole
        //
        if (n.name () == "DirNorthPole" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DirNorthPole_type > r (
            DirNorthPole_traits::create (i, f, this));

          if (!DirNorthPole_.present ())
          {
            this->DirNorthPole_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DirNorthPole_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DirNorthPole",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OrientedLatitudeLongitudeSweepType* OrientedLatitudeLongitudeSweepType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrientedLatitudeLongitudeSweepType (*this, f, c);
    }

    OrientedLatitudeLongitudeSweepType::
    ~OrientedLatitudeLongitudeSweepType ()
    {
    }

    // SweepType
    //

    SweepType::
    SweepType (const DirBeg_type& DirBeg,
               const DomainAngle_type& DomainAngle)
    : ::xml_schema::type (),
      DirBeg_ (DirBeg, ::xml_schema::flags (), this),
      DomainAngle_ (DomainAngle, ::xml_schema::flags (), this)
    {
    }

    SweepType::
    SweepType (::std::auto_ptr< DirBeg_type >& DirBeg,
               ::std::auto_ptr< DomainAngle_type >& DomainAngle)
    : ::xml_schema::type (),
      DirBeg_ (DirBeg, ::xml_schema::flags (), this),
      DomainAngle_ (DomainAngle, ::xml_schema::flags (), this)
    {
    }

    SweepType::
    SweepType (const SweepType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DirBeg_ (x.DirBeg_, f, this),
      DomainAngle_ (x.DomainAngle_, f, this)
    {
    }

    SweepType::
    SweepType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DirBeg_ (f, this),
      DomainAngle_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SweepType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DirBeg
        //
        if (n.name () == "DirBeg" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DirBeg_type > r (
            DirBeg_traits::create (i, f, this));

          if (!DirBeg_.present ())
          {
            this->DirBeg_.set (r);
            continue;
          }
        }

        // DomainAngle
        //
        if (n.name () == "DomainAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DomainAngle_type > r (
            DomainAngle_traits::create (i, f, this));

          if (!DomainAngle_.present ())
          {
            this->DomainAngle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DirBeg_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DirBeg",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!DomainAngle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DomainAngle",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SweepType* SweepType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SweepType (*this, f, c);
    }

    SweepType::
    ~SweepType ()
    {
    }

    // AngleRangeType
    //

    AngleRangeType::
    AngleRangeType ()
    : ::xsd::qif2::D2Type (),
      angularUnit_ (::xml_schema::flags (), this)
    {
    }

    AngleRangeType::
    AngleRangeType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::D2Type (_xsd_ListDoubleType_base),
      angularUnit_ (::xml_schema::flags (), this)
    {
    }

    AngleRangeType::
    AngleRangeType (const AngleRangeType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::D2Type (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    AngleRangeType::
    AngleRangeType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::D2Type (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void AngleRangeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "angularUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< angularUnit_type > r (
            angularUnit_traits::create (i, f, this));

          this->angularUnit_.set (r);
          continue;
        }
      }
    }

    AngleRangeType* AngleRangeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngleRangeType (*this, f, c);
    }

    AngleRangeType::
    ~AngleRangeType ()
    {
    }

    // QIFIdType
    //

    QIFIdType::
    QIFIdType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
    {
    }

    QIFIdType::
    QIFIdType (const QIFIdType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    QIFIdType::
    QIFIdType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    QIFIdType::
    QIFIdType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    QIFIdType::
    QIFIdType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    QIFIdType* QIFIdType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFIdType (*this, f, c);
    }

    QIFIdType::
    ~QIFIdType ()
    {
    }

    // QIFReferenceType
    //

    QIFReferenceType::
    QIFReferenceType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::qif2::QIFIdType (_xsd_unsigned_int_base)
    {
    }

    QIFReferenceType::
    QIFReferenceType (const QIFReferenceType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::QIFIdType (x, f, c)
    {
    }

    QIFReferenceType::
    QIFReferenceType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::QIFIdType (e, f, c)
    {
    }

    QIFReferenceType::
    QIFReferenceType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::QIFIdType (a, f, c)
    {
    }

    QIFReferenceType::
    QIFReferenceType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::QIFIdType (s, e, f, c)
    {
    }

    QIFReferenceType* QIFReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFReferenceType (*this, f, c);
    }

    QIFReferenceType::
    ~QIFReferenceType ()
    {
    }

    // QIFReferenceFullType
    //

    QIFReferenceFullType::
    QIFReferenceFullType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::qif2::QIFReferenceType (_xsd_unsigned_int_base),
      asmPath_ (::xml_schema::flags (), this)
    {
    }

    QIFReferenceFullType::
    QIFReferenceFullType (const QIFReferenceFullType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::QIFReferenceType (x, f, c),
      asmPath_ (x.asmPath_, f, this)
    {
    }

    QIFReferenceFullType::
    QIFReferenceFullType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::QIFReferenceType (e, f | ::xml_schema::flags::base, c),
      asmPath_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void QIFReferenceFullType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "asmPath" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< asmPath_type > r (
            asmPath_traits::create (i, f, this));

          this->asmPath_.set (r);
          continue;
        }
      }
    }

    QIFReferenceFullType* QIFReferenceFullType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QIFReferenceFullType (*this, f, c);
    }

    QIFReferenceFullType::
    ~QIFReferenceFullType ()
    {
    }

    // ElementReferenceType
    //

    ElementReferenceType::
    ElementReferenceType (const Id_type& Id)
    : ::xml_schema::type (),
      Id_ (Id, ::xml_schema::flags (), this)
    {
    }

    ElementReferenceType::
    ElementReferenceType (const ElementReferenceType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Id_ (x.Id_, f, this)
    {
    }

    ElementReferenceType::
    ElementReferenceType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElementReferenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Id
        //
        if (n.name () == "Id" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          if (!Id_.present ())
          {
            this->Id_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Id",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElementReferenceType* ElementReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElementReferenceType (*this, f, c);
    }

    ElementReferenceType::
    ~ElementReferenceType ()
    {
    }

    // ElementReferenceFullType
    //

    ElementReferenceFullType::
    ElementReferenceFullType (const Id_type& Id)
    : ::xml_schema::type (),
      Id_ (Id, ::xml_schema::flags (), this)
    {
    }

    ElementReferenceFullType::
    ElementReferenceFullType (::std::auto_ptr< Id_type >& Id)
    : ::xml_schema::type (),
      Id_ (Id, ::xml_schema::flags (), this)
    {
    }

    ElementReferenceFullType::
    ElementReferenceFullType (const ElementReferenceFullType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Id_ (x.Id_, f, this)
    {
    }

    ElementReferenceFullType::
    ElementReferenceFullType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElementReferenceFullType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Id
        //
        if (n.name () == "Id" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          if (!Id_.present ())
          {
            this->Id_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Id",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElementReferenceFullType* ElementReferenceFullType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElementReferenceFullType (*this, f, c);
    }

    ElementReferenceFullType::
    ~ElementReferenceFullType ()
    {
    }

    // D4Type
    //

    D4Type::
    D4Type ()
    : ::xsd::qif2::ListDoubleType ()
    {
    }

    D4Type::
    D4Type (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base)
    {
    }

    D4Type::
    D4Type (const D4Type& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c)
    {
    }

    D4Type::
    D4Type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f, c)
    {
    }

    D4Type::
    D4Type (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (a, f, c)
    {
    }

    D4Type::
    D4Type (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (s, e, f, c)
    {
    }

    D4Type* D4Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class D4Type (*this, f, c);
    }

    D4Type::
    ~D4Type ()
    {
    }

    // NaturalType
    //

    NaturalType::
    NaturalType (const ::xml_schema::unsigned_int& _xsd_unsigned_int_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (_xsd_unsigned_int_base)
    {
    }

    NaturalType::
    NaturalType (const NaturalType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (x, f, c)
    {
    }

    NaturalType::
    NaturalType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (e, f, c)
    {
    }

    NaturalType::
    NaturalType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (a, f, c)
    {
    }

    NaturalType::
    NaturalType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::unsigned_int, char, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    NaturalType* NaturalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NaturalType (*this, f, c);
    }

    NaturalType::
    ~NaturalType ()
    {
    }

    // ListNaturalType
    //

    ListNaturalType::
    ListNaturalType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif2::NaturalType, char > (e, f, this)
    {
    }

    ListNaturalType::
    ListNaturalType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif2::NaturalType, char > (a, f, this)
    {
    }

    ListNaturalType::
    ListNaturalType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xsd::qif2::NaturalType, char > (s, e, f, this)
    {
    }

    ListNaturalType* ListNaturalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListNaturalType (*this, f, c);
    }

    ListNaturalType::
    ~ListNaturalType ()
    {
    }

    // ArrayNaturalType
    //

    ArrayNaturalType::
    ArrayNaturalType (const N_type& N)
    : ::xsd::qif2::ListNaturalType (),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayNaturalType::
    ArrayNaturalType (const ::xsd::qif2::ListNaturalType& _xsd_ListNaturalType_base,
                      const N_type& N)
    : ::xsd::qif2::ListNaturalType (_xsd_ListNaturalType_base),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayNaturalType::
    ArrayNaturalType (const ArrayNaturalType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ListNaturalType (x, f, c),
      N_ (x.N_, f, this)
    {
    }

    ArrayNaturalType::
    ArrayNaturalType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ListNaturalType (e, f | ::xml_schema::flags::base, c),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ArrayNaturalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ArrayNaturalType* ArrayNaturalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayNaturalType (*this, f, c);
    }

    ArrayNaturalType::
    ~ArrayNaturalType ()
    {
    }

    // ArrayReferenceType
    //

    ArrayReferenceType::
    ArrayReferenceType (const N_type& N)
    : ::xml_schema::type (),
      Id_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayReferenceType::
    ArrayReferenceType (const ArrayReferenceType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Id_ (x.Id_, f, this),
      N_ (x.N_, f, this)
    {
    }

    ArrayReferenceType::
    ArrayReferenceType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Id_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ArrayReferenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Id
        //
        if (n.name () == "Id" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          this->Id_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ArrayReferenceType* ArrayReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayReferenceType (*this, f, c);
    }

    ArrayReferenceType::
    ~ArrayReferenceType ()
    {
    }

    // ArrayReferenceFullType
    //

    ArrayReferenceFullType::
    ArrayReferenceFullType (const N_type& N)
    : ::xml_schema::type (),
      Id_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayReferenceFullType::
    ArrayReferenceFullType (const ArrayReferenceFullType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Id_ (x.Id_, f, this),
      N_ (x.N_, f, this)
    {
    }

    ArrayReferenceFullType::
    ArrayReferenceFullType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Id_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ArrayReferenceFullType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Id
        //
        if (n.name () == "Id" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          this->Id_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ArrayReferenceFullType* ArrayReferenceFullType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayReferenceFullType (*this, f, c);
    }

    ArrayReferenceFullType::
    ~ArrayReferenceFullType ()
    {
    }

    // ListBoolType
    //

    ListBoolType::
    ListBoolType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::boolean, char > (e, f, this)
    {
    }

    ListBoolType::
    ListBoolType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::boolean, char > (a, f, this)
    {
    }

    ListBoolType::
    ListBoolType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::boolean, char > (s, e, f, this)
    {
    }

    ListBoolType* ListBoolType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListBoolType (*this, f, c);
    }

    ListBoolType::
    ~ListBoolType ()
    {
    }

    // ListUnsignedByteType
    //

    ListUnsignedByteType::
    ListUnsignedByteType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (e, f, this)
    {
    }

    ListUnsignedByteType::
    ListUnsignedByteType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (a, f, this)
    {
    }

    ListUnsignedByteType::
    ListUnsignedByteType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::unsigned_byte, char > (s, e, f, this)
    {
    }

    ListUnsignedByteType* ListUnsignedByteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ListUnsignedByteType (*this, f, c);
    }

    ListUnsignedByteType::
    ~ListUnsignedByteType ()
    {
    }

    // QPIdType
    //

    QPIdType::
    QPIdType ()
    : ::xml_schema::token ()
    {
    }

    QPIdType::
    QPIdType (const char* _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdType::
    QPIdType (const ::std::string& _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdType::
    QPIdType (const ::xml_schema::token& _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdType::
    QPIdType (const QPIdType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::token (x, f, c)
    {
    }

    QPIdType::
    QPIdType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::token (e, f, c)
    {
    }

    QPIdType::
    QPIdType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::token (a, f, c)
    {
    }

    QPIdType::
    QPIdType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::token (s, e, f, c)
    {
    }

    QPIdType* QPIdType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QPIdType (*this, f, c);
    }

    QPIdType::
    ~QPIdType ()
    {
    }

    // QPIdReferenceType
    //

    QPIdReferenceType::
    QPIdReferenceType ()
    : ::xml_schema::token ()
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const char* _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const ::std::string& _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const ::xml_schema::token& _xsd_token_base)
    : ::xml_schema::token (_xsd_token_base)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const QPIdReferenceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::token (x, f, c)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::token (e, f, c)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::token (a, f, c)
    {
    }

    QPIdReferenceType::
    QPIdReferenceType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::token (s, e, f, c)
    {
    }

    QPIdReferenceType* QPIdReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QPIdReferenceType (*this, f, c);
    }

    QPIdReferenceType::
    ~QPIdReferenceType ()
    {
    }

    // QPIdFullReferenceType
    //

    QPIdFullReferenceType::
    QPIdFullReferenceType (const ItemQPId_type& ItemQPId)
    : ::xml_schema::type (),
      ItemQPId_ (ItemQPId, ::xml_schema::flags (), this),
      DocumentQPId_ (::xml_schema::flags (), this)
    {
    }

    QPIdFullReferenceType::
    QPIdFullReferenceType (const QPIdFullReferenceType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ItemQPId_ (x.ItemQPId_, f, this),
      DocumentQPId_ (x.DocumentQPId_, f, this)
    {
    }

    QPIdFullReferenceType::
    QPIdFullReferenceType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ItemQPId_ (f, this),
      DocumentQPId_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void QPIdFullReferenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ItemQPId
        //
        if (n.name () == "ItemQPId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ItemQPId_type > r (
            ItemQPId_traits::create (i, f, this));

          if (!ItemQPId_.present ())
          {
            this->ItemQPId_.set (r);
            continue;
          }
        }

        // DocumentQPId
        //
        if (n.name () == "DocumentQPId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DocumentQPId_type > r (
            DocumentQPId_traits::create (i, f, this));

          this->DocumentQPId_.push_back (r);
          continue;
        }

        break;
      }

      if (!ItemQPId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ItemQPId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    QPIdFullReferenceType* QPIdFullReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class QPIdFullReferenceType (*this, f, c);
    }

    QPIdFullReferenceType::
    ~QPIdFullReferenceType ()
    {
    }

    // ArrayUnsignedByteType
    //

    ArrayUnsignedByteType::
    ArrayUnsignedByteType (const N_type& N)
    : ::xsd::qif2::ListUnsignedByteType (),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayUnsignedByteType::
    ArrayUnsignedByteType (const ::xsd::qif2::ListUnsignedByteType& _xsd_ListUnsignedByteType_base,
                           const N_type& N)
    : ::xsd::qif2::ListUnsignedByteType (_xsd_ListUnsignedByteType_base),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayUnsignedByteType::
    ArrayUnsignedByteType (const ArrayUnsignedByteType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ListUnsignedByteType (x, f, c),
      N_ (x.N_, f, this)
    {
    }

    ArrayUnsignedByteType::
    ArrayUnsignedByteType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ListUnsignedByteType (e, f | ::xml_schema::flags::base, c),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ArrayUnsignedByteType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ArrayUnsignedByteType* ArrayUnsignedByteType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayUnsignedByteType (*this, f, c);
    }

    ArrayUnsignedByteType::
    ~ArrayUnsignedByteType ()
    {
    }

    // ArrayIntType
    //

    ArrayIntType::
    ArrayIntType (const N_type& N)
    : ::xsd::qif2::ListIntType (),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayIntType::
    ArrayIntType (const ::xsd::qif2::ListIntType& _xsd_ListIntType_base,
                  const N_type& N)
    : ::xsd::qif2::ListIntType (_xsd_ListIntType_base),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayIntType::
    ArrayIntType (const ArrayIntType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ListIntType (x, f, c),
      N_ (x.N_, f, this)
    {
    }

    ArrayIntType::
    ArrayIntType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ListIntType (e, f | ::xml_schema::flags::base, c),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ArrayIntType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ArrayIntType* ArrayIntType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayIntType (*this, f, c);
    }

    ArrayIntType::
    ~ArrayIntType ()
    {
    }

    // ArrayI2Type
    //

    ArrayI2Type::
    ArrayI2Type (const N_type& N)
    : ::xsd::qif2::ListIntType (),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayI2Type::
    ArrayI2Type (const ::xsd::qif2::ListIntType& _xsd_ListIntType_base,
                 const N_type& N)
    : ::xsd::qif2::ListIntType (_xsd_ListIntType_base),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayI2Type::
    ArrayI2Type (const ArrayI2Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ListIntType (x, f, c),
      N_ (x.N_, f, this)
    {
    }

    ArrayI2Type::
    ArrayI2Type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ListIntType (e, f | ::xml_schema::flags::base, c),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ArrayI2Type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ArrayI2Type* ArrayI2Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayI2Type (*this, f, c);
    }

    ArrayI2Type::
    ~ArrayI2Type ()
    {
    }

    // ArrayI3Type
    //

    ArrayI3Type::
    ArrayI3Type (const N_type& N)
    : ::xsd::qif2::ListIntType (),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayI3Type::
    ArrayI3Type (const ::xsd::qif2::ListIntType& _xsd_ListIntType_base,
                 const N_type& N)
    : ::xsd::qif2::ListIntType (_xsd_ListIntType_base),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayI3Type::
    ArrayI3Type (const ArrayI3Type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ListIntType (x, f, c),
      N_ (x.N_, f, this)
    {
    }

    ArrayI3Type::
    ArrayI3Type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ListIntType (e, f | ::xml_schema::flags::base, c),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ArrayI3Type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ArrayI3Type* ArrayI3Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayI3Type (*this, f, c);
    }

    ArrayI3Type::
    ~ArrayI3Type ()
    {
    }

    // ArrayDoubleType
    //

    ArrayDoubleType::
    ArrayDoubleType (const N_type& N)
    : ::xsd::qif2::ListDoubleType (),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayDoubleType::
    ArrayDoubleType (const ::xsd::qif2::ListDoubleType& _xsd_ListDoubleType_base,
                     const N_type& N)
    : ::xsd::qif2::ListDoubleType (_xsd_ListDoubleType_base),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ArrayDoubleType::
    ArrayDoubleType (const ArrayDoubleType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (x, f, c),
      N_ (x.N_, f, this)
    {
    }

    ArrayDoubleType::
    ArrayDoubleType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ListDoubleType (e, f | ::xml_schema::flags::base, c),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ArrayDoubleType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ArrayDoubleType* ArrayDoubleType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayDoubleType (*this, f, c);
    }

    ArrayDoubleType::
    ~ArrayDoubleType ()
    {
    }

    // ArrayBinaryType
    //

    ArrayBinaryType::
    ArrayBinaryType (const N_type& N,
                     const sizeElement_type& sizeElement)
    : ::xml_schema::base64_binary (),
      N_ (N, ::xml_schema::flags (), this),
      sizeElement_ (sizeElement, ::xml_schema::flags (), this)
    {
    }

    ArrayBinaryType::
    ArrayBinaryType (const ::xml_schema::base64_binary& _xsd_base64_binary_base,
                     const N_type& N,
                     const sizeElement_type& sizeElement)
    : ::xml_schema::base64_binary (_xsd_base64_binary_base),
      N_ (N, ::xml_schema::flags (), this),
      sizeElement_ (sizeElement, ::xml_schema::flags (), this)
    {
    }

    ArrayBinaryType::
    ArrayBinaryType (const ArrayBinaryType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::base64_binary (x, f, c),
      N_ (x.N_, f, this),
      sizeElement_ (x.sizeElement_, f, this)
    {
    }

    ArrayBinaryType::
    ArrayBinaryType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::base64_binary (e, f | ::xml_schema::flags::base, c),
      N_ (f, this),
      sizeElement_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ArrayBinaryType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          this->N_.set (N_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "sizeElement" && n.namespace_ ().empty ())
        {
          this->sizeElement_.set (sizeElement_traits::create (i, f, this));
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }

      if (!sizeElement_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "sizeElement",
          "");
      }
    }

    ArrayBinaryType* ArrayBinaryType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArrayBinaryType (*this, f, c);
    }

    ArrayBinaryType::
    ~ArrayBinaryType ()
    {
    }

    // AttributesType
    //

    AttributesType::
    AttributesType (const N_type& N)
    : ::xml_schema::type (),
      Attribute_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    AttributesType::
    AttributesType (const AttributesType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attribute_ (x.Attribute_, f, this),
      N_ (x.N_, f, this)
    {
    }

    AttributesType::
    AttributesType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attribute_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void AttributesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attribute
        //
        if (n.name () == "Attribute" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attribute_type > r (
            Attribute_traits::create (i, f, this));

          this->Attribute_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    AttributesType* AttributesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributesType (*this, f, c);
    }

    AttributesType::
    ~AttributesType ()
    {
    }

    // AttributeBaseType
    //

    AttributeBaseType::
    AttributeBaseType (const name_type& name)
    : ::xml_schema::type (),
      name_ (name, ::xml_schema::flags (), this)
    {
    }

    AttributeBaseType::
    AttributeBaseType (const AttributeBaseType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      name_ (x.name_, f, this)
    {
    }

    AttributeBaseType::
    AttributeBaseType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      name_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void AttributeBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< name_type > r (
            name_traits::create (i, f, this));

          this->name_.set (r);
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    AttributeBaseType* AttributeBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeBaseType (*this, f, c);
    }

    AttributeBaseType::
    ~AttributeBaseType ()
    {
    }

    // AttributeBoolType
    //

    AttributeBoolType::
    AttributeBoolType (const name_type& name,
                       const value_type& value)
    : ::xsd::qif2::AttributeBaseType (name),
      value_ (value, ::xml_schema::flags (), this)
    {
    }

    AttributeBoolType::
    AttributeBoolType (const AttributeBoolType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeBoolType::
    AttributeBoolType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void AttributeBoolType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    AttributeBoolType* AttributeBoolType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeBoolType (*this, f, c);
    }

    AttributeBoolType::
    ~AttributeBoolType ()
    {
    }

    // AttributeStrType
    //

    AttributeStrType::
    AttributeStrType (const name_type& name,
                      const value_type& value)
    : ::xsd::qif2::AttributeBaseType (name),
      value_ (value, ::xml_schema::flags (), this)
    {
    }

    AttributeStrType::
    AttributeStrType (const AttributeStrType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeStrType::
    AttributeStrType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void AttributeStrType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< value_type > r (
            value_traits::create (i, f, this));

          this->value_.set (r);
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    AttributeStrType* AttributeStrType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeStrType (*this, f, c);
    }

    AttributeStrType::
    ~AttributeStrType ()
    {
    }

    // AttributeQPIdType
    //

    AttributeQPIdType::
    AttributeQPIdType (const name_type& name,
                       const value_type& value)
    : ::xsd::qif2::AttributeBaseType (name),
      value_ (value, ::xml_schema::flags (), this)
    {
    }

    AttributeQPIdType::
    AttributeQPIdType (const AttributeQPIdType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeQPIdType::
    AttributeQPIdType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void AttributeQPIdType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< value_type > r (
            value_traits::create (i, f, this));

          this->value_.set (r);
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    AttributeQPIdType* AttributeQPIdType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeQPIdType (*this, f, c);
    }

    AttributeQPIdType::
    ~AttributeQPIdType ()
    {
    }

    // AttributeI1Type
    //

    AttributeI1Type::
    AttributeI1Type (const name_type& name,
                     const value_type& value)
    : ::xsd::qif2::AttributeBaseType (name),
      value_ (value, ::xml_schema::flags (), this)
    {
    }

    AttributeI1Type::
    AttributeI1Type (const AttributeI1Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeI1Type::
    AttributeI1Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void AttributeI1Type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    AttributeI1Type* AttributeI1Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeI1Type (*this, f, c);
    }

    AttributeI1Type::
    ~AttributeI1Type ()
    {
    }

    // AttributeI2Type
    //

    AttributeI2Type::
    AttributeI2Type (const name_type& name,
                     const value_type& value)
    : ::xsd::qif2::AttributeBaseType (name),
      value_ (value, ::xml_schema::flags (), this)
    {
    }

    AttributeI2Type::
    AttributeI2Type (const AttributeI2Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeI2Type::
    AttributeI2Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void AttributeI2Type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< value_type > r (
            value_traits::create (i, f, this));

          this->value_.set (r);
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    AttributeI2Type* AttributeI2Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeI2Type (*this, f, c);
    }

    AttributeI2Type::
    ~AttributeI2Type ()
    {
    }

    // AttributeD1Type
    //

    AttributeD1Type::
    AttributeD1Type (const name_type& name,
                     const value_type& value)
    : ::xsd::qif2::AttributeBaseType (name),
      value_ (value, ::xml_schema::flags (), this)
    {
    }

    AttributeD1Type::
    AttributeD1Type (const AttributeD1Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeD1Type::
    AttributeD1Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void AttributeD1Type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    AttributeD1Type* AttributeD1Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeD1Type (*this, f, c);
    }

    AttributeD1Type::
    ~AttributeD1Type ()
    {
    }

    // AttributeD3Type
    //

    AttributeD3Type::
    AttributeD3Type (const name_type& name,
                     const value_type& value)
    : ::xsd::qif2::AttributeBaseType (name),
      value_ (value, ::xml_schema::flags (), this)
    {
    }

    AttributeD3Type::
    AttributeD3Type (const AttributeD3Type& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    AttributeD3Type::
    AttributeD3Type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      value_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void AttributeD3Type::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AttributeBaseType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< value_type > r (
            value_traits::create (i, f, this));

          this->value_.set (r);
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    AttributeD3Type* AttributeD3Type::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeD3Type (*this, f, c);
    }

    AttributeD3Type::
    ~AttributeD3Type ()
    {
    }

    // AttributeUserType
    //

    AttributeUserType::
    AttributeUserType (const name_type& name,
                       const nameUserAttribute_type& nameUserAttribute)
    : ::xsd::qif2::AttributeBaseType (name),
      UserDataXML_ (::xml_schema::flags (), this),
      UserDataBinary_ (::xml_schema::flags (), this),
      nameUserAttribute_ (nameUserAttribute, ::xml_schema::flags (), this)
    {
    }

    AttributeUserType::
    AttributeUserType (const AttributeUserType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (x, f, c),
      UserDataXML_ (x.UserDataXML_, f, this),
      UserDataBinary_ (x.UserDataBinary_, f, this),
      nameUserAttribute_ (x.nameUserAttribute_, f, this)
    {
    }

    AttributeUserType::
    AttributeUserType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::AttributeBaseType (e, f | ::xml_schema::flags::base, c),
      UserDataXML_ (f, this),
      UserDataBinary_ (f, this),
      nameUserAttribute_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void AttributeUserType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::AttributeBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // UserDataXML
        //
        if (n.name () == "UserDataXML" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDataXML_type > r (
            UserDataXML_traits::create (i, f, this));

          if (!this->UserDataXML_)
          {
            this->UserDataXML_.set (r);
            continue;
          }
        }

        // UserDataBinary
        //
        if (n.name () == "UserDataBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDataBinary_type > r (
            UserDataBinary_traits::create (i, f, this));

          if (!this->UserDataBinary_)
          {
            this->UserDataBinary_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "nameUserAttribute" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< nameUserAttribute_type > r (
            nameUserAttribute_traits::create (i, f, this));

          this->nameUserAttribute_.set (r);
          continue;
        }
      }

      if (!nameUserAttribute_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "nameUserAttribute",
          "");
      }
    }

    AttributeUserType* AttributeUserType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AttributeUserType (*this, f, c);
    }

    AttributeUserType::
    ~AttributeUserType ()
    {
    }

    // UserDataXMLType
    //

    UserDataXMLType::
    UserDataXMLType ()
    : ::xml_schema::type ()
    {
    }

    UserDataXMLType::
    UserDataXMLType (const UserDataXMLType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    UserDataXMLType::
    UserDataXMLType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void UserDataXMLType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }
    }

    UserDataXMLType* UserDataXMLType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDataXMLType (*this, f, c);
    }

    UserDataXMLType::
    ~UserDataXMLType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributesType > r (
        ::xsd::qif2::Attributes (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributesType > r (
        ::xsd::qif2::Attributes (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributesType > r (
        ::xsd::qif2::Attributes (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Attributes (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Attributes (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Attributes (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Attributes (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Attributes (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Attributes (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributesType > r (
        ::xsd::qif2::Attributes (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributesType > r (
        ::xsd::qif2::Attributes (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributesType > r (
        ::xsd::qif2::Attributes (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AttributesType > r (
          ::xsd::qif2::Attributes (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Attributes" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Attributes",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributesType >
    Attributes (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Attributes" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Attributes",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBaseType > r (
        ::xsd::qif2::Attribute (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBaseType > r (
        ::xsd::qif2::Attribute (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBaseType > r (
        ::xsd::qif2::Attribute (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Attribute (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Attribute (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Attribute (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Attribute (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Attribute (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Attribute (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBaseType > r (
        ::xsd::qif2::Attribute (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBaseType > r (
        ::xsd::qif2::Attribute (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBaseType > r (
        ::xsd::qif2::Attribute (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AttributeBaseType > r (
          ::xsd::qif2::Attribute (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Attribute" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Attribute",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBaseType >
    Attribute (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Attribute" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Attribute",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBoolType > r (
        ::xsd::qif2::AttributeBool (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBoolType > r (
        ::xsd::qif2::AttributeBool (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBoolType > r (
        ::xsd::qif2::AttributeBool (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeBool (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeBool (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeBool (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeBool (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeBool (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeBool (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBoolType > r (
        ::xsd::qif2::AttributeBool (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBoolType > r (
        ::xsd::qif2::AttributeBool (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeBoolType > r (
        ::xsd::qif2::AttributeBool (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AttributeBoolType > r (
          ::xsd::qif2::AttributeBool (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "AttributeBool" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeBoolType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeBoolType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeBool",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeBoolType >
    AttributeBool (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "AttributeBool" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeBoolType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeBoolType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeBool",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeStrType > r (
        ::xsd::qif2::AttributeStr (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeStrType > r (
        ::xsd::qif2::AttributeStr (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeStrType > r (
        ::xsd::qif2::AttributeStr (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeStr (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeStr (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeStr (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeStr (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeStr (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeStr (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeStrType > r (
        ::xsd::qif2::AttributeStr (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeStrType > r (
        ::xsd::qif2::AttributeStr (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeStrType > r (
        ::xsd::qif2::AttributeStr (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AttributeStrType > r (
          ::xsd::qif2::AttributeStr (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "AttributeStr" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeStrType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeStrType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeStr",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeStrType >
    AttributeStr (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "AttributeStr" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeStrType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeStrType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeStr",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType > r (
        ::xsd::qif2::AttributeQPId (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType > r (
        ::xsd::qif2::AttributeQPId (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType > r (
        ::xsd::qif2::AttributeQPId (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeQPId (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeQPId (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeQPId (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeQPId (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeQPId (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeQPId (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType > r (
        ::xsd::qif2::AttributeQPId (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType > r (
        ::xsd::qif2::AttributeQPId (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType > r (
        ::xsd::qif2::AttributeQPId (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType > r (
          ::xsd::qif2::AttributeQPId (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "AttributeQPId" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeQPIdType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeQPId",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType >
    AttributeQPId (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "AttributeQPId" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeQPIdType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeQPIdType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeQPId",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI1Type > r (
        ::xsd::qif2::AttributeI1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI1Type > r (
        ::xsd::qif2::AttributeI1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI1Type > r (
        ::xsd::qif2::AttributeI1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeI1 (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeI1 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeI1 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeI1 (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeI1 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeI1 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI1Type > r (
        ::xsd::qif2::AttributeI1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI1Type > r (
        ::xsd::qif2::AttributeI1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI1Type > r (
        ::xsd::qif2::AttributeI1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AttributeI1Type > r (
          ::xsd::qif2::AttributeI1 (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "AttributeI1" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeI1Type > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeI1Type, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeI1",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI1Type >
    AttributeI1 (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "AttributeI1" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeI1Type > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeI1Type, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeI1",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI2Type > r (
        ::xsd::qif2::AttributeI2 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI2Type > r (
        ::xsd::qif2::AttributeI2 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI2Type > r (
        ::xsd::qif2::AttributeI2 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeI2 (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeI2 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeI2 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeI2 (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeI2 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeI2 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI2Type > r (
        ::xsd::qif2::AttributeI2 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI2Type > r (
        ::xsd::qif2::AttributeI2 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeI2Type > r (
        ::xsd::qif2::AttributeI2 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AttributeI2Type > r (
          ::xsd::qif2::AttributeI2 (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "AttributeI2" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeI2Type > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeI2Type, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeI2",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeI2Type >
    AttributeI2 (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "AttributeI2" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeI2Type > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeI2Type, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeI2",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD1Type > r (
        ::xsd::qif2::AttributeD1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD1Type > r (
        ::xsd::qif2::AttributeD1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD1Type > r (
        ::xsd::qif2::AttributeD1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeD1 (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeD1 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeD1 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeD1 (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeD1 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeD1 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD1Type > r (
        ::xsd::qif2::AttributeD1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD1Type > r (
        ::xsd::qif2::AttributeD1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD1Type > r (
        ::xsd::qif2::AttributeD1 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AttributeD1Type > r (
          ::xsd::qif2::AttributeD1 (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "AttributeD1" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeD1Type > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeD1Type, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeD1",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD1Type >
    AttributeD1 (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "AttributeD1" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeD1Type > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeD1Type, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeD1",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD3Type > r (
        ::xsd::qif2::AttributeD3 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD3Type > r (
        ::xsd::qif2::AttributeD3 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD3Type > r (
        ::xsd::qif2::AttributeD3 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeD3 (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeD3 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeD3 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeD3 (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeD3 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeD3 (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD3Type > r (
        ::xsd::qif2::AttributeD3 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD3Type > r (
        ::xsd::qif2::AttributeD3 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeD3Type > r (
        ::xsd::qif2::AttributeD3 (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AttributeD3Type > r (
          ::xsd::qif2::AttributeD3 (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "AttributeD3" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeD3Type > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeD3Type, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeD3",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeD3Type >
    AttributeD3 (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "AttributeD3" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeD3Type > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeD3Type, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeD3",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeUserType > r (
        ::xsd::qif2::AttributeUser (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeUserType > r (
        ::xsd::qif2::AttributeUser (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeUserType > r (
        ::xsd::qif2::AttributeUser (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeUser (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeUser (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::AttributeUser (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeUser (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeUser (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::AttributeUser (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeUserType > r (
        ::xsd::qif2::AttributeUser (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeUserType > r (
        ::xsd::qif2::AttributeUser (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::AttributeUserType > r (
        ::xsd::qif2::AttributeUser (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::AttributeUserType > r (
          ::xsd::qif2::AttributeUser (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "AttributeUser" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeUserType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeUserType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeUser",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::AttributeUserType >
    AttributeUser (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "AttributeUser" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::AttributeUserType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::AttributeUserType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AttributeUser",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

