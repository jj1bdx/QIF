// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Topology.hxx"

namespace xsd
{
  namespace qif2
  {
    // TopologySetType
    // 

    const TopologySetType::VertexSet_optional& TopologySetType::
    VertexSet () const
    {
      return this->VertexSet_;
    }

    TopologySetType::VertexSet_optional& TopologySetType::
    VertexSet ()
    {
      return this->VertexSet_;
    }

    void TopologySetType::
    VertexSet (const VertexSet_type& x)
    {
      this->VertexSet_.set (x);
    }

    void TopologySetType::
    VertexSet (const VertexSet_optional& x)
    {
      this->VertexSet_ = x;
    }

    void TopologySetType::
    VertexSet (::std::auto_ptr< VertexSet_type > x)
    {
      this->VertexSet_.set (x);
    }

    const TopologySetType::EdgeSet_optional& TopologySetType::
    EdgeSet () const
    {
      return this->EdgeSet_;
    }

    TopologySetType::EdgeSet_optional& TopologySetType::
    EdgeSet ()
    {
      return this->EdgeSet_;
    }

    void TopologySetType::
    EdgeSet (const EdgeSet_type& x)
    {
      this->EdgeSet_.set (x);
    }

    void TopologySetType::
    EdgeSet (const EdgeSet_optional& x)
    {
      this->EdgeSet_ = x;
    }

    void TopologySetType::
    EdgeSet (::std::auto_ptr< EdgeSet_type > x)
    {
      this->EdgeSet_.set (x);
    }

    const TopologySetType::LoopSet_optional& TopologySetType::
    LoopSet () const
    {
      return this->LoopSet_;
    }

    TopologySetType::LoopSet_optional& TopologySetType::
    LoopSet ()
    {
      return this->LoopSet_;
    }

    void TopologySetType::
    LoopSet (const LoopSet_type& x)
    {
      this->LoopSet_.set (x);
    }

    void TopologySetType::
    LoopSet (const LoopSet_optional& x)
    {
      this->LoopSet_ = x;
    }

    void TopologySetType::
    LoopSet (::std::auto_ptr< LoopSet_type > x)
    {
      this->LoopSet_.set (x);
    }

    const TopologySetType::FaceSet_optional& TopologySetType::
    FaceSet () const
    {
      return this->FaceSet_;
    }

    TopologySetType::FaceSet_optional& TopologySetType::
    FaceSet ()
    {
      return this->FaceSet_;
    }

    void TopologySetType::
    FaceSet (const FaceSet_type& x)
    {
      this->FaceSet_.set (x);
    }

    void TopologySetType::
    FaceSet (const FaceSet_optional& x)
    {
      this->FaceSet_ = x;
    }

    void TopologySetType::
    FaceSet (::std::auto_ptr< FaceSet_type > x)
    {
      this->FaceSet_.set (x);
    }

    const TopologySetType::ShellSet_optional& TopologySetType::
    ShellSet () const
    {
      return this->ShellSet_;
    }

    TopologySetType::ShellSet_optional& TopologySetType::
    ShellSet ()
    {
      return this->ShellSet_;
    }

    void TopologySetType::
    ShellSet (const ShellSet_type& x)
    {
      this->ShellSet_.set (x);
    }

    void TopologySetType::
    ShellSet (const ShellSet_optional& x)
    {
      this->ShellSet_ = x;
    }

    void TopologySetType::
    ShellSet (::std::auto_ptr< ShellSet_type > x)
    {
      this->ShellSet_.set (x);
    }

    const TopologySetType::BodySet_optional& TopologySetType::
    BodySet () const
    {
      return this->BodySet_;
    }

    TopologySetType::BodySet_optional& TopologySetType::
    BodySet ()
    {
      return this->BodySet_;
    }

    void TopologySetType::
    BodySet (const BodySet_type& x)
    {
      this->BodySet_.set (x);
    }

    void TopologySetType::
    BodySet (const BodySet_optional& x)
    {
      this->BodySet_ = x;
    }

    void TopologySetType::
    BodySet (::std::auto_ptr< BodySet_type > x)
    {
      this->BodySet_.set (x);
    }

    const TopologySetType::PointCloudSet_optional& TopologySetType::
    PointCloudSet () const
    {
      return this->PointCloudSet_;
    }

    TopologySetType::PointCloudSet_optional& TopologySetType::
    PointCloudSet ()
    {
      return this->PointCloudSet_;
    }

    void TopologySetType::
    PointCloudSet (const PointCloudSet_type& x)
    {
      this->PointCloudSet_.set (x);
    }

    void TopologySetType::
    PointCloudSet (const PointCloudSet_optional& x)
    {
      this->PointCloudSet_ = x;
    }

    void TopologySetType::
    PointCloudSet (::std::auto_ptr< PointCloudSet_type > x)
    {
      this->PointCloudSet_.set (x);
    }


    // TopologyBaseType
    // 


    // VertexSetType
    // 

    const VertexSetType::Vertex_sequence& VertexSetType::
    Vertex () const
    {
      return this->Vertex_;
    }

    VertexSetType::Vertex_sequence& VertexSetType::
    Vertex ()
    {
      return this->Vertex_;
    }

    void VertexSetType::
    Vertex (const Vertex_sequence& s)
    {
      this->Vertex_ = s;
    }

    const VertexSetType::N_type& VertexSetType::
    N () const
    {
      return this->N_.get ();
    }

    VertexSetType::N_type& VertexSetType::
    N ()
    {
      return this->N_.get ();
    }

    void VertexSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void VertexSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // VertexType
    // 

    const VertexType::Point_type& VertexType::
    Point () const
    {
      return this->Point_.get ();
    }

    VertexType::Point_type& VertexType::
    Point ()
    {
      return this->Point_.get ();
    }

    void VertexType::
    Point (const Point_type& x)
    {
      this->Point_.set (x);
    }

    void VertexType::
    Point (::std::auto_ptr< Point_type > x)
    {
      this->Point_.set (x);
    }

    const VertexType::tolerance_optional& VertexType::
    tolerance () const
    {
      return this->tolerance_;
    }

    VertexType::tolerance_optional& VertexType::
    tolerance ()
    {
      return this->tolerance_;
    }

    void VertexType::
    tolerance (const tolerance_type& x)
    {
      this->tolerance_.set (x);
    }

    void VertexType::
    tolerance (const tolerance_optional& x)
    {
      this->tolerance_ = x;
    }


    // EdgeSetType
    // 

    const EdgeSetType::Edge_sequence& EdgeSetType::
    Edge () const
    {
      return this->Edge_;
    }

    EdgeSetType::Edge_sequence& EdgeSetType::
    Edge ()
    {
      return this->Edge_;
    }

    void EdgeSetType::
    Edge (const Edge_sequence& s)
    {
      this->Edge_ = s;
    }

    const EdgeSetType::N_type& EdgeSetType::
    N () const
    {
      return this->N_.get ();
    }

    EdgeSetType::N_type& EdgeSetType::
    N ()
    {
      return this->N_.get ();
    }

    void EdgeSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void EdgeSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // EdgeType
    // 

    const EdgeType::Curve_type& EdgeType::
    Curve () const
    {
      return this->Curve_.get ();
    }

    EdgeType::Curve_type& EdgeType::
    Curve ()
    {
      return this->Curve_.get ();
    }

    void EdgeType::
    Curve (const Curve_type& x)
    {
      this->Curve_.set (x);
    }

    void EdgeType::
    Curve (::std::auto_ptr< Curve_type > x)
    {
      this->Curve_.set (x);
    }

    const EdgeType::VertexBeg_type& EdgeType::
    VertexBeg () const
    {
      return this->VertexBeg_.get ();
    }

    EdgeType::VertexBeg_type& EdgeType::
    VertexBeg ()
    {
      return this->VertexBeg_.get ();
    }

    void EdgeType::
    VertexBeg (const VertexBeg_type& x)
    {
      this->VertexBeg_.set (x);
    }

    void EdgeType::
    VertexBeg (::std::auto_ptr< VertexBeg_type > x)
    {
      this->VertexBeg_.set (x);
    }

    const EdgeType::VertexEnd_type& EdgeType::
    VertexEnd () const
    {
      return this->VertexEnd_.get ();
    }

    EdgeType::VertexEnd_type& EdgeType::
    VertexEnd ()
    {
      return this->VertexEnd_.get ();
    }

    void EdgeType::
    VertexEnd (const VertexEnd_type& x)
    {
      this->VertexEnd_.set (x);
    }

    void EdgeType::
    VertexEnd (::std::auto_ptr< VertexEnd_type > x)
    {
      this->VertexEnd_.set (x);
    }

    const EdgeType::tolerance_optional& EdgeType::
    tolerance () const
    {
      return this->tolerance_;
    }

    EdgeType::tolerance_optional& EdgeType::
    tolerance ()
    {
      return this->tolerance_;
    }

    void EdgeType::
    tolerance (const tolerance_type& x)
    {
      this->tolerance_.set (x);
    }

    void EdgeType::
    tolerance (const tolerance_optional& x)
    {
      this->tolerance_ = x;
    }


    // LoopSetType
    // 

    const LoopSetType::LoopBase_sequence& LoopSetType::
    LoopBase () const
    {
      return this->LoopBase_;
    }

    LoopSetType::LoopBase_sequence& LoopSetType::
    LoopBase ()
    {
      return this->LoopBase_;
    }

    void LoopSetType::
    LoopBase (const LoopBase_sequence& s)
    {
      this->LoopBase_ = s;
    }

    const LoopSetType::N_type& LoopSetType::
    N () const
    {
      return this->N_.get ();
    }

    LoopSetType::N_type& LoopSetType::
    N ()
    {
      return this->N_.get ();
    }

    void LoopSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void LoopSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // LoopBaseType
    // 


    // LoopFormEnumType
    // 

    LoopFormEnumType::
    LoopFormEnumType (value v)
    : ::xml_schema::string (_xsd_LoopFormEnumType_literals_[v])
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    LoopFormEnumType::
    LoopFormEnumType (const LoopFormEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    LoopFormEnumType& LoopFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_LoopFormEnumType_literals_[v]);

      return *this;
    }


    // EdgeOrientedType
    // 

    const EdgeOrientedType::turned_type& EdgeOrientedType::
    turned () const
    {
      return this->turned_.get ();
    }

    EdgeOrientedType::turned_type& EdgeOrientedType::
    turned ()
    {
      return this->turned_.get ();
    }

    void EdgeOrientedType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    EdgeOrientedType::turned_type EdgeOrientedType::
    turned_default_value ()
    {
      return turned_type (false);
    }


    // CoEdgeType
    // 

    const CoEdgeType::EdgeOriented_type& CoEdgeType::
    EdgeOriented () const
    {
      return this->EdgeOriented_.get ();
    }

    CoEdgeType::EdgeOriented_type& CoEdgeType::
    EdgeOriented ()
    {
      return this->EdgeOriented_.get ();
    }

    void CoEdgeType::
    EdgeOriented (const EdgeOriented_type& x)
    {
      this->EdgeOriented_.set (x);
    }

    void CoEdgeType::
    EdgeOriented (::std::auto_ptr< EdgeOriented_type > x)
    {
      this->EdgeOriented_.set (x);
    }

    const CoEdgeType::Curve12_optional& CoEdgeType::
    Curve12 () const
    {
      return this->Curve12_;
    }

    CoEdgeType::Curve12_optional& CoEdgeType::
    Curve12 ()
    {
      return this->Curve12_;
    }

    void CoEdgeType::
    Curve12 (const Curve12_type& x)
    {
      this->Curve12_.set (x);
    }

    void CoEdgeType::
    Curve12 (const Curve12_optional& x)
    {
      this->Curve12_ = x;
    }

    void CoEdgeType::
    Curve12 (::std::auto_ptr< Curve12_type > x)
    {
      this->Curve12_.set (x);
    }


    // CoEdgesType
    // 

    const CoEdgesType::CoEdge_sequence& CoEdgesType::
    CoEdge () const
    {
      return this->CoEdge_;
    }

    CoEdgesType::CoEdge_sequence& CoEdgesType::
    CoEdge ()
    {
      return this->CoEdge_;
    }

    void CoEdgesType::
    CoEdge (const CoEdge_sequence& s)
    {
      this->CoEdge_ = s;
    }

    const CoEdgesType::N_type& CoEdgesType::
    N () const
    {
      return this->N_.get ();
    }

    CoEdgesType::N_type& CoEdgesType::
    N ()
    {
      return this->N_.get ();
    }

    void CoEdgesType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void CoEdgesType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // CoEdgeMeshType
    // 

    const CoEdgeMeshType::EdgeOriented_type& CoEdgeMeshType::
    EdgeOriented () const
    {
      return this->EdgeOriented_.get ();
    }

    CoEdgeMeshType::EdgeOriented_type& CoEdgeMeshType::
    EdgeOriented ()
    {
      return this->EdgeOriented_.get ();
    }

    void CoEdgeMeshType::
    EdgeOriented (const EdgeOriented_type& x)
    {
      this->EdgeOriented_.set (x);
    }

    void CoEdgeMeshType::
    EdgeOriented (::std::auto_ptr< EdgeOriented_type > x)
    {
      this->EdgeOriented_.set (x);
    }

    const CoEdgeMeshType::CurveMesh_optional& CoEdgeMeshType::
    CurveMesh () const
    {
      return this->CurveMesh_;
    }

    CoEdgeMeshType::CurveMesh_optional& CoEdgeMeshType::
    CurveMesh ()
    {
      return this->CurveMesh_;
    }

    void CoEdgeMeshType::
    CurveMesh (const CurveMesh_type& x)
    {
      this->CurveMesh_.set (x);
    }

    void CoEdgeMeshType::
    CurveMesh (const CurveMesh_optional& x)
    {
      this->CurveMesh_ = x;
    }

    void CoEdgeMeshType::
    CurveMesh (::std::auto_ptr< CurveMesh_type > x)
    {
      this->CurveMesh_.set (x);
    }


    // CoEdgesMeshType
    // 

    const CoEdgesMeshType::CoEdgeMesh_sequence& CoEdgesMeshType::
    CoEdgeMesh () const
    {
      return this->CoEdgeMesh_;
    }

    CoEdgesMeshType::CoEdgeMesh_sequence& CoEdgesMeshType::
    CoEdgeMesh ()
    {
      return this->CoEdgeMesh_;
    }

    void CoEdgesMeshType::
    CoEdgeMesh (const CoEdgeMesh_sequence& s)
    {
      this->CoEdgeMesh_ = s;
    }

    const CoEdgesMeshType::N_type& CoEdgesMeshType::
    N () const
    {
      return this->N_.get ();
    }

    CoEdgesMeshType::N_type& CoEdgesMeshType::
    N ()
    {
      return this->N_.get ();
    }

    void CoEdgesMeshType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void CoEdgesMeshType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // LoopType
    // 

    const LoopType::CoEdges_type& LoopType::
    CoEdges () const
    {
      return this->CoEdges_.get ();
    }

    LoopType::CoEdges_type& LoopType::
    CoEdges ()
    {
      return this->CoEdges_.get ();
    }

    void LoopType::
    CoEdges (const CoEdges_type& x)
    {
      this->CoEdges_.set (x);
    }

    void LoopType::
    CoEdges (::std::auto_ptr< CoEdges_type > x)
    {
      this->CoEdges_.set (x);
    }

    const LoopType::form_type& LoopType::
    form () const
    {
      return this->form_.get ();
    }

    LoopType::form_type& LoopType::
    form ()
    {
      return this->form_.get ();
    }

    void LoopType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void LoopType::
    form (::std::auto_ptr< form_type > x)
    {
      this->form_.set (x);
    }

    const LoopType::form_type& LoopType::
    form_default_value ()
    {
      return form_default_value_;
    }


    // LoopMeshType
    // 

    const LoopMeshType::CoEdgesMesh_type& LoopMeshType::
    CoEdgesMesh () const
    {
      return this->CoEdgesMesh_.get ();
    }

    LoopMeshType::CoEdgesMesh_type& LoopMeshType::
    CoEdgesMesh ()
    {
      return this->CoEdgesMesh_.get ();
    }

    void LoopMeshType::
    CoEdgesMesh (const CoEdgesMesh_type& x)
    {
      this->CoEdgesMesh_.set (x);
    }

    void LoopMeshType::
    CoEdgesMesh (::std::auto_ptr< CoEdgesMesh_type > x)
    {
      this->CoEdgesMesh_.set (x);
    }


    // FaceSetType
    // 

    const FaceSetType::FaceBase_sequence& FaceSetType::
    FaceBase () const
    {
      return this->FaceBase_;
    }

    FaceSetType::FaceBase_sequence& FaceSetType::
    FaceBase ()
    {
      return this->FaceBase_;
    }

    void FaceSetType::
    FaceBase (const FaceBase_sequence& s)
    {
      this->FaceBase_ = s;
    }

    const FaceSetType::N_type& FaceSetType::
    N () const
    {
      return this->N_.get ();
    }

    FaceSetType::N_type& FaceSetType::
    N ()
    {
      return this->N_.get ();
    }

    void FaceSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void FaceSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // FaceBaseType
    // 

    const FaceBaseType::InertiaMatrix_optional& FaceBaseType::
    InertiaMatrix () const
    {
      return this->InertiaMatrix_;
    }

    FaceBaseType::InertiaMatrix_optional& FaceBaseType::
    InertiaMatrix ()
    {
      return this->InertiaMatrix_;
    }

    void FaceBaseType::
    InertiaMatrix (const InertiaMatrix_type& x)
    {
      this->InertiaMatrix_.set (x);
    }

    void FaceBaseType::
    InertiaMatrix (const InertiaMatrix_optional& x)
    {
      this->InertiaMatrix_ = x;
    }

    void FaceBaseType::
    InertiaMatrix (::std::auto_ptr< InertiaMatrix_type > x)
    {
      this->InertiaMatrix_.set (x);
    }

    const FaceBaseType::turned_type& FaceBaseType::
    turned () const
    {
      return this->turned_.get ();
    }

    FaceBaseType::turned_type& FaceBaseType::
    turned ()
    {
      return this->turned_.get ();
    }

    void FaceBaseType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    FaceBaseType::turned_type FaceBaseType::
    turned_default_value ()
    {
      return turned_type (false);
    }

    const FaceBaseType::area_optional& FaceBaseType::
    area () const
    {
      return this->area_;
    }

    FaceBaseType::area_optional& FaceBaseType::
    area ()
    {
      return this->area_;
    }

    void FaceBaseType::
    area (const area_type& x)
    {
      this->area_.set (x);
    }

    void FaceBaseType::
    area (const area_optional& x)
    {
      this->area_ = x;
    }

    const FaceBaseType::volume_optional& FaceBaseType::
    volume () const
    {
      return this->volume_;
    }

    FaceBaseType::volume_optional& FaceBaseType::
    volume ()
    {
      return this->volume_;
    }

    void FaceBaseType::
    volume (const volume_type& x)
    {
      this->volume_.set (x);
    }

    void FaceBaseType::
    volume (const volume_optional& x)
    {
      this->volume_ = x;
    }

    const FaceBaseType::massCenter_optional& FaceBaseType::
    massCenter () const
    {
      return this->massCenter_;
    }

    FaceBaseType::massCenter_optional& FaceBaseType::
    massCenter ()
    {
      return this->massCenter_;
    }

    void FaceBaseType::
    massCenter (const massCenter_type& x)
    {
      this->massCenter_.set (x);
    }

    void FaceBaseType::
    massCenter (const massCenter_optional& x)
    {
      this->massCenter_ = x;
    }

    void FaceBaseType::
    massCenter (::std::auto_ptr< massCenter_type > x)
    {
      this->massCenter_.set (x);
    }


    // FaceType
    // 

    const FaceType::Surface_type& FaceType::
    Surface () const
    {
      return this->Surface_.get ();
    }

    FaceType::Surface_type& FaceType::
    Surface ()
    {
      return this->Surface_.get ();
    }

    void FaceType::
    Surface (const Surface_type& x)
    {
      this->Surface_.set (x);
    }

    void FaceType::
    Surface (::std::auto_ptr< Surface_type > x)
    {
      this->Surface_.set (x);
    }

    const FaceType::LoopIds_optional& FaceType::
    LoopIds () const
    {
      return this->LoopIds_;
    }

    FaceType::LoopIds_optional& FaceType::
    LoopIds ()
    {
      return this->LoopIds_;
    }

    void FaceType::
    LoopIds (const LoopIds_type& x)
    {
      this->LoopIds_.set (x);
    }

    void FaceType::
    LoopIds (const LoopIds_optional& x)
    {
      this->LoopIds_ = x;
    }

    void FaceType::
    LoopIds (::std::auto_ptr< LoopIds_type > x)
    {
      this->LoopIds_.set (x);
    }

    const FaceType::hasOuter_type& FaceType::
    hasOuter () const
    {
      return this->hasOuter_.get ();
    }

    FaceType::hasOuter_type& FaceType::
    hasOuter ()
    {
      return this->hasOuter_.get ();
    }

    void FaceType::
    hasOuter (const hasOuter_type& x)
    {
      this->hasOuter_.set (x);
    }

    FaceType::hasOuter_type FaceType::
    hasOuter_default_value ()
    {
      return hasOuter_type (true);
    }


    // FaceMeshType
    // 

    const FaceMeshType::Mesh_type& FaceMeshType::
    Mesh () const
    {
      return this->Mesh_.get ();
    }

    FaceMeshType::Mesh_type& FaceMeshType::
    Mesh ()
    {
      return this->Mesh_.get ();
    }

    void FaceMeshType::
    Mesh (const Mesh_type& x)
    {
      this->Mesh_.set (x);
    }

    void FaceMeshType::
    Mesh (::std::auto_ptr< Mesh_type > x)
    {
      this->Mesh_.set (x);
    }

    const FaceMeshType::LoopIds_optional& FaceMeshType::
    LoopIds () const
    {
      return this->LoopIds_;
    }

    FaceMeshType::LoopIds_optional& FaceMeshType::
    LoopIds ()
    {
      return this->LoopIds_;
    }

    void FaceMeshType::
    LoopIds (const LoopIds_type& x)
    {
      this->LoopIds_.set (x);
    }

    void FaceMeshType::
    LoopIds (const LoopIds_optional& x)
    {
      this->LoopIds_ = x;
    }

    void FaceMeshType::
    LoopIds (::std::auto_ptr< LoopIds_type > x)
    {
      this->LoopIds_.set (x);
    }

    const FaceMeshType::Triangles_optional& FaceMeshType::
    Triangles () const
    {
      return this->Triangles_;
    }

    FaceMeshType::Triangles_optional& FaceMeshType::
    Triangles ()
    {
      return this->Triangles_;
    }

    void FaceMeshType::
    Triangles (const Triangles_type& x)
    {
      this->Triangles_.set (x);
    }

    void FaceMeshType::
    Triangles (const Triangles_optional& x)
    {
      this->Triangles_ = x;
    }

    void FaceMeshType::
    Triangles (::std::auto_ptr< Triangles_type > x)
    {
      this->Triangles_.set (x);
    }

    const FaceMeshType::TrianglesBinary_optional& FaceMeshType::
    TrianglesBinary () const
    {
      return this->TrianglesBinary_;
    }

    FaceMeshType::TrianglesBinary_optional& FaceMeshType::
    TrianglesBinary ()
    {
      return this->TrianglesBinary_;
    }

    void FaceMeshType::
    TrianglesBinary (const TrianglesBinary_type& x)
    {
      this->TrianglesBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesBinary (const TrianglesBinary_optional& x)
    {
      this->TrianglesBinary_ = x;
    }

    void FaceMeshType::
    TrianglesBinary (::std::auto_ptr< TrianglesBinary_type > x)
    {
      this->TrianglesBinary_.set (x);
    }

    const FaceMeshType::TrianglesVisible_optional& FaceMeshType::
    TrianglesVisible () const
    {
      return this->TrianglesVisible_;
    }

    FaceMeshType::TrianglesVisible_optional& FaceMeshType::
    TrianglesVisible ()
    {
      return this->TrianglesVisible_;
    }

    void FaceMeshType::
    TrianglesVisible (const TrianglesVisible_type& x)
    {
      this->TrianglesVisible_.set (x);
    }

    void FaceMeshType::
    TrianglesVisible (const TrianglesVisible_optional& x)
    {
      this->TrianglesVisible_ = x;
    }

    void FaceMeshType::
    TrianglesVisible (::std::auto_ptr< TrianglesVisible_type > x)
    {
      this->TrianglesVisible_.set (x);
    }

    const FaceMeshType::TrianglesVisibleBinary_optional& FaceMeshType::
    TrianglesVisibleBinary () const
    {
      return this->TrianglesVisibleBinary_;
    }

    FaceMeshType::TrianglesVisibleBinary_optional& FaceMeshType::
    TrianglesVisibleBinary ()
    {
      return this->TrianglesVisibleBinary_;
    }

    void FaceMeshType::
    TrianglesVisibleBinary (const TrianglesVisibleBinary_type& x)
    {
      this->TrianglesVisibleBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesVisibleBinary (const TrianglesVisibleBinary_optional& x)
    {
      this->TrianglesVisibleBinary_ = x;
    }

    void FaceMeshType::
    TrianglesVisibleBinary (::std::auto_ptr< TrianglesVisibleBinary_type > x)
    {
      this->TrianglesVisibleBinary_.set (x);
    }

    const FaceMeshType::TrianglesHidden_optional& FaceMeshType::
    TrianglesHidden () const
    {
      return this->TrianglesHidden_;
    }

    FaceMeshType::TrianglesHidden_optional& FaceMeshType::
    TrianglesHidden ()
    {
      return this->TrianglesHidden_;
    }

    void FaceMeshType::
    TrianglesHidden (const TrianglesHidden_type& x)
    {
      this->TrianglesHidden_.set (x);
    }

    void FaceMeshType::
    TrianglesHidden (const TrianglesHidden_optional& x)
    {
      this->TrianglesHidden_ = x;
    }

    void FaceMeshType::
    TrianglesHidden (::std::auto_ptr< TrianglesHidden_type > x)
    {
      this->TrianglesHidden_.set (x);
    }

    const FaceMeshType::TrianglesHiddenBinary_optional& FaceMeshType::
    TrianglesHiddenBinary () const
    {
      return this->TrianglesHiddenBinary_;
    }

    FaceMeshType::TrianglesHiddenBinary_optional& FaceMeshType::
    TrianglesHiddenBinary ()
    {
      return this->TrianglesHiddenBinary_;
    }

    void FaceMeshType::
    TrianglesHiddenBinary (const TrianglesHiddenBinary_type& x)
    {
      this->TrianglesHiddenBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesHiddenBinary (const TrianglesHiddenBinary_optional& x)
    {
      this->TrianglesHiddenBinary_ = x;
    }

    void FaceMeshType::
    TrianglesHiddenBinary (::std::auto_ptr< TrianglesHiddenBinary_type > x)
    {
      this->TrianglesHiddenBinary_.set (x);
    }

    const FaceMeshType::TrianglesColor_optional& FaceMeshType::
    TrianglesColor () const
    {
      return this->TrianglesColor_;
    }

    FaceMeshType::TrianglesColor_optional& FaceMeshType::
    TrianglesColor ()
    {
      return this->TrianglesColor_;
    }

    void FaceMeshType::
    TrianglesColor (const TrianglesColor_type& x)
    {
      this->TrianglesColor_.set (x);
    }

    void FaceMeshType::
    TrianglesColor (const TrianglesColor_optional& x)
    {
      this->TrianglesColor_ = x;
    }

    void FaceMeshType::
    TrianglesColor (::std::auto_ptr< TrianglesColor_type > x)
    {
      this->TrianglesColor_.set (x);
    }

    const FaceMeshType::TrianglesColorBinary_optional& FaceMeshType::
    TrianglesColorBinary () const
    {
      return this->TrianglesColorBinary_;
    }

    FaceMeshType::TrianglesColorBinary_optional& FaceMeshType::
    TrianglesColorBinary ()
    {
      return this->TrianglesColorBinary_;
    }

    void FaceMeshType::
    TrianglesColorBinary (const TrianglesColorBinary_type& x)
    {
      this->TrianglesColorBinary_.set (x);
    }

    void FaceMeshType::
    TrianglesColorBinary (const TrianglesColorBinary_optional& x)
    {
      this->TrianglesColorBinary_ = x;
    }

    void FaceMeshType::
    TrianglesColorBinary (::std::auto_ptr< TrianglesColorBinary_type > x)
    {
      this->TrianglesColorBinary_.set (x);
    }


    // ShellSetType
    // 

    const ShellSetType::Shell_sequence& ShellSetType::
    Shell () const
    {
      return this->Shell_;
    }

    ShellSetType::Shell_sequence& ShellSetType::
    Shell ()
    {
      return this->Shell_;
    }

    void ShellSetType::
    Shell (const Shell_sequence& s)
    {
      this->Shell_ = s;
    }

    const ShellSetType::N_type& ShellSetType::
    N () const
    {
      return this->N_.get ();
    }

    ShellSetType::N_type& ShellSetType::
    N ()
    {
      return this->N_.get ();
    }

    void ShellSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void ShellSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // ShellFormEnumType
    // 

    ShellFormEnumType::
    ShellFormEnumType (value v)
    : ::xml_schema::string (_xsd_ShellFormEnumType_literals_[v])
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const char* v)
    : ::xml_schema::string (v)
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const ::std::string& v)
    : ::xml_schema::string (v)
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const ::xml_schema::string& v)
    : ::xml_schema::string (v)
    {
    }

    ShellFormEnumType::
    ShellFormEnumType (const ShellFormEnumType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (v, f, c)
    {
    }

    ShellFormEnumType& ShellFormEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::string& > (*this) = 
      ::xml_schema::string (_xsd_ShellFormEnumType_literals_[v]);

      return *this;
    }


    // ShellType
    // 

    const ShellType::FaceIds_optional& ShellType::
    FaceIds () const
    {
      return this->FaceIds_;
    }

    ShellType::FaceIds_optional& ShellType::
    FaceIds ()
    {
      return this->FaceIds_;
    }

    void ShellType::
    FaceIds (const FaceIds_type& x)
    {
      this->FaceIds_.set (x);
    }

    void ShellType::
    FaceIds (const FaceIds_optional& x)
    {
      this->FaceIds_ = x;
    }

    void ShellType::
    FaceIds (::std::auto_ptr< FaceIds_type > x)
    {
      this->FaceIds_.set (x);
    }

    const ShellType::turned_type& ShellType::
    turned () const
    {
      return this->turned_.get ();
    }

    ShellType::turned_type& ShellType::
    turned ()
    {
      return this->turned_.get ();
    }

    void ShellType::
    turned (const turned_type& x)
    {
      this->turned_.set (x);
    }

    ShellType::turned_type ShellType::
    turned_default_value ()
    {
      return turned_type (false);
    }

    const ShellType::closed_type& ShellType::
    closed () const
    {
      return this->closed_.get ();
    }

    ShellType::closed_type& ShellType::
    closed ()
    {
      return this->closed_.get ();
    }

    void ShellType::
    closed (const closed_type& x)
    {
      this->closed_.set (x);
    }

    ShellType::closed_type ShellType::
    closed_default_value ()
    {
      return closed_type (false);
    }

    const ShellType::form_type& ShellType::
    form () const
    {
      return this->form_.get ();
    }

    ShellType::form_type& ShellType::
    form ()
    {
      return this->form_.get ();
    }

    void ShellType::
    form (const form_type& x)
    {
      this->form_.set (x);
    }

    void ShellType::
    form (::std::auto_ptr< form_type > x)
    {
      this->form_.set (x);
    }

    const ShellType::form_type& ShellType::
    form_default_value ()
    {
      return form_default_value_;
    }


    // BodySetType
    // 

    const BodySetType::Body_sequence& BodySetType::
    Body () const
    {
      return this->Body_;
    }

    BodySetType::Body_sequence& BodySetType::
    Body ()
    {
      return this->Body_;
    }

    void BodySetType::
    Body (const Body_sequence& s)
    {
      this->Body_ = s;
    }

    const BodySetType::N_type& BodySetType::
    N () const
    {
      return this->N_.get ();
    }

    BodySetType::N_type& BodySetType::
    N ()
    {
      return this->N_.get ();
    }

    void BodySetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void BodySetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // BodyType
    // 

    const BodyType::Transform_optional& BodyType::
    Transform () const
    {
      return this->Transform_;
    }

    BodyType::Transform_optional& BodyType::
    Transform ()
    {
      return this->Transform_;
    }

    void BodyType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void BodyType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void BodyType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const BodyType::ShellIds_optional& BodyType::
    ShellIds () const
    {
      return this->ShellIds_;
    }

    BodyType::ShellIds_optional& BodyType::
    ShellIds ()
    {
      return this->ShellIds_;
    }

    void BodyType::
    ShellIds (const ShellIds_type& x)
    {
      this->ShellIds_.set (x);
    }

    void BodyType::
    ShellIds (const ShellIds_optional& x)
    {
      this->ShellIds_ = x;
    }

    void BodyType::
    ShellIds (::std::auto_ptr< ShellIds_type > x)
    {
      this->ShellIds_.set (x);
    }

    const BodyType::FaceIds_optional& BodyType::
    FaceIds () const
    {
      return this->FaceIds_;
    }

    BodyType::FaceIds_optional& BodyType::
    FaceIds ()
    {
      return this->FaceIds_;
    }

    void BodyType::
    FaceIds (const FaceIds_type& x)
    {
      this->FaceIds_.set (x);
    }

    void BodyType::
    FaceIds (const FaceIds_optional& x)
    {
      this->FaceIds_ = x;
    }

    void BodyType::
    FaceIds (::std::auto_ptr< FaceIds_type > x)
    {
      this->FaceIds_.set (x);
    }

    const BodyType::LoopIds_optional& BodyType::
    LoopIds () const
    {
      return this->LoopIds_;
    }

    BodyType::LoopIds_optional& BodyType::
    LoopIds ()
    {
      return this->LoopIds_;
    }

    void BodyType::
    LoopIds (const LoopIds_type& x)
    {
      this->LoopIds_.set (x);
    }

    void BodyType::
    LoopIds (const LoopIds_optional& x)
    {
      this->LoopIds_ = x;
    }

    void BodyType::
    LoopIds (::std::auto_ptr< LoopIds_type > x)
    {
      this->LoopIds_.set (x);
    }

    const BodyType::EdgeIds_optional& BodyType::
    EdgeIds () const
    {
      return this->EdgeIds_;
    }

    BodyType::EdgeIds_optional& BodyType::
    EdgeIds ()
    {
      return this->EdgeIds_;
    }

    void BodyType::
    EdgeIds (const EdgeIds_type& x)
    {
      this->EdgeIds_.set (x);
    }

    void BodyType::
    EdgeIds (const EdgeIds_optional& x)
    {
      this->EdgeIds_ = x;
    }

    void BodyType::
    EdgeIds (::std::auto_ptr< EdgeIds_type > x)
    {
      this->EdgeIds_.set (x);
    }

    const BodyType::VertexIds_optional& BodyType::
    VertexIds () const
    {
      return this->VertexIds_;
    }

    BodyType::VertexIds_optional& BodyType::
    VertexIds ()
    {
      return this->VertexIds_;
    }

    void BodyType::
    VertexIds (const VertexIds_type& x)
    {
      this->VertexIds_.set (x);
    }

    void BodyType::
    VertexIds (const VertexIds_optional& x)
    {
      this->VertexIds_ = x;
    }

    void BodyType::
    VertexIds (::std::auto_ptr< VertexIds_type > x)
    {
      this->VertexIds_.set (x);
    }


    // PointCloudSetType
    // 

    const PointCloudSetType::PointCloud_sequence& PointCloudSetType::
    PointCloud () const
    {
      return this->PointCloud_;
    }

    PointCloudSetType::PointCloud_sequence& PointCloudSetType::
    PointCloud ()
    {
      return this->PointCloud_;
    }

    void PointCloudSetType::
    PointCloud (const PointCloud_sequence& s)
    {
      this->PointCloud_ = s;
    }

    const PointCloudSetType::N_type& PointCloudSetType::
    N () const
    {
      return this->N_.get ();
    }

    PointCloudSetType::N_type& PointCloudSetType::
    N ()
    {
      return this->N_.get ();
    }

    void PointCloudSetType::
    N (const N_type& x)
    {
      this->N_.set (x);
    }

    void PointCloudSetType::
    N (::std::auto_ptr< N_type > x)
    {
      this->N_.set (x);
    }


    // PointCloudType
    // 

    const PointCloudType::Points_optional& PointCloudType::
    Points () const
    {
      return this->Points_;
    }

    PointCloudType::Points_optional& PointCloudType::
    Points ()
    {
      return this->Points_;
    }

    void PointCloudType::
    Points (const Points_type& x)
    {
      this->Points_.set (x);
    }

    void PointCloudType::
    Points (const Points_optional& x)
    {
      this->Points_ = x;
    }

    void PointCloudType::
    Points (::std::auto_ptr< Points_type > x)
    {
      this->Points_.set (x);
    }

    const PointCloudType::PointsBinary_optional& PointCloudType::
    PointsBinary () const
    {
      return this->PointsBinary_;
    }

    PointCloudType::PointsBinary_optional& PointCloudType::
    PointsBinary ()
    {
      return this->PointsBinary_;
    }

    void PointCloudType::
    PointsBinary (const PointsBinary_type& x)
    {
      this->PointsBinary_.set (x);
    }

    void PointCloudType::
    PointsBinary (const PointsBinary_optional& x)
    {
      this->PointsBinary_ = x;
    }

    void PointCloudType::
    PointsBinary (::std::auto_ptr< PointsBinary_type > x)
    {
      this->PointsBinary_.set (x);
    }

    const PointCloudType::Normals_optional& PointCloudType::
    Normals () const
    {
      return this->Normals_;
    }

    PointCloudType::Normals_optional& PointCloudType::
    Normals ()
    {
      return this->Normals_;
    }

    void PointCloudType::
    Normals (const Normals_type& x)
    {
      this->Normals_.set (x);
    }

    void PointCloudType::
    Normals (const Normals_optional& x)
    {
      this->Normals_ = x;
    }

    void PointCloudType::
    Normals (::std::auto_ptr< Normals_type > x)
    {
      this->Normals_.set (x);
    }

    const PointCloudType::NormalsBinary_optional& PointCloudType::
    NormalsBinary () const
    {
      return this->NormalsBinary_;
    }

    PointCloudType::NormalsBinary_optional& PointCloudType::
    NormalsBinary ()
    {
      return this->NormalsBinary_;
    }

    void PointCloudType::
    NormalsBinary (const NormalsBinary_type& x)
    {
      this->NormalsBinary_.set (x);
    }

    void PointCloudType::
    NormalsBinary (const NormalsBinary_optional& x)
    {
      this->NormalsBinary_ = x;
    }

    void PointCloudType::
    NormalsBinary (::std::auto_ptr< NormalsBinary_type > x)
    {
      this->NormalsBinary_.set (x);
    }

    const PointCloudType::PointsVisible_optional& PointCloudType::
    PointsVisible () const
    {
      return this->PointsVisible_;
    }

    PointCloudType::PointsVisible_optional& PointCloudType::
    PointsVisible ()
    {
      return this->PointsVisible_;
    }

    void PointCloudType::
    PointsVisible (const PointsVisible_type& x)
    {
      this->PointsVisible_.set (x);
    }

    void PointCloudType::
    PointsVisible (const PointsVisible_optional& x)
    {
      this->PointsVisible_ = x;
    }

    void PointCloudType::
    PointsVisible (::std::auto_ptr< PointsVisible_type > x)
    {
      this->PointsVisible_.set (x);
    }

    const PointCloudType::PointsVisibleBinary_optional& PointCloudType::
    PointsVisibleBinary () const
    {
      return this->PointsVisibleBinary_;
    }

    PointCloudType::PointsVisibleBinary_optional& PointCloudType::
    PointsVisibleBinary ()
    {
      return this->PointsVisibleBinary_;
    }

    void PointCloudType::
    PointsVisibleBinary (const PointsVisibleBinary_type& x)
    {
      this->PointsVisibleBinary_.set (x);
    }

    void PointCloudType::
    PointsVisibleBinary (const PointsVisibleBinary_optional& x)
    {
      this->PointsVisibleBinary_ = x;
    }

    void PointCloudType::
    PointsVisibleBinary (::std::auto_ptr< PointsVisibleBinary_type > x)
    {
      this->PointsVisibleBinary_.set (x);
    }

    const PointCloudType::PointsHidden_optional& PointCloudType::
    PointsHidden () const
    {
      return this->PointsHidden_;
    }

    PointCloudType::PointsHidden_optional& PointCloudType::
    PointsHidden ()
    {
      return this->PointsHidden_;
    }

    void PointCloudType::
    PointsHidden (const PointsHidden_type& x)
    {
      this->PointsHidden_.set (x);
    }

    void PointCloudType::
    PointsHidden (const PointsHidden_optional& x)
    {
      this->PointsHidden_ = x;
    }

    void PointCloudType::
    PointsHidden (::std::auto_ptr< PointsHidden_type > x)
    {
      this->PointsHidden_.set (x);
    }

    const PointCloudType::PointsHiddenBinary_optional& PointCloudType::
    PointsHiddenBinary () const
    {
      return this->PointsHiddenBinary_;
    }

    PointCloudType::PointsHiddenBinary_optional& PointCloudType::
    PointsHiddenBinary ()
    {
      return this->PointsHiddenBinary_;
    }

    void PointCloudType::
    PointsHiddenBinary (const PointsHiddenBinary_type& x)
    {
      this->PointsHiddenBinary_.set (x);
    }

    void PointCloudType::
    PointsHiddenBinary (const PointsHiddenBinary_optional& x)
    {
      this->PointsHiddenBinary_ = x;
    }

    void PointCloudType::
    PointsHiddenBinary (::std::auto_ptr< PointsHiddenBinary_type > x)
    {
      this->PointsHiddenBinary_.set (x);
    }

    const PointCloudType::PointsColor_optional& PointCloudType::
    PointsColor () const
    {
      return this->PointsColor_;
    }

    PointCloudType::PointsColor_optional& PointCloudType::
    PointsColor ()
    {
      return this->PointsColor_;
    }

    void PointCloudType::
    PointsColor (const PointsColor_type& x)
    {
      this->PointsColor_.set (x);
    }

    void PointCloudType::
    PointsColor (const PointsColor_optional& x)
    {
      this->PointsColor_ = x;
    }

    void PointCloudType::
    PointsColor (::std::auto_ptr< PointsColor_type > x)
    {
      this->PointsColor_.set (x);
    }

    const PointCloudType::PointsColorBinary_optional& PointCloudType::
    PointsColorBinary () const
    {
      return this->PointsColorBinary_;
    }

    PointCloudType::PointsColorBinary_optional& PointCloudType::
    PointsColorBinary ()
    {
      return this->PointsColorBinary_;
    }

    void PointCloudType::
    PointsColorBinary (const PointsColorBinary_type& x)
    {
      this->PointsColorBinary_.set (x);
    }

    void PointCloudType::
    PointsColorBinary (const PointsColorBinary_optional& x)
    {
      this->PointsColorBinary_ = x;
    }

    void PointCloudType::
    PointsColorBinary (::std::auto_ptr< PointsColorBinary_type > x)
    {
      this->PointsColorBinary_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace xsd
{
  namespace qif2
  {
    // TopologySetType
    //

    TopologySetType::
    TopologySetType ()
    : ::xml_schema::type (),
      VertexSet_ (::xml_schema::flags (), this),
      EdgeSet_ (::xml_schema::flags (), this),
      LoopSet_ (::xml_schema::flags (), this),
      FaceSet_ (::xml_schema::flags (), this),
      ShellSet_ (::xml_schema::flags (), this),
      BodySet_ (::xml_schema::flags (), this),
      PointCloudSet_ (::xml_schema::flags (), this)
    {
    }

    TopologySetType::
    TopologySetType (const TopologySetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      VertexSet_ (x.VertexSet_, f, this),
      EdgeSet_ (x.EdgeSet_, f, this),
      LoopSet_ (x.LoopSet_, f, this),
      FaceSet_ (x.FaceSet_, f, this),
      ShellSet_ (x.ShellSet_, f, this),
      BodySet_ (x.BodySet_, f, this),
      PointCloudSet_ (x.PointCloudSet_, f, this)
    {
    }

    TopologySetType::
    TopologySetType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      VertexSet_ (f, this),
      EdgeSet_ (f, this),
      LoopSet_ (f, this),
      FaceSet_ (f, this),
      ShellSet_ (f, this),
      BodySet_ (f, this),
      PointCloudSet_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TopologySetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // VertexSet
        //
        if (n.name () == "VertexSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VertexSet_type > r (
            VertexSet_traits::create (i, f, this));

          if (!this->VertexSet_)
          {
            this->VertexSet_.set (r);
            continue;
          }
        }

        // EdgeSet
        //
        if (n.name () == "EdgeSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EdgeSet_type > r (
            EdgeSet_traits::create (i, f, this));

          if (!this->EdgeSet_)
          {
            this->EdgeSet_.set (r);
            continue;
          }
        }

        // LoopSet
        //
        if (n.name () == "LoopSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LoopSet_type > r (
            LoopSet_traits::create (i, f, this));

          if (!this->LoopSet_)
          {
            this->LoopSet_.set (r);
            continue;
          }
        }

        // FaceSet
        //
        if (n.name () == "FaceSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FaceSet_type > r (
            FaceSet_traits::create (i, f, this));

          if (!this->FaceSet_)
          {
            this->FaceSet_.set (r);
            continue;
          }
        }

        // ShellSet
        //
        if (n.name () == "ShellSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ShellSet_type > r (
            ShellSet_traits::create (i, f, this));

          if (!this->ShellSet_)
          {
            this->ShellSet_.set (r);
            continue;
          }
        }

        // BodySet
        //
        if (n.name () == "BodySet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BodySet_type > r (
            BodySet_traits::create (i, f, this));

          if (!this->BodySet_)
          {
            this->BodySet_.set (r);
            continue;
          }
        }

        // PointCloudSet
        //
        if (n.name () == "PointCloudSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointCloudSet_type > r (
            PointCloudSet_traits::create (i, f, this));

          if (!this->PointCloudSet_)
          {
            this->PointCloudSet_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TopologySetType* TopologySetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TopologySetType (*this, f, c);
    }

    TopologySetType::
    ~TopologySetType ()
    {
    }

    // TopologyBaseType
    //

    TopologyBaseType::
    TopologyBaseType (const id_type& id)
    : ::xsd::qif2::DrawableBaseType (id)
    {
    }

    TopologyBaseType::
    TopologyBaseType (const TopologyBaseType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::DrawableBaseType (x, f, c)
    {
    }

    TopologyBaseType::
    TopologyBaseType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::DrawableBaseType (e, f, c)
    {
    }

    TopologyBaseType* TopologyBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TopologyBaseType (*this, f, c);
    }

    TopologyBaseType::
    ~TopologyBaseType ()
    {
    }

    // VertexSetType
    //

    VertexSetType::
    VertexSetType (const N_type& N)
    : ::xml_schema::type (),
      Vertex_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    VertexSetType::
    VertexSetType (const VertexSetType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Vertex_ (x.Vertex_, f, this),
      N_ (x.N_, f, this)
    {
    }

    VertexSetType::
    VertexSetType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Vertex_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void VertexSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Vertex
        //
        if (n.name () == "Vertex" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Vertex_type > r (
            Vertex_traits::create (i, f, this));

          this->Vertex_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    VertexSetType* VertexSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VertexSetType (*this, f, c);
    }

    VertexSetType::
    ~VertexSetType ()
    {
    }

    // VertexType
    //

    VertexType::
    VertexType (const id_type& id,
                const Point_type& Point)
    : ::xsd::qif2::TopologyBaseType (id),
      Point_ (Point, ::xml_schema::flags (), this),
      tolerance_ (::xml_schema::flags (), this)
    {
    }

    VertexType::
    VertexType (const id_type& id,
                ::std::auto_ptr< Point_type >& Point)
    : ::xsd::qif2::TopologyBaseType (id),
      Point_ (Point, ::xml_schema::flags (), this),
      tolerance_ (::xml_schema::flags (), this)
    {
    }

    VertexType::
    VertexType (const VertexType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      Point_ (x.Point_, f, this),
      tolerance_ (x.tolerance_, f, this)
    {
    }

    VertexType::
    VertexType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Point_ (f, this),
      tolerance_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void VertexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Point
        //
        if (n.name () == "Point" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Point_type > r (
            Point_traits::create (i, f, this));

          if (!Point_.present ())
          {
            this->Point_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Point_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Point",
          "http://qifstandards.org/xsd/qif2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "tolerance" && n.namespace_ ().empty ())
        {
          this->tolerance_.set (tolerance_traits::create (i, f, this));
          continue;
        }
      }
    }

    VertexType* VertexType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class VertexType (*this, f, c);
    }

    VertexType::
    ~VertexType ()
    {
    }

    // EdgeSetType
    //

    EdgeSetType::
    EdgeSetType (const N_type& N)
    : ::xml_schema::type (),
      Edge_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    EdgeSetType::
    EdgeSetType (const EdgeSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Edge_ (x.Edge_, f, this),
      N_ (x.N_, f, this)
    {
    }

    EdgeSetType::
    EdgeSetType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Edge_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EdgeSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Edge
        //
        if (n.name () == "Edge" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Edge_type > r (
            Edge_traits::create (i, f, this));

          this->Edge_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    EdgeSetType* EdgeSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgeSetType (*this, f, c);
    }

    EdgeSetType::
    ~EdgeSetType ()
    {
    }

    // EdgeType
    //

    EdgeType::
    EdgeType (const id_type& id,
              const Curve_type& Curve,
              const VertexBeg_type& VertexBeg,
              const VertexEnd_type& VertexEnd)
    : ::xsd::qif2::TopologyBaseType (id),
      Curve_ (Curve, ::xml_schema::flags (), this),
      VertexBeg_ (VertexBeg, ::xml_schema::flags (), this),
      VertexEnd_ (VertexEnd, ::xml_schema::flags (), this),
      tolerance_ (::xml_schema::flags (), this)
    {
    }

    EdgeType::
    EdgeType (const id_type& id,
              ::std::auto_ptr< Curve_type >& Curve,
              ::std::auto_ptr< VertexBeg_type >& VertexBeg,
              ::std::auto_ptr< VertexEnd_type >& VertexEnd)
    : ::xsd::qif2::TopologyBaseType (id),
      Curve_ (Curve, ::xml_schema::flags (), this),
      VertexBeg_ (VertexBeg, ::xml_schema::flags (), this),
      VertexEnd_ (VertexEnd, ::xml_schema::flags (), this),
      tolerance_ (::xml_schema::flags (), this)
    {
    }

    EdgeType::
    EdgeType (const EdgeType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      Curve_ (x.Curve_, f, this),
      VertexBeg_ (x.VertexBeg_, f, this),
      VertexEnd_ (x.VertexEnd_, f, this),
      tolerance_ (x.tolerance_, f, this)
    {
    }

    EdgeType::
    EdgeType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Curve_ (f, this),
      VertexBeg_ (f, this),
      VertexEnd_ (f, this),
      tolerance_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EdgeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Curve
        //
        if (n.name () == "Curve" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Curve_type > r (
            Curve_traits::create (i, f, this));

          if (!Curve_.present ())
          {
            this->Curve_.set (r);
            continue;
          }
        }

        // VertexBeg
        //
        if (n.name () == "VertexBeg" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VertexBeg_type > r (
            VertexBeg_traits::create (i, f, this));

          if (!VertexBeg_.present ())
          {
            this->VertexBeg_.set (r);
            continue;
          }
        }

        // VertexEnd
        //
        if (n.name () == "VertexEnd" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VertexEnd_type > r (
            VertexEnd_traits::create (i, f, this));

          if (!VertexEnd_.present ())
          {
            this->VertexEnd_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Curve_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Curve",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!VertexBeg_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "VertexBeg",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!VertexEnd_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "VertexEnd",
          "http://qifstandards.org/xsd/qif2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "tolerance" && n.namespace_ ().empty ())
        {
          this->tolerance_.set (tolerance_traits::create (i, f, this));
          continue;
        }
      }
    }

    EdgeType* EdgeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgeType (*this, f, c);
    }

    EdgeType::
    ~EdgeType ()
    {
    }

    // LoopSetType
    //

    LoopSetType::
    LoopSetType (const N_type& N)
    : ::xml_schema::type (),
      LoopBase_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    LoopSetType::
    LoopSetType (const LoopSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      LoopBase_ (x.LoopBase_, f, this),
      N_ (x.N_, f, this)
    {
    }

    LoopSetType::
    LoopSetType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      LoopBase_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void LoopSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // LoopBase
        //
        if (n.name () == "LoopBase" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LoopBase_type > r (
            LoopBase_traits::create (i, f, this));

          this->LoopBase_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    LoopSetType* LoopSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopSetType (*this, f, c);
    }

    LoopSetType::
    ~LoopSetType ()
    {
    }

    // LoopBaseType
    //

    LoopBaseType::
    LoopBaseType (const id_type& id)
    : ::xsd::qif2::TopologyBaseType (id)
    {
    }

    LoopBaseType::
    LoopBaseType (const LoopBaseType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c)
    {
    }

    LoopBaseType::
    LoopBaseType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f, c)
    {
    }

    LoopBaseType* LoopBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopBaseType (*this, f, c);
    }

    LoopBaseType::
    ~LoopBaseType ()
    {
    }

    // LoopFormEnumType
    //

    LoopFormEnumType::
    LoopFormEnumType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_LoopFormEnumType_convert ();
    }

    LoopFormEnumType::
    LoopFormEnumType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_LoopFormEnumType_convert ();
    }

    LoopFormEnumType::
    LoopFormEnumType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_LoopFormEnumType_convert ();
    }

    LoopFormEnumType* LoopFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopFormEnumType (*this, f, c);
    }

    LoopFormEnumType::value LoopFormEnumType::
    _xsd_LoopFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LoopFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_LoopFormEnumType_indexes_,
                        _xsd_LoopFormEnumType_indexes_ + 4,
                        *this,
                        c));

      if (i == _xsd_LoopFormEnumType_indexes_ + 4 || _xsd_LoopFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const LoopFormEnumType::
    _xsd_LoopFormEnumType_literals_[4] =
    {
      "UNKNOWN",
      "OUTER",
      "INNER",
      "SLIT"
    };

    const LoopFormEnumType::value LoopFormEnumType::
    _xsd_LoopFormEnumType_indexes_[4] =
    {
      ::xsd::qif2::LoopFormEnumType::INNER,
      ::xsd::qif2::LoopFormEnumType::OUTER,
      ::xsd::qif2::LoopFormEnumType::SLIT,
      ::xsd::qif2::LoopFormEnumType::UNKNOWN
    };

    // EdgeOrientedType
    //

    EdgeOrientedType::
    EdgeOrientedType (const Id_type& Id)
    : ::xsd::qif2::ElementReferenceType (Id),
      turned_ (turned_default_value (), ::xml_schema::flags (), this)
    {
    }

    EdgeOrientedType::
    EdgeOrientedType (const EdgeOrientedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ElementReferenceType (x, f, c),
      turned_ (x.turned_, f, this)
    {
    }

    EdgeOrientedType::
    EdgeOrientedType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ElementReferenceType (e, f | ::xml_schema::flags::base, c),
      turned_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EdgeOrientedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ElementReferenceType::parse (p, f);

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }
    }

    EdgeOrientedType* EdgeOrientedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgeOrientedType (*this, f, c);
    }

    EdgeOrientedType::
    ~EdgeOrientedType ()
    {
    }

    // CoEdgeType
    //

    CoEdgeType::
    CoEdgeType (const EdgeOriented_type& EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (EdgeOriented, ::xml_schema::flags (), this),
      Curve12_ (::xml_schema::flags (), this)
    {
    }

    CoEdgeType::
    CoEdgeType (::std::auto_ptr< EdgeOriented_type >& EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (EdgeOriented, ::xml_schema::flags (), this),
      Curve12_ (::xml_schema::flags (), this)
    {
    }

    CoEdgeType::
    CoEdgeType (const CoEdgeType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EdgeOriented_ (x.EdgeOriented_, f, this),
      Curve12_ (x.Curve12_, f, this)
    {
    }

    CoEdgeType::
    CoEdgeType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EdgeOriented_ (f, this),
      Curve12_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CoEdgeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EdgeOriented
        //
        if (n.name () == "EdgeOriented" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EdgeOriented_type > r (
            EdgeOriented_traits::create (i, f, this));

          if (!EdgeOriented_.present ())
          {
            this->EdgeOriented_.set (r);
            continue;
          }
        }

        // Curve12
        //
        if (n.name () == "Curve12" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Curve12_type > r (
            Curve12_traits::create (i, f, this));

          if (!this->Curve12_)
          {
            this->Curve12_.set (r);
            continue;
          }
        }

        break;
      }

      if (!EdgeOriented_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EdgeOriented",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CoEdgeType* CoEdgeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgeType (*this, f, c);
    }

    CoEdgeType::
    ~CoEdgeType ()
    {
    }

    // CoEdgesType
    //

    CoEdgesType::
    CoEdgesType (const N_type& N)
    : ::xml_schema::type (),
      CoEdge_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    CoEdgesType::
    CoEdgesType (const CoEdgesType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoEdge_ (x.CoEdge_, f, this),
      N_ (x.N_, f, this)
    {
    }

    CoEdgesType::
    CoEdgesType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoEdge_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CoEdgesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CoEdge
        //
        if (n.name () == "CoEdge" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoEdge_type > r (
            CoEdge_traits::create (i, f, this));

          this->CoEdge_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    CoEdgesType* CoEdgesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgesType (*this, f, c);
    }

    CoEdgesType::
    ~CoEdgesType ()
    {
    }

    // CoEdgeMeshType
    //

    CoEdgeMeshType::
    CoEdgeMeshType (const EdgeOriented_type& EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (EdgeOriented, ::xml_schema::flags (), this),
      CurveMesh_ (::xml_schema::flags (), this)
    {
    }

    CoEdgeMeshType::
    CoEdgeMeshType (::std::auto_ptr< EdgeOriented_type >& EdgeOriented)
    : ::xml_schema::type (),
      EdgeOriented_ (EdgeOriented, ::xml_schema::flags (), this),
      CurveMesh_ (::xml_schema::flags (), this)
    {
    }

    CoEdgeMeshType::
    CoEdgeMeshType (const CoEdgeMeshType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EdgeOriented_ (x.EdgeOriented_, f, this),
      CurveMesh_ (x.CurveMesh_, f, this)
    {
    }

    CoEdgeMeshType::
    CoEdgeMeshType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EdgeOriented_ (f, this),
      CurveMesh_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CoEdgeMeshType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // EdgeOriented
        //
        if (n.name () == "EdgeOriented" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EdgeOriented_type > r (
            EdgeOriented_traits::create (i, f, this));

          if (!EdgeOriented_.present ())
          {
            this->EdgeOriented_.set (r);
            continue;
          }
        }

        // CurveMesh
        //
        if (n.name () == "CurveMesh" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CurveMesh_type > r (
            CurveMesh_traits::create (i, f, this));

          if (!this->CurveMesh_)
          {
            this->CurveMesh_.set (r);
            continue;
          }
        }

        break;
      }

      if (!EdgeOriented_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EdgeOriented",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CoEdgeMeshType* CoEdgeMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgeMeshType (*this, f, c);
    }

    CoEdgeMeshType::
    ~CoEdgeMeshType ()
    {
    }

    // CoEdgesMeshType
    //

    CoEdgesMeshType::
    CoEdgesMeshType (const N_type& N)
    : ::xml_schema::type (),
      CoEdgeMesh_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    CoEdgesMeshType::
    CoEdgesMeshType (const CoEdgesMeshType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CoEdgeMesh_ (x.CoEdgeMesh_, f, this),
      N_ (x.N_, f, this)
    {
    }

    CoEdgesMeshType::
    CoEdgesMeshType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CoEdgeMesh_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CoEdgesMeshType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CoEdgeMesh
        //
        if (n.name () == "CoEdgeMesh" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoEdgeMesh_type > r (
            CoEdgeMesh_traits::create (i, f, this));

          this->CoEdgeMesh_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    CoEdgesMeshType* CoEdgesMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CoEdgesMeshType (*this, f, c);
    }

    CoEdgesMeshType::
    ~CoEdgesMeshType ()
    {
    }

    // LoopType
    //

    const LoopType::form_type LoopType::form_default_value_ (
      "UNKNOWN");

    LoopType::
    LoopType (const id_type& id,
              const CoEdges_type& CoEdges)
    : ::xsd::qif2::LoopBaseType (id),
      CoEdges_ (CoEdges, ::xml_schema::flags (), this),
      form_ (form_default_value (), ::xml_schema::flags (), this)
    {
    }

    LoopType::
    LoopType (const id_type& id,
              ::std::auto_ptr< CoEdges_type >& CoEdges)
    : ::xsd::qif2::LoopBaseType (id),
      CoEdges_ (CoEdges, ::xml_schema::flags (), this),
      form_ (form_default_value (), ::xml_schema::flags (), this)
    {
    }

    LoopType::
    LoopType (const LoopType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::LoopBaseType (x, f, c),
      CoEdges_ (x.CoEdges_, f, this),
      form_ (x.form_, f, this)
    {
    }

    LoopType::
    LoopType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::LoopBaseType (e, f | ::xml_schema::flags::base, c),
      CoEdges_ (f, this),
      form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void LoopType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::LoopBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CoEdges
        //
        if (n.name () == "CoEdges" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoEdges_type > r (
            CoEdges_traits::create (i, f, this));

          if (!CoEdges_.present ())
          {
            this->CoEdges_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CoEdges_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CoEdges",
          "http://qifstandards.org/xsd/qif2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "form" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< form_type > r (
            form_traits::create (i, f, this));

          this->form_.set (r);
          continue;
        }
      }

      if (!form_.present ())
      {
        this->form_.set (form_default_value ());
      }
    }

    LoopType* LoopType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopType (*this, f, c);
    }

    LoopType::
    ~LoopType ()
    {
    }

    // LoopMeshType
    //

    LoopMeshType::
    LoopMeshType (const id_type& id,
                  const CoEdgesMesh_type& CoEdgesMesh)
    : ::xsd::qif2::LoopBaseType (id),
      CoEdgesMesh_ (CoEdgesMesh, ::xml_schema::flags (), this)
    {
    }

    LoopMeshType::
    LoopMeshType (const id_type& id,
                  ::std::auto_ptr< CoEdgesMesh_type >& CoEdgesMesh)
    : ::xsd::qif2::LoopBaseType (id),
      CoEdgesMesh_ (CoEdgesMesh, ::xml_schema::flags (), this)
    {
    }

    LoopMeshType::
    LoopMeshType (const LoopMeshType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::LoopBaseType (x, f, c),
      CoEdgesMesh_ (x.CoEdgesMesh_, f, this)
    {
    }

    LoopMeshType::
    LoopMeshType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::LoopBaseType (e, f | ::xml_schema::flags::base, c),
      CoEdgesMesh_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void LoopMeshType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::LoopBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CoEdgesMesh
        //
        if (n.name () == "CoEdgesMesh" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoEdgesMesh_type > r (
            CoEdgesMesh_traits::create (i, f, this));

          if (!CoEdgesMesh_.present ())
          {
            this->CoEdgesMesh_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CoEdgesMesh_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CoEdgesMesh",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LoopMeshType* LoopMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LoopMeshType (*this, f, c);
    }

    LoopMeshType::
    ~LoopMeshType ()
    {
    }

    // FaceSetType
    //

    FaceSetType::
    FaceSetType (const N_type& N)
    : ::xml_schema::type (),
      FaceBase_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    FaceSetType::
    FaceSetType (const FaceSetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FaceBase_ (x.FaceBase_, f, this),
      N_ (x.N_, f, this)
    {
    }

    FaceSetType::
    FaceSetType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FaceBase_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void FaceSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FaceBase
        //
        if (n.name () == "FaceBase" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FaceBase_type > r (
            FaceBase_traits::create (i, f, this));

          this->FaceBase_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    FaceSetType* FaceSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FaceSetType (*this, f, c);
    }

    FaceSetType::
    ~FaceSetType ()
    {
    }

    // FaceBaseType
    //

    FaceBaseType::
    FaceBaseType (const id_type& id)
    : ::xsd::qif2::TopologyBaseType (id),
      InertiaMatrix_ (::xml_schema::flags (), this),
      turned_ (turned_default_value (), ::xml_schema::flags (), this),
      area_ (::xml_schema::flags (), this),
      volume_ (::xml_schema::flags (), this),
      massCenter_ (::xml_schema::flags (), this)
    {
    }

    FaceBaseType::
    FaceBaseType (const FaceBaseType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      InertiaMatrix_ (x.InertiaMatrix_, f, this),
      turned_ (x.turned_, f, this),
      area_ (x.area_, f, this),
      volume_ (x.volume_, f, this),
      massCenter_ (x.massCenter_, f, this)
    {
    }

    FaceBaseType::
    FaceBaseType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      InertiaMatrix_ (f, this),
      turned_ (f, this),
      area_ (f, this),
      volume_ (f, this),
      massCenter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void FaceBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InertiaMatrix
        //
        if (n.name () == "InertiaMatrix" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InertiaMatrix_type > r (
            InertiaMatrix_traits::create (i, f, this));

          if (!this->InertiaMatrix_)
          {
            this->InertiaMatrix_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "area" && n.namespace_ ().empty ())
        {
          this->area_.set (area_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "volume" && n.namespace_ ().empty ())
        {
          this->volume_.set (volume_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "massCenter" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< massCenter_type > r (
            massCenter_traits::create (i, f, this));

          this->massCenter_.set (r);
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }
    }

    FaceBaseType* FaceBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FaceBaseType (*this, f, c);
    }

    FaceBaseType::
    ~FaceBaseType ()
    {
    }

    // FaceType
    //

    FaceType::
    FaceType (const id_type& id,
              const Surface_type& Surface)
    : ::xsd::qif2::FaceBaseType (id),
      Surface_ (Surface, ::xml_schema::flags (), this),
      LoopIds_ (::xml_schema::flags (), this),
      hasOuter_ (hasOuter_default_value (), ::xml_schema::flags (), this)
    {
    }

    FaceType::
    FaceType (const id_type& id,
              ::std::auto_ptr< Surface_type >& Surface)
    : ::xsd::qif2::FaceBaseType (id),
      Surface_ (Surface, ::xml_schema::flags (), this),
      LoopIds_ (::xml_schema::flags (), this),
      hasOuter_ (hasOuter_default_value (), ::xml_schema::flags (), this)
    {
    }

    FaceType::
    FaceType (const FaceType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::FaceBaseType (x, f, c),
      Surface_ (x.Surface_, f, this),
      LoopIds_ (x.LoopIds_, f, this),
      hasOuter_ (x.hasOuter_, f, this)
    {
    }

    FaceType::
    FaceType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::FaceBaseType (e, f | ::xml_schema::flags::base, c),
      Surface_ (f, this),
      LoopIds_ (f, this),
      hasOuter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void FaceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FaceBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Surface
        //
        if (n.name () == "Surface" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Surface_type > r (
            Surface_traits::create (i, f, this));

          if (!Surface_.present ())
          {
            this->Surface_.set (r);
            continue;
          }
        }

        // LoopIds
        //
        if (n.name () == "LoopIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LoopIds_type > r (
            LoopIds_traits::create (i, f, this));

          if (!this->LoopIds_)
          {
            this->LoopIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Surface_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Surface",
          "http://qifstandards.org/xsd/qif2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "hasOuter" && n.namespace_ ().empty ())
        {
          this->hasOuter_.set (hasOuter_traits::create (i, f, this));
          continue;
        }
      }

      if (!hasOuter_.present ())
      {
        this->hasOuter_.set (hasOuter_default_value ());
      }
    }

    FaceType* FaceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FaceType (*this, f, c);
    }

    FaceType::
    ~FaceType ()
    {
    }

    // FaceMeshType
    //

    FaceMeshType::
    FaceMeshType (const id_type& id,
                  const Mesh_type& Mesh)
    : ::xsd::qif2::FaceBaseType (id),
      Mesh_ (Mesh, ::xml_schema::flags (), this),
      LoopIds_ (::xml_schema::flags (), this),
      Triangles_ (::xml_schema::flags (), this),
      TrianglesBinary_ (::xml_schema::flags (), this),
      TrianglesVisible_ (::xml_schema::flags (), this),
      TrianglesVisibleBinary_ (::xml_schema::flags (), this),
      TrianglesHidden_ (::xml_schema::flags (), this),
      TrianglesHiddenBinary_ (::xml_schema::flags (), this),
      TrianglesColor_ (::xml_schema::flags (), this),
      TrianglesColorBinary_ (::xml_schema::flags (), this)
    {
    }

    FaceMeshType::
    FaceMeshType (const id_type& id,
                  ::std::auto_ptr< Mesh_type >& Mesh)
    : ::xsd::qif2::FaceBaseType (id),
      Mesh_ (Mesh, ::xml_schema::flags (), this),
      LoopIds_ (::xml_schema::flags (), this),
      Triangles_ (::xml_schema::flags (), this),
      TrianglesBinary_ (::xml_schema::flags (), this),
      TrianglesVisible_ (::xml_schema::flags (), this),
      TrianglesVisibleBinary_ (::xml_schema::flags (), this),
      TrianglesHidden_ (::xml_schema::flags (), this),
      TrianglesHiddenBinary_ (::xml_schema::flags (), this),
      TrianglesColor_ (::xml_schema::flags (), this),
      TrianglesColorBinary_ (::xml_schema::flags (), this)
    {
    }

    FaceMeshType::
    FaceMeshType (const FaceMeshType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::FaceBaseType (x, f, c),
      Mesh_ (x.Mesh_, f, this),
      LoopIds_ (x.LoopIds_, f, this),
      Triangles_ (x.Triangles_, f, this),
      TrianglesBinary_ (x.TrianglesBinary_, f, this),
      TrianglesVisible_ (x.TrianglesVisible_, f, this),
      TrianglesVisibleBinary_ (x.TrianglesVisibleBinary_, f, this),
      TrianglesHidden_ (x.TrianglesHidden_, f, this),
      TrianglesHiddenBinary_ (x.TrianglesHiddenBinary_, f, this),
      TrianglesColor_ (x.TrianglesColor_, f, this),
      TrianglesColorBinary_ (x.TrianglesColorBinary_, f, this)
    {
    }

    FaceMeshType::
    FaceMeshType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::FaceBaseType (e, f | ::xml_schema::flags::base, c),
      Mesh_ (f, this),
      LoopIds_ (f, this),
      Triangles_ (f, this),
      TrianglesBinary_ (f, this),
      TrianglesVisible_ (f, this),
      TrianglesVisibleBinary_ (f, this),
      TrianglesHidden_ (f, this),
      TrianglesHiddenBinary_ (f, this),
      TrianglesColor_ (f, this),
      TrianglesColorBinary_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void FaceMeshType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FaceBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Mesh
        //
        if (n.name () == "Mesh" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Mesh_type > r (
            Mesh_traits::create (i, f, this));

          if (!Mesh_.present ())
          {
            this->Mesh_.set (r);
            continue;
          }
        }

        // LoopIds
        //
        if (n.name () == "LoopIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LoopIds_type > r (
            LoopIds_traits::create (i, f, this));

          if (!this->LoopIds_)
          {
            this->LoopIds_.set (r);
            continue;
          }
        }

        // Triangles
        //
        if (n.name () == "Triangles" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Triangles_type > r (
            Triangles_traits::create (i, f, this));

          if (!this->Triangles_)
          {
            this->Triangles_.set (r);
            continue;
          }
        }

        // TrianglesBinary
        //
        if (n.name () == "TrianglesBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesBinary_type > r (
            TrianglesBinary_traits::create (i, f, this));

          if (!this->TrianglesBinary_)
          {
            this->TrianglesBinary_.set (r);
            continue;
          }
        }

        // TrianglesVisible
        //
        if (n.name () == "TrianglesVisible" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesVisible_type > r (
            TrianglesVisible_traits::create (i, f, this));

          if (!this->TrianglesVisible_)
          {
            this->TrianglesVisible_.set (r);
            continue;
          }
        }

        // TrianglesVisibleBinary
        //
        if (n.name () == "TrianglesVisibleBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesVisibleBinary_type > r (
            TrianglesVisibleBinary_traits::create (i, f, this));

          if (!this->TrianglesVisibleBinary_)
          {
            this->TrianglesVisibleBinary_.set (r);
            continue;
          }
        }

        // TrianglesHidden
        //
        if (n.name () == "TrianglesHidden" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesHidden_type > r (
            TrianglesHidden_traits::create (i, f, this));

          if (!this->TrianglesHidden_)
          {
            this->TrianglesHidden_.set (r);
            continue;
          }
        }

        // TrianglesHiddenBinary
        //
        if (n.name () == "TrianglesHiddenBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesHiddenBinary_type > r (
            TrianglesHiddenBinary_traits::create (i, f, this));

          if (!this->TrianglesHiddenBinary_)
          {
            this->TrianglesHiddenBinary_.set (r);
            continue;
          }
        }

        // TrianglesColor
        //
        if (n.name () == "TrianglesColor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesColor_type > r (
            TrianglesColor_traits::create (i, f, this));

          if (!this->TrianglesColor_)
          {
            this->TrianglesColor_.set (r);
            continue;
          }
        }

        // TrianglesColorBinary
        //
        if (n.name () == "TrianglesColorBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TrianglesColorBinary_type > r (
            TrianglesColorBinary_traits::create (i, f, this));

          if (!this->TrianglesColorBinary_)
          {
            this->TrianglesColorBinary_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Mesh_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Mesh",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FaceMeshType* FaceMeshType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FaceMeshType (*this, f, c);
    }

    FaceMeshType::
    ~FaceMeshType ()
    {
    }

    // ShellSetType
    //

    ShellSetType::
    ShellSetType (const N_type& N)
    : ::xml_schema::type (),
      Shell_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    ShellSetType::
    ShellSetType (const ShellSetType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Shell_ (x.Shell_, f, this),
      N_ (x.N_, f, this)
    {
    }

    ShellSetType::
    ShellSetType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Shell_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ShellSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Shell
        //
        if (n.name () == "Shell" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Shell_type > r (
            Shell_traits::create (i, f, this));

          this->Shell_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    ShellSetType* ShellSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShellSetType (*this, f, c);
    }

    ShellSetType::
    ~ShellSetType ()
    {
    }

    // ShellFormEnumType
    //

    ShellFormEnumType::
    ShellFormEnumType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (e, f, c)
    {
      _xsd_ShellFormEnumType_convert ();
    }

    ShellFormEnumType::
    ShellFormEnumType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (a, f, c)
    {
      _xsd_ShellFormEnumType_convert ();
    }

    ShellFormEnumType::
    ShellFormEnumType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::string (s, e, f, c)
    {
      _xsd_ShellFormEnumType_convert ();
    }

    ShellFormEnumType* ShellFormEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShellFormEnumType (*this, f, c);
    }

    ShellFormEnumType::value ShellFormEnumType::
    _xsd_ShellFormEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ShellFormEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_ShellFormEnumType_indexes_,
                        _xsd_ShellFormEnumType_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_ShellFormEnumType_indexes_ + 3 || _xsd_ShellFormEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ShellFormEnumType::
    _xsd_ShellFormEnumType_literals_[3] =
    {
      "UNKNOWN",
      "OUTER",
      "INNER"
    };

    const ShellFormEnumType::value ShellFormEnumType::
    _xsd_ShellFormEnumType_indexes_[3] =
    {
      ::xsd::qif2::ShellFormEnumType::INNER,
      ::xsd::qif2::ShellFormEnumType::OUTER,
      ::xsd::qif2::ShellFormEnumType::UNKNOWN
    };

    // ShellType
    //

    const ShellType::form_type ShellType::form_default_value_ (
      "UNKNOWN");

    ShellType::
    ShellType (const id_type& id)
    : ::xsd::qif2::TopologyBaseType (id),
      FaceIds_ (::xml_schema::flags (), this),
      turned_ (turned_default_value (), ::xml_schema::flags (), this),
      closed_ (closed_default_value (), ::xml_schema::flags (), this),
      form_ (form_default_value (), ::xml_schema::flags (), this)
    {
    }

    ShellType::
    ShellType (const ShellType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      FaceIds_ (x.FaceIds_, f, this),
      turned_ (x.turned_, f, this),
      closed_ (x.closed_, f, this),
      form_ (x.form_, f, this)
    {
    }

    ShellType::
    ShellType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      FaceIds_ (f, this),
      turned_ (f, this),
      closed_ (f, this),
      form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ShellType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FaceIds
        //
        if (n.name () == "FaceIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FaceIds_type > r (
            FaceIds_traits::create (i, f, this));

          if (!this->FaceIds_)
          {
            this->FaceIds_.set (r);
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "turned" && n.namespace_ ().empty ())
        {
          this->turned_.set (turned_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "closed" && n.namespace_ ().empty ())
        {
          this->closed_.set (closed_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "form" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< form_type > r (
            form_traits::create (i, f, this));

          this->form_.set (r);
          continue;
        }
      }

      if (!turned_.present ())
      {
        this->turned_.set (turned_default_value ());
      }

      if (!closed_.present ())
      {
        this->closed_.set (closed_default_value ());
      }

      if (!form_.present ())
      {
        this->form_.set (form_default_value ());
      }
    }

    ShellType* ShellType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ShellType (*this, f, c);
    }

    ShellType::
    ~ShellType ()
    {
    }

    // BodySetType
    //

    BodySetType::
    BodySetType (const N_type& N)
    : ::xml_schema::type (),
      Body_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    BodySetType::
    BodySetType (const BodySetType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Body_ (x.Body_, f, this),
      N_ (x.N_, f, this)
    {
    }

    BodySetType::
    BodySetType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Body_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void BodySetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Body
        //
        if (n.name () == "Body" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Body_type > r (
            Body_traits::create (i, f, this));

          this->Body_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    BodySetType* BodySetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BodySetType (*this, f, c);
    }

    BodySetType::
    ~BodySetType ()
    {
    }

    // BodyType
    //

    BodyType::
    BodyType (const id_type& id)
    : ::xsd::qif2::TopologyBaseType (id),
      Transform_ (::xml_schema::flags (), this),
      ShellIds_ (::xml_schema::flags (), this),
      FaceIds_ (::xml_schema::flags (), this),
      LoopIds_ (::xml_schema::flags (), this),
      EdgeIds_ (::xml_schema::flags (), this),
      VertexIds_ (::xml_schema::flags (), this)
    {
    }

    BodyType::
    BodyType (const BodyType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      Transform_ (x.Transform_, f, this),
      ShellIds_ (x.ShellIds_, f, this),
      FaceIds_ (x.FaceIds_, f, this),
      LoopIds_ (x.LoopIds_, f, this),
      EdgeIds_ (x.EdgeIds_, f, this),
      VertexIds_ (x.VertexIds_, f, this)
    {
    }

    BodyType::
    BodyType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Transform_ (f, this),
      ShellIds_ (f, this),
      FaceIds_ (f, this),
      LoopIds_ (f, this),
      EdgeIds_ (f, this),
      VertexIds_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void BodyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // ShellIds
        //
        if (n.name () == "ShellIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ShellIds_type > r (
            ShellIds_traits::create (i, f, this));

          if (!this->ShellIds_)
          {
            this->ShellIds_.set (r);
            continue;
          }
        }

        // FaceIds
        //
        if (n.name () == "FaceIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FaceIds_type > r (
            FaceIds_traits::create (i, f, this));

          if (!this->FaceIds_)
          {
            this->FaceIds_.set (r);
            continue;
          }
        }

        // LoopIds
        //
        if (n.name () == "LoopIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LoopIds_type > r (
            LoopIds_traits::create (i, f, this));

          if (!this->LoopIds_)
          {
            this->LoopIds_.set (r);
            continue;
          }
        }

        // EdgeIds
        //
        if (n.name () == "EdgeIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EdgeIds_type > r (
            EdgeIds_traits::create (i, f, this));

          if (!this->EdgeIds_)
          {
            this->EdgeIds_.set (r);
            continue;
          }
        }

        // VertexIds
        //
        if (n.name () == "VertexIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< VertexIds_type > r (
            VertexIds_traits::create (i, f, this));

          if (!this->VertexIds_)
          {
            this->VertexIds_.set (r);
            continue;
          }
        }

        break;
      }
    }

    BodyType* BodyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BodyType (*this, f, c);
    }

    BodyType::
    ~BodyType ()
    {
    }

    // PointCloudSetType
    //

    PointCloudSetType::
    PointCloudSetType (const N_type& N)
    : ::xml_schema::type (),
      PointCloud_ (::xml_schema::flags (), this),
      N_ (N, ::xml_schema::flags (), this)
    {
    }

    PointCloudSetType::
    PointCloudSetType (const PointCloudSetType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointCloud_ (x.PointCloud_, f, this),
      N_ (x.N_, f, this)
    {
    }

    PointCloudSetType::
    PointCloudSetType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointCloud_ (f, this),
      N_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointCloudSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointCloud
        //
        if (n.name () == "PointCloud" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointCloud_type > r (
            PointCloud_traits::create (i, f, this));

          this->PointCloud_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "N" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< N_type > r (
            N_traits::create (i, f, this));

          this->N_.set (r);
          continue;
        }
      }

      if (!N_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "N",
          "");
      }
    }

    PointCloudSetType* PointCloudSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCloudSetType (*this, f, c);
    }

    PointCloudSetType::
    ~PointCloudSetType ()
    {
    }

    // PointCloudType
    //

    PointCloudType::
    PointCloudType (const id_type& id)
    : ::xsd::qif2::TopologyBaseType (id),
      Points_ (::xml_schema::flags (), this),
      PointsBinary_ (::xml_schema::flags (), this),
      Normals_ (::xml_schema::flags (), this),
      NormalsBinary_ (::xml_schema::flags (), this),
      PointsVisible_ (::xml_schema::flags (), this),
      PointsVisibleBinary_ (::xml_schema::flags (), this),
      PointsHidden_ (::xml_schema::flags (), this),
      PointsHiddenBinary_ (::xml_schema::flags (), this),
      PointsColor_ (::xml_schema::flags (), this),
      PointsColorBinary_ (::xml_schema::flags (), this)
    {
    }

    PointCloudType::
    PointCloudType (const PointCloudType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (x, f, c),
      Points_ (x.Points_, f, this),
      PointsBinary_ (x.PointsBinary_, f, this),
      Normals_ (x.Normals_, f, this),
      NormalsBinary_ (x.NormalsBinary_, f, this),
      PointsVisible_ (x.PointsVisible_, f, this),
      PointsVisibleBinary_ (x.PointsVisibleBinary_, f, this),
      PointsHidden_ (x.PointsHidden_, f, this),
      PointsHiddenBinary_ (x.PointsHiddenBinary_, f, this),
      PointsColor_ (x.PointsColor_, f, this),
      PointsColorBinary_ (x.PointsColorBinary_, f, this)
    {
    }

    PointCloudType::
    PointCloudType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::TopologyBaseType (e, f | ::xml_schema::flags::base, c),
      Points_ (f, this),
      PointsBinary_ (f, this),
      Normals_ (f, this),
      NormalsBinary_ (f, this),
      PointsVisible_ (f, this),
      PointsVisibleBinary_ (f, this),
      PointsHidden_ (f, this),
      PointsHiddenBinary_ (f, this),
      PointsColor_ (f, this),
      PointsColorBinary_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointCloudType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::TopologyBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Points
        //
        if (n.name () == "Points" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Points_type > r (
            Points_traits::create (i, f, this));

          if (!this->Points_)
          {
            this->Points_.set (r);
            continue;
          }
        }

        // PointsBinary
        //
        if (n.name () == "PointsBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsBinary_type > r (
            PointsBinary_traits::create (i, f, this));

          if (!this->PointsBinary_)
          {
            this->PointsBinary_.set (r);
            continue;
          }
        }

        // Normals
        //
        if (n.name () == "Normals" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normals_type > r (
            Normals_traits::create (i, f, this));

          if (!this->Normals_)
          {
            this->Normals_.set (r);
            continue;
          }
        }

        // NormalsBinary
        //
        if (n.name () == "NormalsBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NormalsBinary_type > r (
            NormalsBinary_traits::create (i, f, this));

          if (!this->NormalsBinary_)
          {
            this->NormalsBinary_.set (r);
            continue;
          }
        }

        // PointsVisible
        //
        if (n.name () == "PointsVisible" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsVisible_type > r (
            PointsVisible_traits::create (i, f, this));

          if (!this->PointsVisible_)
          {
            this->PointsVisible_.set (r);
            continue;
          }
        }

        // PointsVisibleBinary
        //
        if (n.name () == "PointsVisibleBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsVisibleBinary_type > r (
            PointsVisibleBinary_traits::create (i, f, this));

          if (!this->PointsVisibleBinary_)
          {
            this->PointsVisibleBinary_.set (r);
            continue;
          }
        }

        // PointsHidden
        //
        if (n.name () == "PointsHidden" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsHidden_type > r (
            PointsHidden_traits::create (i, f, this));

          if (!this->PointsHidden_)
          {
            this->PointsHidden_.set (r);
            continue;
          }
        }

        // PointsHiddenBinary
        //
        if (n.name () == "PointsHiddenBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsHiddenBinary_type > r (
            PointsHiddenBinary_traits::create (i, f, this));

          if (!this->PointsHiddenBinary_)
          {
            this->PointsHiddenBinary_.set (r);
            continue;
          }
        }

        // PointsColor
        //
        if (n.name () == "PointsColor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsColor_type > r (
            PointsColor_traits::create (i, f, this));

          if (!this->PointsColor_)
          {
            this->PointsColor_.set (r);
            continue;
          }
        }

        // PointsColorBinary
        //
        if (n.name () == "PointsColorBinary" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointsColorBinary_type > r (
            PointsColorBinary_traits::create (i, f, this));

          if (!this->PointsColorBinary_)
          {
            this->PointsColorBinary_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointCloudType* PointCloudType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCloudType (*this, f, c);
    }

    PointCloudType::
    ~PointCloudType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TopologySetType > r (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TopologySetType > r (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TopologySetType > r (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TopologySet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TopologySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TopologySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TopologySet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TopologySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TopologySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TopologySetType > r (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TopologySetType > r (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TopologySetType > r (
        ::xsd::qif2::TopologySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::TopologySetType > r (
          ::xsd::qif2::TopologySet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "TopologySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TopologySetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TopologySetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TopologySet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TopologySetType >
    TopologySet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "TopologySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TopologySetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TopologySetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TopologySet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::VertexSetType > r (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::VertexSetType > r (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::VertexSetType > r (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::VertexSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::VertexSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::VertexSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::VertexSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::VertexSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::VertexSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::VertexSetType > r (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::VertexSetType > r (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::VertexSetType > r (
        ::xsd::qif2::VertexSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::VertexSetType > r (
          ::xsd::qif2::VertexSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "VertexSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::VertexSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::VertexSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "VertexSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::VertexSetType >
    VertexSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "VertexSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::VertexSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::VertexSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "VertexSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::VertexType > r (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::VertexType > r (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::VertexType > r (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Vertex (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Vertex (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Vertex (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Vertex (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Vertex (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Vertex (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::VertexType > r (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::VertexType > r (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::VertexType > r (
        ::xsd::qif2::Vertex (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::VertexType > r (
          ::xsd::qif2::Vertex (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Vertex" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::VertexType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::VertexType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Vertex",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::VertexType >
    Vertex (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Vertex" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::VertexType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::VertexType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Vertex",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeSetType > r (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeSetType > r (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeSetType > r (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgeSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgeSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgeSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgeSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgeSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgeSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeSetType > r (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeSetType > r (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeSetType > r (
        ::xsd::qif2::EdgeSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::EdgeSetType > r (
          ::xsd::qif2::EdgeSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "EdgeSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgeSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgeSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgeSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeSetType >
    EdgeSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "EdgeSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgeSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgeSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgeSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeType > r (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeType > r (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeType > r (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Edge (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Edge (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Edge (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Edge (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Edge (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Edge (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeType > r (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeType > r (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgeType > r (
        ::xsd::qif2::Edge (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::EdgeType > r (
          ::xsd::qif2::Edge (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Edge" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgeType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgeType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Edge",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgeType >
    Edge (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Edge" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgeType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgeType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Edge",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LoopSetType > r (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopSetType > r (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopSetType > r (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LoopSetType > r (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopSetType > r (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopSetType > r (
        ::xsd::qif2::LoopSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::LoopSetType > r (
          ::xsd::qif2::LoopSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "LoopSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LoopSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LoopSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopSetType >
    LoopSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "LoopSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LoopSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LoopSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LoopBaseType > r (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopBaseType > r (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopBaseType > r (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopBase (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopBase (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LoopBaseType > r (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopBaseType > r (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopBaseType > r (
        ::xsd::qif2::LoopBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::LoopBaseType > r (
          ::xsd::qif2::LoopBase (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "LoopBase" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LoopBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LoopBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopBase",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopBaseType >
    LoopBase (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "LoopBase" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LoopBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LoopBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopBase",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LoopType > r (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopType > r (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopType > r (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Loop (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Loop (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Loop (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Loop (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Loop (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Loop (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LoopType > r (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopType > r (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopType > r (
        ::xsd::qif2::Loop (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::LoopType > r (
          ::xsd::qif2::Loop (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Loop" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LoopType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LoopType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Loop",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopType >
    Loop (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Loop" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LoopType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LoopType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Loop",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LoopMeshType > r (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopMeshType > r (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopMeshType > r (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopMesh (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LoopMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopMesh (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LoopMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LoopMeshType > r (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopMeshType > r (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LoopMeshType > r (
        ::xsd::qif2::LoopMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::LoopMeshType > r (
          ::xsd::qif2::LoopMesh (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "LoopMesh" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LoopMeshType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LoopMeshType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopMesh",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LoopMeshType >
    LoopMesh (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "LoopMesh" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LoopMeshType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LoopMeshType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LoopMesh",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FaceSetType > r (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceSetType > r (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceSetType > r (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FaceSetType > r (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceSetType > r (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceSetType > r (
        ::xsd::qif2::FaceSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::FaceSetType > r (
          ::xsd::qif2::FaceSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FaceSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FaceSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FaceSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceSetType >
    FaceSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "FaceSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FaceSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FaceSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FaceBaseType > r (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceBaseType > r (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceBaseType > r (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceBase (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceBase (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceBase (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FaceBaseType > r (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceBaseType > r (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceBaseType > r (
        ::xsd::qif2::FaceBase (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::FaceBaseType > r (
          ::xsd::qif2::FaceBase (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FaceBase" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FaceBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FaceBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceBase",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceBaseType >
    FaceBase (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "FaceBase" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FaceBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FaceBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceBase",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FaceType > r (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceType > r (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceType > r (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Face (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Face (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Face (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Face (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Face (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Face (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FaceType > r (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceType > r (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceType > r (
        ::xsd::qif2::Face (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::FaceType > r (
          ::xsd::qif2::Face (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Face" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FaceType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FaceType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Face",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceType >
    Face (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Face" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FaceType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FaceType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Face",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FaceMeshType > r (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceMeshType > r (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceMeshType > r (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceMesh (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FaceMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceMesh (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FaceMesh (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FaceMeshType > r (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceMeshType > r (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FaceMeshType > r (
        ::xsd::qif2::FaceMesh (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::FaceMeshType > r (
          ::xsd::qif2::FaceMesh (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FaceMesh" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FaceMeshType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FaceMeshType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceMesh",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FaceMeshType >
    FaceMesh (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "FaceMesh" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FaceMeshType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FaceMeshType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FaceMesh",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ShellSetType > r (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ShellSetType > r (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ShellSetType > r (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ShellSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ShellSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ShellSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ShellSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ShellSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ShellSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ShellSetType > r (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ShellSetType > r (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ShellSetType > r (
        ::xsd::qif2::ShellSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ShellSetType > r (
          ::xsd::qif2::ShellSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ShellSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ShellSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ShellSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ShellSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ShellSetType >
    ShellSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ShellSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ShellSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ShellSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ShellSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ShellType > r (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ShellType > r (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ShellType > r (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Shell (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Shell (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Shell (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Shell (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Shell (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Shell (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ShellType > r (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ShellType > r (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ShellType > r (
        ::xsd::qif2::Shell (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ShellType > r (
          ::xsd::qif2::Shell (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Shell" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ShellType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ShellType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Shell",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ShellType >
    Shell (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Shell" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ShellType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ShellType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Shell",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::BodySetType > r (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::BodySetType > r (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::BodySetType > r (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BodySet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BodySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::BodySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BodySet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BodySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::BodySet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::BodySetType > r (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::BodySetType > r (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::BodySetType > r (
        ::xsd::qif2::BodySet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::BodySetType > r (
          ::xsd::qif2::BodySet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "BodySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::BodySetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::BodySetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "BodySet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::BodySetType >
    BodySet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "BodySet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::BodySetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::BodySetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "BodySet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::BodyType > r (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::BodyType > r (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::BodyType > r (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Body (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Body (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Body (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Body (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Body (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Body (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::BodyType > r (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::BodyType > r (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::BodyType > r (
        ::xsd::qif2::Body (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (const ::xercesc::DOMDocument& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::BodyType > r (
          ::xsd::qif2::Body (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Body" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::BodyType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::BodyType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Body",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::BodyType >
    Body (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Body" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::BodyType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::BodyType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Body",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > r (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > r (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > r (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloudSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloudSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloudSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloudSet (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloudSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloudSet (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > r (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > r (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > r (
        ::xsd::qif2::PointCloudSet (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > r (
          ::xsd::qif2::PointCloudSet (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointCloudSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointCloudSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointCloudSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudSetType >
    PointCloudSet (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointCloudSet" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointCloudSetType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointCloudSetType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointCloudSet",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudType > r (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudType > r (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudType > r (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloud (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloud (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointCloud (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloud (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloud (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointCloud (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudType > r (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudType > r (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointCloudType > r (
        ::xsd::qif2::PointCloud (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointCloudType > r (
          ::xsd::qif2::PointCloud (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointCloud" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointCloudType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointCloudType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointCloud",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointCloudType >
    PointCloud (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointCloud" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointCloudType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointCloudType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointCloud",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

