// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Features.hxx"

namespace xsd
{
  namespace qif2
  {
    // FeatureBaseType
    // 

    const FeatureBaseType::Attributes_optional& FeatureBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    FeatureBaseType::Attributes_optional& FeatureBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void FeatureBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void FeatureBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void FeatureBaseType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const FeatureBaseType::id_type& FeatureBaseType::
    id () const
    {
      return this->id_.get ();
    }

    FeatureBaseType::id_type& FeatureBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void FeatureBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void FeatureBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // FeatureItemBaseType
    // 

    const FeatureItemBaseType::FeatureNominalId_optional& FeatureItemBaseType::
    FeatureNominalId () const
    {
      return this->FeatureNominalId_;
    }

    FeatureItemBaseType::FeatureNominalId_optional& FeatureItemBaseType::
    FeatureNominalId ()
    {
      return this->FeatureNominalId_;
    }

    void FeatureItemBaseType::
    FeatureNominalId (const FeatureNominalId_type& x)
    {
      this->FeatureNominalId_.set (x);
    }

    void FeatureItemBaseType::
    FeatureNominalId (const FeatureNominalId_optional& x)
    {
      this->FeatureNominalId_ = x;
    }

    void FeatureItemBaseType::
    FeatureNominalId (::std::auto_ptr< FeatureNominalId_type > x)
    {
      this->FeatureNominalId_.set (x);
    }

    const FeatureItemBaseType::ParentFeatureItemId_optional& FeatureItemBaseType::
    ParentFeatureItemId () const
    {
      return this->ParentFeatureItemId_;
    }

    FeatureItemBaseType::ParentFeatureItemId_optional& FeatureItemBaseType::
    ParentFeatureItemId ()
    {
      return this->ParentFeatureItemId_;
    }

    void FeatureItemBaseType::
    ParentFeatureItemId (const ParentFeatureItemId_type& x)
    {
      this->ParentFeatureItemId_.set (x);
    }

    void FeatureItemBaseType::
    ParentFeatureItemId (const ParentFeatureItemId_optional& x)
    {
      this->ParentFeatureItemId_ = x;
    }

    void FeatureItemBaseType::
    ParentFeatureItemId (::std::auto_ptr< ParentFeatureItemId_type > x)
    {
      this->ParentFeatureItemId_.set (x);
    }

    const FeatureItemBaseType::FeatureName_type& FeatureItemBaseType::
    FeatureName () const
    {
      return this->FeatureName_.get ();
    }

    FeatureItemBaseType::FeatureName_type& FeatureItemBaseType::
    FeatureName ()
    {
      return this->FeatureName_.get ();
    }

    void FeatureItemBaseType::
    FeatureName (const FeatureName_type& x)
    {
      this->FeatureName_.set (x);
    }

    void FeatureItemBaseType::
    FeatureName (::std::auto_ptr< FeatureName_type > x)
    {
      this->FeatureName_.set (x);
    }

    const FeatureItemBaseType::QPId_optional& FeatureItemBaseType::
    QPId () const
    {
      return this->QPId_;
    }

    FeatureItemBaseType::QPId_optional& FeatureItemBaseType::
    QPId ()
    {
      return this->QPId_;
    }

    void FeatureItemBaseType::
    QPId (const QPId_type& x)
    {
      this->QPId_.set (x);
    }

    void FeatureItemBaseType::
    QPId (const QPId_optional& x)
    {
      this->QPId_ = x;
    }

    void FeatureItemBaseType::
    QPId (::std::auto_ptr< QPId_type > x)
    {
      this->QPId_.set (x);
    }

    const FeatureItemBaseType::NotableEventIds_optional& FeatureItemBaseType::
    NotableEventIds () const
    {
      return this->NotableEventIds_;
    }

    FeatureItemBaseType::NotableEventIds_optional& FeatureItemBaseType::
    NotableEventIds ()
    {
      return this->NotableEventIds_;
    }

    void FeatureItemBaseType::
    NotableEventIds (const NotableEventIds_type& x)
    {
      this->NotableEventIds_.set (x);
    }

    void FeatureItemBaseType::
    NotableEventIds (const NotableEventIds_optional& x)
    {
      this->NotableEventIds_ = x;
    }

    void FeatureItemBaseType::
    NotableEventIds (::std::auto_ptr< NotableEventIds_type > x)
    {
      this->NotableEventIds_.set (x);
    }

    const FeatureItemBaseType::CoordinateSystemId_optional& FeatureItemBaseType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_;
    }

    FeatureItemBaseType::CoordinateSystemId_optional& FeatureItemBaseType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_;
    }

    void FeatureItemBaseType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void FeatureItemBaseType::
    CoordinateSystemId (const CoordinateSystemId_optional& x)
    {
      this->CoordinateSystemId_ = x;
    }

    void FeatureItemBaseType::
    CoordinateSystemId (::std::auto_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (x);
    }


    // FeatureDefinitionBaseType
    // 


    // PointListNominalType
    // 

    const PointListNominalType::MeasurePoint_sequence& PointListNominalType::
    MeasurePoint () const
    {
      return this->MeasurePoint_;
    }

    PointListNominalType::MeasurePoint_sequence& PointListNominalType::
    MeasurePoint ()
    {
      return this->MeasurePoint_;
    }

    void PointListNominalType::
    MeasurePoint (const MeasurePoint_sequence& s)
    {
      this->MeasurePoint_ = s;
    }

    const PointListNominalType::linearUnit_optional& PointListNominalType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    PointListNominalType::linearUnit_optional& PointListNominalType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void PointListNominalType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void PointListNominalType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void PointListNominalType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const PointListNominalType::decimalPlaces_optional& PointListNominalType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    PointListNominalType::decimalPlaces_optional& PointListNominalType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void PointListNominalType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void PointListNominalType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const PointListNominalType::significantFigures_optional& PointListNominalType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    PointListNominalType::significantFigures_optional& PointListNominalType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void PointListNominalType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void PointListNominalType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const PointListNominalType::validity_optional& PointListNominalType::
    validity () const
    {
      return this->validity_;
    }

    PointListNominalType::validity_optional& PointListNominalType::
    validity ()
    {
      return this->validity_;
    }

    void PointListNominalType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void PointListNominalType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void PointListNominalType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const PointListNominalType::xDecimalPlaces_optional& PointListNominalType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    PointListNominalType::xDecimalPlaces_optional& PointListNominalType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void PointListNominalType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void PointListNominalType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const PointListNominalType::xSignificantFigures_optional& PointListNominalType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    PointListNominalType::xSignificantFigures_optional& PointListNominalType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void PointListNominalType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void PointListNominalType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const PointListNominalType::xValidity_optional& PointListNominalType::
    xValidity () const
    {
      return this->xValidity_;
    }

    PointListNominalType::xValidity_optional& PointListNominalType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void PointListNominalType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void PointListNominalType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void PointListNominalType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const PointListNominalType::yDecimalPlaces_optional& PointListNominalType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    PointListNominalType::yDecimalPlaces_optional& PointListNominalType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void PointListNominalType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void PointListNominalType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const PointListNominalType::ySignificantFigures_optional& PointListNominalType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    PointListNominalType::ySignificantFigures_optional& PointListNominalType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void PointListNominalType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void PointListNominalType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const PointListNominalType::yValidity_optional& PointListNominalType::
    yValidity () const
    {
      return this->yValidity_;
    }

    PointListNominalType::yValidity_optional& PointListNominalType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void PointListNominalType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void PointListNominalType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void PointListNominalType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const PointListNominalType::zDecimalPlaces_optional& PointListNominalType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    PointListNominalType::zDecimalPlaces_optional& PointListNominalType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void PointListNominalType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void PointListNominalType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const PointListNominalType::zSignificantFigures_optional& PointListNominalType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    PointListNominalType::zSignificantFigures_optional& PointListNominalType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void PointListNominalType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void PointListNominalType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const PointListNominalType::zValidity_optional& PointListNominalType::
    zValidity () const
    {
      return this->zValidity_;
    }

    PointListNominalType::zValidity_optional& PointListNominalType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void PointListNominalType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void PointListNominalType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void PointListNominalType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }


    // FeatureNominalBaseType
    // 

    const FeatureNominalBaseType::Name_optional& FeatureNominalBaseType::
    Name () const
    {
      return this->Name_;
    }

    FeatureNominalBaseType::Name_optional& FeatureNominalBaseType::
    Name ()
    {
      return this->Name_;
    }

    void FeatureNominalBaseType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void FeatureNominalBaseType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void FeatureNominalBaseType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const FeatureNominalBaseType::PointList_optional& FeatureNominalBaseType::
    PointList () const
    {
      return this->PointList_;
    }

    FeatureNominalBaseType::PointList_optional& FeatureNominalBaseType::
    PointList ()
    {
      return this->PointList_;
    }

    void FeatureNominalBaseType::
    PointList (const PointList_type& x)
    {
      this->PointList_.set (x);
    }

    void FeatureNominalBaseType::
    PointList (const PointList_optional& x)
    {
      this->PointList_ = x;
    }

    void FeatureNominalBaseType::
    PointList (::std::auto_ptr< PointList_type > x)
    {
      this->PointList_.set (x);
    }

    const FeatureNominalBaseType::FeatureDefinitionId_type& FeatureNominalBaseType::
    FeatureDefinitionId () const
    {
      return this->FeatureDefinitionId_.get ();
    }

    FeatureNominalBaseType::FeatureDefinitionId_type& FeatureNominalBaseType::
    FeatureDefinitionId ()
    {
      return this->FeatureDefinitionId_.get ();
    }

    void FeatureNominalBaseType::
    FeatureDefinitionId (const FeatureDefinitionId_type& x)
    {
      this->FeatureDefinitionId_.set (x);
    }

    void FeatureNominalBaseType::
    FeatureDefinitionId (::std::auto_ptr< FeatureDefinitionId_type > x)
    {
      this->FeatureDefinitionId_.set (x);
    }

    const FeatureNominalBaseType::EntityInternalIds_optional& FeatureNominalBaseType::
    EntityInternalIds () const
    {
      return this->EntityInternalIds_;
    }

    FeatureNominalBaseType::EntityInternalIds_optional& FeatureNominalBaseType::
    EntityInternalIds ()
    {
      return this->EntityInternalIds_;
    }

    void FeatureNominalBaseType::
    EntityInternalIds (const EntityInternalIds_type& x)
    {
      this->EntityInternalIds_.set (x);
    }

    void FeatureNominalBaseType::
    EntityInternalIds (const EntityInternalIds_optional& x)
    {
      this->EntityInternalIds_ = x;
    }

    void FeatureNominalBaseType::
    EntityInternalIds (::std::auto_ptr< EntityInternalIds_type > x)
    {
      this->EntityInternalIds_.set (x);
    }

    const FeatureNominalBaseType::EntityExternalIds_optional& FeatureNominalBaseType::
    EntityExternalIds () const
    {
      return this->EntityExternalIds_;
    }

    FeatureNominalBaseType::EntityExternalIds_optional& FeatureNominalBaseType::
    EntityExternalIds ()
    {
      return this->EntityExternalIds_;
    }

    void FeatureNominalBaseType::
    EntityExternalIds (const EntityExternalIds_type& x)
    {
      this->EntityExternalIds_.set (x);
    }

    void FeatureNominalBaseType::
    EntityExternalIds (const EntityExternalIds_optional& x)
    {
      this->EntityExternalIds_ = x;
    }

    void FeatureNominalBaseType::
    EntityExternalIds (::std::auto_ptr< EntityExternalIds_type > x)
    {
      this->EntityExternalIds_.set (x);
    }


    // PointListActualType
    // 

    const PointListActualType::MeasurePoint_sequence& PointListActualType::
    MeasurePoint () const
    {
      return this->MeasurePoint_;
    }

    PointListActualType::MeasurePoint_sequence& PointListActualType::
    MeasurePoint ()
    {
      return this->MeasurePoint_;
    }

    void PointListActualType::
    MeasurePoint (const MeasurePoint_sequence& s)
    {
      this->MeasurePoint_ = s;
    }

    const PointListActualType::linearUnit_optional& PointListActualType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    PointListActualType::linearUnit_optional& PointListActualType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void PointListActualType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void PointListActualType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void PointListActualType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const PointListActualType::decimalPlaces_optional& PointListActualType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    PointListActualType::decimalPlaces_optional& PointListActualType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void PointListActualType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void PointListActualType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const PointListActualType::significantFigures_optional& PointListActualType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    PointListActualType::significantFigures_optional& PointListActualType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void PointListActualType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void PointListActualType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const PointListActualType::validity_optional& PointListActualType::
    validity () const
    {
      return this->validity_;
    }

    PointListActualType::validity_optional& PointListActualType::
    validity ()
    {
      return this->validity_;
    }

    void PointListActualType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void PointListActualType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void PointListActualType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const PointListActualType::xDecimalPlaces_optional& PointListActualType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    PointListActualType::xDecimalPlaces_optional& PointListActualType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void PointListActualType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void PointListActualType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const PointListActualType::xSignificantFigures_optional& PointListActualType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    PointListActualType::xSignificantFigures_optional& PointListActualType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void PointListActualType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void PointListActualType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const PointListActualType::xValidity_optional& PointListActualType::
    xValidity () const
    {
      return this->xValidity_;
    }

    PointListActualType::xValidity_optional& PointListActualType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void PointListActualType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void PointListActualType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void PointListActualType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const PointListActualType::yDecimalPlaces_optional& PointListActualType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    PointListActualType::yDecimalPlaces_optional& PointListActualType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void PointListActualType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void PointListActualType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const PointListActualType::ySignificantFigures_optional& PointListActualType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    PointListActualType::ySignificantFigures_optional& PointListActualType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void PointListActualType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void PointListActualType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const PointListActualType::yValidity_optional& PointListActualType::
    yValidity () const
    {
      return this->yValidity_;
    }

    PointListActualType::yValidity_optional& PointListActualType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void PointListActualType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void PointListActualType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void PointListActualType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const PointListActualType::zDecimalPlaces_optional& PointListActualType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    PointListActualType::zDecimalPlaces_optional& PointListActualType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void PointListActualType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void PointListActualType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const PointListActualType::zSignificantFigures_optional& PointListActualType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    PointListActualType::zSignificantFigures_optional& PointListActualType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void PointListActualType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void PointListActualType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const PointListActualType::zValidity_optional& PointListActualType::
    zValidity () const
    {
      return this->zValidity_;
    }

    PointListActualType::zValidity_optional& PointListActualType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void PointListActualType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void PointListActualType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void PointListActualType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }

    const PointListActualType::combinedUncertainty_optional& PointListActualType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    PointListActualType::combinedUncertainty_optional& PointListActualType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void PointListActualType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void PointListActualType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    const PointListActualType::meanError_optional& PointListActualType::
    meanError () const
    {
      return this->meanError_;
    }

    PointListActualType::meanError_optional& PointListActualType::
    meanError ()
    {
      return this->meanError_;
    }

    void PointListActualType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void PointListActualType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    const PointListActualType::xCombinedUncertainty_optional& PointListActualType::
    xCombinedUncertainty () const
    {
      return this->xCombinedUncertainty_;
    }

    PointListActualType::xCombinedUncertainty_optional& PointListActualType::
    xCombinedUncertainty ()
    {
      return this->xCombinedUncertainty_;
    }

    void PointListActualType::
    xCombinedUncertainty (const xCombinedUncertainty_type& x)
    {
      this->xCombinedUncertainty_.set (x);
    }

    void PointListActualType::
    xCombinedUncertainty (const xCombinedUncertainty_optional& x)
    {
      this->xCombinedUncertainty_ = x;
    }

    const PointListActualType::xMeanError_optional& PointListActualType::
    xMeanError () const
    {
      return this->xMeanError_;
    }

    PointListActualType::xMeanError_optional& PointListActualType::
    xMeanError ()
    {
      return this->xMeanError_;
    }

    void PointListActualType::
    xMeanError (const xMeanError_type& x)
    {
      this->xMeanError_.set (x);
    }

    void PointListActualType::
    xMeanError (const xMeanError_optional& x)
    {
      this->xMeanError_ = x;
    }

    const PointListActualType::yCombinedUncertainty_optional& PointListActualType::
    yCombinedUncertainty () const
    {
      return this->yCombinedUncertainty_;
    }

    PointListActualType::yCombinedUncertainty_optional& PointListActualType::
    yCombinedUncertainty ()
    {
      return this->yCombinedUncertainty_;
    }

    void PointListActualType::
    yCombinedUncertainty (const yCombinedUncertainty_type& x)
    {
      this->yCombinedUncertainty_.set (x);
    }

    void PointListActualType::
    yCombinedUncertainty (const yCombinedUncertainty_optional& x)
    {
      this->yCombinedUncertainty_ = x;
    }

    const PointListActualType::yMeanError_optional& PointListActualType::
    yMeanError () const
    {
      return this->yMeanError_;
    }

    PointListActualType::yMeanError_optional& PointListActualType::
    yMeanError ()
    {
      return this->yMeanError_;
    }

    void PointListActualType::
    yMeanError (const yMeanError_type& x)
    {
      this->yMeanError_.set (x);
    }

    void PointListActualType::
    yMeanError (const yMeanError_optional& x)
    {
      this->yMeanError_ = x;
    }

    const PointListActualType::zCombinedUncertainty_optional& PointListActualType::
    zCombinedUncertainty () const
    {
      return this->zCombinedUncertainty_;
    }

    PointListActualType::zCombinedUncertainty_optional& PointListActualType::
    zCombinedUncertainty ()
    {
      return this->zCombinedUncertainty_;
    }

    void PointListActualType::
    zCombinedUncertainty (const zCombinedUncertainty_type& x)
    {
      this->zCombinedUncertainty_.set (x);
    }

    void PointListActualType::
    zCombinedUncertainty (const zCombinedUncertainty_optional& x)
    {
      this->zCombinedUncertainty_ = x;
    }

    const PointListActualType::zMeanError_optional& PointListActualType::
    zMeanError () const
    {
      return this->zMeanError_;
    }

    PointListActualType::zMeanError_optional& PointListActualType::
    zMeanError ()
    {
      return this->zMeanError_;
    }

    void PointListActualType::
    zMeanError (const zMeanError_type& x)
    {
      this->zMeanError_.set (x);
    }

    void PointListActualType::
    zMeanError (const zMeanError_optional& x)
    {
      this->zMeanError_ = x;
    }


    // FeatureActualBaseType
    // 

    const FeatureActualBaseType::PointList_optional& FeatureActualBaseType::
    PointList () const
    {
      return this->PointList_;
    }

    FeatureActualBaseType::PointList_optional& FeatureActualBaseType::
    PointList ()
    {
      return this->PointList_;
    }

    void FeatureActualBaseType::
    PointList (const PointList_type& x)
    {
      this->PointList_.set (x);
    }

    void FeatureActualBaseType::
    PointList (const PointList_optional& x)
    {
      this->PointList_ = x;
    }

    void FeatureActualBaseType::
    PointList (::std::auto_ptr< PointList_type > x)
    {
      this->PointList_.set (x);
    }

    const FeatureActualBaseType::FeatureItemId_type& FeatureActualBaseType::
    FeatureItemId () const
    {
      return this->FeatureItemId_.get ();
    }

    FeatureActualBaseType::FeatureItemId_type& FeatureActualBaseType::
    FeatureItemId ()
    {
      return this->FeatureItemId_.get ();
    }

    void FeatureActualBaseType::
    FeatureItemId (const FeatureItemId_type& x)
    {
      this->FeatureItemId_.set (x);
    }

    void FeatureActualBaseType::
    FeatureItemId (::std::auto_ptr< FeatureItemId_type > x)
    {
      this->FeatureItemId_.set (x);
    }

    const FeatureActualBaseType::ActualComponentId_optional& FeatureActualBaseType::
    ActualComponentId () const
    {
      return this->ActualComponentId_;
    }

    FeatureActualBaseType::ActualComponentId_optional& FeatureActualBaseType::
    ActualComponentId ()
    {
      return this->ActualComponentId_;
    }

    void FeatureActualBaseType::
    ActualComponentId (const ActualComponentId_type& x)
    {
      this->ActualComponentId_.set (x);
    }

    void FeatureActualBaseType::
    ActualComponentId (const ActualComponentId_optional& x)
    {
      this->ActualComponentId_ = x;
    }

    void FeatureActualBaseType::
    ActualComponentId (::std::auto_ptr< ActualComponentId_type > x)
    {
      this->ActualComponentId_.set (x);
    }

    const FeatureActualBaseType::ManufacturingProcessId_optional& FeatureActualBaseType::
    ManufacturingProcessId () const
    {
      return this->ManufacturingProcessId_;
    }

    FeatureActualBaseType::ManufacturingProcessId_optional& FeatureActualBaseType::
    ManufacturingProcessId ()
    {
      return this->ManufacturingProcessId_;
    }

    void FeatureActualBaseType::
    ManufacturingProcessId (const ManufacturingProcessId_type& x)
    {
      this->ManufacturingProcessId_.set (x);
    }

    void FeatureActualBaseType::
    ManufacturingProcessId (const ManufacturingProcessId_optional& x)
    {
      this->ManufacturingProcessId_ = x;
    }

    void FeatureActualBaseType::
    ManufacturingProcessId (::std::auto_ptr< ManufacturingProcessId_type > x)
    {
      this->ManufacturingProcessId_.set (x);
    }

    const FeatureActualBaseType::MeasurementDeviceIds_optional& FeatureActualBaseType::
    MeasurementDeviceIds () const
    {
      return this->MeasurementDeviceIds_;
    }

    FeatureActualBaseType::MeasurementDeviceIds_optional& FeatureActualBaseType::
    MeasurementDeviceIds ()
    {
      return this->MeasurementDeviceIds_;
    }

    void FeatureActualBaseType::
    MeasurementDeviceIds (const MeasurementDeviceIds_type& x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    void FeatureActualBaseType::
    MeasurementDeviceIds (const MeasurementDeviceIds_optional& x)
    {
      this->MeasurementDeviceIds_ = x;
    }

    void FeatureActualBaseType::
    MeasurementDeviceIds (::std::auto_ptr< MeasurementDeviceIds_type > x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    const FeatureActualBaseType::NotedEventIds_optional& FeatureActualBaseType::
    NotedEventIds () const
    {
      return this->NotedEventIds_;
    }

    FeatureActualBaseType::NotedEventIds_optional& FeatureActualBaseType::
    NotedEventIds ()
    {
      return this->NotedEventIds_;
    }

    void FeatureActualBaseType::
    NotedEventIds (const NotedEventIds_type& x)
    {
      this->NotedEventIds_.set (x);
    }

    void FeatureActualBaseType::
    NotedEventIds (const NotedEventIds_optional& x)
    {
      this->NotedEventIds_ = x;
    }

    void FeatureActualBaseType::
    NotedEventIds (::std::auto_ptr< NotedEventIds_type > x)
    {
      this->NotedEventIds_.set (x);
    }


    // SetFeatureType
    // 


    // MeasuredFeatureType
    // 

    const MeasuredFeatureType::PointList_optional& MeasuredFeatureType::
    PointList () const
    {
      return this->PointList_;
    }

    MeasuredFeatureType::PointList_optional& MeasuredFeatureType::
    PointList ()
    {
      return this->PointList_;
    }

    void MeasuredFeatureType::
    PointList (const PointList_type& x)
    {
      this->PointList_.set (x);
    }

    void MeasuredFeatureType::
    PointList (const PointList_optional& x)
    {
      this->PointList_ = x;
    }

    void MeasuredFeatureType::
    PointList (::std::auto_ptr< PointList_type > x)
    {
      this->PointList_.set (x);
    }


    // ConstructionMethodBaseType
    // 

    const ConstructionMethodBaseType::NominalsCalculated_optional& ConstructionMethodBaseType::
    NominalsCalculated () const
    {
      return this->NominalsCalculated_;
    }

    ConstructionMethodBaseType::NominalsCalculated_optional& ConstructionMethodBaseType::
    NominalsCalculated ()
    {
      return this->NominalsCalculated_;
    }

    void ConstructionMethodBaseType::
    NominalsCalculated (const NominalsCalculated_type& x)
    {
      this->NominalsCalculated_.set (x);
    }

    void ConstructionMethodBaseType::
    NominalsCalculated (const NominalsCalculated_optional& x)
    {
      this->NominalsCalculated_ = x;
    }


    // PointRangeType
    // 

    const PointRangeType::Start_type& PointRangeType::
    Start () const
    {
      return this->Start_.get ();
    }

    PointRangeType::Start_type& PointRangeType::
    Start ()
    {
      return this->Start_.get ();
    }

    void PointRangeType::
    Start (const Start_type& x)
    {
      this->Start_.set (x);
    }

    const PointRangeType::Stop_type& PointRangeType::
    Stop () const
    {
      return this->Stop_.get ();
    }

    PointRangeType::Stop_type& PointRangeType::
    Stop ()
    {
      return this->Stop_.get ();
    }

    void PointRangeType::
    Stop (const Stop_type& x)
    {
      this->Stop_.set (x);
    }


    // PointIndexType
    // 

    const PointIndexType::Single_optional& PointIndexType::
    Single () const
    {
      return this->Single_;
    }

    PointIndexType::Single_optional& PointIndexType::
    Single ()
    {
      return this->Single_;
    }

    void PointIndexType::
    Single (const Single_type& x)
    {
      this->Single_.set (x);
    }

    void PointIndexType::
    Single (const Single_optional& x)
    {
      this->Single_ = x;
    }

    const PointIndexType::Range_optional& PointIndexType::
    Range () const
    {
      return this->Range_;
    }

    PointIndexType::Range_optional& PointIndexType::
    Range ()
    {
      return this->Range_;
    }

    void PointIndexType::
    Range (const Range_type& x)
    {
      this->Range_.set (x);
    }

    void PointIndexType::
    Range (const Range_optional& x)
    {
      this->Range_ = x;
    }

    void PointIndexType::
    Range (::std::auto_ptr< Range_type > x)
    {
      this->Range_.set (x);
    }

    const PointIndexType::All_optional& PointIndexType::
    All () const
    {
      return this->All_;
    }

    PointIndexType::All_optional& PointIndexType::
    All ()
    {
      return this->All_;
    }

    void PointIndexType::
    All (const All_type& x)
    {
      this->All_.set (x);
    }

    void PointIndexType::
    All (const All_optional& x)
    {
      this->All_ = x;
    }

    void PointIndexType::
    All (::std::auto_ptr< All_type > x)
    {
      this->All_.set (x);
    }

    const PointIndexType::All_type& PointIndexType::
    All_default_value ()
    {
      return All_default_value_;
    }


    // BaseFeaturePointSetType
    // 

    const BaseFeaturePointSetType::FeatureItemId_type& BaseFeaturePointSetType::
    FeatureItemId () const
    {
      return this->FeatureItemId_.get ();
    }

    BaseFeaturePointSetType::FeatureItemId_type& BaseFeaturePointSetType::
    FeatureItemId ()
    {
      return this->FeatureItemId_.get ();
    }

    void BaseFeaturePointSetType::
    FeatureItemId (const FeatureItemId_type& x)
    {
      this->FeatureItemId_.set (x);
    }

    void BaseFeaturePointSetType::
    FeatureItemId (::std::auto_ptr< FeatureItemId_type > x)
    {
      this->FeatureItemId_.set (x);
    }

    const BaseFeaturePointSetType::PointIndex_type& BaseFeaturePointSetType::
    PointIndex () const
    {
      return this->PointIndex_.get ();
    }

    BaseFeaturePointSetType::PointIndex_type& BaseFeaturePointSetType::
    PointIndex ()
    {
      return this->PointIndex_.get ();
    }

    void BaseFeaturePointSetType::
    PointIndex (const PointIndex_type& x)
    {
      this->PointIndex_.set (x);
    }

    void BaseFeaturePointSetType::
    PointIndex (::std::auto_ptr< PointIndex_type > x)
    {
      this->PointIndex_.set (x);
    }

    const BaseFeaturePointSetType::ReferencedComponent_type& BaseFeaturePointSetType::
    ReferencedComponent () const
    {
      return this->ReferencedComponent_.get ();
    }

    BaseFeaturePointSetType::ReferencedComponent_type& BaseFeaturePointSetType::
    ReferencedComponent ()
    {
      return this->ReferencedComponent_.get ();
    }

    void BaseFeaturePointSetType::
    ReferencedComponent (const ReferencedComponent_type& x)
    {
      this->ReferencedComponent_.set (x);
    }

    void BaseFeaturePointSetType::
    ReferencedComponent (::std::auto_ptr< ReferencedComponent_type > x)
    {
      this->ReferencedComponent_.set (x);
    }

    const BaseFeaturePointSetType::SequenceNumber_type& BaseFeaturePointSetType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    BaseFeaturePointSetType::SequenceNumber_type& BaseFeaturePointSetType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void BaseFeaturePointSetType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }


    // BaseFeaturePointListType
    // 

    const BaseFeaturePointListType::BaseFeaturePointSet_sequence& BaseFeaturePointListType::
    BaseFeaturePointSet () const
    {
      return this->BaseFeaturePointSet_;
    }

    BaseFeaturePointListType::BaseFeaturePointSet_sequence& BaseFeaturePointListType::
    BaseFeaturePointSet ()
    {
      return this->BaseFeaturePointSet_;
    }

    void BaseFeaturePointListType::
    BaseFeaturePointSet (const BaseFeaturePointSet_sequence& s)
    {
      this->BaseFeaturePointSet_ = s;
    }


    // TransformationReferenceType
    // 

    const TransformationReferenceType::ReferencedComponent_type& TransformationReferenceType::
    ReferencedComponent () const
    {
      return this->ReferencedComponent_.get ();
    }

    TransformationReferenceType::ReferencedComponent_type& TransformationReferenceType::
    ReferencedComponent ()
    {
      return this->ReferencedComponent_.get ();
    }

    void TransformationReferenceType::
    ReferencedComponent (const ReferencedComponent_type& x)
    {
      this->ReferencedComponent_.set (x);
    }

    void TransformationReferenceType::
    ReferencedComponent (::std::auto_ptr< ReferencedComponent_type > x)
    {
      this->ReferencedComponent_.set (x);
    }

    const TransformationReferenceType::CoordinateSystemId_type& TransformationReferenceType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_.get ();
    }

    TransformationReferenceType::CoordinateSystemId_type& TransformationReferenceType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_.get ();
    }

    void TransformationReferenceType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void TransformationReferenceType::
    CoordinateSystemId (::std::auto_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (x);
    }

    const TransformationReferenceType::SequenceNumber_type& TransformationReferenceType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    TransformationReferenceType::SequenceNumber_type& TransformationReferenceType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void TransformationReferenceType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }


    // ArcConstructionMethodType
    // 

    const ArcConstructionMethodType::BestFit_optional& ArcConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ArcConstructionMethodType::BestFit_optional& ArcConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ArcConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ArcConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ArcConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ArcConstructionMethodType::Recompensated_optional& ArcConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ArcConstructionMethodType::Recompensated_optional& ArcConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ArcConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ArcConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ArcConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ArcConstructionMethodType::Projection_optional& ArcConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    ArcConstructionMethodType::Projection_optional& ArcConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void ArcConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void ArcConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void ArcConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const ArcConstructionMethodType::Copy_optional& ArcConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ArcConstructionMethodType::Copy_optional& ArcConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ArcConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ArcConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ArcConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ArcConstructionMethodType::Cast_optional& ArcConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ArcConstructionMethodType::Cast_optional& ArcConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ArcConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ArcConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ArcConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ArcConstructionMethodType::Transform_optional& ArcConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ArcConstructionMethodType::Transform_optional& ArcConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ArcConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ArcConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ArcConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const ArcConstructionMethodType::FromScan_optional& ArcConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    ArcConstructionMethodType::FromScan_optional& ArcConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void ArcConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void ArcConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void ArcConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }

    const ArcConstructionMethodType::Extract_optional& ArcConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    ArcConstructionMethodType::Extract_optional& ArcConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void ArcConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void ArcConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void ArcConstructionMethodType::
    Extract (::std::auto_ptr< Extract_type > x)
    {
      this->Extract_.set (x);
    }


    // ArcBestFitType
    // 

    const ArcBestFitType::BaseFeature_sequence& ArcBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ArcBestFitType::BaseFeature_sequence& ArcBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ArcBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ArcRecompType
    // 

    const ArcRecompType::BaseFeaturePointList_type& ArcRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ArcRecompType::BaseFeaturePointList_type& ArcRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ArcRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ArcRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ArcProjectionType
    // 

    const ArcProjectionType::ProjectionArc_type& ArcProjectionType::
    ProjectionArc () const
    {
      return this->ProjectionArc_.get ();
    }

    ArcProjectionType::ProjectionArc_type& ArcProjectionType::
    ProjectionArc ()
    {
      return this->ProjectionArc_.get ();
    }

    void ArcProjectionType::
    ProjectionArc (const ProjectionArc_type& x)
    {
      this->ProjectionArc_.set (x);
    }

    void ArcProjectionType::
    ProjectionArc (::std::auto_ptr< ProjectionArc_type > x)
    {
      this->ProjectionArc_.set (x);
    }

    const ArcProjectionType::ProjectionPlane_type& ArcProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    ArcProjectionType::ProjectionPlane_type& ArcProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void ArcProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void ArcProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }


    // ArcCopyType
    // 

    const ArcCopyType::BaseArc_type& ArcCopyType::
    BaseArc () const
    {
      return this->BaseArc_.get ();
    }

    ArcCopyType::BaseArc_type& ArcCopyType::
    BaseArc ()
    {
      return this->BaseArc_.get ();
    }

    void ArcCopyType::
    BaseArc (const BaseArc_type& x)
    {
      this->BaseArc_.set (x);
    }

    void ArcCopyType::
    BaseArc (::std::auto_ptr< BaseArc_type > x)
    {
      this->BaseArc_.set (x);
    }


    // ArcCastType
    // 

    const ArcCastType::BaseFeature_type& ArcCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ArcCastType::BaseFeature_type& ArcCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ArcCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ArcCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ArcTransformType
    // 

    const ArcTransformType::BaseArc_type& ArcTransformType::
    BaseArc () const
    {
      return this->BaseArc_.get ();
    }

    ArcTransformType::BaseArc_type& ArcTransformType::
    BaseArc ()
    {
      return this->BaseArc_.get ();
    }

    void ArcTransformType::
    BaseArc (const BaseArc_type& x)
    {
      this->BaseArc_.set (x);
    }

    void ArcTransformType::
    BaseArc (::std::auto_ptr< BaseArc_type > x)
    {
      this->BaseArc_.set (x);
    }

    const ArcTransformType::Transformation_type& ArcTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ArcTransformType::Transformation_type& ArcTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ArcTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ArcTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ArcFromScanType
    // 

    const ArcFromScanType::SurfaceFeature_type& ArcFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    ArcFromScanType::SurfaceFeature_type& ArcFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void ArcFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void ArcFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const ArcFromScanType::SearchRadius_type& ArcFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    ArcFromScanType::SearchRadius_type& ArcFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void ArcFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void ArcFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const ArcFromScanType::Depth_type& ArcFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    ArcFromScanType::Depth_type& ArcFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void ArcFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void ArcFromScanType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }


    // ArcExtractType
    // 

    const ArcExtractType::CurveFeature_type& ArcExtractType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    ArcExtractType::CurveFeature_type& ArcExtractType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void ArcExtractType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void ArcExtractType::
    CurveFeature (::std::auto_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (x);
    }


    // ArcCheckedType
    // 

    const ArcCheckedType::Measured_optional& ArcCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ArcCheckedType::Measured_optional& ArcCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ArcCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ArcCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ArcCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ArcCheckedType::Constructed_optional& ArcCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ArcCheckedType::Constructed_optional& ArcCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ArcCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ArcCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ArcCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ArcCheckedFeatureType
    // 

    const ArcCheckedFeatureType::CheckDetails_optional& ArcCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ArcCheckedFeatureType::CheckDetails_optional& ArcCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ArcCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ArcCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ArcCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ArcActualDeterminationType
    // 

    const ArcActualDeterminationType::Checked_optional& ArcActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ArcActualDeterminationType::Checked_optional& ArcActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ArcActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ArcActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ArcActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ArcActualDeterminationType::Set_optional& ArcActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ArcActualDeterminationType::Set_optional& ArcActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ArcActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ArcActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ArcActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ArcFeatureItemType
    // 

    const ArcFeatureItemType::DeterminationMode_type& ArcFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ArcFeatureItemType::DeterminationMode_type& ArcFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ArcFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ArcFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ArcFeatureItemType::SubstituteFeatureAlgorithm_optional& ArcFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ArcFeatureItemType::SubstituteFeatureAlgorithm_optional& ArcFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ArcFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ArcFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ArcFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ArcFeatureDefinitionType
    // 

    const ArcFeatureDefinitionType::InternalExternal_type& ArcFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ArcFeatureDefinitionType::InternalExternal_type& ArcFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ArcFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ArcFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ArcFeatureDefinitionType::Radius_type& ArcFeatureDefinitionType::
    Radius () const
    {
      return this->Radius_.get ();
    }

    ArcFeatureDefinitionType::Radius_type& ArcFeatureDefinitionType::
    Radius ()
    {
      return this->Radius_.get ();
    }

    void ArcFeatureDefinitionType::
    Radius (const Radius_type& x)
    {
      this->Radius_.set (x);
    }

    void ArcFeatureDefinitionType::
    Radius (::std::auto_ptr< Radius_type > x)
    {
      this->Radius_.set (x);
    }


    // ArcFeatureNominalType
    // 

    const ArcFeatureNominalType::Location_type& ArcFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    ArcFeatureNominalType::Location_type& ArcFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void ArcFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void ArcFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const ArcFeatureNominalType::Sweep_type& ArcFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    ArcFeatureNominalType::Sweep_type& ArcFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void ArcFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ArcFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const ArcFeatureNominalType::Normal_type& ArcFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    ArcFeatureNominalType::Normal_type& ArcFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void ArcFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void ArcFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // ArcFeatureActualType
    // 

    const ArcFeatureActualType::Location_optional& ArcFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    ArcFeatureActualType::Location_optional& ArcFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void ArcFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void ArcFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void ArcFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const ArcFeatureActualType::Normal_optional& ArcFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    ArcFeatureActualType::Normal_optional& ArcFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void ArcFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void ArcFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void ArcFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const ArcFeatureActualType::Radius_optional& ArcFeatureActualType::
    Radius () const
    {
      return this->Radius_;
    }

    ArcFeatureActualType::Radius_optional& ArcFeatureActualType::
    Radius ()
    {
      return this->Radius_;
    }

    void ArcFeatureActualType::
    Radius (const Radius_type& x)
    {
      this->Radius_.set (x);
    }

    void ArcFeatureActualType::
    Radius (const Radius_optional& x)
    {
      this->Radius_ = x;
    }

    void ArcFeatureActualType::
    Radius (::std::auto_ptr< Radius_type > x)
    {
      this->Radius_.set (x);
    }

    const ArcFeatureActualType::RadiusMin_optional& ArcFeatureActualType::
    RadiusMin () const
    {
      return this->RadiusMin_;
    }

    ArcFeatureActualType::RadiusMin_optional& ArcFeatureActualType::
    RadiusMin ()
    {
      return this->RadiusMin_;
    }

    void ArcFeatureActualType::
    RadiusMin (const RadiusMin_type& x)
    {
      this->RadiusMin_.set (x);
    }

    void ArcFeatureActualType::
    RadiusMin (const RadiusMin_optional& x)
    {
      this->RadiusMin_ = x;
    }

    void ArcFeatureActualType::
    RadiusMin (::std::auto_ptr< RadiusMin_type > x)
    {
      this->RadiusMin_.set (x);
    }

    const ArcFeatureActualType::RadiusMax_optional& ArcFeatureActualType::
    RadiusMax () const
    {
      return this->RadiusMax_;
    }

    ArcFeatureActualType::RadiusMax_optional& ArcFeatureActualType::
    RadiusMax ()
    {
      return this->RadiusMax_;
    }

    void ArcFeatureActualType::
    RadiusMax (const RadiusMax_type& x)
    {
      this->RadiusMax_.set (x);
    }

    void ArcFeatureActualType::
    RadiusMax (const RadiusMax_optional& x)
    {
      this->RadiusMax_ = x;
    }

    void ArcFeatureActualType::
    RadiusMax (::std::auto_ptr< RadiusMax_type > x)
    {
      this->RadiusMax_.set (x);
    }

    const ArcFeatureActualType::Sweep_optional& ArcFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    ArcFeatureActualType::Sweep_optional& ArcFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void ArcFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ArcFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void ArcFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const ArcFeatureActualType::Form_optional& ArcFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ArcFeatureActualType::Form_optional& ArcFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ArcFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ArcFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ArcFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // CircleConstructionMethodType
    // 

    const CircleConstructionMethodType::BestFit_optional& CircleConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CircleConstructionMethodType::BestFit_optional& CircleConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CircleConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CircleConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CircleConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const CircleConstructionMethodType::Recompensated_optional& CircleConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CircleConstructionMethodType::Recompensated_optional& CircleConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CircleConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CircleConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CircleConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const CircleConstructionMethodType::Intersection_optional& CircleConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    CircleConstructionMethodType::Intersection_optional& CircleConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void CircleConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void CircleConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void CircleConstructionMethodType::
    Intersection (::std::auto_ptr< Intersection_type > x)
    {
      this->Intersection_.set (x);
    }

    const CircleConstructionMethodType::Projection_optional& CircleConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    CircleConstructionMethodType::Projection_optional& CircleConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void CircleConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void CircleConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void CircleConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const CircleConstructionMethodType::Copy_optional& CircleConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CircleConstructionMethodType::Copy_optional& CircleConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CircleConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CircleConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CircleConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const CircleConstructionMethodType::Cast_optional& CircleConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CircleConstructionMethodType::Cast_optional& CircleConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CircleConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CircleConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CircleConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const CircleConstructionMethodType::Tangent_optional& CircleConstructionMethodType::
    Tangent () const
    {
      return this->Tangent_;
    }

    CircleConstructionMethodType::Tangent_optional& CircleConstructionMethodType::
    Tangent ()
    {
      return this->Tangent_;
    }

    void CircleConstructionMethodType::
    Tangent (const Tangent_type& x)
    {
      this->Tangent_.set (x);
    }

    void CircleConstructionMethodType::
    Tangent (const Tangent_optional& x)
    {
      this->Tangent_ = x;
    }

    void CircleConstructionMethodType::
    Tangent (::std::auto_ptr< Tangent_type > x)
    {
      this->Tangent_.set (x);
    }

    const CircleConstructionMethodType::TangentThrough_optional& CircleConstructionMethodType::
    TangentThrough () const
    {
      return this->TangentThrough_;
    }

    CircleConstructionMethodType::TangentThrough_optional& CircleConstructionMethodType::
    TangentThrough ()
    {
      return this->TangentThrough_;
    }

    void CircleConstructionMethodType::
    TangentThrough (const TangentThrough_type& x)
    {
      this->TangentThrough_.set (x);
    }

    void CircleConstructionMethodType::
    TangentThrough (const TangentThrough_optional& x)
    {
      this->TangentThrough_ = x;
    }

    void CircleConstructionMethodType::
    TangentThrough (::std::auto_ptr< TangentThrough_type > x)
    {
      this->TangentThrough_.set (x);
    }

    const CircleConstructionMethodType::Transform_optional& CircleConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CircleConstructionMethodType::Transform_optional& CircleConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CircleConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CircleConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CircleConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const CircleConstructionMethodType::FromCone_optional& CircleConstructionMethodType::
    FromCone () const
    {
      return this->FromCone_;
    }

    CircleConstructionMethodType::FromCone_optional& CircleConstructionMethodType::
    FromCone ()
    {
      return this->FromCone_;
    }

    void CircleConstructionMethodType::
    FromCone (const FromCone_type& x)
    {
      this->FromCone_.set (x);
    }

    void CircleConstructionMethodType::
    FromCone (const FromCone_optional& x)
    {
      this->FromCone_ = x;
    }

    void CircleConstructionMethodType::
    FromCone (::std::auto_ptr< FromCone_type > x)
    {
      this->FromCone_.set (x);
    }

    const CircleConstructionMethodType::FromScan_optional& CircleConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    CircleConstructionMethodType::FromScan_optional& CircleConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void CircleConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void CircleConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void CircleConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // CircleBestFitType
    // 

    const CircleBestFitType::BaseFeature_sequence& CircleBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CircleBestFitType::BaseFeature_sequence& CircleBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CircleBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // CircleRecompType
    // 

    const CircleRecompType::BaseFeaturePointList_type& CircleRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CircleRecompType::BaseFeaturePointList_type& CircleRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CircleRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CircleRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // CircleIntersectionType
    // 

    const CircleIntersectionType::IntersectionPlane_type& CircleIntersectionType::
    IntersectionPlane () const
    {
      return this->IntersectionPlane_.get ();
    }

    CircleIntersectionType::IntersectionPlane_type& CircleIntersectionType::
    IntersectionPlane ()
    {
      return this->IntersectionPlane_.get ();
    }

    void CircleIntersectionType::
    IntersectionPlane (const IntersectionPlane_type& x)
    {
      this->IntersectionPlane_.set (x);
    }

    void CircleIntersectionType::
    IntersectionPlane (::std::auto_ptr< IntersectionPlane_type > x)
    {
      this->IntersectionPlane_.set (x);
    }

    const CircleIntersectionType::IntersectionFeature_type& CircleIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_.get ();
    }

    CircleIntersectionType::IntersectionFeature_type& CircleIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_.get ();
    }

    void CircleIntersectionType::
    IntersectionFeature (const IntersectionFeature_type& x)
    {
      this->IntersectionFeature_.set (x);
    }

    void CircleIntersectionType::
    IntersectionFeature (::std::auto_ptr< IntersectionFeature_type > x)
    {
      this->IntersectionFeature_.set (x);
    }


    // CircleProjectionType
    // 

    const CircleProjectionType::ProjectionCircle_type& CircleProjectionType::
    ProjectionCircle () const
    {
      return this->ProjectionCircle_.get ();
    }

    CircleProjectionType::ProjectionCircle_type& CircleProjectionType::
    ProjectionCircle ()
    {
      return this->ProjectionCircle_.get ();
    }

    void CircleProjectionType::
    ProjectionCircle (const ProjectionCircle_type& x)
    {
      this->ProjectionCircle_.set (x);
    }

    void CircleProjectionType::
    ProjectionCircle (::std::auto_ptr< ProjectionCircle_type > x)
    {
      this->ProjectionCircle_.set (x);
    }

    const CircleProjectionType::ProjectionPlane_type& CircleProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    CircleProjectionType::ProjectionPlane_type& CircleProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void CircleProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void CircleProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }


    // CircleCopyType
    // 

    const CircleCopyType::BaseCircle_type& CircleCopyType::
    BaseCircle () const
    {
      return this->BaseCircle_.get ();
    }

    CircleCopyType::BaseCircle_type& CircleCopyType::
    BaseCircle ()
    {
      return this->BaseCircle_.get ();
    }

    void CircleCopyType::
    BaseCircle (const BaseCircle_type& x)
    {
      this->BaseCircle_.set (x);
    }

    void CircleCopyType::
    BaseCircle (::std::auto_ptr< BaseCircle_type > x)
    {
      this->BaseCircle_.set (x);
    }


    // CircleCastType
    // 

    const CircleCastType::BaseFeature_type& CircleCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CircleCastType::BaseFeature_type& CircleCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CircleCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CircleCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // CircleTangentType
    // 

    const CircleTangentType::TangentFeature_sequence& CircleTangentType::
    TangentFeature () const
    {
      return this->TangentFeature_;
    }

    CircleTangentType::TangentFeature_sequence& CircleTangentType::
    TangentFeature ()
    {
      return this->TangentFeature_;
    }

    void CircleTangentType::
    TangentFeature (const TangentFeature_sequence& s)
    {
      this->TangentFeature_ = s;
    }


    // CircleTangentThroughType
    // 

    const CircleTangentThroughType::TangentFeature_type& CircleTangentThroughType::
    TangentFeature () const
    {
      return this->TangentFeature_.get ();
    }

    CircleTangentThroughType::TangentFeature_type& CircleTangentThroughType::
    TangentFeature ()
    {
      return this->TangentFeature_.get ();
    }

    void CircleTangentThroughType::
    TangentFeature (const TangentFeature_type& x)
    {
      this->TangentFeature_.set (x);
    }

    void CircleTangentThroughType::
    TangentFeature (::std::auto_ptr< TangentFeature_type > x)
    {
      this->TangentFeature_.set (x);
    }

    const CircleTangentThroughType::PointFeature_type& CircleTangentThroughType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    CircleTangentThroughType::PointFeature_type& CircleTangentThroughType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void CircleTangentThroughType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void CircleTangentThroughType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // CircleTransformType
    // 

    const CircleTransformType::BaseCircle_type& CircleTransformType::
    BaseCircle () const
    {
      return this->BaseCircle_.get ();
    }

    CircleTransformType::BaseCircle_type& CircleTransformType::
    BaseCircle ()
    {
      return this->BaseCircle_.get ();
    }

    void CircleTransformType::
    BaseCircle (const BaseCircle_type& x)
    {
      this->BaseCircle_.set (x);
    }

    void CircleTransformType::
    BaseCircle (::std::auto_ptr< BaseCircle_type > x)
    {
      this->BaseCircle_.set (x);
    }

    const CircleTransformType::Transformation_type& CircleTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CircleTransformType::Transformation_type& CircleTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CircleTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CircleTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // CircleFromConeType
    // 

    const CircleFromConeType::Diameter_optional& CircleFromConeType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CircleFromConeType::Diameter_optional& CircleFromConeType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CircleFromConeType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CircleFromConeType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CircleFromConeType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CircleFromConeType::Distance_optional& CircleFromConeType::
    Distance () const
    {
      return this->Distance_;
    }

    CircleFromConeType::Distance_optional& CircleFromConeType::
    Distance ()
    {
      return this->Distance_;
    }

    void CircleFromConeType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void CircleFromConeType::
    Distance (const Distance_optional& x)
    {
      this->Distance_ = x;
    }

    void CircleFromConeType::
    Distance (::std::auto_ptr< Distance_type > x)
    {
      this->Distance_.set (x);
    }


    // CircleFromScanType
    // 

    const CircleFromScanType::SurfaceFeature_type& CircleFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    CircleFromScanType::SurfaceFeature_type& CircleFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void CircleFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void CircleFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const CircleFromScanType::SearchRadius_type& CircleFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    CircleFromScanType::SearchRadius_type& CircleFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void CircleFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void CircleFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const CircleFromScanType::Depth_type& CircleFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    CircleFromScanType::Depth_type& CircleFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void CircleFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void CircleFromScanType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }


    // CircleCheckedType
    // 

    const CircleCheckedType::Measured_optional& CircleCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CircleCheckedType::Measured_optional& CircleCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CircleCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CircleCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CircleCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const CircleCheckedType::Constructed_optional& CircleCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CircleCheckedType::Constructed_optional& CircleCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CircleCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CircleCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CircleCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // CircleCheckedFeatureType
    // 

    const CircleCheckedFeatureType::CheckDetails_optional& CircleCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CircleCheckedFeatureType::CheckDetails_optional& CircleCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CircleCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CircleCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CircleCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // CircleActualDeterminationType
    // 

    const CircleActualDeterminationType::Checked_optional& CircleActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CircleActualDeterminationType::Checked_optional& CircleActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CircleActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CircleActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CircleActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const CircleActualDeterminationType::Set_optional& CircleActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CircleActualDeterminationType::Set_optional& CircleActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CircleActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CircleActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CircleActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // CircleFeatureItemType
    // 

    const CircleFeatureItemType::DeterminationMode_type& CircleFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CircleFeatureItemType::DeterminationMode_type& CircleFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CircleFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CircleFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const CircleFeatureItemType::SubstituteFeatureAlgorithm_optional& CircleFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    CircleFeatureItemType::SubstituteFeatureAlgorithm_optional& CircleFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void CircleFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void CircleFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void CircleFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // CircleFeatureDefinitionType
    // 

    const CircleFeatureDefinitionType::InternalExternal_type& CircleFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CircleFeatureDefinitionType::InternalExternal_type& CircleFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CircleFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CircleFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const CircleFeatureDefinitionType::Diameter_type& CircleFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CircleFeatureDefinitionType::Diameter_type& CircleFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CircleFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CircleFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }


    // CircleFeatureNominalType
    // 

    const CircleFeatureNominalType::Location_type& CircleFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    CircleFeatureNominalType::Location_type& CircleFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void CircleFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CircleFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CircleFeatureNominalType::Normal_type& CircleFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    CircleFeatureNominalType::Normal_type& CircleFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void CircleFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void CircleFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // CircleFeatureActualType
    // 

    const CircleFeatureActualType::Location_optional& CircleFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    CircleFeatureActualType::Location_optional& CircleFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void CircleFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CircleFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void CircleFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CircleFeatureActualType::Normal_optional& CircleFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    CircleFeatureActualType::Normal_optional& CircleFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void CircleFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void CircleFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void CircleFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const CircleFeatureActualType::Diameter_optional& CircleFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CircleFeatureActualType::Diameter_optional& CircleFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CircleFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CircleFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CircleFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CircleFeatureActualType::DiameterMin_optional& CircleFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    CircleFeatureActualType::DiameterMin_optional& CircleFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void CircleFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void CircleFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void CircleFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const CircleFeatureActualType::DiameterMax_optional& CircleFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    CircleFeatureActualType::DiameterMax_optional& CircleFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void CircleFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void CircleFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void CircleFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const CircleFeatureActualType::Form_optional& CircleFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    CircleFeatureActualType::Form_optional& CircleFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void CircleFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CircleFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CircleFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // ConeConstructionMethodType
    // 

    const ConeConstructionMethodType::BestFit_optional& ConeConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ConeConstructionMethodType::BestFit_optional& ConeConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ConeConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ConeConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ConeConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ConeConstructionMethodType::Recompensated_optional& ConeConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ConeConstructionMethodType::Recompensated_optional& ConeConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ConeConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ConeConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ConeConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ConeConstructionMethodType::Copy_optional& ConeConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ConeConstructionMethodType::Copy_optional& ConeConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ConeConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ConeConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ConeConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ConeConstructionMethodType::Cast_optional& ConeConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ConeConstructionMethodType::Cast_optional& ConeConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ConeConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ConeConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ConeConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ConeConstructionMethodType::Transform_optional& ConeConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ConeConstructionMethodType::Transform_optional& ConeConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ConeConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ConeConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ConeConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const ConeConstructionMethodType::FromScan_optional& ConeConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    ConeConstructionMethodType::FromScan_optional& ConeConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void ConeConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void ConeConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void ConeConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // ConeBestFitType
    // 

    const ConeBestFitType::BaseFeature_sequence& ConeBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ConeBestFitType::BaseFeature_sequence& ConeBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ConeBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ConeRecompType
    // 

    const ConeRecompType::BaseFeaturePointList_type& ConeRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ConeRecompType::BaseFeaturePointList_type& ConeRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ConeRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ConeRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ConeCopyType
    // 

    const ConeCopyType::BaseCone_type& ConeCopyType::
    BaseCone () const
    {
      return this->BaseCone_.get ();
    }

    ConeCopyType::BaseCone_type& ConeCopyType::
    BaseCone ()
    {
      return this->BaseCone_.get ();
    }

    void ConeCopyType::
    BaseCone (const BaseCone_type& x)
    {
      this->BaseCone_.set (x);
    }

    void ConeCopyType::
    BaseCone (::std::auto_ptr< BaseCone_type > x)
    {
      this->BaseCone_.set (x);
    }


    // ConeCastType
    // 

    const ConeCastType::BaseFeature_type& ConeCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ConeCastType::BaseFeature_type& ConeCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ConeCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ConeCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ConeTransformType
    // 

    const ConeTransformType::BaseCone_type& ConeTransformType::
    BaseCone () const
    {
      return this->BaseCone_.get ();
    }

    ConeTransformType::BaseCone_type& ConeTransformType::
    BaseCone ()
    {
      return this->BaseCone_.get ();
    }

    void ConeTransformType::
    BaseCone (const BaseCone_type& x)
    {
      this->BaseCone_.set (x);
    }

    void ConeTransformType::
    BaseCone (::std::auto_ptr< BaseCone_type > x)
    {
      this->BaseCone_.set (x);
    }

    const ConeTransformType::Transformation_type& ConeTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ConeTransformType::Transformation_type& ConeTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ConeTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ConeTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ConeFromScanType
    // 

    const ConeFromScanType::SurfaceFeature_type& ConeFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    ConeFromScanType::SurfaceFeature_type& ConeFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void ConeFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void ConeFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const ConeFromScanType::SearchRadius_type& ConeFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    ConeFromScanType::SearchRadius_type& ConeFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void ConeFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void ConeFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // ConeCheckedType
    // 

    const ConeCheckedType::Measured_optional& ConeCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ConeCheckedType::Measured_optional& ConeCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ConeCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ConeCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ConeCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ConeCheckedType::Constructed_optional& ConeCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ConeCheckedType::Constructed_optional& ConeCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ConeCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ConeCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ConeCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ConeCheckedFeatureType
    // 

    const ConeCheckedFeatureType::CheckDetails_optional& ConeCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ConeCheckedFeatureType::CheckDetails_optional& ConeCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ConeCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ConeCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ConeCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ConeActualDeterminationType
    // 

    const ConeActualDeterminationType::Checked_optional& ConeActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ConeActualDeterminationType::Checked_optional& ConeActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ConeActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ConeActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ConeActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ConeActualDeterminationType::Set_optional& ConeActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ConeActualDeterminationType::Set_optional& ConeActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ConeActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ConeActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ConeActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ConeFeatureItemType
    // 

    const ConeFeatureItemType::DeterminationMode_type& ConeFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ConeFeatureItemType::DeterminationMode_type& ConeFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ConeFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ConeFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ConeFeatureItemType::SubstituteFeatureAlgorithm_optional& ConeFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ConeFeatureItemType::SubstituteFeatureAlgorithm_optional& ConeFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ConeFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ConeFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ConeFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ConeFeatureDefinitionType
    // 

    const ConeFeatureDefinitionType::InternalExternal_type& ConeFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ConeFeatureDefinitionType::InternalExternal_type& ConeFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ConeFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ConeFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ConeFeatureDefinitionType::Diameter_type& ConeFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ConeFeatureDefinitionType::Diameter_type& ConeFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ConeFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConeFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ConeFeatureDefinitionType::HalfAngle_optional& ConeFeatureDefinitionType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConeFeatureDefinitionType::HalfAngle_optional& ConeFeatureDefinitionType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConeFeatureDefinitionType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConeFeatureDefinitionType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConeFeatureDefinitionType::
    HalfAngle (::std::auto_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (x);
    }

    const ConeFeatureDefinitionType::FullAngle_optional& ConeFeatureDefinitionType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConeFeatureDefinitionType::FullAngle_optional& ConeFeatureDefinitionType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConeFeatureDefinitionType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConeFeatureDefinitionType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConeFeatureDefinitionType::
    FullAngle (::std::auto_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (x);
    }

    const ConeFeatureDefinitionType::LargeEndDistance_optional& ConeFeatureDefinitionType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConeFeatureDefinitionType::LargeEndDistance_optional& ConeFeatureDefinitionType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConeFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConeFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConeFeatureDefinitionType::
    LargeEndDistance (::std::auto_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (x);
    }

    const ConeFeatureDefinitionType::SmallEndDistance_optional& ConeFeatureDefinitionType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConeFeatureDefinitionType::SmallEndDistance_optional& ConeFeatureDefinitionType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConeFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConeFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConeFeatureDefinitionType::
    SmallEndDistance (::std::auto_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (x);
    }


    // ConeFeatureNominalType
    // 

    const ConeFeatureNominalType::Axis_type& ConeFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    ConeFeatureNominalType::Axis_type& ConeFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void ConeFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConeFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const ConeFeatureNominalType::Sweep_optional& ConeFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_;
    }

    ConeFeatureNominalType::Sweep_optional& ConeFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void ConeFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ConeFeatureNominalType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void ConeFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }


    // ConeFeatureActualType
    // 

    const ConeFeatureActualType::Axis_optional& ConeFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    ConeFeatureActualType::Axis_optional& ConeFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void ConeFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConeFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void ConeFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const ConeFeatureActualType::Diameter_optional& ConeFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    ConeFeatureActualType::Diameter_optional& ConeFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void ConeFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConeFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void ConeFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ConeFeatureActualType::DiameterMin_optional& ConeFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    ConeFeatureActualType::DiameterMin_optional& ConeFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void ConeFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void ConeFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void ConeFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const ConeFeatureActualType::DiameterMax_optional& ConeFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    ConeFeatureActualType::DiameterMax_optional& ConeFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void ConeFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void ConeFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void ConeFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const ConeFeatureActualType::HalfAngle_optional& ConeFeatureActualType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConeFeatureActualType::HalfAngle_optional& ConeFeatureActualType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConeFeatureActualType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConeFeatureActualType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConeFeatureActualType::
    HalfAngle (::std::auto_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (x);
    }

    const ConeFeatureActualType::FullAngle_optional& ConeFeatureActualType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConeFeatureActualType::FullAngle_optional& ConeFeatureActualType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConeFeatureActualType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConeFeatureActualType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConeFeatureActualType::
    FullAngle (::std::auto_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (x);
    }

    const ConeFeatureActualType::SmallEndDistance_optional& ConeFeatureActualType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConeFeatureActualType::SmallEndDistance_optional& ConeFeatureActualType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConeFeatureActualType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConeFeatureActualType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConeFeatureActualType::
    SmallEndDistance (::std::auto_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (x);
    }

    const ConeFeatureActualType::LargeEndDistance_optional& ConeFeatureActualType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConeFeatureActualType::LargeEndDistance_optional& ConeFeatureActualType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConeFeatureActualType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConeFeatureActualType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConeFeatureActualType::
    LargeEndDistance (::std::auto_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (x);
    }

    const ConeFeatureActualType::Sweep_optional& ConeFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    ConeFeatureActualType::Sweep_optional& ConeFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void ConeFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ConeFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void ConeFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const ConeFeatureActualType::Form_optional& ConeFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ConeFeatureActualType::Form_optional& ConeFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ConeFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ConeFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ConeFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // ConicalSegmentConstructionMethodType
    // 

    const ConicalSegmentConstructionMethodType::BestFit_optional& ConicalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ConicalSegmentConstructionMethodType::BestFit_optional& ConicalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ConicalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ConicalSegmentConstructionMethodType::Recompensated_optional& ConicalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ConicalSegmentConstructionMethodType::Recompensated_optional& ConicalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ConicalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ConicalSegmentConstructionMethodType::Copy_optional& ConicalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ConicalSegmentConstructionMethodType::Copy_optional& ConicalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ConicalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ConicalSegmentConstructionMethodType::Cast_optional& ConicalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ConicalSegmentConstructionMethodType::Cast_optional& ConicalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ConicalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ConicalSegmentConstructionMethodType::Transform_optional& ConicalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ConicalSegmentConstructionMethodType::Transform_optional& ConicalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ConicalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // ConicalSegmentBestFitType
    // 

    const ConicalSegmentBestFitType::BaseFeature_sequence& ConicalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ConicalSegmentBestFitType::BaseFeature_sequence& ConicalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ConicalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ConicalSegmentRecompType
    // 

    const ConicalSegmentRecompType::BaseFeaturePointList_type& ConicalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ConicalSegmentRecompType::BaseFeaturePointList_type& ConicalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ConicalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ConicalSegmentRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ConicalSegmentCopyType
    // 

    const ConicalSegmentCopyType::BaseConicalSegment_type& ConicalSegmentCopyType::
    BaseConicalSegment () const
    {
      return this->BaseConicalSegment_.get ();
    }

    ConicalSegmentCopyType::BaseConicalSegment_type& ConicalSegmentCopyType::
    BaseConicalSegment ()
    {
      return this->BaseConicalSegment_.get ();
    }

    void ConicalSegmentCopyType::
    BaseConicalSegment (const BaseConicalSegment_type& x)
    {
      this->BaseConicalSegment_.set (x);
    }

    void ConicalSegmentCopyType::
    BaseConicalSegment (::std::auto_ptr< BaseConicalSegment_type > x)
    {
      this->BaseConicalSegment_.set (x);
    }


    // ConicalSegmentCastType
    // 

    const ConicalSegmentCastType::BaseFeature_type& ConicalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ConicalSegmentCastType::BaseFeature_type& ConicalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ConicalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ConicalSegmentCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ConicalSegmentTransformType
    // 

    const ConicalSegmentTransformType::BaseConicalSegment_type& ConicalSegmentTransformType::
    BaseConicalSegment () const
    {
      return this->BaseConicalSegment_.get ();
    }

    ConicalSegmentTransformType::BaseConicalSegment_type& ConicalSegmentTransformType::
    BaseConicalSegment ()
    {
      return this->BaseConicalSegment_.get ();
    }

    void ConicalSegmentTransformType::
    BaseConicalSegment (const BaseConicalSegment_type& x)
    {
      this->BaseConicalSegment_.set (x);
    }

    void ConicalSegmentTransformType::
    BaseConicalSegment (::std::auto_ptr< BaseConicalSegment_type > x)
    {
      this->BaseConicalSegment_.set (x);
    }

    const ConicalSegmentTransformType::Transformation_type& ConicalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ConicalSegmentTransformType::Transformation_type& ConicalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ConicalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ConicalSegmentTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ConicalSegmentCheckedType
    // 

    const ConicalSegmentCheckedType::Measured_optional& ConicalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ConicalSegmentCheckedType::Measured_optional& ConicalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ConicalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ConicalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ConicalSegmentCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ConicalSegmentCheckedType::Constructed_optional& ConicalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ConicalSegmentCheckedType::Constructed_optional& ConicalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ConicalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ConicalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ConicalSegmentCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ConicalSegmentCheckedFeatureType
    // 

    const ConicalSegmentCheckedFeatureType::CheckDetails_optional& ConicalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ConicalSegmentCheckedFeatureType::CheckDetails_optional& ConicalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ConicalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ConicalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ConicalSegmentCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ConicalSegmentActualDeterminationType
    // 

    const ConicalSegmentActualDeterminationType::Checked_optional& ConicalSegmentActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ConicalSegmentActualDeterminationType::Checked_optional& ConicalSegmentActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ConicalSegmentActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ConicalSegmentActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ConicalSegmentActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ConicalSegmentActualDeterminationType::Set_optional& ConicalSegmentActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ConicalSegmentActualDeterminationType::Set_optional& ConicalSegmentActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ConicalSegmentActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ConicalSegmentActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ConicalSegmentActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ConicalSegmentFeatureItemType
    // 

    const ConicalSegmentFeatureItemType::DeterminationMode_type& ConicalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ConicalSegmentFeatureItemType::DeterminationMode_type& ConicalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ConicalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ConicalSegmentFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ConicalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& ConicalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ConicalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& ConicalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ConicalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ConicalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ConicalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ConicalSegmentFeatureDefinitionType
    // 

    const ConicalSegmentFeatureDefinitionType::InternalExternal_type& ConicalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ConicalSegmentFeatureDefinitionType::InternalExternal_type& ConicalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ConicalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ConicalSegmentFeatureDefinitionType::Diameter_type& ConicalSegmentFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ConicalSegmentFeatureDefinitionType::Diameter_type& ConicalSegmentFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ConicalSegmentFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ConicalSegmentFeatureDefinitionType::HalfAngle_optional& ConicalSegmentFeatureDefinitionType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConicalSegmentFeatureDefinitionType::HalfAngle_optional& ConicalSegmentFeatureDefinitionType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConicalSegmentFeatureDefinitionType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    HalfAngle (::std::auto_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (x);
    }

    const ConicalSegmentFeatureDefinitionType::FullAngle_optional& ConicalSegmentFeatureDefinitionType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConicalSegmentFeatureDefinitionType::FullAngle_optional& ConicalSegmentFeatureDefinitionType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConicalSegmentFeatureDefinitionType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    FullAngle (::std::auto_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (x);
    }

    const ConicalSegmentFeatureDefinitionType::LargeEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConicalSegmentFeatureDefinitionType::LargeEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConicalSegmentFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    LargeEndDistance (::std::auto_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (x);
    }

    const ConicalSegmentFeatureDefinitionType::SmallEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConicalSegmentFeatureDefinitionType::SmallEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConicalSegmentFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    SmallEndDistance (::std::auto_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (x);
    }


    // ConicalSegmentFeatureNominalType
    // 

    const ConicalSegmentFeatureNominalType::Axis_type& ConicalSegmentFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    ConicalSegmentFeatureNominalType::Axis_type& ConicalSegmentFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void ConicalSegmentFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConicalSegmentFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const ConicalSegmentFeatureNominalType::Sweep_type& ConicalSegmentFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    ConicalSegmentFeatureNominalType::Sweep_type& ConicalSegmentFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void ConicalSegmentFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ConicalSegmentFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }


    // ConicalSegmentFeatureActualType
    // 

    const ConicalSegmentFeatureActualType::Axis_optional& ConicalSegmentFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    ConicalSegmentFeatureActualType::Axis_optional& ConicalSegmentFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void ConicalSegmentFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void ConicalSegmentFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const ConicalSegmentFeatureActualType::Diameter_optional& ConicalSegmentFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    ConicalSegmentFeatureActualType::Diameter_optional& ConicalSegmentFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void ConicalSegmentFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void ConicalSegmentFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ConicalSegmentFeatureActualType::DiameterMin_optional& ConicalSegmentFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    ConicalSegmentFeatureActualType::DiameterMin_optional& ConicalSegmentFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void ConicalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void ConicalSegmentFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const ConicalSegmentFeatureActualType::DiameterMax_optional& ConicalSegmentFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    ConicalSegmentFeatureActualType::DiameterMax_optional& ConicalSegmentFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void ConicalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void ConicalSegmentFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const ConicalSegmentFeatureActualType::HalfAngle_optional& ConicalSegmentFeatureActualType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConicalSegmentFeatureActualType::HalfAngle_optional& ConicalSegmentFeatureActualType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConicalSegmentFeatureActualType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConicalSegmentFeatureActualType::
    HalfAngle (::std::auto_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (x);
    }

    const ConicalSegmentFeatureActualType::FullAngle_optional& ConicalSegmentFeatureActualType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConicalSegmentFeatureActualType::FullAngle_optional& ConicalSegmentFeatureActualType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConicalSegmentFeatureActualType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConicalSegmentFeatureActualType::
    FullAngle (::std::auto_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (x);
    }

    const ConicalSegmentFeatureActualType::SmallEndDistance_optional& ConicalSegmentFeatureActualType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConicalSegmentFeatureActualType::SmallEndDistance_optional& ConicalSegmentFeatureActualType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConicalSegmentFeatureActualType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConicalSegmentFeatureActualType::
    SmallEndDistance (::std::auto_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (x);
    }

    const ConicalSegmentFeatureActualType::LargeEndDistance_optional& ConicalSegmentFeatureActualType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConicalSegmentFeatureActualType::LargeEndDistance_optional& ConicalSegmentFeatureActualType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConicalSegmentFeatureActualType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConicalSegmentFeatureActualType::
    LargeEndDistance (::std::auto_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (x);
    }

    const ConicalSegmentFeatureActualType::Sweep_optional& ConicalSegmentFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    ConicalSegmentFeatureActualType::Sweep_optional& ConicalSegmentFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void ConicalSegmentFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void ConicalSegmentFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const ConicalSegmentFeatureActualType::Form_optional& ConicalSegmentFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ConicalSegmentFeatureActualType::Form_optional& ConicalSegmentFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ConicalSegmentFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ConicalSegmentFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // CuboidConstructionMethodType
    // 

    const CuboidConstructionMethodType::BestFit_optional& CuboidConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CuboidConstructionMethodType::BestFit_optional& CuboidConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CuboidConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CuboidConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CuboidConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const CuboidConstructionMethodType::Recompensated_optional& CuboidConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CuboidConstructionMethodType::Recompensated_optional& CuboidConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CuboidConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CuboidConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CuboidConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const CuboidConstructionMethodType::Copy_optional& CuboidConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CuboidConstructionMethodType::Copy_optional& CuboidConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CuboidConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CuboidConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CuboidConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const CuboidConstructionMethodType::Cast_optional& CuboidConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CuboidConstructionMethodType::Cast_optional& CuboidConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CuboidConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CuboidConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CuboidConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const CuboidConstructionMethodType::Transform_optional& CuboidConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CuboidConstructionMethodType::Transform_optional& CuboidConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CuboidConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CuboidConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CuboidConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // CuboidBestFitType
    // 

    const CuboidBestFitType::BaseFeature_sequence& CuboidBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CuboidBestFitType::BaseFeature_sequence& CuboidBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CuboidBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // CuboidRecompType
    // 

    const CuboidRecompType::BaseFeaturePointList_type& CuboidRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CuboidRecompType::BaseFeaturePointList_type& CuboidRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CuboidRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CuboidRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // CuboidCopyType
    // 

    const CuboidCopyType::BaseCuboid_type& CuboidCopyType::
    BaseCuboid () const
    {
      return this->BaseCuboid_.get ();
    }

    CuboidCopyType::BaseCuboid_type& CuboidCopyType::
    BaseCuboid ()
    {
      return this->BaseCuboid_.get ();
    }

    void CuboidCopyType::
    BaseCuboid (const BaseCuboid_type& x)
    {
      this->BaseCuboid_.set (x);
    }

    void CuboidCopyType::
    BaseCuboid (::std::auto_ptr< BaseCuboid_type > x)
    {
      this->BaseCuboid_.set (x);
    }


    // CuboidCastType
    // 

    const CuboidCastType::BaseFeature_type& CuboidCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CuboidCastType::BaseFeature_type& CuboidCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CuboidCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CuboidCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // CuboidTransformType
    // 

    const CuboidTransformType::BaseCuboid_type& CuboidTransformType::
    BaseCuboid () const
    {
      return this->BaseCuboid_.get ();
    }

    CuboidTransformType::BaseCuboid_type& CuboidTransformType::
    BaseCuboid ()
    {
      return this->BaseCuboid_.get ();
    }

    void CuboidTransformType::
    BaseCuboid (const BaseCuboid_type& x)
    {
      this->BaseCuboid_.set (x);
    }

    void CuboidTransformType::
    BaseCuboid (::std::auto_ptr< BaseCuboid_type > x)
    {
      this->BaseCuboid_.set (x);
    }

    const CuboidTransformType::Transformation_type& CuboidTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CuboidTransformType::Transformation_type& CuboidTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CuboidTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CuboidTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // CuboidCheckedType
    // 

    const CuboidCheckedType::Measured_optional& CuboidCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CuboidCheckedType::Measured_optional& CuboidCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CuboidCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CuboidCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CuboidCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const CuboidCheckedType::Constructed_optional& CuboidCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CuboidCheckedType::Constructed_optional& CuboidCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CuboidCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CuboidCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CuboidCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // CuboidCheckedFeatureType
    // 

    const CuboidCheckedFeatureType::CheckDetails_optional& CuboidCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CuboidCheckedFeatureType::CheckDetails_optional& CuboidCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CuboidCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CuboidCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CuboidCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // CuboidActualDeterminationType
    // 

    const CuboidActualDeterminationType::Checked_optional& CuboidActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CuboidActualDeterminationType::Checked_optional& CuboidActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CuboidActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CuboidActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CuboidActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const CuboidActualDeterminationType::Set_optional& CuboidActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CuboidActualDeterminationType::Set_optional& CuboidActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CuboidActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CuboidActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CuboidActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // CuboidFeatureItemType
    // 

    const CuboidFeatureItemType::DeterminationMode_type& CuboidFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CuboidFeatureItemType::DeterminationMode_type& CuboidFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CuboidFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CuboidFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const CuboidFeatureItemType::SubstituteFeatureAlgorithm_optional& CuboidFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    CuboidFeatureItemType::SubstituteFeatureAlgorithm_optional& CuboidFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void CuboidFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void CuboidFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void CuboidFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // CuboidFeatureDefinitionType
    // 

    const CuboidFeatureDefinitionType::InternalExternal_type& CuboidFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CuboidFeatureDefinitionType::InternalExternal_type& CuboidFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CuboidFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CuboidFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const CuboidFeatureDefinitionType::Length_type& CuboidFeatureDefinitionType::
    Length () const
    {
      return this->Length_.get ();
    }

    CuboidFeatureDefinitionType::Length_type& CuboidFeatureDefinitionType::
    Length ()
    {
      return this->Length_.get ();
    }

    void CuboidFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CuboidFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CuboidFeatureDefinitionType::Width_type& CuboidFeatureDefinitionType::
    Width () const
    {
      return this->Width_.get ();
    }

    CuboidFeatureDefinitionType::Width_type& CuboidFeatureDefinitionType::
    Width ()
    {
      return this->Width_.get ();
    }

    void CuboidFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void CuboidFeatureDefinitionType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const CuboidFeatureDefinitionType::Height_type& CuboidFeatureDefinitionType::
    Height () const
    {
      return this->Height_.get ();
    }

    CuboidFeatureDefinitionType::Height_type& CuboidFeatureDefinitionType::
    Height ()
    {
      return this->Height_.get ();
    }

    void CuboidFeatureDefinitionType::
    Height (const Height_type& x)
    {
      this->Height_.set (x);
    }

    void CuboidFeatureDefinitionType::
    Height (::std::auto_ptr< Height_type > x)
    {
      this->Height_.set (x);
    }


    // CuboidFeatureNominalType
    // 

    const CuboidFeatureNominalType::Location_type& CuboidFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    CuboidFeatureNominalType::Location_type& CuboidFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void CuboidFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CuboidFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CuboidFeatureNominalType::LengthVector_type& CuboidFeatureNominalType::
    LengthVector () const
    {
      return this->LengthVector_.get ();
    }

    CuboidFeatureNominalType::LengthVector_type& CuboidFeatureNominalType::
    LengthVector ()
    {
      return this->LengthVector_.get ();
    }

    void CuboidFeatureNominalType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void CuboidFeatureNominalType::
    LengthVector (::std::auto_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (x);
    }

    const CuboidFeatureNominalType::HeightVector_type& CuboidFeatureNominalType::
    HeightVector () const
    {
      return this->HeightVector_.get ();
    }

    CuboidFeatureNominalType::HeightVector_type& CuboidFeatureNominalType::
    HeightVector ()
    {
      return this->HeightVector_.get ();
    }

    void CuboidFeatureNominalType::
    HeightVector (const HeightVector_type& x)
    {
      this->HeightVector_.set (x);
    }

    void CuboidFeatureNominalType::
    HeightVector (::std::auto_ptr< HeightVector_type > x)
    {
      this->HeightVector_.set (x);
    }


    // CuboidFeatureActualType
    // 

    const CuboidFeatureActualType::Location_optional& CuboidFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    CuboidFeatureActualType::Location_optional& CuboidFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void CuboidFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CuboidFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void CuboidFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CuboidFeatureActualType::Length_optional& CuboidFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    CuboidFeatureActualType::Length_optional& CuboidFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void CuboidFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CuboidFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CuboidFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CuboidFeatureActualType::LengthMax_optional& CuboidFeatureActualType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    CuboidFeatureActualType::LengthMax_optional& CuboidFeatureActualType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void CuboidFeatureActualType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void CuboidFeatureActualType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void CuboidFeatureActualType::
    LengthMax (::std::auto_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (x);
    }

    const CuboidFeatureActualType::LengthMin_optional& CuboidFeatureActualType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    CuboidFeatureActualType::LengthMin_optional& CuboidFeatureActualType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void CuboidFeatureActualType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void CuboidFeatureActualType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void CuboidFeatureActualType::
    LengthMin (::std::auto_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (x);
    }

    const CuboidFeatureActualType::LengthVector_optional& CuboidFeatureActualType::
    LengthVector () const
    {
      return this->LengthVector_;
    }

    CuboidFeatureActualType::LengthVector_optional& CuboidFeatureActualType::
    LengthVector ()
    {
      return this->LengthVector_;
    }

    void CuboidFeatureActualType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void CuboidFeatureActualType::
    LengthVector (const LengthVector_optional& x)
    {
      this->LengthVector_ = x;
    }

    void CuboidFeatureActualType::
    LengthVector (::std::auto_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (x);
    }

    const CuboidFeatureActualType::Width_optional& CuboidFeatureActualType::
    Width () const
    {
      return this->Width_;
    }

    CuboidFeatureActualType::Width_optional& CuboidFeatureActualType::
    Width ()
    {
      return this->Width_;
    }

    void CuboidFeatureActualType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void CuboidFeatureActualType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void CuboidFeatureActualType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const CuboidFeatureActualType::WidthMax_optional& CuboidFeatureActualType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    CuboidFeatureActualType::WidthMax_optional& CuboidFeatureActualType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void CuboidFeatureActualType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void CuboidFeatureActualType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void CuboidFeatureActualType::
    WidthMax (::std::auto_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (x);
    }

    const CuboidFeatureActualType::WidthMin_optional& CuboidFeatureActualType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    CuboidFeatureActualType::WidthMin_optional& CuboidFeatureActualType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void CuboidFeatureActualType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void CuboidFeatureActualType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void CuboidFeatureActualType::
    WidthMin (::std::auto_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (x);
    }

    const CuboidFeatureActualType::Height_optional& CuboidFeatureActualType::
    Height () const
    {
      return this->Height_;
    }

    CuboidFeatureActualType::Height_optional& CuboidFeatureActualType::
    Height ()
    {
      return this->Height_;
    }

    void CuboidFeatureActualType::
    Height (const Height_type& x)
    {
      this->Height_.set (x);
    }

    void CuboidFeatureActualType::
    Height (const Height_optional& x)
    {
      this->Height_ = x;
    }

    void CuboidFeatureActualType::
    Height (::std::auto_ptr< Height_type > x)
    {
      this->Height_.set (x);
    }

    const CuboidFeatureActualType::HeightMax_optional& CuboidFeatureActualType::
    HeightMax () const
    {
      return this->HeightMax_;
    }

    CuboidFeatureActualType::HeightMax_optional& CuboidFeatureActualType::
    HeightMax ()
    {
      return this->HeightMax_;
    }

    void CuboidFeatureActualType::
    HeightMax (const HeightMax_type& x)
    {
      this->HeightMax_.set (x);
    }

    void CuboidFeatureActualType::
    HeightMax (const HeightMax_optional& x)
    {
      this->HeightMax_ = x;
    }

    void CuboidFeatureActualType::
    HeightMax (::std::auto_ptr< HeightMax_type > x)
    {
      this->HeightMax_.set (x);
    }

    const CuboidFeatureActualType::HeightMin_optional& CuboidFeatureActualType::
    HeightMin () const
    {
      return this->HeightMin_;
    }

    CuboidFeatureActualType::HeightMin_optional& CuboidFeatureActualType::
    HeightMin ()
    {
      return this->HeightMin_;
    }

    void CuboidFeatureActualType::
    HeightMin (const HeightMin_type& x)
    {
      this->HeightMin_.set (x);
    }

    void CuboidFeatureActualType::
    HeightMin (const HeightMin_optional& x)
    {
      this->HeightMin_ = x;
    }

    void CuboidFeatureActualType::
    HeightMin (::std::auto_ptr< HeightMin_type > x)
    {
      this->HeightMin_.set (x);
    }

    const CuboidFeatureActualType::HeightVector_optional& CuboidFeatureActualType::
    HeightVector () const
    {
      return this->HeightVector_;
    }

    CuboidFeatureActualType::HeightVector_optional& CuboidFeatureActualType::
    HeightVector ()
    {
      return this->HeightVector_;
    }

    void CuboidFeatureActualType::
    HeightVector (const HeightVector_type& x)
    {
      this->HeightVector_.set (x);
    }

    void CuboidFeatureActualType::
    HeightVector (const HeightVector_optional& x)
    {
      this->HeightVector_ = x;
    }

    void CuboidFeatureActualType::
    HeightVector (::std::auto_ptr< HeightVector_type > x)
    {
      this->HeightVector_.set (x);
    }

    const CuboidFeatureActualType::Form_optional& CuboidFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    CuboidFeatureActualType::Form_optional& CuboidFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void CuboidFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CuboidFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CuboidFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // CylinderConstructionMethodType
    // 

    const CylinderConstructionMethodType::BestFit_optional& CylinderConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CylinderConstructionMethodType::BestFit_optional& CylinderConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CylinderConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CylinderConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CylinderConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const CylinderConstructionMethodType::Recompensated_optional& CylinderConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CylinderConstructionMethodType::Recompensated_optional& CylinderConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CylinderConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CylinderConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CylinderConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const CylinderConstructionMethodType::Copy_optional& CylinderConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CylinderConstructionMethodType::Copy_optional& CylinderConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CylinderConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CylinderConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CylinderConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const CylinderConstructionMethodType::Cast_optional& CylinderConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CylinderConstructionMethodType::Cast_optional& CylinderConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CylinderConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CylinderConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CylinderConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const CylinderConstructionMethodType::Transform_optional& CylinderConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CylinderConstructionMethodType::Transform_optional& CylinderConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CylinderConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CylinderConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CylinderConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const CylinderConstructionMethodType::FromScan_optional& CylinderConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    CylinderConstructionMethodType::FromScan_optional& CylinderConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void CylinderConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void CylinderConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void CylinderConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // CylinderBestFitType
    // 

    const CylinderBestFitType::BaseFeature_sequence& CylinderBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CylinderBestFitType::BaseFeature_sequence& CylinderBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CylinderBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // CylinderRecompType
    // 

    const CylinderRecompType::BaseFeaturePointList_type& CylinderRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CylinderRecompType::BaseFeaturePointList_type& CylinderRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CylinderRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CylinderRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // CylinderCopyType
    // 

    const CylinderCopyType::BaseCylinder_type& CylinderCopyType::
    BaseCylinder () const
    {
      return this->BaseCylinder_.get ();
    }

    CylinderCopyType::BaseCylinder_type& CylinderCopyType::
    BaseCylinder ()
    {
      return this->BaseCylinder_.get ();
    }

    void CylinderCopyType::
    BaseCylinder (const BaseCylinder_type& x)
    {
      this->BaseCylinder_.set (x);
    }

    void CylinderCopyType::
    BaseCylinder (::std::auto_ptr< BaseCylinder_type > x)
    {
      this->BaseCylinder_.set (x);
    }


    // CylinderCastType
    // 

    const CylinderCastType::BaseFeature_type& CylinderCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CylinderCastType::BaseFeature_type& CylinderCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CylinderCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CylinderCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // CylinderTransformType
    // 

    const CylinderTransformType::BaseCylinder_type& CylinderTransformType::
    BaseCylinder () const
    {
      return this->BaseCylinder_.get ();
    }

    CylinderTransformType::BaseCylinder_type& CylinderTransformType::
    BaseCylinder ()
    {
      return this->BaseCylinder_.get ();
    }

    void CylinderTransformType::
    BaseCylinder (const BaseCylinder_type& x)
    {
      this->BaseCylinder_.set (x);
    }

    void CylinderTransformType::
    BaseCylinder (::std::auto_ptr< BaseCylinder_type > x)
    {
      this->BaseCylinder_.set (x);
    }

    const CylinderTransformType::Transformation_type& CylinderTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CylinderTransformType::Transformation_type& CylinderTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CylinderTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CylinderTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // CylinderFromScanType
    // 

    const CylinderFromScanType::SurfaceFeature_type& CylinderFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    CylinderFromScanType::SurfaceFeature_type& CylinderFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void CylinderFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void CylinderFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const CylinderFromScanType::SearchRadius_type& CylinderFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    CylinderFromScanType::SearchRadius_type& CylinderFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void CylinderFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void CylinderFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // CylinderCheckedType
    // 

    const CylinderCheckedType::Measured_optional& CylinderCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CylinderCheckedType::Measured_optional& CylinderCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CylinderCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CylinderCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CylinderCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const CylinderCheckedType::Constructed_optional& CylinderCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CylinderCheckedType::Constructed_optional& CylinderCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CylinderCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CylinderCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CylinderCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // CylinderCheckedFeatureType
    // 

    const CylinderCheckedFeatureType::CheckDetails_optional& CylinderCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CylinderCheckedFeatureType::CheckDetails_optional& CylinderCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CylinderCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // CylinderActualDeterminationType
    // 

    const CylinderActualDeterminationType::Checked_optional& CylinderActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CylinderActualDeterminationType::Checked_optional& CylinderActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CylinderActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CylinderActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CylinderActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const CylinderActualDeterminationType::Set_optional& CylinderActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CylinderActualDeterminationType::Set_optional& CylinderActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CylinderActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CylinderActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CylinderActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // CylinderFeatureItemType
    // 

    const CylinderFeatureItemType::DeterminationMode_type& CylinderFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CylinderFeatureItemType::DeterminationMode_type& CylinderFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CylinderFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CylinderFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const CylinderFeatureItemType::SubstituteFeatureAlgorithm_optional& CylinderFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    CylinderFeatureItemType::SubstituteFeatureAlgorithm_optional& CylinderFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void CylinderFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void CylinderFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void CylinderFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // CylinderFeatureDefinitionType
    // 

    const CylinderFeatureDefinitionType::InternalExternal_type& CylinderFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CylinderFeatureDefinitionType::InternalExternal_type& CylinderFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CylinderFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CylinderFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const CylinderFeatureDefinitionType::Diameter_type& CylinderFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CylinderFeatureDefinitionType::Diameter_type& CylinderFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CylinderFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylinderFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CylinderFeatureDefinitionType::Length_optional& CylinderFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    CylinderFeatureDefinitionType::Length_optional& CylinderFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void CylinderFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylinderFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylinderFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CylinderFeatureDefinitionType::Bottom_optional& CylinderFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    CylinderFeatureDefinitionType::Bottom_optional& CylinderFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void CylinderFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void CylinderFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void CylinderFeatureDefinitionType::
    Bottom (::std::auto_ptr< Bottom_type > x)
    {
      this->Bottom_.set (x);
    }


    // CylinderFeatureNominalType
    // 

    const CylinderFeatureNominalType::Axis_type& CylinderFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    CylinderFeatureNominalType::Axis_type& CylinderFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void CylinderFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylinderFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const CylinderFeatureNominalType::Sweep_optional& CylinderFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_;
    }

    CylinderFeatureNominalType::Sweep_optional& CylinderFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void CylinderFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CylinderFeatureNominalType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void CylinderFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }


    // CylinderFeatureActualType
    // 

    const CylinderFeatureActualType::Axis_optional& CylinderFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    CylinderFeatureActualType::Axis_optional& CylinderFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void CylinderFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylinderFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void CylinderFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const CylinderFeatureActualType::Diameter_optional& CylinderFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CylinderFeatureActualType::Diameter_optional& CylinderFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CylinderFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylinderFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CylinderFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CylinderFeatureActualType::Length_optional& CylinderFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    CylinderFeatureActualType::Length_optional& CylinderFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void CylinderFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylinderFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylinderFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CylinderFeatureActualType::DiameterMin_optional& CylinderFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    CylinderFeatureActualType::DiameterMin_optional& CylinderFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void CylinderFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void CylinderFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void CylinderFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const CylinderFeatureActualType::DiameterMax_optional& CylinderFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    CylinderFeatureActualType::DiameterMax_optional& CylinderFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void CylinderFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void CylinderFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void CylinderFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const CylinderFeatureActualType::Sweep_optional& CylinderFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    CylinderFeatureActualType::Sweep_optional& CylinderFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void CylinderFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CylinderFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void CylinderFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const CylinderFeatureActualType::Form_optional& CylinderFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    CylinderFeatureActualType::Form_optional& CylinderFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void CylinderFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CylinderFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CylinderFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // CylindricalSegmentConstructionMethodType
    // 

    const CylindricalSegmentConstructionMethodType::BestFit_optional& CylindricalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CylindricalSegmentConstructionMethodType::BestFit_optional& CylindricalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CylindricalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const CylindricalSegmentConstructionMethodType::Recompensated_optional& CylindricalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CylindricalSegmentConstructionMethodType::Recompensated_optional& CylindricalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CylindricalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const CylindricalSegmentConstructionMethodType::Copy_optional& CylindricalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CylindricalSegmentConstructionMethodType::Copy_optional& CylindricalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CylindricalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const CylindricalSegmentConstructionMethodType::Cast_optional& CylindricalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CylindricalSegmentConstructionMethodType::Cast_optional& CylindricalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CylindricalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const CylindricalSegmentConstructionMethodType::Transform_optional& CylindricalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CylindricalSegmentConstructionMethodType::Transform_optional& CylindricalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CylindricalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // CylindricalSegmentBestFitType
    // 

    const CylindricalSegmentBestFitType::BaseFeature_sequence& CylindricalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CylindricalSegmentBestFitType::BaseFeature_sequence& CylindricalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CylindricalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // CylindricalSegmentRecompType
    // 

    const CylindricalSegmentRecompType::BaseFeaturePointList_type& CylindricalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CylindricalSegmentRecompType::BaseFeaturePointList_type& CylindricalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CylindricalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CylindricalSegmentRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // CylindricalSegmentCopyType
    // 

    const CylindricalSegmentCopyType::BaseCylindricalSegment_type& CylindricalSegmentCopyType::
    BaseCylindricalSegment () const
    {
      return this->BaseCylindricalSegment_.get ();
    }

    CylindricalSegmentCopyType::BaseCylindricalSegment_type& CylindricalSegmentCopyType::
    BaseCylindricalSegment ()
    {
      return this->BaseCylindricalSegment_.get ();
    }

    void CylindricalSegmentCopyType::
    BaseCylindricalSegment (const BaseCylindricalSegment_type& x)
    {
      this->BaseCylindricalSegment_.set (x);
    }

    void CylindricalSegmentCopyType::
    BaseCylindricalSegment (::std::auto_ptr< BaseCylindricalSegment_type > x)
    {
      this->BaseCylindricalSegment_.set (x);
    }


    // CylindricalSegmentCastType
    // 

    const CylindricalSegmentCastType::BaseFeature_type& CylindricalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CylindricalSegmentCastType::BaseFeature_type& CylindricalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CylindricalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CylindricalSegmentCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // CylindricalSegmentTransformType
    // 

    const CylindricalSegmentTransformType::BaseCylindricalSegment_type& CylindricalSegmentTransformType::
    BaseCylindricalSegment () const
    {
      return this->BaseCylindricalSegment_.get ();
    }

    CylindricalSegmentTransformType::BaseCylindricalSegment_type& CylindricalSegmentTransformType::
    BaseCylindricalSegment ()
    {
      return this->BaseCylindricalSegment_.get ();
    }

    void CylindricalSegmentTransformType::
    BaseCylindricalSegment (const BaseCylindricalSegment_type& x)
    {
      this->BaseCylindricalSegment_.set (x);
    }

    void CylindricalSegmentTransformType::
    BaseCylindricalSegment (::std::auto_ptr< BaseCylindricalSegment_type > x)
    {
      this->BaseCylindricalSegment_.set (x);
    }

    const CylindricalSegmentTransformType::Transformation_type& CylindricalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CylindricalSegmentTransformType::Transformation_type& CylindricalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CylindricalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CylindricalSegmentTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // CylindricalSegmentCheckedType
    // 

    const CylindricalSegmentCheckedType::Measured_optional& CylindricalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CylindricalSegmentCheckedType::Measured_optional& CylindricalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CylindricalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CylindricalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CylindricalSegmentCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const CylindricalSegmentCheckedType::Constructed_optional& CylindricalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CylindricalSegmentCheckedType::Constructed_optional& CylindricalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CylindricalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CylindricalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CylindricalSegmentCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // CylindricalSegmentCheckedFeatureType
    // 

    const CylindricalSegmentCheckedFeatureType::CheckDetails_optional& CylindricalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CylindricalSegmentCheckedFeatureType::CheckDetails_optional& CylindricalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CylindricalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CylindricalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CylindricalSegmentCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // CylindricalSegmentActualDeterminationType
    // 

    const CylindricalSegmentActualDeterminationType::Checked_optional& CylindricalSegmentActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CylindricalSegmentActualDeterminationType::Checked_optional& CylindricalSegmentActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CylindricalSegmentActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CylindricalSegmentActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CylindricalSegmentActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const CylindricalSegmentActualDeterminationType::Set_optional& CylindricalSegmentActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CylindricalSegmentActualDeterminationType::Set_optional& CylindricalSegmentActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CylindricalSegmentActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CylindricalSegmentActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CylindricalSegmentActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // CylindricalSegmentFeatureItemType
    // 

    const CylindricalSegmentFeatureItemType::DeterminationMode_type& CylindricalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CylindricalSegmentFeatureItemType::DeterminationMode_type& CylindricalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CylindricalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CylindricalSegmentFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const CylindricalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& CylindricalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    CylindricalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& CylindricalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void CylindricalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void CylindricalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void CylindricalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // CylindricalSegmentFeatureDefinitionType
    // 

    const CylindricalSegmentFeatureDefinitionType::InternalExternal_type& CylindricalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CylindricalSegmentFeatureDefinitionType::InternalExternal_type& CylindricalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CylindricalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const CylindricalSegmentFeatureDefinitionType::Diameter_type& CylindricalSegmentFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CylindricalSegmentFeatureDefinitionType::Diameter_type& CylindricalSegmentFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CylindricalSegmentFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CylindricalSegmentFeatureDefinitionType::Length_optional& CylindricalSegmentFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    CylindricalSegmentFeatureDefinitionType::Length_optional& CylindricalSegmentFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CylindricalSegmentFeatureDefinitionType::Bottom_optional& CylindricalSegmentFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    CylindricalSegmentFeatureDefinitionType::Bottom_optional& CylindricalSegmentFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Bottom (::std::auto_ptr< Bottom_type > x)
    {
      this->Bottom_.set (x);
    }


    // CylindricalSegmentFeatureNominalType
    // 

    const CylindricalSegmentFeatureNominalType::Axis_type& CylindricalSegmentFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    CylindricalSegmentFeatureNominalType::Axis_type& CylindricalSegmentFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void CylindricalSegmentFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylindricalSegmentFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const CylindricalSegmentFeatureNominalType::Sweep_type& CylindricalSegmentFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    CylindricalSegmentFeatureNominalType::Sweep_type& CylindricalSegmentFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void CylindricalSegmentFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CylindricalSegmentFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }


    // CylindricalSegmentFeatureActualType
    // 

    const CylindricalSegmentFeatureActualType::Axis_optional& CylindricalSegmentFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    CylindricalSegmentFeatureActualType::Axis_optional& CylindricalSegmentFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void CylindricalSegmentFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const CylindricalSegmentFeatureActualType::Diameter_optional& CylindricalSegmentFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CylindricalSegmentFeatureActualType::Diameter_optional& CylindricalSegmentFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CylindricalSegmentFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CylindricalSegmentFeatureActualType::Length_optional& CylindricalSegmentFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    CylindricalSegmentFeatureActualType::Length_optional& CylindricalSegmentFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void CylindricalSegmentFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CylindricalSegmentFeatureActualType::DiameterMin_optional& CylindricalSegmentFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    CylindricalSegmentFeatureActualType::DiameterMin_optional& CylindricalSegmentFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const CylindricalSegmentFeatureActualType::DiameterMax_optional& CylindricalSegmentFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    CylindricalSegmentFeatureActualType::DiameterMax_optional& CylindricalSegmentFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const CylindricalSegmentFeatureActualType::Sweep_optional& CylindricalSegmentFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    CylindricalSegmentFeatureActualType::Sweep_optional& CylindricalSegmentFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void CylindricalSegmentFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const CylindricalSegmentFeatureActualType::Form_optional& CylindricalSegmentFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    CylindricalSegmentFeatureActualType::Form_optional& CylindricalSegmentFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void CylindricalSegmentFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // EdgePointConstructionMethodType
    // 

    const EdgePointConstructionMethodType::Copy_optional& EdgePointConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    EdgePointConstructionMethodType::Copy_optional& EdgePointConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void EdgePointConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void EdgePointConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void EdgePointConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const EdgePointConstructionMethodType::Cast_optional& EdgePointConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    EdgePointConstructionMethodType::Cast_optional& EdgePointConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void EdgePointConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void EdgePointConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void EdgePointConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const EdgePointConstructionMethodType::Transform_optional& EdgePointConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    EdgePointConstructionMethodType::Transform_optional& EdgePointConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void EdgePointConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void EdgePointConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void EdgePointConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const EdgePointConstructionMethodType::FromScan_optional& EdgePointConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    EdgePointConstructionMethodType::FromScan_optional& EdgePointConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void EdgePointConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void EdgePointConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void EdgePointConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // EdgePointCopyType
    // 

    const EdgePointCopyType::BaseEdgePoint_type& EdgePointCopyType::
    BaseEdgePoint () const
    {
      return this->BaseEdgePoint_.get ();
    }

    EdgePointCopyType::BaseEdgePoint_type& EdgePointCopyType::
    BaseEdgePoint ()
    {
      return this->BaseEdgePoint_.get ();
    }

    void EdgePointCopyType::
    BaseEdgePoint (const BaseEdgePoint_type& x)
    {
      this->BaseEdgePoint_.set (x);
    }

    void EdgePointCopyType::
    BaseEdgePoint (::std::auto_ptr< BaseEdgePoint_type > x)
    {
      this->BaseEdgePoint_.set (x);
    }


    // EdgePointCastType
    // 

    const EdgePointCastType::BaseFeature_type& EdgePointCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    EdgePointCastType::BaseFeature_type& EdgePointCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void EdgePointCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void EdgePointCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // EdgePointTransformType
    // 

    const EdgePointTransformType::BaseEdgePoint_type& EdgePointTransformType::
    BaseEdgePoint () const
    {
      return this->BaseEdgePoint_.get ();
    }

    EdgePointTransformType::BaseEdgePoint_type& EdgePointTransformType::
    BaseEdgePoint ()
    {
      return this->BaseEdgePoint_.get ();
    }

    void EdgePointTransformType::
    BaseEdgePoint (const BaseEdgePoint_type& x)
    {
      this->BaseEdgePoint_.set (x);
    }

    void EdgePointTransformType::
    BaseEdgePoint (::std::auto_ptr< BaseEdgePoint_type > x)
    {
      this->BaseEdgePoint_.set (x);
    }

    const EdgePointTransformType::Transformation_type& EdgePointTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    EdgePointTransformType::Transformation_type& EdgePointTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void EdgePointTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void EdgePointTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // EdgePointFromScanType
    // 

    const EdgePointFromScanType::SurfaceFeature_type& EdgePointFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    EdgePointFromScanType::SurfaceFeature_type& EdgePointFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void EdgePointFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void EdgePointFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const EdgePointFromScanType::SearchRadius_type& EdgePointFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    EdgePointFromScanType::SearchRadius_type& EdgePointFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void EdgePointFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void EdgePointFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const EdgePointFromScanType::PatchRadius_type& EdgePointFromScanType::
    PatchRadius () const
    {
      return this->PatchRadius_.get ();
    }

    EdgePointFromScanType::PatchRadius_type& EdgePointFromScanType::
    PatchRadius ()
    {
      return this->PatchRadius_.get ();
    }

    void EdgePointFromScanType::
    PatchRadius (const PatchRadius_type& x)
    {
      this->PatchRadius_.set (x);
    }

    void EdgePointFromScanType::
    PatchRadius (::std::auto_ptr< PatchRadius_type > x)
    {
      this->PatchRadius_.set (x);
    }

    const EdgePointFromScanType::Distance_type& EdgePointFromScanType::
    Distance () const
    {
      return this->Distance_.get ();
    }

    EdgePointFromScanType::Distance_type& EdgePointFromScanType::
    Distance ()
    {
      return this->Distance_.get ();
    }

    void EdgePointFromScanType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void EdgePointFromScanType::
    Distance (::std::auto_ptr< Distance_type > x)
    {
      this->Distance_.set (x);
    }

    const EdgePointFromScanType::Depth_type& EdgePointFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    EdgePointFromScanType::Depth_type& EdgePointFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void EdgePointFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void EdgePointFromScanType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }

    const EdgePointFromScanType::RetrievalMethod_type& EdgePointFromScanType::
    RetrievalMethod () const
    {
      return this->RetrievalMethod_.get ();
    }

    EdgePointFromScanType::RetrievalMethod_type& EdgePointFromScanType::
    RetrievalMethod ()
    {
      return this->RetrievalMethod_.get ();
    }

    void EdgePointFromScanType::
    RetrievalMethod (const RetrievalMethod_type& x)
    {
      this->RetrievalMethod_.set (x);
    }

    void EdgePointFromScanType::
    RetrievalMethod (::std::auto_ptr< RetrievalMethod_type > x)
    {
      this->RetrievalMethod_.set (x);
    }


    // EdgePointCheckedType
    // 

    const EdgePointCheckedType::Measured_optional& EdgePointCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    EdgePointCheckedType::Measured_optional& EdgePointCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void EdgePointCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void EdgePointCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void EdgePointCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const EdgePointCheckedType::Constructed_optional& EdgePointCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    EdgePointCheckedType::Constructed_optional& EdgePointCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void EdgePointCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void EdgePointCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void EdgePointCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // EdgePointCheckedFeatureType
    // 

    const EdgePointCheckedFeatureType::CheckDetails_optional& EdgePointCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    EdgePointCheckedFeatureType::CheckDetails_optional& EdgePointCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void EdgePointCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void EdgePointCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void EdgePointCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // EdgePointActualDeterminationType
    // 

    const EdgePointActualDeterminationType::Checked_optional& EdgePointActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    EdgePointActualDeterminationType::Checked_optional& EdgePointActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void EdgePointActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void EdgePointActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void EdgePointActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const EdgePointActualDeterminationType::Set_optional& EdgePointActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    EdgePointActualDeterminationType::Set_optional& EdgePointActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void EdgePointActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void EdgePointActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void EdgePointActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // EdgePointFeatureItemType
    // 

    const EdgePointFeatureItemType::DeterminationMode_type& EdgePointFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    EdgePointFeatureItemType::DeterminationMode_type& EdgePointFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void EdgePointFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void EdgePointFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }


    // EdgePointFeatureDefinitionType
    // 

    const EdgePointFeatureDefinitionType::InternalExternal_type& EdgePointFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    EdgePointFeatureDefinitionType::InternalExternal_type& EdgePointFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void EdgePointFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void EdgePointFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }


    // EdgePointFeatureNominalType
    // 

    const EdgePointFeatureNominalType::Location_type& EdgePointFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    EdgePointFeatureNominalType::Location_type& EdgePointFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void EdgePointFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void EdgePointFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const EdgePointFeatureNominalType::Normal_type& EdgePointFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    EdgePointFeatureNominalType::Normal_type& EdgePointFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void EdgePointFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EdgePointFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const EdgePointFeatureNominalType::AdjacentNormal_optional& EdgePointFeatureNominalType::
    AdjacentNormal () const
    {
      return this->AdjacentNormal_;
    }

    EdgePointFeatureNominalType::AdjacentNormal_optional& EdgePointFeatureNominalType::
    AdjacentNormal ()
    {
      return this->AdjacentNormal_;
    }

    void EdgePointFeatureNominalType::
    AdjacentNormal (const AdjacentNormal_type& x)
    {
      this->AdjacentNormal_.set (x);
    }

    void EdgePointFeatureNominalType::
    AdjacentNormal (const AdjacentNormal_optional& x)
    {
      this->AdjacentNormal_ = x;
    }

    void EdgePointFeatureNominalType::
    AdjacentNormal (::std::auto_ptr< AdjacentNormal_type > x)
    {
      this->AdjacentNormal_.set (x);
    }


    // EdgePointFeatureActualType
    // 

    const EdgePointFeatureActualType::Location_optional& EdgePointFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    EdgePointFeatureActualType::Location_optional& EdgePointFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void EdgePointFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void EdgePointFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void EdgePointFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const EdgePointFeatureActualType::Normal_optional& EdgePointFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    EdgePointFeatureActualType::Normal_optional& EdgePointFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void EdgePointFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EdgePointFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void EdgePointFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const EdgePointFeatureActualType::AdjacentNormal_optional& EdgePointFeatureActualType::
    AdjacentNormal () const
    {
      return this->AdjacentNormal_;
    }

    EdgePointFeatureActualType::AdjacentNormal_optional& EdgePointFeatureActualType::
    AdjacentNormal ()
    {
      return this->AdjacentNormal_;
    }

    void EdgePointFeatureActualType::
    AdjacentNormal (const AdjacentNormal_type& x)
    {
      this->AdjacentNormal_.set (x);
    }

    void EdgePointFeatureActualType::
    AdjacentNormal (const AdjacentNormal_optional& x)
    {
      this->AdjacentNormal_ = x;
    }

    void EdgePointFeatureActualType::
    AdjacentNormal (::std::auto_ptr< AdjacentNormal_type > x)
    {
      this->AdjacentNormal_.set (x);
    }


    // EllipseConstructionMethodType
    // 

    const EllipseConstructionMethodType::BestFit_optional& EllipseConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    EllipseConstructionMethodType::BestFit_optional& EllipseConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void EllipseConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void EllipseConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void EllipseConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const EllipseConstructionMethodType::Recompensated_optional& EllipseConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    EllipseConstructionMethodType::Recompensated_optional& EllipseConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void EllipseConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void EllipseConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void EllipseConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const EllipseConstructionMethodType::Intersection_optional& EllipseConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    EllipseConstructionMethodType::Intersection_optional& EllipseConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void EllipseConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void EllipseConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void EllipseConstructionMethodType::
    Intersection (::std::auto_ptr< Intersection_type > x)
    {
      this->Intersection_.set (x);
    }

    const EllipseConstructionMethodType::Projection_optional& EllipseConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    EllipseConstructionMethodType::Projection_optional& EllipseConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void EllipseConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void EllipseConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void EllipseConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const EllipseConstructionMethodType::Copy_optional& EllipseConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    EllipseConstructionMethodType::Copy_optional& EllipseConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void EllipseConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void EllipseConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void EllipseConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const EllipseConstructionMethodType::Cast_optional& EllipseConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    EllipseConstructionMethodType::Cast_optional& EllipseConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void EllipseConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void EllipseConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void EllipseConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const EllipseConstructionMethodType::Transform_optional& EllipseConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    EllipseConstructionMethodType::Transform_optional& EllipseConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void EllipseConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void EllipseConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void EllipseConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const EllipseConstructionMethodType::FromScan_optional& EllipseConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    EllipseConstructionMethodType::FromScan_optional& EllipseConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void EllipseConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void EllipseConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void EllipseConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // EllipseBestFitType
    // 

    const EllipseBestFitType::BaseFeature_sequence& EllipseBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    EllipseBestFitType::BaseFeature_sequence& EllipseBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void EllipseBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // EllipseRecompType
    // 

    const EllipseRecompType::BaseFeaturePointList_type& EllipseRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    EllipseRecompType::BaseFeaturePointList_type& EllipseRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void EllipseRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void EllipseRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // EllipseProjectionType
    // 

    const EllipseProjectionType::ProjectionFeature_type& EllipseProjectionType::
    ProjectionFeature () const
    {
      return this->ProjectionFeature_.get ();
    }

    EllipseProjectionType::ProjectionFeature_type& EllipseProjectionType::
    ProjectionFeature ()
    {
      return this->ProjectionFeature_.get ();
    }

    void EllipseProjectionType::
    ProjectionFeature (const ProjectionFeature_type& x)
    {
      this->ProjectionFeature_.set (x);
    }

    void EllipseProjectionType::
    ProjectionFeature (::std::auto_ptr< ProjectionFeature_type > x)
    {
      this->ProjectionFeature_.set (x);
    }

    const EllipseProjectionType::ProjectionPlane_type& EllipseProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    EllipseProjectionType::ProjectionPlane_type& EllipseProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void EllipseProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void EllipseProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }


    // EllipseIntersectionType
    // 

    const EllipseIntersectionType::IntersectionPlane_type& EllipseIntersectionType::
    IntersectionPlane () const
    {
      return this->IntersectionPlane_.get ();
    }

    EllipseIntersectionType::IntersectionPlane_type& EllipseIntersectionType::
    IntersectionPlane ()
    {
      return this->IntersectionPlane_.get ();
    }

    void EllipseIntersectionType::
    IntersectionPlane (const IntersectionPlane_type& x)
    {
      this->IntersectionPlane_.set (x);
    }

    void EllipseIntersectionType::
    IntersectionPlane (::std::auto_ptr< IntersectionPlane_type > x)
    {
      this->IntersectionPlane_.set (x);
    }

    const EllipseIntersectionType::IntersectionFeature_type& EllipseIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_.get ();
    }

    EllipseIntersectionType::IntersectionFeature_type& EllipseIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_.get ();
    }

    void EllipseIntersectionType::
    IntersectionFeature (const IntersectionFeature_type& x)
    {
      this->IntersectionFeature_.set (x);
    }

    void EllipseIntersectionType::
    IntersectionFeature (::std::auto_ptr< IntersectionFeature_type > x)
    {
      this->IntersectionFeature_.set (x);
    }


    // EllipseCopyType
    // 

    const EllipseCopyType::BaseEllipse_type& EllipseCopyType::
    BaseEllipse () const
    {
      return this->BaseEllipse_.get ();
    }

    EllipseCopyType::BaseEllipse_type& EllipseCopyType::
    BaseEllipse ()
    {
      return this->BaseEllipse_.get ();
    }

    void EllipseCopyType::
    BaseEllipse (const BaseEllipse_type& x)
    {
      this->BaseEllipse_.set (x);
    }

    void EllipseCopyType::
    BaseEllipse (::std::auto_ptr< BaseEllipse_type > x)
    {
      this->BaseEllipse_.set (x);
    }


    // EllipseCastType
    // 

    const EllipseCastType::BaseFeature_type& EllipseCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    EllipseCastType::BaseFeature_type& EllipseCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void EllipseCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void EllipseCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // EllipseTransformType
    // 

    const EllipseTransformType::BaseEllipse_type& EllipseTransformType::
    BaseEllipse () const
    {
      return this->BaseEllipse_.get ();
    }

    EllipseTransformType::BaseEllipse_type& EllipseTransformType::
    BaseEllipse ()
    {
      return this->BaseEllipse_.get ();
    }

    void EllipseTransformType::
    BaseEllipse (const BaseEllipse_type& x)
    {
      this->BaseEllipse_.set (x);
    }

    void EllipseTransformType::
    BaseEllipse (::std::auto_ptr< BaseEllipse_type > x)
    {
      this->BaseEllipse_.set (x);
    }

    const EllipseTransformType::Transformation_type& EllipseTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    EllipseTransformType::Transformation_type& EllipseTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void EllipseTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void EllipseTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // EllipseFromScanType
    // 

    const EllipseFromScanType::SurfaceFeature_type& EllipseFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    EllipseFromScanType::SurfaceFeature_type& EllipseFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void EllipseFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void EllipseFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const EllipseFromScanType::SearchRadius_type& EllipseFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    EllipseFromScanType::SearchRadius_type& EllipseFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void EllipseFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void EllipseFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const EllipseFromScanType::Depth_type& EllipseFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    EllipseFromScanType::Depth_type& EllipseFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void EllipseFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void EllipseFromScanType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }


    // EllipseCheckedType
    // 

    const EllipseCheckedType::Measured_optional& EllipseCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    EllipseCheckedType::Measured_optional& EllipseCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void EllipseCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void EllipseCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void EllipseCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const EllipseCheckedType::Constructed_optional& EllipseCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    EllipseCheckedType::Constructed_optional& EllipseCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void EllipseCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void EllipseCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void EllipseCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // EllipseCheckedFeatureType
    // 

    const EllipseCheckedFeatureType::CheckDetails_optional& EllipseCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    EllipseCheckedFeatureType::CheckDetails_optional& EllipseCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void EllipseCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void EllipseCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void EllipseCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // EllipseActualDeterminationType
    // 

    const EllipseActualDeterminationType::Checked_optional& EllipseActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    EllipseActualDeterminationType::Checked_optional& EllipseActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void EllipseActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void EllipseActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void EllipseActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const EllipseActualDeterminationType::Set_optional& EllipseActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    EllipseActualDeterminationType::Set_optional& EllipseActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void EllipseActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void EllipseActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void EllipseActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // EllipseFeatureItemType
    // 

    const EllipseFeatureItemType::DeterminationMode_type& EllipseFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    EllipseFeatureItemType::DeterminationMode_type& EllipseFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void EllipseFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void EllipseFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const EllipseFeatureItemType::SubstituteFeatureAlgorithm_optional& EllipseFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    EllipseFeatureItemType::SubstituteFeatureAlgorithm_optional& EllipseFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void EllipseFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void EllipseFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void EllipseFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // EllipseFeatureDefinitionType
    // 

    const EllipseFeatureDefinitionType::InternalExternal_type& EllipseFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    EllipseFeatureDefinitionType::InternalExternal_type& EllipseFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void EllipseFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void EllipseFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const EllipseFeatureDefinitionType::MajorDiameter_type& EllipseFeatureDefinitionType::
    MajorDiameter () const
    {
      return this->MajorDiameter_.get ();
    }

    EllipseFeatureDefinitionType::MajorDiameter_type& EllipseFeatureDefinitionType::
    MajorDiameter ()
    {
      return this->MajorDiameter_.get ();
    }

    void EllipseFeatureDefinitionType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void EllipseFeatureDefinitionType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }

    const EllipseFeatureDefinitionType::MinorDiameter_type& EllipseFeatureDefinitionType::
    MinorDiameter () const
    {
      return this->MinorDiameter_.get ();
    }

    EllipseFeatureDefinitionType::MinorDiameter_type& EllipseFeatureDefinitionType::
    MinorDiameter ()
    {
      return this->MinorDiameter_.get ();
    }

    void EllipseFeatureDefinitionType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void EllipseFeatureDefinitionType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }


    // EllipseFeatureNominalType
    // 

    const EllipseFeatureNominalType::Axis_type& EllipseFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    EllipseFeatureNominalType::Axis_type& EllipseFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void EllipseFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void EllipseFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const EllipseFeatureNominalType::Normal_type& EllipseFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    EllipseFeatureNominalType::Normal_type& EllipseFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void EllipseFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EllipseFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // EllipseFeatureActualType
    // 

    const EllipseFeatureActualType::Axis_optional& EllipseFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    EllipseFeatureActualType::Axis_optional& EllipseFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void EllipseFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void EllipseFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void EllipseFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const EllipseFeatureActualType::Normal_optional& EllipseFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    EllipseFeatureActualType::Normal_optional& EllipseFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void EllipseFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EllipseFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void EllipseFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const EllipseFeatureActualType::MajorDiameter_optional& EllipseFeatureActualType::
    MajorDiameter () const
    {
      return this->MajorDiameter_;
    }

    EllipseFeatureActualType::MajorDiameter_optional& EllipseFeatureActualType::
    MajorDiameter ()
    {
      return this->MajorDiameter_;
    }

    void EllipseFeatureActualType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void EllipseFeatureActualType::
    MajorDiameter (const MajorDiameter_optional& x)
    {
      this->MajorDiameter_ = x;
    }

    void EllipseFeatureActualType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }

    const EllipseFeatureActualType::MinorDiameter_optional& EllipseFeatureActualType::
    MinorDiameter () const
    {
      return this->MinorDiameter_;
    }

    EllipseFeatureActualType::MinorDiameter_optional& EllipseFeatureActualType::
    MinorDiameter ()
    {
      return this->MinorDiameter_;
    }

    void EllipseFeatureActualType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void EllipseFeatureActualType::
    MinorDiameter (const MinorDiameter_optional& x)
    {
      this->MinorDiameter_ = x;
    }

    void EllipseFeatureActualType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }

    const EllipseFeatureActualType::Form_optional& EllipseFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    EllipseFeatureActualType::Form_optional& EllipseFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void EllipseFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void EllipseFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void EllipseFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // ElongatedCylinderConstructionMethodType
    // 

    const ElongatedCylinderConstructionMethodType::BestFit_optional& ElongatedCylinderConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ElongatedCylinderConstructionMethodType::BestFit_optional& ElongatedCylinderConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ElongatedCylinderConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ElongatedCylinderConstructionMethodType::Recompensated_optional& ElongatedCylinderConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ElongatedCylinderConstructionMethodType::Recompensated_optional& ElongatedCylinderConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ElongatedCylinderConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ElongatedCylinderConstructionMethodType::Copy_optional& ElongatedCylinderConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ElongatedCylinderConstructionMethodType::Copy_optional& ElongatedCylinderConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ElongatedCylinderConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ElongatedCylinderConstructionMethodType::Cast_optional& ElongatedCylinderConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ElongatedCylinderConstructionMethodType::Cast_optional& ElongatedCylinderConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ElongatedCylinderConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ElongatedCylinderConstructionMethodType::Transform_optional& ElongatedCylinderConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ElongatedCylinderConstructionMethodType::Transform_optional& ElongatedCylinderConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ElongatedCylinderConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // ElongatedCylinderBestFitType
    // 

    const ElongatedCylinderBestFitType::BaseFeature_sequence& ElongatedCylinderBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ElongatedCylinderBestFitType::BaseFeature_sequence& ElongatedCylinderBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ElongatedCylinderBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ElongatedCylinderRecompType
    // 

    const ElongatedCylinderRecompType::BaseFeaturePointList_type& ElongatedCylinderRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ElongatedCylinderRecompType::BaseFeaturePointList_type& ElongatedCylinderRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ElongatedCylinderRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ElongatedCylinderRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ElongatedCylinderCopyType
    // 

    const ElongatedCylinderCopyType::BaseElongatedCylinder_type& ElongatedCylinderCopyType::
    BaseElongatedCylinder () const
    {
      return this->BaseElongatedCylinder_.get ();
    }

    ElongatedCylinderCopyType::BaseElongatedCylinder_type& ElongatedCylinderCopyType::
    BaseElongatedCylinder ()
    {
      return this->BaseElongatedCylinder_.get ();
    }

    void ElongatedCylinderCopyType::
    BaseElongatedCylinder (const BaseElongatedCylinder_type& x)
    {
      this->BaseElongatedCylinder_.set (x);
    }

    void ElongatedCylinderCopyType::
    BaseElongatedCylinder (::std::auto_ptr< BaseElongatedCylinder_type > x)
    {
      this->BaseElongatedCylinder_.set (x);
    }


    // ElongatedCylinderCastType
    // 

    const ElongatedCylinderCastType::BaseFeature_type& ElongatedCylinderCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ElongatedCylinderCastType::BaseFeature_type& ElongatedCylinderCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ElongatedCylinderCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ElongatedCylinderCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ElongatedCylinderTransformType
    // 

    const ElongatedCylinderTransformType::BaseElongatedCylinder_type& ElongatedCylinderTransformType::
    BaseElongatedCylinder () const
    {
      return this->BaseElongatedCylinder_.get ();
    }

    ElongatedCylinderTransformType::BaseElongatedCylinder_type& ElongatedCylinderTransformType::
    BaseElongatedCylinder ()
    {
      return this->BaseElongatedCylinder_.get ();
    }

    void ElongatedCylinderTransformType::
    BaseElongatedCylinder (const BaseElongatedCylinder_type& x)
    {
      this->BaseElongatedCylinder_.set (x);
    }

    void ElongatedCylinderTransformType::
    BaseElongatedCylinder (::std::auto_ptr< BaseElongatedCylinder_type > x)
    {
      this->BaseElongatedCylinder_.set (x);
    }

    const ElongatedCylinderTransformType::Transformation_type& ElongatedCylinderTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ElongatedCylinderTransformType::Transformation_type& ElongatedCylinderTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ElongatedCylinderTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ElongatedCylinderTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ElongatedCylinderCheckedType
    // 

    const ElongatedCylinderCheckedType::Measured_optional& ElongatedCylinderCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ElongatedCylinderCheckedType::Measured_optional& ElongatedCylinderCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ElongatedCylinderCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ElongatedCylinderCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ElongatedCylinderCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ElongatedCylinderCheckedType::Constructed_optional& ElongatedCylinderCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ElongatedCylinderCheckedType::Constructed_optional& ElongatedCylinderCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ElongatedCylinderCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ElongatedCylinderCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ElongatedCylinderCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ElongatedCylinderCheckedFeatureType
    // 

    const ElongatedCylinderCheckedFeatureType::CheckDetails_optional& ElongatedCylinderCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ElongatedCylinderCheckedFeatureType::CheckDetails_optional& ElongatedCylinderCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ElongatedCylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ElongatedCylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ElongatedCylinderCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ElongatedCylinderActualDeterminationType
    // 

    const ElongatedCylinderActualDeterminationType::Checked_optional& ElongatedCylinderActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ElongatedCylinderActualDeterminationType::Checked_optional& ElongatedCylinderActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ElongatedCylinderActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ElongatedCylinderActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ElongatedCylinderActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ElongatedCylinderActualDeterminationType::Set_optional& ElongatedCylinderActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ElongatedCylinderActualDeterminationType::Set_optional& ElongatedCylinderActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ElongatedCylinderActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ElongatedCylinderActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ElongatedCylinderActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ElongatedCylinderFeatureItemType
    // 

    const ElongatedCylinderFeatureItemType::DeterminationMode_type& ElongatedCylinderFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ElongatedCylinderFeatureItemType::DeterminationMode_type& ElongatedCylinderFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ElongatedCylinderFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ElongatedCylinderFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ElongatedCylinderFeatureItemType::SubstituteFeatureAlgorithm_optional& ElongatedCylinderFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ElongatedCylinderFeatureItemType::SubstituteFeatureAlgorithm_optional& ElongatedCylinderFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ElongatedCylinderFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ElongatedCylinderFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ElongatedCylinderFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ElongatedCylinderFeatureDefinitionType
    // 

    const ElongatedCylinderFeatureDefinitionType::InternalExternal_type& ElongatedCylinderFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ElongatedCylinderFeatureDefinitionType::InternalExternal_type& ElongatedCylinderFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ElongatedCylinderFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ElongatedCylinderFeatureDefinitionType::Diameter_type& ElongatedCylinderFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ElongatedCylinderFeatureDefinitionType::Diameter_type& ElongatedCylinderFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ElongatedCylinderFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ElongatedCylinderFeatureDefinitionType::Length_type& ElongatedCylinderFeatureDefinitionType::
    Length () const
    {
      return this->Length_.get ();
    }

    ElongatedCylinderFeatureDefinitionType::Length_type& ElongatedCylinderFeatureDefinitionType::
    Length ()
    {
      return this->Length_.get ();
    }

    void ElongatedCylinderFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const ElongatedCylinderFeatureDefinitionType::Width_optional& ElongatedCylinderFeatureDefinitionType::
    Width () const
    {
      return this->Width_;
    }

    ElongatedCylinderFeatureDefinitionType::Width_optional& ElongatedCylinderFeatureDefinitionType::
    Width ()
    {
      return this->Width_;
    }

    void ElongatedCylinderFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void ElongatedCylinderFeatureDefinitionType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const ElongatedCylinderFeatureDefinitionType::Depth_optional& ElongatedCylinderFeatureDefinitionType::
    Depth () const
    {
      return this->Depth_;
    }

    ElongatedCylinderFeatureDefinitionType::Depth_optional& ElongatedCylinderFeatureDefinitionType::
    Depth ()
    {
      return this->Depth_;
    }

    void ElongatedCylinderFeatureDefinitionType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void ElongatedCylinderFeatureDefinitionType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }


    // ElongatedCylinderFeatureNominalType
    // 

    const ElongatedCylinderFeatureNominalType::CenterPlane_type& ElongatedCylinderFeatureNominalType::
    CenterPlane () const
    {
      return this->CenterPlane_.get ();
    }

    ElongatedCylinderFeatureNominalType::CenterPlane_type& ElongatedCylinderFeatureNominalType::
    CenterPlane ()
    {
      return this->CenterPlane_.get ();
    }

    void ElongatedCylinderFeatureNominalType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void ElongatedCylinderFeatureNominalType::
    CenterPlane (::std::auto_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (x);
    }

    const ElongatedCylinderFeatureNominalType::DepthVector_type& ElongatedCylinderFeatureNominalType::
    DepthVector () const
    {
      return this->DepthVector_.get ();
    }

    ElongatedCylinderFeatureNominalType::DepthVector_type& ElongatedCylinderFeatureNominalType::
    DepthVector ()
    {
      return this->DepthVector_.get ();
    }

    void ElongatedCylinderFeatureNominalType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void ElongatedCylinderFeatureNominalType::
    DepthVector (::std::auto_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (x);
    }


    // ElongatedCylinderFeatureActualType
    // 

    const ElongatedCylinderFeatureActualType::Diameter_optional& ElongatedCylinderFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    ElongatedCylinderFeatureActualType::Diameter_optional& ElongatedCylinderFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void ElongatedCylinderFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ElongatedCylinderFeatureActualType::DiameterMin_optional& ElongatedCylinderFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    ElongatedCylinderFeatureActualType::DiameterMin_optional& ElongatedCylinderFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const ElongatedCylinderFeatureActualType::DiameterMax_optional& ElongatedCylinderFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    ElongatedCylinderFeatureActualType::DiameterMax_optional& ElongatedCylinderFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const ElongatedCylinderFeatureActualType::CenterPlane_optional& ElongatedCylinderFeatureActualType::
    CenterPlane () const
    {
      return this->CenterPlane_;
    }

    ElongatedCylinderFeatureActualType::CenterPlane_optional& ElongatedCylinderFeatureActualType::
    CenterPlane ()
    {
      return this->CenterPlane_;
    }

    void ElongatedCylinderFeatureActualType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    CenterPlane (const CenterPlane_optional& x)
    {
      this->CenterPlane_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    CenterPlane (::std::auto_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (x);
    }

    const ElongatedCylinderFeatureActualType::Length_optional& ElongatedCylinderFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    ElongatedCylinderFeatureActualType::Length_optional& ElongatedCylinderFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void ElongatedCylinderFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const ElongatedCylinderFeatureActualType::LengthMax_optional& ElongatedCylinderFeatureActualType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    ElongatedCylinderFeatureActualType::LengthMax_optional& ElongatedCylinderFeatureActualType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void ElongatedCylinderFeatureActualType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    LengthMax (::std::auto_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (x);
    }

    const ElongatedCylinderFeatureActualType::LengthMin_optional& ElongatedCylinderFeatureActualType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    ElongatedCylinderFeatureActualType::LengthMin_optional& ElongatedCylinderFeatureActualType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void ElongatedCylinderFeatureActualType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    LengthMin (::std::auto_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (x);
    }

    const ElongatedCylinderFeatureActualType::Width_optional& ElongatedCylinderFeatureActualType::
    Width () const
    {
      return this->Width_;
    }

    ElongatedCylinderFeatureActualType::Width_optional& ElongatedCylinderFeatureActualType::
    Width ()
    {
      return this->Width_;
    }

    void ElongatedCylinderFeatureActualType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const ElongatedCylinderFeatureActualType::WidthMax_optional& ElongatedCylinderFeatureActualType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    ElongatedCylinderFeatureActualType::WidthMax_optional& ElongatedCylinderFeatureActualType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void ElongatedCylinderFeatureActualType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    WidthMax (::std::auto_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (x);
    }

    const ElongatedCylinderFeatureActualType::WidthMin_optional& ElongatedCylinderFeatureActualType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    ElongatedCylinderFeatureActualType::WidthMin_optional& ElongatedCylinderFeatureActualType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void ElongatedCylinderFeatureActualType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    WidthMin (::std::auto_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (x);
    }

    const ElongatedCylinderFeatureActualType::Depth_optional& ElongatedCylinderFeatureActualType::
    Depth () const
    {
      return this->Depth_;
    }

    ElongatedCylinderFeatureActualType::Depth_optional& ElongatedCylinderFeatureActualType::
    Depth ()
    {
      return this->Depth_;
    }

    void ElongatedCylinderFeatureActualType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }

    const ElongatedCylinderFeatureActualType::DepthMax_optional& ElongatedCylinderFeatureActualType::
    DepthMax () const
    {
      return this->DepthMax_;
    }

    ElongatedCylinderFeatureActualType::DepthMax_optional& ElongatedCylinderFeatureActualType::
    DepthMax ()
    {
      return this->DepthMax_;
    }

    void ElongatedCylinderFeatureActualType::
    DepthMax (const DepthMax_type& x)
    {
      this->DepthMax_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    DepthMax (const DepthMax_optional& x)
    {
      this->DepthMax_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    DepthMax (::std::auto_ptr< DepthMax_type > x)
    {
      this->DepthMax_.set (x);
    }

    const ElongatedCylinderFeatureActualType::DepthMin_optional& ElongatedCylinderFeatureActualType::
    DepthMin () const
    {
      return this->DepthMin_;
    }

    ElongatedCylinderFeatureActualType::DepthMin_optional& ElongatedCylinderFeatureActualType::
    DepthMin ()
    {
      return this->DepthMin_;
    }

    void ElongatedCylinderFeatureActualType::
    DepthMin (const DepthMin_type& x)
    {
      this->DepthMin_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    DepthMin (const DepthMin_optional& x)
    {
      this->DepthMin_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    DepthMin (::std::auto_ptr< DepthMin_type > x)
    {
      this->DepthMin_.set (x);
    }

    const ElongatedCylinderFeatureActualType::DepthVector_optional& ElongatedCylinderFeatureActualType::
    DepthVector () const
    {
      return this->DepthVector_;
    }

    ElongatedCylinderFeatureActualType::DepthVector_optional& ElongatedCylinderFeatureActualType::
    DepthVector ()
    {
      return this->DepthVector_;
    }

    void ElongatedCylinderFeatureActualType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    DepthVector (const DepthVector_optional& x)
    {
      this->DepthVector_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    DepthVector (::std::auto_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (x);
    }

    const ElongatedCylinderFeatureActualType::Form_optional& ElongatedCylinderFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ElongatedCylinderFeatureActualType::Form_optional& ElongatedCylinderFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ElongatedCylinderFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // ExtrudedCrossSectionConstructionMethodType
    // 

    const ExtrudedCrossSectionConstructionMethodType::BestFit_optional& ExtrudedCrossSectionConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ExtrudedCrossSectionConstructionMethodType::BestFit_optional& ExtrudedCrossSectionConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ExtrudedCrossSectionConstructionMethodType::Recompensated_optional& ExtrudedCrossSectionConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ExtrudedCrossSectionConstructionMethodType::Recompensated_optional& ExtrudedCrossSectionConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ExtrudedCrossSectionConstructionMethodType::Copy_optional& ExtrudedCrossSectionConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ExtrudedCrossSectionConstructionMethodType::Copy_optional& ExtrudedCrossSectionConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ExtrudedCrossSectionConstructionMethodType::Cast_optional& ExtrudedCrossSectionConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ExtrudedCrossSectionConstructionMethodType::Cast_optional& ExtrudedCrossSectionConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ExtrudedCrossSectionConstructionMethodType::Transform_optional& ExtrudedCrossSectionConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ExtrudedCrossSectionConstructionMethodType::Transform_optional& ExtrudedCrossSectionConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // ExtrudedCrossSectionBestFitType
    // 

    const ExtrudedCrossSectionBestFitType::BaseFeature_sequence& ExtrudedCrossSectionBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ExtrudedCrossSectionBestFitType::BaseFeature_sequence& ExtrudedCrossSectionBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ExtrudedCrossSectionBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ExtrudedCrossSectionRecompType
    // 

    const ExtrudedCrossSectionRecompType::BaseFeaturePointList_type& ExtrudedCrossSectionRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ExtrudedCrossSectionRecompType::BaseFeaturePointList_type& ExtrudedCrossSectionRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ExtrudedCrossSectionRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ExtrudedCrossSectionRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ExtrudedCrossSectionCopyType
    // 

    const ExtrudedCrossSectionCopyType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection () const
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    ExtrudedCrossSectionCopyType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection ()
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    void ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection (const BaseExtrudedCrossSection_type& x)
    {
      this->BaseExtrudedCrossSection_.set (x);
    }

    void ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection (::std::auto_ptr< BaseExtrudedCrossSection_type > x)
    {
      this->BaseExtrudedCrossSection_.set (x);
    }


    // ExtrudedCrossSectionCastType
    // 

    const ExtrudedCrossSectionCastType::BaseFeature_type& ExtrudedCrossSectionCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ExtrudedCrossSectionCastType::BaseFeature_type& ExtrudedCrossSectionCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ExtrudedCrossSectionCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ExtrudedCrossSectionCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ExtrudedCrossSectionTransformType
    // 

    const ExtrudedCrossSectionTransformType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection () const
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    ExtrudedCrossSectionTransformType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection ()
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    void ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection (const BaseExtrudedCrossSection_type& x)
    {
      this->BaseExtrudedCrossSection_.set (x);
    }

    void ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection (::std::auto_ptr< BaseExtrudedCrossSection_type > x)
    {
      this->BaseExtrudedCrossSection_.set (x);
    }

    const ExtrudedCrossSectionTransformType::Transformation_type& ExtrudedCrossSectionTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ExtrudedCrossSectionTransformType::Transformation_type& ExtrudedCrossSectionTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ExtrudedCrossSectionTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ExtrudedCrossSectionTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ExtrudedCrossSectionCheckedType
    // 

    const ExtrudedCrossSectionCheckedType::Measured_optional& ExtrudedCrossSectionCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ExtrudedCrossSectionCheckedType::Measured_optional& ExtrudedCrossSectionCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ExtrudedCrossSectionCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ExtrudedCrossSectionCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ExtrudedCrossSectionCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ExtrudedCrossSectionCheckedType::Constructed_optional& ExtrudedCrossSectionCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ExtrudedCrossSectionCheckedType::Constructed_optional& ExtrudedCrossSectionCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ExtrudedCrossSectionCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ExtrudedCrossSectionCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ExtrudedCrossSectionCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ExtrudedCrossSectionCheckedFeatureType
    // 

    const ExtrudedCrossSectionCheckedFeatureType::CheckDetails_optional& ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ExtrudedCrossSectionCheckedFeatureType::CheckDetails_optional& ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ExtrudedCrossSectionActualDeterminationType
    // 

    const ExtrudedCrossSectionActualDeterminationType::Checked_optional& ExtrudedCrossSectionActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ExtrudedCrossSectionActualDeterminationType::Checked_optional& ExtrudedCrossSectionActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ExtrudedCrossSectionActualDeterminationType::Set_optional& ExtrudedCrossSectionActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ExtrudedCrossSectionActualDeterminationType::Set_optional& ExtrudedCrossSectionActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ExtrudedCrossSectionFeatureItemType
    // 

    const ExtrudedCrossSectionFeatureItemType::DeterminationMode_type& ExtrudedCrossSectionFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ExtrudedCrossSectionFeatureItemType::DeterminationMode_type& ExtrudedCrossSectionFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ExtrudedCrossSectionFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ExtrudedCrossSectionFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ExtrudedCrossSectionFeatureItemType::SubstituteFeatureAlgorithm_optional& ExtrudedCrossSectionFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ExtrudedCrossSectionFeatureItemType::SubstituteFeatureAlgorithm_optional& ExtrudedCrossSectionFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ExtrudedCrossSectionFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ExtrudedCrossSectionFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ExtrudedCrossSectionFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ExtrudedCrossSectionFeatureDefinitionType
    // 

    const ExtrudedCrossSectionFeatureDefinitionType::InternalExternal_type& ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ExtrudedCrossSectionFeatureDefinitionType::InternalExternal_type& ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ExtrudedCrossSectionFeatureDefinitionType::Length_type& ExtrudedCrossSectionFeatureDefinitionType::
    Length () const
    {
      return this->Length_.get ();
    }

    ExtrudedCrossSectionFeatureDefinitionType::Length_type& ExtrudedCrossSectionFeatureDefinitionType::
    Length ()
    {
      return this->Length_.get ();
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }


    // ExtrudedCrossSectionFeatureNominalType
    // 

    const ExtrudedCrossSectionFeatureNominalType::Direction_type& ExtrudedCrossSectionFeatureNominalType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    ExtrudedCrossSectionFeatureNominalType::Direction_type& ExtrudedCrossSectionFeatureNominalType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void ExtrudedCrossSectionFeatureNominalType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void ExtrudedCrossSectionFeatureNominalType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }

    const ExtrudedCrossSectionFeatureNominalType::CrossSectionReferenceFeatureId_type& ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId () const
    {
      return this->CrossSectionReferenceFeatureId_.get ();
    }

    ExtrudedCrossSectionFeatureNominalType::CrossSectionReferenceFeatureId_type& ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId ()
    {
      return this->CrossSectionReferenceFeatureId_.get ();
    }

    void ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId (const CrossSectionReferenceFeatureId_type& x)
    {
      this->CrossSectionReferenceFeatureId_.set (x);
    }

    void ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId (::std::auto_ptr< CrossSectionReferenceFeatureId_type > x)
    {
      this->CrossSectionReferenceFeatureId_.set (x);
    }


    // ExtrudedCrossSectionFeatureActualType
    // 

    const ExtrudedCrossSectionFeatureActualType::Direction_optional& ExtrudedCrossSectionFeatureActualType::
    Direction () const
    {
      return this->Direction_;
    }

    ExtrudedCrossSectionFeatureActualType::Direction_optional& ExtrudedCrossSectionFeatureActualType::
    Direction ()
    {
      return this->Direction_;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void ExtrudedCrossSectionFeatureActualType::
    Direction (const Direction_optional& x)
    {
      this->Direction_ = x;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }

    const ExtrudedCrossSectionFeatureActualType::Length_optional& ExtrudedCrossSectionFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    ExtrudedCrossSectionFeatureActualType::Length_optional& ExtrudedCrossSectionFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ExtrudedCrossSectionFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const ExtrudedCrossSectionFeatureActualType::Form_optional& ExtrudedCrossSectionFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ExtrudedCrossSectionFeatureActualType::Form_optional& ExtrudedCrossSectionFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ExtrudedCrossSectionFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // GenericFeatureItemType
    // 


    // GenericFeatureDefinitionType
    // 


    // GenericFeatureNominalType
    // 

    const GenericFeatureNominalType::Location_optional& GenericFeatureNominalType::
    Location () const
    {
      return this->Location_;
    }

    GenericFeatureNominalType::Location_optional& GenericFeatureNominalType::
    Location ()
    {
      return this->Location_;
    }

    void GenericFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void GenericFeatureNominalType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void GenericFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const GenericFeatureNominalType::ReferenceFeatureNominalId_sequence& GenericFeatureNominalType::
    ReferenceFeatureNominalId () const
    {
      return this->ReferenceFeatureNominalId_;
    }

    GenericFeatureNominalType::ReferenceFeatureNominalId_sequence& GenericFeatureNominalType::
    ReferenceFeatureNominalId ()
    {
      return this->ReferenceFeatureNominalId_;
    }

    void GenericFeatureNominalType::
    ReferenceFeatureNominalId (const ReferenceFeatureNominalId_sequence& s)
    {
      this->ReferenceFeatureNominalId_ = s;
    }


    // GenericFeatureActualType
    // 


    // LineConstructionMethodType
    // 

    const LineConstructionMethodType::BestFit_optional& LineConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    LineConstructionMethodType::BestFit_optional& LineConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void LineConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void LineConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void LineConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const LineConstructionMethodType::Recompensated_optional& LineConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    LineConstructionMethodType::Recompensated_optional& LineConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void LineConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void LineConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void LineConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const LineConstructionMethodType::Midline_optional& LineConstructionMethodType::
    Midline () const
    {
      return this->Midline_;
    }

    LineConstructionMethodType::Midline_optional& LineConstructionMethodType::
    Midline ()
    {
      return this->Midline_;
    }

    void LineConstructionMethodType::
    Midline (const Midline_type& x)
    {
      this->Midline_.set (x);
    }

    void LineConstructionMethodType::
    Midline (const Midline_optional& x)
    {
      this->Midline_ = x;
    }

    void LineConstructionMethodType::
    Midline (::std::auto_ptr< Midline_type > x)
    {
      this->Midline_.set (x);
    }

    const LineConstructionMethodType::Intersection_optional& LineConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    LineConstructionMethodType::Intersection_optional& LineConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void LineConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void LineConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void LineConstructionMethodType::
    Intersection (::std::auto_ptr< Intersection_type > x)
    {
      this->Intersection_.set (x);
    }

    const LineConstructionMethodType::Projection_optional& LineConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    LineConstructionMethodType::Projection_optional& LineConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void LineConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void LineConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void LineConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const LineConstructionMethodType::Perpendicular_optional& LineConstructionMethodType::
    Perpendicular () const
    {
      return this->Perpendicular_;
    }

    LineConstructionMethodType::Perpendicular_optional& LineConstructionMethodType::
    Perpendicular ()
    {
      return this->Perpendicular_;
    }

    void LineConstructionMethodType::
    Perpendicular (const Perpendicular_type& x)
    {
      this->Perpendicular_.set (x);
    }

    void LineConstructionMethodType::
    Perpendicular (const Perpendicular_optional& x)
    {
      this->Perpendicular_ = x;
    }

    void LineConstructionMethodType::
    Perpendicular (::std::auto_ptr< Perpendicular_type > x)
    {
      this->Perpendicular_.set (x);
    }

    const LineConstructionMethodType::Parallel_optional& LineConstructionMethodType::
    Parallel () const
    {
      return this->Parallel_;
    }

    LineConstructionMethodType::Parallel_optional& LineConstructionMethodType::
    Parallel ()
    {
      return this->Parallel_;
    }

    void LineConstructionMethodType::
    Parallel (const Parallel_type& x)
    {
      this->Parallel_.set (x);
    }

    void LineConstructionMethodType::
    Parallel (const Parallel_optional& x)
    {
      this->Parallel_ = x;
    }

    void LineConstructionMethodType::
    Parallel (::std::auto_ptr< Parallel_type > x)
    {
      this->Parallel_.set (x);
    }

    const LineConstructionMethodType::Copy_optional& LineConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    LineConstructionMethodType::Copy_optional& LineConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void LineConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void LineConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void LineConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const LineConstructionMethodType::Cast_optional& LineConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    LineConstructionMethodType::Cast_optional& LineConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void LineConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void LineConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void LineConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const LineConstructionMethodType::TangentThrough_optional& LineConstructionMethodType::
    TangentThrough () const
    {
      return this->TangentThrough_;
    }

    LineConstructionMethodType::TangentThrough_optional& LineConstructionMethodType::
    TangentThrough ()
    {
      return this->TangentThrough_;
    }

    void LineConstructionMethodType::
    TangentThrough (const TangentThrough_type& x)
    {
      this->TangentThrough_.set (x);
    }

    void LineConstructionMethodType::
    TangentThrough (const TangentThrough_optional& x)
    {
      this->TangentThrough_ = x;
    }

    void LineConstructionMethodType::
    TangentThrough (::std::auto_ptr< TangentThrough_type > x)
    {
      this->TangentThrough_.set (x);
    }

    const LineConstructionMethodType::Transform_optional& LineConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    LineConstructionMethodType::Transform_optional& LineConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void LineConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void LineConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void LineConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const LineConstructionMethodType::Extract_optional& LineConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    LineConstructionMethodType::Extract_optional& LineConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void LineConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void LineConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void LineConstructionMethodType::
    Extract (::std::auto_ptr< Extract_type > x)
    {
      this->Extract_.set (x);
    }

    const LineConstructionMethodType::FromScan_optional& LineConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    LineConstructionMethodType::FromScan_optional& LineConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void LineConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void LineConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void LineConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // LineBestFitType
    // 

    const LineBestFitType::BaseFeature_sequence& LineBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    LineBestFitType::BaseFeature_sequence& LineBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void LineBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // LineRecompType
    // 

    const LineRecompType::BaseFeaturePointList_type& LineRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    LineRecompType::BaseFeaturePointList_type& LineRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void LineRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void LineRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // LineMidlineType
    // 

    const LineMidlineType::BaseLine_sequence& LineMidlineType::
    BaseLine () const
    {
      return this->BaseLine_;
    }

    LineMidlineType::BaseLine_sequence& LineMidlineType::
    BaseLine ()
    {
      return this->BaseLine_;
    }

    void LineMidlineType::
    BaseLine (const BaseLine_sequence& s)
    {
      this->BaseLine_ = s;
    }


    // LineIntersectionType
    // 

    const LineIntersectionType::BasePlane_sequence& LineIntersectionType::
    BasePlane () const
    {
      return this->BasePlane_;
    }

    LineIntersectionType::BasePlane_sequence& LineIntersectionType::
    BasePlane ()
    {
      return this->BasePlane_;
    }

    void LineIntersectionType::
    BasePlane (const BasePlane_sequence& s)
    {
      this->BasePlane_ = s;
    }


    // LineProjectionType
    // 

    const LineProjectionType::ProjectionPlane_type& LineProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    LineProjectionType::ProjectionPlane_type& LineProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void LineProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void LineProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }

    const LineProjectionType::ProjectionLine_type& LineProjectionType::
    ProjectionLine () const
    {
      return this->ProjectionLine_.get ();
    }

    LineProjectionType::ProjectionLine_type& LineProjectionType::
    ProjectionLine ()
    {
      return this->ProjectionLine_.get ();
    }

    void LineProjectionType::
    ProjectionLine (const ProjectionLine_type& x)
    {
      this->ProjectionLine_.set (x);
    }

    void LineProjectionType::
    ProjectionLine (::std::auto_ptr< ProjectionLine_type > x)
    {
      this->ProjectionLine_.set (x);
    }


    // LinePerpendicularType
    // 

    const LinePerpendicularType::PerpendicularFeature_type& LinePerpendicularType::
    PerpendicularFeature () const
    {
      return this->PerpendicularFeature_.get ();
    }

    LinePerpendicularType::PerpendicularFeature_type& LinePerpendicularType::
    PerpendicularFeature ()
    {
      return this->PerpendicularFeature_.get ();
    }

    void LinePerpendicularType::
    PerpendicularFeature (const PerpendicularFeature_type& x)
    {
      this->PerpendicularFeature_.set (x);
    }

    void LinePerpendicularType::
    PerpendicularFeature (::std::auto_ptr< PerpendicularFeature_type > x)
    {
      this->PerpendicularFeature_.set (x);
    }

    const LinePerpendicularType::PointFeature_type& LinePerpendicularType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    LinePerpendicularType::PointFeature_type& LinePerpendicularType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void LinePerpendicularType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void LinePerpendicularType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // LineParallelType
    // 

    const LineParallelType::ParallelFeature_type& LineParallelType::
    ParallelFeature () const
    {
      return this->ParallelFeature_.get ();
    }

    LineParallelType::ParallelFeature_type& LineParallelType::
    ParallelFeature ()
    {
      return this->ParallelFeature_.get ();
    }

    void LineParallelType::
    ParallelFeature (const ParallelFeature_type& x)
    {
      this->ParallelFeature_.set (x);
    }

    void LineParallelType::
    ParallelFeature (::std::auto_ptr< ParallelFeature_type > x)
    {
      this->ParallelFeature_.set (x);
    }

    const LineParallelType::PointFeature_type& LineParallelType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    LineParallelType::PointFeature_type& LineParallelType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void LineParallelType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void LineParallelType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // LineCopyType
    // 

    const LineCopyType::BaseLine_type& LineCopyType::
    BaseLine () const
    {
      return this->BaseLine_.get ();
    }

    LineCopyType::BaseLine_type& LineCopyType::
    BaseLine ()
    {
      return this->BaseLine_.get ();
    }

    void LineCopyType::
    BaseLine (const BaseLine_type& x)
    {
      this->BaseLine_.set (x);
    }

    void LineCopyType::
    BaseLine (::std::auto_ptr< BaseLine_type > x)
    {
      this->BaseLine_.set (x);
    }


    // LineCastType
    // 

    const LineCastType::BaseFeature_type& LineCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    LineCastType::BaseFeature_type& LineCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void LineCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void LineCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // LineTangentThroughType
    // 

    const LineTangentThroughType::TangentFeature_type& LineTangentThroughType::
    TangentFeature () const
    {
      return this->TangentFeature_.get ();
    }

    LineTangentThroughType::TangentFeature_type& LineTangentThroughType::
    TangentFeature ()
    {
      return this->TangentFeature_.get ();
    }

    void LineTangentThroughType::
    TangentFeature (const TangentFeature_type& x)
    {
      this->TangentFeature_.set (x);
    }

    void LineTangentThroughType::
    TangentFeature (::std::auto_ptr< TangentFeature_type > x)
    {
      this->TangentFeature_.set (x);
    }

    const LineTangentThroughType::PointFeature_type& LineTangentThroughType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    LineTangentThroughType::PointFeature_type& LineTangentThroughType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void LineTangentThroughType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void LineTangentThroughType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // LineTransformType
    // 

    const LineTransformType::BaseLine_type& LineTransformType::
    BaseLine () const
    {
      return this->BaseLine_.get ();
    }

    LineTransformType::BaseLine_type& LineTransformType::
    BaseLine ()
    {
      return this->BaseLine_.get ();
    }

    void LineTransformType::
    BaseLine (const BaseLine_type& x)
    {
      this->BaseLine_.set (x);
    }

    void LineTransformType::
    BaseLine (::std::auto_ptr< BaseLine_type > x)
    {
      this->BaseLine_.set (x);
    }

    const LineTransformType::Transformation_type& LineTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    LineTransformType::Transformation_type& LineTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void LineTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void LineTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // LineFromScanType
    // 

    const LineFromScanType::SurfaceFeature_type& LineFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    LineFromScanType::SurfaceFeature_type& LineFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void LineFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void LineFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const LineFromScanType::SearchRadius_type& LineFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    LineFromScanType::SearchRadius_type& LineFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void LineFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void LineFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // LineExtractType
    // 

    const LineExtractType::CurveFeature_type& LineExtractType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    LineExtractType::CurveFeature_type& LineExtractType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void LineExtractType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void LineExtractType::
    CurveFeature (::std::auto_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (x);
    }


    // LineCheckedType
    // 

    const LineCheckedType::Measured_optional& LineCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    LineCheckedType::Measured_optional& LineCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void LineCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void LineCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void LineCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const LineCheckedType::Constructed_optional& LineCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    LineCheckedType::Constructed_optional& LineCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void LineCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void LineCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void LineCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // LineCheckedFeatureType
    // 

    const LineCheckedFeatureType::CheckDetails_optional& LineCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    LineCheckedFeatureType::CheckDetails_optional& LineCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void LineCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void LineCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void LineCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // LineActualDeterminationType
    // 

    const LineActualDeterminationType::Checked_optional& LineActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    LineActualDeterminationType::Checked_optional& LineActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void LineActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void LineActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void LineActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const LineActualDeterminationType::Set_optional& LineActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    LineActualDeterminationType::Set_optional& LineActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void LineActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void LineActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void LineActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // LineFeatureItemType
    // 

    const LineFeatureItemType::DeterminationMode_type& LineFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    LineFeatureItemType::DeterminationMode_type& LineFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void LineFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void LineFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const LineFeatureItemType::SubstituteFeatureAlgorithm_optional& LineFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    LineFeatureItemType::SubstituteFeatureAlgorithm_optional& LineFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void LineFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void LineFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void LineFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // LineFeatureDefinitionType
    // 


    // LineFeatureNominalType
    // 

    const LineFeatureNominalType::Location_type& LineFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    LineFeatureNominalType::Location_type& LineFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void LineFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void LineFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const LineFeatureNominalType::Direction_type& LineFeatureNominalType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    LineFeatureNominalType::Direction_type& LineFeatureNominalType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void LineFeatureNominalType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void LineFeatureNominalType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }

    const LineFeatureNominalType::Length_optional& LineFeatureNominalType::
    Length () const
    {
      return this->Length_;
    }

    LineFeatureNominalType::Length_optional& LineFeatureNominalType::
    Length ()
    {
      return this->Length_;
    }

    void LineFeatureNominalType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void LineFeatureNominalType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void LineFeatureNominalType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const LineFeatureNominalType::Normal_optional& LineFeatureNominalType::
    Normal () const
    {
      return this->Normal_;
    }

    LineFeatureNominalType::Normal_optional& LineFeatureNominalType::
    Normal ()
    {
      return this->Normal_;
    }

    void LineFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void LineFeatureNominalType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void LineFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // LineFeatureActualType
    // 

    const LineFeatureActualType::Location_optional& LineFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    LineFeatureActualType::Location_optional& LineFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void LineFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void LineFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void LineFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const LineFeatureActualType::Direction_optional& LineFeatureActualType::
    Direction () const
    {
      return this->Direction_;
    }

    LineFeatureActualType::Direction_optional& LineFeatureActualType::
    Direction ()
    {
      return this->Direction_;
    }

    void LineFeatureActualType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void LineFeatureActualType::
    Direction (const Direction_optional& x)
    {
      this->Direction_ = x;
    }

    void LineFeatureActualType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }

    const LineFeatureActualType::Length_optional& LineFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    LineFeatureActualType::Length_optional& LineFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void LineFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void LineFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void LineFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const LineFeatureActualType::Normal_optional& LineFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    LineFeatureActualType::Normal_optional& LineFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void LineFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void LineFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void LineFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const LineFeatureActualType::Form_optional& LineFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    LineFeatureActualType::Form_optional& LineFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void LineFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void LineFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void LineFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // OppositeLinesConstructionMethodType
    // 

    const OppositeLinesConstructionMethodType::BestFit_optional& OppositeLinesConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    OppositeLinesConstructionMethodType::BestFit_optional& OppositeLinesConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void OppositeLinesConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void OppositeLinesConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const OppositeLinesConstructionMethodType::Recompensated_optional& OppositeLinesConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    OppositeLinesConstructionMethodType::Recompensated_optional& OppositeLinesConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void OppositeLinesConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void OppositeLinesConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const OppositeLinesConstructionMethodType::Projection_optional& OppositeLinesConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    OppositeLinesConstructionMethodType::Projection_optional& OppositeLinesConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void OppositeLinesConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void OppositeLinesConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const OppositeLinesConstructionMethodType::Copy_optional& OppositeLinesConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    OppositeLinesConstructionMethodType::Copy_optional& OppositeLinesConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void OppositeLinesConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void OppositeLinesConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const OppositeLinesConstructionMethodType::Cast_optional& OppositeLinesConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    OppositeLinesConstructionMethodType::Cast_optional& OppositeLinesConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void OppositeLinesConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void OppositeLinesConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const OppositeLinesConstructionMethodType::Transform_optional& OppositeLinesConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    OppositeLinesConstructionMethodType::Transform_optional& OppositeLinesConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void OppositeLinesConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void OppositeLinesConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const OppositeLinesConstructionMethodType::FromScan_optional& OppositeLinesConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    OppositeLinesConstructionMethodType::FromScan_optional& OppositeLinesConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void OppositeLinesConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void OppositeLinesConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // OppositeLinesBestFitType
    // 

    const OppositeLinesBestFitType::BaseFeature_sequence& OppositeLinesBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    OppositeLinesBestFitType::BaseFeature_sequence& OppositeLinesBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void OppositeLinesBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // OppositeLinesRecompType
    // 

    const OppositeLinesRecompType::BaseFeaturePointList_type& OppositeLinesRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    OppositeLinesRecompType::BaseFeaturePointList_type& OppositeLinesRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void OppositeLinesRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void OppositeLinesRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // OppositeLinesProjectionType
    // 

    const OppositeLinesProjectionType::ProjectionPlane_type& OppositeLinesProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    OppositeLinesProjectionType::ProjectionPlane_type& OppositeLinesProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void OppositeLinesProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void OppositeLinesProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }

    const OppositeLinesProjectionType::ProjectionOppositeLines_type& OppositeLinesProjectionType::
    ProjectionOppositeLines () const
    {
      return this->ProjectionOppositeLines_.get ();
    }

    OppositeLinesProjectionType::ProjectionOppositeLines_type& OppositeLinesProjectionType::
    ProjectionOppositeLines ()
    {
      return this->ProjectionOppositeLines_.get ();
    }

    void OppositeLinesProjectionType::
    ProjectionOppositeLines (const ProjectionOppositeLines_type& x)
    {
      this->ProjectionOppositeLines_.set (x);
    }

    void OppositeLinesProjectionType::
    ProjectionOppositeLines (::std::auto_ptr< ProjectionOppositeLines_type > x)
    {
      this->ProjectionOppositeLines_.set (x);
    }


    // OppositeLinesCopyType
    // 

    const OppositeLinesCopyType::BaseOppositeLines_type& OppositeLinesCopyType::
    BaseOppositeLines () const
    {
      return this->BaseOppositeLines_.get ();
    }

    OppositeLinesCopyType::BaseOppositeLines_type& OppositeLinesCopyType::
    BaseOppositeLines ()
    {
      return this->BaseOppositeLines_.get ();
    }

    void OppositeLinesCopyType::
    BaseOppositeLines (const BaseOppositeLines_type& x)
    {
      this->BaseOppositeLines_.set (x);
    }

    void OppositeLinesCopyType::
    BaseOppositeLines (::std::auto_ptr< BaseOppositeLines_type > x)
    {
      this->BaseOppositeLines_.set (x);
    }


    // OppositeLinesCastType
    // 

    const OppositeLinesCastType::BaseFeature_type& OppositeLinesCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    OppositeLinesCastType::BaseFeature_type& OppositeLinesCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void OppositeLinesCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void OppositeLinesCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // OppositeLinesTransformType
    // 

    const OppositeLinesTransformType::BaseOppositeLines_type& OppositeLinesTransformType::
    BaseOppositeLines () const
    {
      return this->BaseOppositeLines_.get ();
    }

    OppositeLinesTransformType::BaseOppositeLines_type& OppositeLinesTransformType::
    BaseOppositeLines ()
    {
      return this->BaseOppositeLines_.get ();
    }

    void OppositeLinesTransformType::
    BaseOppositeLines (const BaseOppositeLines_type& x)
    {
      this->BaseOppositeLines_.set (x);
    }

    void OppositeLinesTransformType::
    BaseOppositeLines (::std::auto_ptr< BaseOppositeLines_type > x)
    {
      this->BaseOppositeLines_.set (x);
    }

    const OppositeLinesTransformType::Transformation_type& OppositeLinesTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    OppositeLinesTransformType::Transformation_type& OppositeLinesTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void OppositeLinesTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void OppositeLinesTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // OppositeLinesFromScanType
    // 

    const OppositeLinesFromScanType::SurfaceFeature_type& OppositeLinesFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    OppositeLinesFromScanType::SurfaceFeature_type& OppositeLinesFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void OppositeLinesFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void OppositeLinesFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const OppositeLinesFromScanType::SearchRadius_type& OppositeLinesFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    OppositeLinesFromScanType::SearchRadius_type& OppositeLinesFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void OppositeLinesFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void OppositeLinesFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const OppositeLinesFromScanType::Depth_type& OppositeLinesFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    OppositeLinesFromScanType::Depth_type& OppositeLinesFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void OppositeLinesFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositeLinesFromScanType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }


    // OppositeLinesCheckedType
    // 

    const OppositeLinesCheckedType::Measured_optional& OppositeLinesCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    OppositeLinesCheckedType::Measured_optional& OppositeLinesCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void OppositeLinesCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void OppositeLinesCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void OppositeLinesCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const OppositeLinesCheckedType::Constructed_optional& OppositeLinesCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositeLinesCheckedType::Constructed_optional& OppositeLinesCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositeLinesCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositeLinesCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositeLinesCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // OppositeLinesCheckedFeatureType
    // 

    const OppositeLinesCheckedFeatureType::CheckDetails_optional& OppositeLinesCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    OppositeLinesCheckedFeatureType::CheckDetails_optional& OppositeLinesCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void OppositeLinesCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void OppositeLinesCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void OppositeLinesCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // OppositeLinesActualDeterminationType
    // 

    const OppositeLinesActualDeterminationType::Checked_optional& OppositeLinesActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    OppositeLinesActualDeterminationType::Checked_optional& OppositeLinesActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void OppositeLinesActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void OppositeLinesActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void OppositeLinesActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const OppositeLinesActualDeterminationType::Set_optional& OppositeLinesActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    OppositeLinesActualDeterminationType::Set_optional& OppositeLinesActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void OppositeLinesActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void OppositeLinesActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void OppositeLinesActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // OppositeLinesFeatureItemType
    // 

    const OppositeLinesFeatureItemType::DeterminationMode_type& OppositeLinesFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    OppositeLinesFeatureItemType::DeterminationMode_type& OppositeLinesFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void OppositeLinesFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void OppositeLinesFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const OppositeLinesFeatureItemType::SubstituteFeatureAlgorithm_optional& OppositeLinesFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    OppositeLinesFeatureItemType::SubstituteFeatureAlgorithm_optional& OppositeLinesFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void OppositeLinesFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void OppositeLinesFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void OppositeLinesFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // OppositeLinesFeatureDefinitionType
    // 

    const OppositeLinesFeatureDefinitionType::InternalExternal_type& OppositeLinesFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    OppositeLinesFeatureDefinitionType::InternalExternal_type& OppositeLinesFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void OppositeLinesFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::Width_type& OppositeLinesFeatureDefinitionType::
    Width () const
    {
      return this->Width_.get ();
    }

    OppositeLinesFeatureDefinitionType::Width_type& OppositeLinesFeatureDefinitionType::
    Width ()
    {
      return this->Width_.get ();
    }

    void OppositeLinesFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::Length_optional& OppositeLinesFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    OppositeLinesFeatureDefinitionType::Length_optional& OppositeLinesFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeLinesFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeLinesFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::EndType_type& OppositeLinesFeatureDefinitionType::
    EndType () const
    {
      return this->EndType_.get ();
    }

    OppositeLinesFeatureDefinitionType::EndType_type& OppositeLinesFeatureDefinitionType::
    EndType ()
    {
      return this->EndType_.get ();
    }

    void OppositeLinesFeatureDefinitionType::
    EndType (const EndType_type& x)
    {
      this->EndType_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    EndType (::std::auto_ptr< EndType_type > x)
    {
      this->EndType_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::TaperAngle_optional& OppositeLinesFeatureDefinitionType::
    TaperAngle () const
    {
      return this->TaperAngle_;
    }

    OppositeLinesFeatureDefinitionType::TaperAngle_optional& OppositeLinesFeatureDefinitionType::
    TaperAngle ()
    {
      return this->TaperAngle_;
    }

    void OppositeLinesFeatureDefinitionType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    TaperAngle (const TaperAngle_optional& x)
    {
      this->TaperAngle_ = x;
    }

    void OppositeLinesFeatureDefinitionType::
    TaperAngle (::std::auto_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::SingleOpenEnd_optional& OppositeLinesFeatureDefinitionType::
    SingleOpenEnd () const
    {
      return this->SingleOpenEnd_;
    }

    OppositeLinesFeatureDefinitionType::SingleOpenEnd_optional& OppositeLinesFeatureDefinitionType::
    SingleOpenEnd ()
    {
      return this->SingleOpenEnd_;
    }

    void OppositeLinesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_type& x)
    {
      this->SingleOpenEnd_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_optional& x)
    {
      this->SingleOpenEnd_ = x;
    }

    const OppositeLinesFeatureDefinitionType::EndRadius1_optional& OppositeLinesFeatureDefinitionType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeLinesFeatureDefinitionType::EndRadius1_optional& OppositeLinesFeatureDefinitionType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius1 (::std::auto_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::EndRadius2_optional& OppositeLinesFeatureDefinitionType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeLinesFeatureDefinitionType::EndRadius2_optional& OppositeLinesFeatureDefinitionType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius2 (::std::auto_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (x);
    }


    // OppositeLinesFeatureNominalType
    // 

    const OppositeLinesFeatureNominalType::CenterLine_type& OppositeLinesFeatureNominalType::
    CenterLine () const
    {
      return this->CenterLine_.get ();
    }

    OppositeLinesFeatureNominalType::CenterLine_type& OppositeLinesFeatureNominalType::
    CenterLine ()
    {
      return this->CenterLine_.get ();
    }

    void OppositeLinesFeatureNominalType::
    CenterLine (const CenterLine_type& x)
    {
      this->CenterLine_.set (x);
    }

    void OppositeLinesFeatureNominalType::
    CenterLine (::std::auto_ptr< CenterLine_type > x)
    {
      this->CenterLine_.set (x);
    }

    const OppositeLinesFeatureNominalType::Normal_type& OppositeLinesFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    OppositeLinesFeatureNominalType::Normal_type& OppositeLinesFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void OppositeLinesFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void OppositeLinesFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // OppositeLinesFeatureActualType
    // 

    const OppositeLinesFeatureActualType::CenterLine_optional& OppositeLinesFeatureActualType::
    CenterLine () const
    {
      return this->CenterLine_;
    }

    OppositeLinesFeatureActualType::CenterLine_optional& OppositeLinesFeatureActualType::
    CenterLine ()
    {
      return this->CenterLine_;
    }

    void OppositeLinesFeatureActualType::
    CenterLine (const CenterLine_type& x)
    {
      this->CenterLine_.set (x);
    }

    void OppositeLinesFeatureActualType::
    CenterLine (const CenterLine_optional& x)
    {
      this->CenterLine_ = x;
    }

    void OppositeLinesFeatureActualType::
    CenterLine (::std::auto_ptr< CenterLine_type > x)
    {
      this->CenterLine_.set (x);
    }

    const OppositeLinesFeatureActualType::Normal_optional& OppositeLinesFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    OppositeLinesFeatureActualType::Normal_optional& OppositeLinesFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void OppositeLinesFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void OppositeLinesFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void OppositeLinesFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const OppositeLinesFeatureActualType::Width_optional& OppositeLinesFeatureActualType::
    Width () const
    {
      return this->Width_;
    }

    OppositeLinesFeatureActualType::Width_optional& OppositeLinesFeatureActualType::
    Width ()
    {
      return this->Width_;
    }

    void OppositeLinesFeatureActualType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeLinesFeatureActualType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void OppositeLinesFeatureActualType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const OppositeLinesFeatureActualType::WidthMin_optional& OppositeLinesFeatureActualType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    OppositeLinesFeatureActualType::WidthMin_optional& OppositeLinesFeatureActualType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void OppositeLinesFeatureActualType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void OppositeLinesFeatureActualType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void OppositeLinesFeatureActualType::
    WidthMin (::std::auto_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (x);
    }

    const OppositeLinesFeatureActualType::WidthMax_optional& OppositeLinesFeatureActualType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    OppositeLinesFeatureActualType::WidthMax_optional& OppositeLinesFeatureActualType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void OppositeLinesFeatureActualType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void OppositeLinesFeatureActualType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void OppositeLinesFeatureActualType::
    WidthMax (::std::auto_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (x);
    }

    const OppositeLinesFeatureActualType::Length_optional& OppositeLinesFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    OppositeLinesFeatureActualType::Length_optional& OppositeLinesFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeLinesFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeLinesFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeLinesFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const OppositeLinesFeatureActualType::LengthMin_optional& OppositeLinesFeatureActualType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    OppositeLinesFeatureActualType::LengthMin_optional& OppositeLinesFeatureActualType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void OppositeLinesFeatureActualType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void OppositeLinesFeatureActualType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void OppositeLinesFeatureActualType::
    LengthMin (::std::auto_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (x);
    }

    const OppositeLinesFeatureActualType::LengthMax_optional& OppositeLinesFeatureActualType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    OppositeLinesFeatureActualType::LengthMax_optional& OppositeLinesFeatureActualType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void OppositeLinesFeatureActualType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void OppositeLinesFeatureActualType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void OppositeLinesFeatureActualType::
    LengthMax (::std::auto_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (x);
    }

    const OppositeLinesFeatureActualType::TaperAngle_optional& OppositeLinesFeatureActualType::
    TaperAngle () const
    {
      return this->TaperAngle_;
    }

    OppositeLinesFeatureActualType::TaperAngle_optional& OppositeLinesFeatureActualType::
    TaperAngle ()
    {
      return this->TaperAngle_;
    }

    void OppositeLinesFeatureActualType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositeLinesFeatureActualType::
    TaperAngle (const TaperAngle_optional& x)
    {
      this->TaperAngle_ = x;
    }

    void OppositeLinesFeatureActualType::
    TaperAngle (::std::auto_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (x);
    }

    const OppositeLinesFeatureActualType::EndRadius1_optional& OppositeLinesFeatureActualType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeLinesFeatureActualType::EndRadius1_optional& OppositeLinesFeatureActualType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeLinesFeatureActualType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeLinesFeatureActualType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeLinesFeatureActualType::
    EndRadius1 (::std::auto_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (x);
    }

    const OppositeLinesFeatureActualType::EndRadius2_optional& OppositeLinesFeatureActualType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeLinesFeatureActualType::EndRadius2_optional& OppositeLinesFeatureActualType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeLinesFeatureActualType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeLinesFeatureActualType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeLinesFeatureActualType::
    EndRadius2 (::std::auto_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (x);
    }

    const OppositeLinesFeatureActualType::Form_optional& OppositeLinesFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    OppositeLinesFeatureActualType::Form_optional& OppositeLinesFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void OppositeLinesFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void OppositeLinesFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void OppositeLinesFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // OppositePlanesConstructionMethodType
    // 

    const OppositePlanesConstructionMethodType::BestFit_optional& OppositePlanesConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    OppositePlanesConstructionMethodType::BestFit_optional& OppositePlanesConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void OppositePlanesConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void OppositePlanesConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const OppositePlanesConstructionMethodType::Recompensated_optional& OppositePlanesConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    OppositePlanesConstructionMethodType::Recompensated_optional& OppositePlanesConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void OppositePlanesConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void OppositePlanesConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const OppositePlanesConstructionMethodType::Copy_optional& OppositePlanesConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    OppositePlanesConstructionMethodType::Copy_optional& OppositePlanesConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void OppositePlanesConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void OppositePlanesConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const OppositePlanesConstructionMethodType::Cast_optional& OppositePlanesConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    OppositePlanesConstructionMethodType::Cast_optional& OppositePlanesConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void OppositePlanesConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void OppositePlanesConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const OppositePlanesConstructionMethodType::Transform_optional& OppositePlanesConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    OppositePlanesConstructionMethodType::Transform_optional& OppositePlanesConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void OppositePlanesConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void OppositePlanesConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const OppositePlanesConstructionMethodType::FromScan_optional& OppositePlanesConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    OppositePlanesConstructionMethodType::FromScan_optional& OppositePlanesConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void OppositePlanesConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void OppositePlanesConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // OppositePlanesBestFitType
    // 

    const OppositePlanesBestFitType::BaseFeature_sequence& OppositePlanesBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    OppositePlanesBestFitType::BaseFeature_sequence& OppositePlanesBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void OppositePlanesBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // OppositePlanesRecompType
    // 

    const OppositePlanesRecompType::BaseFeaturePointList_type& OppositePlanesRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    OppositePlanesRecompType::BaseFeaturePointList_type& OppositePlanesRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void OppositePlanesRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void OppositePlanesRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // OppositePlanesCopyType
    // 

    const OppositePlanesCopyType::BaseOppositePlanes_type& OppositePlanesCopyType::
    BaseOppositePlanes () const
    {
      return this->BaseOppositePlanes_.get ();
    }

    OppositePlanesCopyType::BaseOppositePlanes_type& OppositePlanesCopyType::
    BaseOppositePlanes ()
    {
      return this->BaseOppositePlanes_.get ();
    }

    void OppositePlanesCopyType::
    BaseOppositePlanes (const BaseOppositePlanes_type& x)
    {
      this->BaseOppositePlanes_.set (x);
    }

    void OppositePlanesCopyType::
    BaseOppositePlanes (::std::auto_ptr< BaseOppositePlanes_type > x)
    {
      this->BaseOppositePlanes_.set (x);
    }


    // OppositePlanesCastType
    // 

    const OppositePlanesCastType::BaseFeature_type& OppositePlanesCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    OppositePlanesCastType::BaseFeature_type& OppositePlanesCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void OppositePlanesCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void OppositePlanesCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // OppositePlanesTransformType
    // 

    const OppositePlanesTransformType::BaseOppositePlanes_type& OppositePlanesTransformType::
    BaseOppositePlanes () const
    {
      return this->BaseOppositePlanes_.get ();
    }

    OppositePlanesTransformType::BaseOppositePlanes_type& OppositePlanesTransformType::
    BaseOppositePlanes ()
    {
      return this->BaseOppositePlanes_.get ();
    }

    void OppositePlanesTransformType::
    BaseOppositePlanes (const BaseOppositePlanes_type& x)
    {
      this->BaseOppositePlanes_.set (x);
    }

    void OppositePlanesTransformType::
    BaseOppositePlanes (::std::auto_ptr< BaseOppositePlanes_type > x)
    {
      this->BaseOppositePlanes_.set (x);
    }

    const OppositePlanesTransformType::Transformation_type& OppositePlanesTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    OppositePlanesTransformType::Transformation_type& OppositePlanesTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void OppositePlanesTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void OppositePlanesTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // OppositePlanesFromScanType
    // 

    const OppositePlanesFromScanType::SurfaceFeature_type& OppositePlanesFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    OppositePlanesFromScanType::SurfaceFeature_type& OppositePlanesFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void OppositePlanesFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void OppositePlanesFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const OppositePlanesFromScanType::SearchRadius_type& OppositePlanesFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    OppositePlanesFromScanType::SearchRadius_type& OppositePlanesFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void OppositePlanesFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void OppositePlanesFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // OppositePlanesCheckedType
    // 

    const OppositePlanesCheckedType::Measured_optional& OppositePlanesCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    OppositePlanesCheckedType::Measured_optional& OppositePlanesCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void OppositePlanesCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void OppositePlanesCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void OppositePlanesCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const OppositePlanesCheckedType::Constructed_optional& OppositePlanesCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositePlanesCheckedType::Constructed_optional& OppositePlanesCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositePlanesCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositePlanesCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositePlanesCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // OppositePlanesCheckedFeatureType
    // 

    const OppositePlanesCheckedFeatureType::CheckDetails_optional& OppositePlanesCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    OppositePlanesCheckedFeatureType::CheckDetails_optional& OppositePlanesCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void OppositePlanesCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void OppositePlanesCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void OppositePlanesCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // OppositePlanesActualDeterminationType
    // 

    const OppositePlanesActualDeterminationType::Checked_optional& OppositePlanesActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    OppositePlanesActualDeterminationType::Checked_optional& OppositePlanesActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void OppositePlanesActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void OppositePlanesActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void OppositePlanesActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const OppositePlanesActualDeterminationType::Set_optional& OppositePlanesActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    OppositePlanesActualDeterminationType::Set_optional& OppositePlanesActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void OppositePlanesActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void OppositePlanesActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void OppositePlanesActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // OppositePlanesFeatureItemType
    // 

    const OppositePlanesFeatureItemType::DeterminationMode_type& OppositePlanesFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    OppositePlanesFeatureItemType::DeterminationMode_type& OppositePlanesFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void OppositePlanesFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void OppositePlanesFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const OppositePlanesFeatureItemType::SubstituteFeatureAlgorithm_optional& OppositePlanesFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    OppositePlanesFeatureItemType::SubstituteFeatureAlgorithm_optional& OppositePlanesFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void OppositePlanesFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void OppositePlanesFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void OppositePlanesFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // OppositePlanesFeatureDefinitionType
    // 

    const OppositePlanesFeatureDefinitionType::InternalExternal_type& OppositePlanesFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    OppositePlanesFeatureDefinitionType::InternalExternal_type& OppositePlanesFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void OppositePlanesFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::Width_type& OppositePlanesFeatureDefinitionType::
    Width () const
    {
      return this->Width_.get ();
    }

    OppositePlanesFeatureDefinitionType::Width_type& OppositePlanesFeatureDefinitionType::
    Width ()
    {
      return this->Width_.get ();
    }

    void OppositePlanesFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::Length_optional& OppositePlanesFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    OppositePlanesFeatureDefinitionType::Length_optional& OppositePlanesFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void OppositePlanesFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::EndType_type& OppositePlanesFeatureDefinitionType::
    EndType () const
    {
      return this->EndType_.get ();
    }

    OppositePlanesFeatureDefinitionType::EndType_type& OppositePlanesFeatureDefinitionType::
    EndType ()
    {
      return this->EndType_.get ();
    }

    void OppositePlanesFeatureDefinitionType::
    EndType (const EndType_type& x)
    {
      this->EndType_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    EndType (::std::auto_ptr< EndType_type > x)
    {
      this->EndType_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::Depth_optional& OppositePlanesFeatureDefinitionType::
    Depth () const
    {
      return this->Depth_;
    }

    OppositePlanesFeatureDefinitionType::Depth_optional& OppositePlanesFeatureDefinitionType::
    Depth ()
    {
      return this->Depth_;
    }

    void OppositePlanesFeatureDefinitionType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::Bottom_optional& OppositePlanesFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    OppositePlanesFeatureDefinitionType::Bottom_optional& OppositePlanesFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void OppositePlanesFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    Bottom (::std::auto_ptr< Bottom_type > x)
    {
      this->Bottom_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::SingleOpenEnd_optional& OppositePlanesFeatureDefinitionType::
    SingleOpenEnd () const
    {
      return this->SingleOpenEnd_;
    }

    OppositePlanesFeatureDefinitionType::SingleOpenEnd_optional& OppositePlanesFeatureDefinitionType::
    SingleOpenEnd ()
    {
      return this->SingleOpenEnd_;
    }

    void OppositePlanesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_type& x)
    {
      this->SingleOpenEnd_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_optional& x)
    {
      this->SingleOpenEnd_ = x;
    }

    const OppositePlanesFeatureDefinitionType::EndRadius1_optional& OppositePlanesFeatureDefinitionType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositePlanesFeatureDefinitionType::EndRadius1_optional& OppositePlanesFeatureDefinitionType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius1 (::std::auto_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::EndRadius2_optional& OppositePlanesFeatureDefinitionType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositePlanesFeatureDefinitionType::EndRadius2_optional& OppositePlanesFeatureDefinitionType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius2 (::std::auto_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::TaperAngle_optional& OppositePlanesFeatureDefinitionType::
    TaperAngle () const
    {
      return this->TaperAngle_;
    }

    OppositePlanesFeatureDefinitionType::TaperAngle_optional& OppositePlanesFeatureDefinitionType::
    TaperAngle ()
    {
      return this->TaperAngle_;
    }

    void OppositePlanesFeatureDefinitionType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    TaperAngle (const TaperAngle_optional& x)
    {
      this->TaperAngle_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    TaperAngle (::std::auto_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::DraftAngle_optional& OppositePlanesFeatureDefinitionType::
    DraftAngle () const
    {
      return this->DraftAngle_;
    }

    OppositePlanesFeatureDefinitionType::DraftAngle_optional& OppositePlanesFeatureDefinitionType::
    DraftAngle ()
    {
      return this->DraftAngle_;
    }

    void OppositePlanesFeatureDefinitionType::
    DraftAngle (const DraftAngle_type& x)
    {
      this->DraftAngle_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    DraftAngle (const DraftAngle_optional& x)
    {
      this->DraftAngle_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    DraftAngle (::std::auto_ptr< DraftAngle_type > x)
    {
      this->DraftAngle_.set (x);
    }


    // OppositePlanesFeatureNominalType
    // 

    const OppositePlanesFeatureNominalType::CenterPlane_type& OppositePlanesFeatureNominalType::
    CenterPlane () const
    {
      return this->CenterPlane_.get ();
    }

    OppositePlanesFeatureNominalType::CenterPlane_type& OppositePlanesFeatureNominalType::
    CenterPlane ()
    {
      return this->CenterPlane_.get ();
    }

    void OppositePlanesFeatureNominalType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void OppositePlanesFeatureNominalType::
    CenterPlane (::std::auto_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (x);
    }

    const OppositePlanesFeatureNominalType::LengthVector_optional& OppositePlanesFeatureNominalType::
    LengthVector () const
    {
      return this->LengthVector_;
    }

    OppositePlanesFeatureNominalType::LengthVector_optional& OppositePlanesFeatureNominalType::
    LengthVector ()
    {
      return this->LengthVector_;
    }

    void OppositePlanesFeatureNominalType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void OppositePlanesFeatureNominalType::
    LengthVector (const LengthVector_optional& x)
    {
      this->LengthVector_ = x;
    }

    void OppositePlanesFeatureNominalType::
    LengthVector (::std::auto_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (x);
    }

    const OppositePlanesFeatureNominalType::DepthVector_optional& OppositePlanesFeatureNominalType::
    DepthVector () const
    {
      return this->DepthVector_;
    }

    OppositePlanesFeatureNominalType::DepthVector_optional& OppositePlanesFeatureNominalType::
    DepthVector ()
    {
      return this->DepthVector_;
    }

    void OppositePlanesFeatureNominalType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void OppositePlanesFeatureNominalType::
    DepthVector (const DepthVector_optional& x)
    {
      this->DepthVector_ = x;
    }

    void OppositePlanesFeatureNominalType::
    DepthVector (::std::auto_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (x);
    }

    const OppositePlanesFeatureNominalType::DraftVector_optional& OppositePlanesFeatureNominalType::
    DraftVector () const
    {
      return this->DraftVector_;
    }

    OppositePlanesFeatureNominalType::DraftVector_optional& OppositePlanesFeatureNominalType::
    DraftVector ()
    {
      return this->DraftVector_;
    }

    void OppositePlanesFeatureNominalType::
    DraftVector (const DraftVector_type& x)
    {
      this->DraftVector_.set (x);
    }

    void OppositePlanesFeatureNominalType::
    DraftVector (const DraftVector_optional& x)
    {
      this->DraftVector_ = x;
    }

    void OppositePlanesFeatureNominalType::
    DraftVector (::std::auto_ptr< DraftVector_type > x)
    {
      this->DraftVector_.set (x);
    }


    // OppositePlanesFeatureActualType
    // 

    const OppositePlanesFeatureActualType::CenterPlane_optional& OppositePlanesFeatureActualType::
    CenterPlane () const
    {
      return this->CenterPlane_;
    }

    OppositePlanesFeatureActualType::CenterPlane_optional& OppositePlanesFeatureActualType::
    CenterPlane ()
    {
      return this->CenterPlane_;
    }

    void OppositePlanesFeatureActualType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void OppositePlanesFeatureActualType::
    CenterPlane (const CenterPlane_optional& x)
    {
      this->CenterPlane_ = x;
    }

    void OppositePlanesFeatureActualType::
    CenterPlane (::std::auto_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (x);
    }

    const OppositePlanesFeatureActualType::LengthVector_optional& OppositePlanesFeatureActualType::
    LengthVector () const
    {
      return this->LengthVector_;
    }

    OppositePlanesFeatureActualType::LengthVector_optional& OppositePlanesFeatureActualType::
    LengthVector ()
    {
      return this->LengthVector_;
    }

    void OppositePlanesFeatureActualType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void OppositePlanesFeatureActualType::
    LengthVector (const LengthVector_optional& x)
    {
      this->LengthVector_ = x;
    }

    void OppositePlanesFeatureActualType::
    LengthVector (::std::auto_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (x);
    }

    const OppositePlanesFeatureActualType::DepthVector_optional& OppositePlanesFeatureActualType::
    DepthVector () const
    {
      return this->DepthVector_;
    }

    OppositePlanesFeatureActualType::DepthVector_optional& OppositePlanesFeatureActualType::
    DepthVector ()
    {
      return this->DepthVector_;
    }

    void OppositePlanesFeatureActualType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void OppositePlanesFeatureActualType::
    DepthVector (const DepthVector_optional& x)
    {
      this->DepthVector_ = x;
    }

    void OppositePlanesFeatureActualType::
    DepthVector (::std::auto_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (x);
    }

    const OppositePlanesFeatureActualType::Width_optional& OppositePlanesFeatureActualType::
    Width () const
    {
      return this->Width_;
    }

    OppositePlanesFeatureActualType::Width_optional& OppositePlanesFeatureActualType::
    Width ()
    {
      return this->Width_;
    }

    void OppositePlanesFeatureActualType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositePlanesFeatureActualType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void OppositePlanesFeatureActualType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const OppositePlanesFeatureActualType::WidthMin_optional& OppositePlanesFeatureActualType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    OppositePlanesFeatureActualType::WidthMin_optional& OppositePlanesFeatureActualType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void OppositePlanesFeatureActualType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void OppositePlanesFeatureActualType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void OppositePlanesFeatureActualType::
    WidthMin (::std::auto_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (x);
    }

    const OppositePlanesFeatureActualType::WidthMax_optional& OppositePlanesFeatureActualType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    OppositePlanesFeatureActualType::WidthMax_optional& OppositePlanesFeatureActualType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void OppositePlanesFeatureActualType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void OppositePlanesFeatureActualType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void OppositePlanesFeatureActualType::
    WidthMax (::std::auto_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (x);
    }

    const OppositePlanesFeatureActualType::Length_optional& OppositePlanesFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    OppositePlanesFeatureActualType::Length_optional& OppositePlanesFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void OppositePlanesFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositePlanesFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositePlanesFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const OppositePlanesFeatureActualType::LengthMin_optional& OppositePlanesFeatureActualType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    OppositePlanesFeatureActualType::LengthMin_optional& OppositePlanesFeatureActualType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void OppositePlanesFeatureActualType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void OppositePlanesFeatureActualType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void OppositePlanesFeatureActualType::
    LengthMin (::std::auto_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (x);
    }

    const OppositePlanesFeatureActualType::LengthMax_optional& OppositePlanesFeatureActualType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    OppositePlanesFeatureActualType::LengthMax_optional& OppositePlanesFeatureActualType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void OppositePlanesFeatureActualType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void OppositePlanesFeatureActualType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void OppositePlanesFeatureActualType::
    LengthMax (::std::auto_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (x);
    }

    const OppositePlanesFeatureActualType::Depth_optional& OppositePlanesFeatureActualType::
    Depth () const
    {
      return this->Depth_;
    }

    OppositePlanesFeatureActualType::Depth_optional& OppositePlanesFeatureActualType::
    Depth ()
    {
      return this->Depth_;
    }

    void OppositePlanesFeatureActualType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositePlanesFeatureActualType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void OppositePlanesFeatureActualType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }

    const OppositePlanesFeatureActualType::TaperAngle_optional& OppositePlanesFeatureActualType::
    TaperAngle () const
    {
      return this->TaperAngle_;
    }

    OppositePlanesFeatureActualType::TaperAngle_optional& OppositePlanesFeatureActualType::
    TaperAngle ()
    {
      return this->TaperAngle_;
    }

    void OppositePlanesFeatureActualType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositePlanesFeatureActualType::
    TaperAngle (const TaperAngle_optional& x)
    {
      this->TaperAngle_ = x;
    }

    void OppositePlanesFeatureActualType::
    TaperAngle (::std::auto_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (x);
    }

    const OppositePlanesFeatureActualType::DraftAngle_optional& OppositePlanesFeatureActualType::
    DraftAngle () const
    {
      return this->DraftAngle_;
    }

    OppositePlanesFeatureActualType::DraftAngle_optional& OppositePlanesFeatureActualType::
    DraftAngle ()
    {
      return this->DraftAngle_;
    }

    void OppositePlanesFeatureActualType::
    DraftAngle (const DraftAngle_type& x)
    {
      this->DraftAngle_.set (x);
    }

    void OppositePlanesFeatureActualType::
    DraftAngle (const DraftAngle_optional& x)
    {
      this->DraftAngle_ = x;
    }

    void OppositePlanesFeatureActualType::
    DraftAngle (::std::auto_ptr< DraftAngle_type > x)
    {
      this->DraftAngle_.set (x);
    }

    const OppositePlanesFeatureActualType::EndRadius1_optional& OppositePlanesFeatureActualType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositePlanesFeatureActualType::EndRadius1_optional& OppositePlanesFeatureActualType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositePlanesFeatureActualType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositePlanesFeatureActualType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositePlanesFeatureActualType::
    EndRadius1 (::std::auto_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (x);
    }

    const OppositePlanesFeatureActualType::EndRadius2_optional& OppositePlanesFeatureActualType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositePlanesFeatureActualType::EndRadius2_optional& OppositePlanesFeatureActualType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositePlanesFeatureActualType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositePlanesFeatureActualType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositePlanesFeatureActualType::
    EndRadius2 (::std::auto_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (x);
    }

    const OppositePlanesFeatureActualType::Form_optional& OppositePlanesFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    OppositePlanesFeatureActualType::Form_optional& OppositePlanesFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void OppositePlanesFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void OppositePlanesFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void OppositePlanesFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // PlaneConstructionMethodType
    // 

    const PlaneConstructionMethodType::BestFit_optional& PlaneConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    PlaneConstructionMethodType::BestFit_optional& PlaneConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void PlaneConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void PlaneConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void PlaneConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const PlaneConstructionMethodType::Recompensated_optional& PlaneConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    PlaneConstructionMethodType::Recompensated_optional& PlaneConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void PlaneConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void PlaneConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void PlaneConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const PlaneConstructionMethodType::Midplane_optional& PlaneConstructionMethodType::
    Midplane () const
    {
      return this->Midplane_;
    }

    PlaneConstructionMethodType::Midplane_optional& PlaneConstructionMethodType::
    Midplane ()
    {
      return this->Midplane_;
    }

    void PlaneConstructionMethodType::
    Midplane (const Midplane_type& x)
    {
      this->Midplane_.set (x);
    }

    void PlaneConstructionMethodType::
    Midplane (const Midplane_optional& x)
    {
      this->Midplane_ = x;
    }

    void PlaneConstructionMethodType::
    Midplane (::std::auto_ptr< Midplane_type > x)
    {
      this->Midplane_.set (x);
    }

    const PlaneConstructionMethodType::Offset_optional& PlaneConstructionMethodType::
    Offset () const
    {
      return this->Offset_;
    }

    PlaneConstructionMethodType::Offset_optional& PlaneConstructionMethodType::
    Offset ()
    {
      return this->Offset_;
    }

    void PlaneConstructionMethodType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void PlaneConstructionMethodType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    void PlaneConstructionMethodType::
    Offset (::std::auto_ptr< Offset_type > x)
    {
      this->Offset_.set (x);
    }

    const PlaneConstructionMethodType::Perpendicular_optional& PlaneConstructionMethodType::
    Perpendicular () const
    {
      return this->Perpendicular_;
    }

    PlaneConstructionMethodType::Perpendicular_optional& PlaneConstructionMethodType::
    Perpendicular ()
    {
      return this->Perpendicular_;
    }

    void PlaneConstructionMethodType::
    Perpendicular (const Perpendicular_type& x)
    {
      this->Perpendicular_.set (x);
    }

    void PlaneConstructionMethodType::
    Perpendicular (const Perpendicular_optional& x)
    {
      this->Perpendicular_ = x;
    }

    void PlaneConstructionMethodType::
    Perpendicular (::std::auto_ptr< Perpendicular_type > x)
    {
      this->Perpendicular_.set (x);
    }

    const PlaneConstructionMethodType::Parallel_optional& PlaneConstructionMethodType::
    Parallel () const
    {
      return this->Parallel_;
    }

    PlaneConstructionMethodType::Parallel_optional& PlaneConstructionMethodType::
    Parallel ()
    {
      return this->Parallel_;
    }

    void PlaneConstructionMethodType::
    Parallel (const Parallel_type& x)
    {
      this->Parallel_.set (x);
    }

    void PlaneConstructionMethodType::
    Parallel (const Parallel_optional& x)
    {
      this->Parallel_ = x;
    }

    void PlaneConstructionMethodType::
    Parallel (::std::auto_ptr< Parallel_type > x)
    {
      this->Parallel_.set (x);
    }

    const PlaneConstructionMethodType::Copy_optional& PlaneConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PlaneConstructionMethodType::Copy_optional& PlaneConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PlaneConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PlaneConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PlaneConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const PlaneConstructionMethodType::Cast_optional& PlaneConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    PlaneConstructionMethodType::Cast_optional& PlaneConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void PlaneConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void PlaneConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void PlaneConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const PlaneConstructionMethodType::TangentThrough_optional& PlaneConstructionMethodType::
    TangentThrough () const
    {
      return this->TangentThrough_;
    }

    PlaneConstructionMethodType::TangentThrough_optional& PlaneConstructionMethodType::
    TangentThrough ()
    {
      return this->TangentThrough_;
    }

    void PlaneConstructionMethodType::
    TangentThrough (const TangentThrough_type& x)
    {
      this->TangentThrough_.set (x);
    }

    void PlaneConstructionMethodType::
    TangentThrough (const TangentThrough_optional& x)
    {
      this->TangentThrough_ = x;
    }

    void PlaneConstructionMethodType::
    TangentThrough (::std::auto_ptr< TangentThrough_type > x)
    {
      this->TangentThrough_.set (x);
    }

    const PlaneConstructionMethodType::Transform_optional& PlaneConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PlaneConstructionMethodType::Transform_optional& PlaneConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PlaneConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PlaneConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PlaneConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const PlaneConstructionMethodType::Extract_optional& PlaneConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    PlaneConstructionMethodType::Extract_optional& PlaneConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void PlaneConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void PlaneConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void PlaneConstructionMethodType::
    Extract (::std::auto_ptr< Extract_type > x)
    {
      this->Extract_.set (x);
    }


    // PlaneBestFitType
    // 

    const PlaneBestFitType::BaseFeature_sequence& PlaneBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PlaneBestFitType::BaseFeature_sequence& PlaneBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PlaneBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PlaneRecompType
    // 

    const PlaneRecompType::BaseFeaturePointList_type& PlaneRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    PlaneRecompType::BaseFeaturePointList_type& PlaneRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void PlaneRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void PlaneRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // PlaneMidplaneType
    // 

    const PlaneMidplaneType::BasePlane_sequence& PlaneMidplaneType::
    BasePlane () const
    {
      return this->BasePlane_;
    }

    PlaneMidplaneType::BasePlane_sequence& PlaneMidplaneType::
    BasePlane ()
    {
      return this->BasePlane_;
    }

    void PlaneMidplaneType::
    BasePlane (const BasePlane_sequence& s)
    {
      this->BasePlane_ = s;
    }


    // PlaneOffsetType
    // 

    const PlaneOffsetType::BasePlane_type& PlaneOffsetType::
    BasePlane () const
    {
      return this->BasePlane_.get ();
    }

    PlaneOffsetType::BasePlane_type& PlaneOffsetType::
    BasePlane ()
    {
      return this->BasePlane_.get ();
    }

    void PlaneOffsetType::
    BasePlane (const BasePlane_type& x)
    {
      this->BasePlane_.set (x);
    }

    void PlaneOffsetType::
    BasePlane (::std::auto_ptr< BasePlane_type > x)
    {
      this->BasePlane_.set (x);
    }

    const PlaneOffsetType::Offset_type& PlaneOffsetType::
    Offset () const
    {
      return this->Offset_.get ();
    }

    PlaneOffsetType::Offset_type& PlaneOffsetType::
    Offset ()
    {
      return this->Offset_.get ();
    }

    void PlaneOffsetType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void PlaneOffsetType::
    Offset (::std::auto_ptr< Offset_type > x)
    {
      this->Offset_.set (x);
    }


    // PlanePerpendicularType
    // 

    const PlanePerpendicularType::PerpendicularFeature_type& PlanePerpendicularType::
    PerpendicularFeature () const
    {
      return this->PerpendicularFeature_.get ();
    }

    PlanePerpendicularType::PerpendicularFeature_type& PlanePerpendicularType::
    PerpendicularFeature ()
    {
      return this->PerpendicularFeature_.get ();
    }

    void PlanePerpendicularType::
    PerpendicularFeature (const PerpendicularFeature_type& x)
    {
      this->PerpendicularFeature_.set (x);
    }

    void PlanePerpendicularType::
    PerpendicularFeature (::std::auto_ptr< PerpendicularFeature_type > x)
    {
      this->PerpendicularFeature_.set (x);
    }

    const PlanePerpendicularType::PointFeature_type& PlanePerpendicularType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    PlanePerpendicularType::PointFeature_type& PlanePerpendicularType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void PlanePerpendicularType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void PlanePerpendicularType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // PlaneParallelType
    // 

    const PlaneParallelType::ParallelFeature_type& PlaneParallelType::
    ParallelFeature () const
    {
      return this->ParallelFeature_.get ();
    }

    PlaneParallelType::ParallelFeature_type& PlaneParallelType::
    ParallelFeature ()
    {
      return this->ParallelFeature_.get ();
    }

    void PlaneParallelType::
    ParallelFeature (const ParallelFeature_type& x)
    {
      this->ParallelFeature_.set (x);
    }

    void PlaneParallelType::
    ParallelFeature (::std::auto_ptr< ParallelFeature_type > x)
    {
      this->ParallelFeature_.set (x);
    }

    const PlaneParallelType::PointFeature_type& PlaneParallelType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    PlaneParallelType::PointFeature_type& PlaneParallelType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void PlaneParallelType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void PlaneParallelType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // PlaneCopyType
    // 

    const PlaneCopyType::BasePlane_type& PlaneCopyType::
    BasePlane () const
    {
      return this->BasePlane_.get ();
    }

    PlaneCopyType::BasePlane_type& PlaneCopyType::
    BasePlane ()
    {
      return this->BasePlane_.get ();
    }

    void PlaneCopyType::
    BasePlane (const BasePlane_type& x)
    {
      this->BasePlane_.set (x);
    }

    void PlaneCopyType::
    BasePlane (::std::auto_ptr< BasePlane_type > x)
    {
      this->BasePlane_.set (x);
    }


    // PlaneCastType
    // 

    const PlaneCastType::BaseFeature_type& PlaneCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PlaneCastType::BaseFeature_type& PlaneCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PlaneCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PlaneCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // PlaneTangentThroughType
    // 

    const PlaneTangentThroughType::TangentFeature_type& PlaneTangentThroughType::
    TangentFeature () const
    {
      return this->TangentFeature_.get ();
    }

    PlaneTangentThroughType::TangentFeature_type& PlaneTangentThroughType::
    TangentFeature ()
    {
      return this->TangentFeature_.get ();
    }

    void PlaneTangentThroughType::
    TangentFeature (const TangentFeature_type& x)
    {
      this->TangentFeature_.set (x);
    }

    void PlaneTangentThroughType::
    TangentFeature (::std::auto_ptr< TangentFeature_type > x)
    {
      this->TangentFeature_.set (x);
    }

    const PlaneTangentThroughType::PointFeature_type& PlaneTangentThroughType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    PlaneTangentThroughType::PointFeature_type& PlaneTangentThroughType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void PlaneTangentThroughType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void PlaneTangentThroughType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // PlaneTransformType
    // 

    const PlaneTransformType::BasePlane_type& PlaneTransformType::
    BasePlane () const
    {
      return this->BasePlane_.get ();
    }

    PlaneTransformType::BasePlane_type& PlaneTransformType::
    BasePlane ()
    {
      return this->BasePlane_.get ();
    }

    void PlaneTransformType::
    BasePlane (const BasePlane_type& x)
    {
      this->BasePlane_.set (x);
    }

    void PlaneTransformType::
    BasePlane (::std::auto_ptr< BasePlane_type > x)
    {
      this->BasePlane_.set (x);
    }

    const PlaneTransformType::Transformation_type& PlaneTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PlaneTransformType::Transformation_type& PlaneTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PlaneTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PlaneTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // PlaneExtractType
    // 

    const PlaneExtractType::SurfaceFeature_type& PlaneExtractType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PlaneExtractType::SurfaceFeature_type& PlaneExtractType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PlaneExtractType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PlaneExtractType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }


    // PlaneCheckedType
    // 

    const PlaneCheckedType::Measured_optional& PlaneCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PlaneCheckedType::Measured_optional& PlaneCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PlaneCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PlaneCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PlaneCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const PlaneCheckedType::Constructed_optional& PlaneCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PlaneCheckedType::Constructed_optional& PlaneCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PlaneCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PlaneCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PlaneCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // PlaneCheckedFeatureType
    // 

    const PlaneCheckedFeatureType::CheckDetails_optional& PlaneCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PlaneCheckedFeatureType::CheckDetails_optional& PlaneCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PlaneCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PlaneCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PlaneCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // PlaneActualDeterminationType
    // 

    const PlaneActualDeterminationType::Checked_optional& PlaneActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PlaneActualDeterminationType::Checked_optional& PlaneActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PlaneActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PlaneActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PlaneActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const PlaneActualDeterminationType::Set_optional& PlaneActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PlaneActualDeterminationType::Set_optional& PlaneActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PlaneActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PlaneActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PlaneActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // PlaneFeatureItemType
    // 

    const PlaneFeatureItemType::DeterminationMode_type& PlaneFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PlaneFeatureItemType::DeterminationMode_type& PlaneFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PlaneFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PlaneFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const PlaneFeatureItemType::SubstituteFeatureAlgorithm_optional& PlaneFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    PlaneFeatureItemType::SubstituteFeatureAlgorithm_optional& PlaneFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void PlaneFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void PlaneFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void PlaneFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // PlaneFeatureDefinitionType
    // 


    // PlaneFeatureNominalType
    // 

    const PlaneFeatureNominalType::Location_type& PlaneFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    PlaneFeatureNominalType::Location_type& PlaneFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void PlaneFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PlaneFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const PlaneFeatureNominalType::Normal_type& PlaneFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    PlaneFeatureNominalType::Normal_type& PlaneFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void PlaneFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PlaneFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const PlaneFeatureNominalType::PolyLine_optional& PlaneFeatureNominalType::
    PolyLine () const
    {
      return this->PolyLine_;
    }

    PlaneFeatureNominalType::PolyLine_optional& PlaneFeatureNominalType::
    PolyLine ()
    {
      return this->PolyLine_;
    }

    void PlaneFeatureNominalType::
    PolyLine (const PolyLine_type& x)
    {
      this->PolyLine_.set (x);
    }

    void PlaneFeatureNominalType::
    PolyLine (const PolyLine_optional& x)
    {
      this->PolyLine_ = x;
    }

    void PlaneFeatureNominalType::
    PolyLine (::std::auto_ptr< PolyLine_type > x)
    {
      this->PolyLine_.set (x);
    }


    // PlaneFeatureActualType
    // 

    const PlaneFeatureActualType::Location_optional& PlaneFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    PlaneFeatureActualType::Location_optional& PlaneFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void PlaneFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PlaneFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void PlaneFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const PlaneFeatureActualType::Normal_optional& PlaneFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    PlaneFeatureActualType::Normal_optional& PlaneFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void PlaneFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PlaneFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void PlaneFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const PlaneFeatureActualType::PolyLine_optional& PlaneFeatureActualType::
    PolyLine () const
    {
      return this->PolyLine_;
    }

    PlaneFeatureActualType::PolyLine_optional& PlaneFeatureActualType::
    PolyLine ()
    {
      return this->PolyLine_;
    }

    void PlaneFeatureActualType::
    PolyLine (const PolyLine_type& x)
    {
      this->PolyLine_.set (x);
    }

    void PlaneFeatureActualType::
    PolyLine (const PolyLine_optional& x)
    {
      this->PolyLine_ = x;
    }

    void PlaneFeatureActualType::
    PolyLine (::std::auto_ptr< PolyLine_type > x)
    {
      this->PolyLine_.set (x);
    }

    const PlaneFeatureActualType::Form_optional& PlaneFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    PlaneFeatureActualType::Form_optional& PlaneFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void PlaneFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void PlaneFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void PlaneFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // PointDefinedCurveConstructionMethodType
    // 

    const PointDefinedCurveConstructionMethodType::BestFit_optional& PointDefinedCurveConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    PointDefinedCurveConstructionMethodType::BestFit_optional& PointDefinedCurveConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void PointDefinedCurveConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const PointDefinedCurveConstructionMethodType::Recompensated_optional& PointDefinedCurveConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    PointDefinedCurveConstructionMethodType::Recompensated_optional& PointDefinedCurveConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void PointDefinedCurveConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const PointDefinedCurveConstructionMethodType::Copy_optional& PointDefinedCurveConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PointDefinedCurveConstructionMethodType::Copy_optional& PointDefinedCurveConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PointDefinedCurveConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const PointDefinedCurveConstructionMethodType::Transform_optional& PointDefinedCurveConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PointDefinedCurveConstructionMethodType::Transform_optional& PointDefinedCurveConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PointDefinedCurveConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const PointDefinedCurveConstructionMethodType::FromScan_optional& PointDefinedCurveConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    PointDefinedCurveConstructionMethodType::FromScan_optional& PointDefinedCurveConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void PointDefinedCurveConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }

    const PointDefinedCurveConstructionMethodType::Extract_optional& PointDefinedCurveConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    PointDefinedCurveConstructionMethodType::Extract_optional& PointDefinedCurveConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void PointDefinedCurveConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Extract (::std::auto_ptr< Extract_type > x)
    {
      this->Extract_.set (x);
    }


    // PointDefinedCurveBestFitType
    // 

    const PointDefinedCurveBestFitType::BaseFeature_sequence& PointDefinedCurveBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointDefinedCurveBestFitType::BaseFeature_sequence& PointDefinedCurveBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointDefinedCurveBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PointDefinedCurveRecompType
    // 

    const PointDefinedCurveRecompType::BaseFeaturePointList_type& PointDefinedCurveRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    PointDefinedCurveRecompType::BaseFeaturePointList_type& PointDefinedCurveRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void PointDefinedCurveRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void PointDefinedCurveRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // PointDefinedCurveCopyType
    // 

    const PointDefinedCurveCopyType::BasePointDefinedCurve_type& PointDefinedCurveCopyType::
    BasePointDefinedCurve () const
    {
      return this->BasePointDefinedCurve_.get ();
    }

    PointDefinedCurveCopyType::BasePointDefinedCurve_type& PointDefinedCurveCopyType::
    BasePointDefinedCurve ()
    {
      return this->BasePointDefinedCurve_.get ();
    }

    void PointDefinedCurveCopyType::
    BasePointDefinedCurve (const BasePointDefinedCurve_type& x)
    {
      this->BasePointDefinedCurve_.set (x);
    }

    void PointDefinedCurveCopyType::
    BasePointDefinedCurve (::std::auto_ptr< BasePointDefinedCurve_type > x)
    {
      this->BasePointDefinedCurve_.set (x);
    }


    // PointDefinedCurveTransformType
    // 

    const PointDefinedCurveTransformType::BasePointDefinedCurve_type& PointDefinedCurveTransformType::
    BasePointDefinedCurve () const
    {
      return this->BasePointDefinedCurve_.get ();
    }

    PointDefinedCurveTransformType::BasePointDefinedCurve_type& PointDefinedCurveTransformType::
    BasePointDefinedCurve ()
    {
      return this->BasePointDefinedCurve_.get ();
    }

    void PointDefinedCurveTransformType::
    BasePointDefinedCurve (const BasePointDefinedCurve_type& x)
    {
      this->BasePointDefinedCurve_.set (x);
    }

    void PointDefinedCurveTransformType::
    BasePointDefinedCurve (::std::auto_ptr< BasePointDefinedCurve_type > x)
    {
      this->BasePointDefinedCurve_.set (x);
    }

    const PointDefinedCurveTransformType::Transformation_type& PointDefinedCurveTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PointDefinedCurveTransformType::Transformation_type& PointDefinedCurveTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PointDefinedCurveTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PointDefinedCurveTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // PointDefinedCurveFromScanType
    // 

    const PointDefinedCurveFromScanType::SurfaceFeature_type& PointDefinedCurveFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointDefinedCurveFromScanType::SurfaceFeature_type& PointDefinedCurveFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointDefinedCurveFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointDefinedCurveFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const PointDefinedCurveFromScanType::SearchRadius_type& PointDefinedCurveFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    PointDefinedCurveFromScanType::SearchRadius_type& PointDefinedCurveFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void PointDefinedCurveFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void PointDefinedCurveFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // PointDefinedCurveExtractType
    // 

    const PointDefinedCurveExtractType::CurveFeature_type& PointDefinedCurveExtractType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    PointDefinedCurveExtractType::CurveFeature_type& PointDefinedCurveExtractType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void PointDefinedCurveExtractType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void PointDefinedCurveExtractType::
    CurveFeature (::std::auto_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (x);
    }


    // PointDefinedCurveCheckedType
    // 

    const PointDefinedCurveCheckedType::Measured_optional& PointDefinedCurveCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PointDefinedCurveCheckedType::Measured_optional& PointDefinedCurveCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PointDefinedCurveCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PointDefinedCurveCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PointDefinedCurveCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const PointDefinedCurveCheckedType::Constructed_optional& PointDefinedCurveCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointDefinedCurveCheckedType::Constructed_optional& PointDefinedCurveCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointDefinedCurveCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointDefinedCurveCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointDefinedCurveCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // PointDefinedCurveCheckedFeatureType
    // 

    const PointDefinedCurveCheckedFeatureType::CheckDetails_optional& PointDefinedCurveCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PointDefinedCurveCheckedFeatureType::CheckDetails_optional& PointDefinedCurveCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PointDefinedCurveCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PointDefinedCurveCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PointDefinedCurveCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // PointDefinedCurveActualDeterminationType
    // 

    const PointDefinedCurveActualDeterminationType::Checked_optional& PointDefinedCurveActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PointDefinedCurveActualDeterminationType::Checked_optional& PointDefinedCurveActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PointDefinedCurveActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PointDefinedCurveActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PointDefinedCurveActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const PointDefinedCurveActualDeterminationType::Set_optional& PointDefinedCurveActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PointDefinedCurveActualDeterminationType::Set_optional& PointDefinedCurveActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PointDefinedCurveActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PointDefinedCurveActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PointDefinedCurveActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // PointDefinedCurveFeatureItemType
    // 

    const PointDefinedCurveFeatureItemType::DeterminationMode_type& PointDefinedCurveFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PointDefinedCurveFeatureItemType::DeterminationMode_type& PointDefinedCurveFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PointDefinedCurveFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PointDefinedCurveFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const PointDefinedCurveFeatureItemType::SubstituteFeatureAlgorithm_optional& PointDefinedCurveFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    PointDefinedCurveFeatureItemType::SubstituteFeatureAlgorithm_optional& PointDefinedCurveFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void PointDefinedCurveFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void PointDefinedCurveFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void PointDefinedCurveFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // PointDefinedCurveFeatureDefinitionType
    // 


    // PointDefinedCurveFeatureNominalType
    // 

    const PointDefinedCurveFeatureNominalType::DefiningPoints_type& PointDefinedCurveFeatureNominalType::
    DefiningPoints () const
    {
      return this->DefiningPoints_.get ();
    }

    PointDefinedCurveFeatureNominalType::DefiningPoints_type& PointDefinedCurveFeatureNominalType::
    DefiningPoints ()
    {
      return this->DefiningPoints_.get ();
    }

    void PointDefinedCurveFeatureNominalType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedCurveFeatureNominalType::
    DefiningPoints (::std::auto_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (x);
    }

    const PointDefinedCurveFeatureNominalType::Plane_optional& PointDefinedCurveFeatureNominalType::
    Plane () const
    {
      return this->Plane_;
    }

    PointDefinedCurveFeatureNominalType::Plane_optional& PointDefinedCurveFeatureNominalType::
    Plane ()
    {
      return this->Plane_;
    }

    void PointDefinedCurveFeatureNominalType::
    Plane (const Plane_type& x)
    {
      this->Plane_.set (x);
    }

    void PointDefinedCurveFeatureNominalType::
    Plane (const Plane_optional& x)
    {
      this->Plane_ = x;
    }

    void PointDefinedCurveFeatureNominalType::
    Plane (::std::auto_ptr< Plane_type > x)
    {
      this->Plane_.set (x);
    }


    // TargetPointsActualType
    // 

    const TargetPointsActualType::TargetPoint_sequence& TargetPointsActualType::
    TargetPoint () const
    {
      return this->TargetPoint_;
    }

    TargetPointsActualType::TargetPoint_sequence& TargetPointsActualType::
    TargetPoint ()
    {
      return this->TargetPoint_;
    }

    void TargetPointsActualType::
    TargetPoint (const TargetPoint_sequence& s)
    {
      this->TargetPoint_ = s;
    }

    const TargetPointsActualType::linearUnit_optional& TargetPointsActualType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    TargetPointsActualType::linearUnit_optional& TargetPointsActualType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void TargetPointsActualType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void TargetPointsActualType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void TargetPointsActualType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const TargetPointsActualType::decimalPlaces_optional& TargetPointsActualType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    TargetPointsActualType::decimalPlaces_optional& TargetPointsActualType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void TargetPointsActualType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void TargetPointsActualType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const TargetPointsActualType::significantFigures_optional& TargetPointsActualType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    TargetPointsActualType::significantFigures_optional& TargetPointsActualType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void TargetPointsActualType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void TargetPointsActualType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const TargetPointsActualType::validity_optional& TargetPointsActualType::
    validity () const
    {
      return this->validity_;
    }

    TargetPointsActualType::validity_optional& TargetPointsActualType::
    validity ()
    {
      return this->validity_;
    }

    void TargetPointsActualType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void TargetPointsActualType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void TargetPointsActualType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const TargetPointsActualType::xDecimalPlaces_optional& TargetPointsActualType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    TargetPointsActualType::xDecimalPlaces_optional& TargetPointsActualType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void TargetPointsActualType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void TargetPointsActualType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const TargetPointsActualType::xSignificantFigures_optional& TargetPointsActualType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    TargetPointsActualType::xSignificantFigures_optional& TargetPointsActualType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void TargetPointsActualType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void TargetPointsActualType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const TargetPointsActualType::xValidity_optional& TargetPointsActualType::
    xValidity () const
    {
      return this->xValidity_;
    }

    TargetPointsActualType::xValidity_optional& TargetPointsActualType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void TargetPointsActualType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void TargetPointsActualType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void TargetPointsActualType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const TargetPointsActualType::yDecimalPlaces_optional& TargetPointsActualType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    TargetPointsActualType::yDecimalPlaces_optional& TargetPointsActualType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void TargetPointsActualType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void TargetPointsActualType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const TargetPointsActualType::ySignificantFigures_optional& TargetPointsActualType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    TargetPointsActualType::ySignificantFigures_optional& TargetPointsActualType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void TargetPointsActualType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void TargetPointsActualType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const TargetPointsActualType::yValidity_optional& TargetPointsActualType::
    yValidity () const
    {
      return this->yValidity_;
    }

    TargetPointsActualType::yValidity_optional& TargetPointsActualType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void TargetPointsActualType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void TargetPointsActualType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void TargetPointsActualType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const TargetPointsActualType::zDecimalPlaces_optional& TargetPointsActualType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    TargetPointsActualType::zDecimalPlaces_optional& TargetPointsActualType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void TargetPointsActualType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void TargetPointsActualType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const TargetPointsActualType::zSignificantFigures_optional& TargetPointsActualType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    TargetPointsActualType::zSignificantFigures_optional& TargetPointsActualType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void TargetPointsActualType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void TargetPointsActualType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const TargetPointsActualType::zValidity_optional& TargetPointsActualType::
    zValidity () const
    {
      return this->zValidity_;
    }

    TargetPointsActualType::zValidity_optional& TargetPointsActualType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void TargetPointsActualType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void TargetPointsActualType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void TargetPointsActualType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }

    const TargetPointsActualType::combinedUncertainty_optional& TargetPointsActualType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    TargetPointsActualType::combinedUncertainty_optional& TargetPointsActualType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void TargetPointsActualType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void TargetPointsActualType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    const TargetPointsActualType::meanError_optional& TargetPointsActualType::
    meanError () const
    {
      return this->meanError_;
    }

    TargetPointsActualType::meanError_optional& TargetPointsActualType::
    meanError ()
    {
      return this->meanError_;
    }

    void TargetPointsActualType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void TargetPointsActualType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    const TargetPointsActualType::xCombinedUncertainty_optional& TargetPointsActualType::
    xCombinedUncertainty () const
    {
      return this->xCombinedUncertainty_;
    }

    TargetPointsActualType::xCombinedUncertainty_optional& TargetPointsActualType::
    xCombinedUncertainty ()
    {
      return this->xCombinedUncertainty_;
    }

    void TargetPointsActualType::
    xCombinedUncertainty (const xCombinedUncertainty_type& x)
    {
      this->xCombinedUncertainty_.set (x);
    }

    void TargetPointsActualType::
    xCombinedUncertainty (const xCombinedUncertainty_optional& x)
    {
      this->xCombinedUncertainty_ = x;
    }

    const TargetPointsActualType::xMeanError_optional& TargetPointsActualType::
    xMeanError () const
    {
      return this->xMeanError_;
    }

    TargetPointsActualType::xMeanError_optional& TargetPointsActualType::
    xMeanError ()
    {
      return this->xMeanError_;
    }

    void TargetPointsActualType::
    xMeanError (const xMeanError_type& x)
    {
      this->xMeanError_.set (x);
    }

    void TargetPointsActualType::
    xMeanError (const xMeanError_optional& x)
    {
      this->xMeanError_ = x;
    }

    const TargetPointsActualType::yCombinedUncertainty_optional& TargetPointsActualType::
    yCombinedUncertainty () const
    {
      return this->yCombinedUncertainty_;
    }

    TargetPointsActualType::yCombinedUncertainty_optional& TargetPointsActualType::
    yCombinedUncertainty ()
    {
      return this->yCombinedUncertainty_;
    }

    void TargetPointsActualType::
    yCombinedUncertainty (const yCombinedUncertainty_type& x)
    {
      this->yCombinedUncertainty_.set (x);
    }

    void TargetPointsActualType::
    yCombinedUncertainty (const yCombinedUncertainty_optional& x)
    {
      this->yCombinedUncertainty_ = x;
    }

    const TargetPointsActualType::yMeanError_optional& TargetPointsActualType::
    yMeanError () const
    {
      return this->yMeanError_;
    }

    TargetPointsActualType::yMeanError_optional& TargetPointsActualType::
    yMeanError ()
    {
      return this->yMeanError_;
    }

    void TargetPointsActualType::
    yMeanError (const yMeanError_type& x)
    {
      this->yMeanError_.set (x);
    }

    void TargetPointsActualType::
    yMeanError (const yMeanError_optional& x)
    {
      this->yMeanError_ = x;
    }

    const TargetPointsActualType::zCombinedUncertainty_optional& TargetPointsActualType::
    zCombinedUncertainty () const
    {
      return this->zCombinedUncertainty_;
    }

    TargetPointsActualType::zCombinedUncertainty_optional& TargetPointsActualType::
    zCombinedUncertainty ()
    {
      return this->zCombinedUncertainty_;
    }

    void TargetPointsActualType::
    zCombinedUncertainty (const zCombinedUncertainty_type& x)
    {
      this->zCombinedUncertainty_.set (x);
    }

    void TargetPointsActualType::
    zCombinedUncertainty (const zCombinedUncertainty_optional& x)
    {
      this->zCombinedUncertainty_ = x;
    }

    const TargetPointsActualType::zMeanError_optional& TargetPointsActualType::
    zMeanError () const
    {
      return this->zMeanError_;
    }

    TargetPointsActualType::zMeanError_optional& TargetPointsActualType::
    zMeanError ()
    {
      return this->zMeanError_;
    }

    void TargetPointsActualType::
    zMeanError (const zMeanError_type& x)
    {
      this->zMeanError_.set (x);
    }

    void TargetPointsActualType::
    zMeanError (const zMeanError_optional& x)
    {
      this->zMeanError_ = x;
    }


    // PointDefinedCurveFeatureActualType
    // 

    const PointDefinedCurveFeatureActualType::DefiningPoints_optional& PointDefinedCurveFeatureActualType::
    DefiningPoints () const
    {
      return this->DefiningPoints_;
    }

    PointDefinedCurveFeatureActualType::DefiningPoints_optional& PointDefinedCurveFeatureActualType::
    DefiningPoints ()
    {
      return this->DefiningPoints_;
    }

    void PointDefinedCurveFeatureActualType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedCurveFeatureActualType::
    DefiningPoints (const DefiningPoints_optional& x)
    {
      this->DefiningPoints_ = x;
    }

    void PointDefinedCurveFeatureActualType::
    DefiningPoints (::std::auto_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (x);
    }

    const PointDefinedCurveFeatureActualType::Plane_optional& PointDefinedCurveFeatureActualType::
    Plane () const
    {
      return this->Plane_;
    }

    PointDefinedCurveFeatureActualType::Plane_optional& PointDefinedCurveFeatureActualType::
    Plane ()
    {
      return this->Plane_;
    }

    void PointDefinedCurveFeatureActualType::
    Plane (const Plane_type& x)
    {
      this->Plane_.set (x);
    }

    void PointDefinedCurveFeatureActualType::
    Plane (const Plane_optional& x)
    {
      this->Plane_ = x;
    }

    void PointDefinedCurveFeatureActualType::
    Plane (::std::auto_ptr< Plane_type > x)
    {
      this->Plane_.set (x);
    }

    const PointDefinedCurveFeatureActualType::Form_optional& PointDefinedCurveFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    PointDefinedCurveFeatureActualType::Form_optional& PointDefinedCurveFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void PointDefinedCurveFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void PointDefinedCurveFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void PointDefinedCurveFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // PointDefinedSurfaceConstructionMethodType
    // 

    const PointDefinedSurfaceConstructionMethodType::BestFit_optional& PointDefinedSurfaceConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    PointDefinedSurfaceConstructionMethodType::BestFit_optional& PointDefinedSurfaceConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const PointDefinedSurfaceConstructionMethodType::Recompensated_optional& PointDefinedSurfaceConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    PointDefinedSurfaceConstructionMethodType::Recompensated_optional& PointDefinedSurfaceConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const PointDefinedSurfaceConstructionMethodType::Copy_optional& PointDefinedSurfaceConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PointDefinedSurfaceConstructionMethodType::Copy_optional& PointDefinedSurfaceConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const PointDefinedSurfaceConstructionMethodType::Transform_optional& PointDefinedSurfaceConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PointDefinedSurfaceConstructionMethodType::Transform_optional& PointDefinedSurfaceConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const PointDefinedSurfaceConstructionMethodType::Extract_optional& PointDefinedSurfaceConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    PointDefinedSurfaceConstructionMethodType::Extract_optional& PointDefinedSurfaceConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Extract (::std::auto_ptr< Extract_type > x)
    {
      this->Extract_.set (x);
    }


    // PointDefinedSurfaceBestFitType
    // 

    const PointDefinedSurfaceBestFitType::BaseFeature_sequence& PointDefinedSurfaceBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointDefinedSurfaceBestFitType::BaseFeature_sequence& PointDefinedSurfaceBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointDefinedSurfaceBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PointDefinedSurfaceRecompType
    // 

    const PointDefinedSurfaceRecompType::BaseFeaturePointList_type& PointDefinedSurfaceRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    PointDefinedSurfaceRecompType::BaseFeaturePointList_type& PointDefinedSurfaceRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void PointDefinedSurfaceRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void PointDefinedSurfaceRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // PointDefinedSurfaceCopyType
    // 

    const PointDefinedSurfaceCopyType::BasePointDefinedSurface_type& PointDefinedSurfaceCopyType::
    BasePointDefinedSurface () const
    {
      return this->BasePointDefinedSurface_.get ();
    }

    PointDefinedSurfaceCopyType::BasePointDefinedSurface_type& PointDefinedSurfaceCopyType::
    BasePointDefinedSurface ()
    {
      return this->BasePointDefinedSurface_.get ();
    }

    void PointDefinedSurfaceCopyType::
    BasePointDefinedSurface (const BasePointDefinedSurface_type& x)
    {
      this->BasePointDefinedSurface_.set (x);
    }

    void PointDefinedSurfaceCopyType::
    BasePointDefinedSurface (::std::auto_ptr< BasePointDefinedSurface_type > x)
    {
      this->BasePointDefinedSurface_.set (x);
    }


    // PointDefinedSurfaceTransformType
    // 

    const PointDefinedSurfaceTransformType::BasePointDefinedSurface_type& PointDefinedSurfaceTransformType::
    BasePointDefinedSurface () const
    {
      return this->BasePointDefinedSurface_.get ();
    }

    PointDefinedSurfaceTransformType::BasePointDefinedSurface_type& PointDefinedSurfaceTransformType::
    BasePointDefinedSurface ()
    {
      return this->BasePointDefinedSurface_.get ();
    }

    void PointDefinedSurfaceTransformType::
    BasePointDefinedSurface (const BasePointDefinedSurface_type& x)
    {
      this->BasePointDefinedSurface_.set (x);
    }

    void PointDefinedSurfaceTransformType::
    BasePointDefinedSurface (::std::auto_ptr< BasePointDefinedSurface_type > x)
    {
      this->BasePointDefinedSurface_.set (x);
    }

    const PointDefinedSurfaceTransformType::Transformation_type& PointDefinedSurfaceTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PointDefinedSurfaceTransformType::Transformation_type& PointDefinedSurfaceTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PointDefinedSurfaceTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PointDefinedSurfaceTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // PointDefinedSurfaceExtractType
    // 

    const PointDefinedSurfaceExtractType::SurfaceFeature_type& PointDefinedSurfaceExtractType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointDefinedSurfaceExtractType::SurfaceFeature_type& PointDefinedSurfaceExtractType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointDefinedSurfaceExtractType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointDefinedSurfaceExtractType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }


    // PointDefinedSurfaceCheckedType
    // 

    const PointDefinedSurfaceCheckedType::Measured_optional& PointDefinedSurfaceCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PointDefinedSurfaceCheckedType::Measured_optional& PointDefinedSurfaceCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PointDefinedSurfaceCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PointDefinedSurfaceCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PointDefinedSurfaceCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const PointDefinedSurfaceCheckedType::Constructed_optional& PointDefinedSurfaceCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointDefinedSurfaceCheckedType::Constructed_optional& PointDefinedSurfaceCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointDefinedSurfaceCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointDefinedSurfaceCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointDefinedSurfaceCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // PointDefinedSurfaceCheckedFeatureType
    // 

    const PointDefinedSurfaceCheckedFeatureType::CheckDetails_optional& PointDefinedSurfaceCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PointDefinedSurfaceCheckedFeatureType::CheckDetails_optional& PointDefinedSurfaceCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PointDefinedSurfaceCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PointDefinedSurfaceCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PointDefinedSurfaceCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // PointDefinedSurfaceActualDeterminationType
    // 

    const PointDefinedSurfaceActualDeterminationType::Checked_optional& PointDefinedSurfaceActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PointDefinedSurfaceActualDeterminationType::Checked_optional& PointDefinedSurfaceActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PointDefinedSurfaceActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PointDefinedSurfaceActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PointDefinedSurfaceActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const PointDefinedSurfaceActualDeterminationType::Set_optional& PointDefinedSurfaceActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PointDefinedSurfaceActualDeterminationType::Set_optional& PointDefinedSurfaceActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PointDefinedSurfaceActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PointDefinedSurfaceActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PointDefinedSurfaceActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // PointDefinedSurfaceFeatureItemType
    // 

    const PointDefinedSurfaceFeatureItemType::DeterminationMode_type& PointDefinedSurfaceFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PointDefinedSurfaceFeatureItemType::DeterminationMode_type& PointDefinedSurfaceFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PointDefinedSurfaceFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PointDefinedSurfaceFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const PointDefinedSurfaceFeatureItemType::SubstituteFeatureAlgorithm_optional& PointDefinedSurfaceFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    PointDefinedSurfaceFeatureItemType::SubstituteFeatureAlgorithm_optional& PointDefinedSurfaceFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void PointDefinedSurfaceFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void PointDefinedSurfaceFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void PointDefinedSurfaceFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // PointDefinedSurfaceFeatureDefinitionType
    // 


    // TargetPointsNominalType
    // 

    const TargetPointsNominalType::TargetPoint_sequence& TargetPointsNominalType::
    TargetPoint () const
    {
      return this->TargetPoint_;
    }

    TargetPointsNominalType::TargetPoint_sequence& TargetPointsNominalType::
    TargetPoint ()
    {
      return this->TargetPoint_;
    }

    void TargetPointsNominalType::
    TargetPoint (const TargetPoint_sequence& s)
    {
      this->TargetPoint_ = s;
    }

    const TargetPointsNominalType::linearUnit_optional& TargetPointsNominalType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    TargetPointsNominalType::linearUnit_optional& TargetPointsNominalType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void TargetPointsNominalType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void TargetPointsNominalType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void TargetPointsNominalType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const TargetPointsNominalType::decimalPlaces_optional& TargetPointsNominalType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    TargetPointsNominalType::decimalPlaces_optional& TargetPointsNominalType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void TargetPointsNominalType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void TargetPointsNominalType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const TargetPointsNominalType::significantFigures_optional& TargetPointsNominalType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    TargetPointsNominalType::significantFigures_optional& TargetPointsNominalType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void TargetPointsNominalType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void TargetPointsNominalType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const TargetPointsNominalType::validity_optional& TargetPointsNominalType::
    validity () const
    {
      return this->validity_;
    }

    TargetPointsNominalType::validity_optional& TargetPointsNominalType::
    validity ()
    {
      return this->validity_;
    }

    void TargetPointsNominalType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void TargetPointsNominalType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void TargetPointsNominalType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const TargetPointsNominalType::xDecimalPlaces_optional& TargetPointsNominalType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    TargetPointsNominalType::xDecimalPlaces_optional& TargetPointsNominalType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void TargetPointsNominalType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void TargetPointsNominalType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const TargetPointsNominalType::xSignificantFigures_optional& TargetPointsNominalType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    TargetPointsNominalType::xSignificantFigures_optional& TargetPointsNominalType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void TargetPointsNominalType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void TargetPointsNominalType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const TargetPointsNominalType::xValidity_optional& TargetPointsNominalType::
    xValidity () const
    {
      return this->xValidity_;
    }

    TargetPointsNominalType::xValidity_optional& TargetPointsNominalType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void TargetPointsNominalType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void TargetPointsNominalType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void TargetPointsNominalType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const TargetPointsNominalType::yDecimalPlaces_optional& TargetPointsNominalType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    TargetPointsNominalType::yDecimalPlaces_optional& TargetPointsNominalType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void TargetPointsNominalType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void TargetPointsNominalType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const TargetPointsNominalType::ySignificantFigures_optional& TargetPointsNominalType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    TargetPointsNominalType::ySignificantFigures_optional& TargetPointsNominalType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void TargetPointsNominalType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void TargetPointsNominalType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const TargetPointsNominalType::yValidity_optional& TargetPointsNominalType::
    yValidity () const
    {
      return this->yValidity_;
    }

    TargetPointsNominalType::yValidity_optional& TargetPointsNominalType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void TargetPointsNominalType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void TargetPointsNominalType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void TargetPointsNominalType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const TargetPointsNominalType::zDecimalPlaces_optional& TargetPointsNominalType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    TargetPointsNominalType::zDecimalPlaces_optional& TargetPointsNominalType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void TargetPointsNominalType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void TargetPointsNominalType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const TargetPointsNominalType::zSignificantFigures_optional& TargetPointsNominalType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    TargetPointsNominalType::zSignificantFigures_optional& TargetPointsNominalType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void TargetPointsNominalType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void TargetPointsNominalType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const TargetPointsNominalType::zValidity_optional& TargetPointsNominalType::
    zValidity () const
    {
      return this->zValidity_;
    }

    TargetPointsNominalType::zValidity_optional& TargetPointsNominalType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void TargetPointsNominalType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void TargetPointsNominalType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void TargetPointsNominalType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }


    // PointDefinedSurfaceFeatureNominalType
    // 

    const PointDefinedSurfaceFeatureNominalType::DefiningPoints_type& PointDefinedSurfaceFeatureNominalType::
    DefiningPoints () const
    {
      return this->DefiningPoints_.get ();
    }

    PointDefinedSurfaceFeatureNominalType::DefiningPoints_type& PointDefinedSurfaceFeatureNominalType::
    DefiningPoints ()
    {
      return this->DefiningPoints_.get ();
    }

    void PointDefinedSurfaceFeatureNominalType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedSurfaceFeatureNominalType::
    DefiningPoints (::std::auto_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (x);
    }


    // PointDefinedSurfaceFeatureActualType
    // 

    const PointDefinedSurfaceFeatureActualType::DefiningPoints_optional& PointDefinedSurfaceFeatureActualType::
    DefiningPoints () const
    {
      return this->DefiningPoints_;
    }

    PointDefinedSurfaceFeatureActualType::DefiningPoints_optional& PointDefinedSurfaceFeatureActualType::
    DefiningPoints ()
    {
      return this->DefiningPoints_;
    }

    void PointDefinedSurfaceFeatureActualType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedSurfaceFeatureActualType::
    DefiningPoints (const DefiningPoints_optional& x)
    {
      this->DefiningPoints_ = x;
    }

    void PointDefinedSurfaceFeatureActualType::
    DefiningPoints (::std::auto_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (x);
    }

    const PointDefinedSurfaceFeatureActualType::Form_optional& PointDefinedSurfaceFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    PointDefinedSurfaceFeatureActualType::Form_optional& PointDefinedSurfaceFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void PointDefinedSurfaceFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void PointDefinedSurfaceFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void PointDefinedSurfaceFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // PointConstructionMethodType
    // 

    const PointConstructionMethodType::Intersection_optional& PointConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    PointConstructionMethodType::Intersection_optional& PointConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void PointConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void PointConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void PointConstructionMethodType::
    Intersection (::std::auto_ptr< Intersection_type > x)
    {
      this->Intersection_.set (x);
    }

    const PointConstructionMethodType::Projection_optional& PointConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    PointConstructionMethodType::Projection_optional& PointConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void PointConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void PointConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void PointConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const PointConstructionMethodType::Copy_optional& PointConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PointConstructionMethodType::Copy_optional& PointConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PointConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PointConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PointConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const PointConstructionMethodType::Cast_optional& PointConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    PointConstructionMethodType::Cast_optional& PointConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void PointConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void PointConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void PointConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const PointConstructionMethodType::Transform_optional& PointConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PointConstructionMethodType::Transform_optional& PointConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PointConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PointConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PointConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const PointConstructionMethodType::FromCone_optional& PointConstructionMethodType::
    FromCone () const
    {
      return this->FromCone_;
    }

    PointConstructionMethodType::FromCone_optional& PointConstructionMethodType::
    FromCone ()
    {
      return this->FromCone_;
    }

    void PointConstructionMethodType::
    FromCone (const FromCone_type& x)
    {
      this->FromCone_.set (x);
    }

    void PointConstructionMethodType::
    FromCone (const FromCone_optional& x)
    {
      this->FromCone_ = x;
    }

    void PointConstructionMethodType::
    FromCone (::std::auto_ptr< FromCone_type > x)
    {
      this->FromCone_.set (x);
    }

    const PointConstructionMethodType::FromScan_optional& PointConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    PointConstructionMethodType::FromScan_optional& PointConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void PointConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void PointConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void PointConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }

    const PointConstructionMethodType::CenterOfGravity_optional& PointConstructionMethodType::
    CenterOfGravity () const
    {
      return this->CenterOfGravity_;
    }

    PointConstructionMethodType::CenterOfGravity_optional& PointConstructionMethodType::
    CenterOfGravity ()
    {
      return this->CenterOfGravity_;
    }

    void PointConstructionMethodType::
    CenterOfGravity (const CenterOfGravity_type& x)
    {
      this->CenterOfGravity_.set (x);
    }

    void PointConstructionMethodType::
    CenterOfGravity (const CenterOfGravity_optional& x)
    {
      this->CenterOfGravity_ = x;
    }

    void PointConstructionMethodType::
    CenterOfGravity (::std::auto_ptr< CenterOfGravity_type > x)
    {
      this->CenterOfGravity_.set (x);
    }

    const PointConstructionMethodType::Pierce_optional& PointConstructionMethodType::
    Pierce () const
    {
      return this->Pierce_;
    }

    PointConstructionMethodType::Pierce_optional& PointConstructionMethodType::
    Pierce ()
    {
      return this->Pierce_;
    }

    void PointConstructionMethodType::
    Pierce (const Pierce_type& x)
    {
      this->Pierce_.set (x);
    }

    void PointConstructionMethodType::
    Pierce (const Pierce_optional& x)
    {
      this->Pierce_ = x;
    }

    void PointConstructionMethodType::
    Pierce (::std::auto_ptr< Pierce_type > x)
    {
      this->Pierce_.set (x);
    }

    const PointConstructionMethodType::MidPoint_optional& PointConstructionMethodType::
    MidPoint () const
    {
      return this->MidPoint_;
    }

    PointConstructionMethodType::MidPoint_optional& PointConstructionMethodType::
    MidPoint ()
    {
      return this->MidPoint_;
    }

    void PointConstructionMethodType::
    MidPoint (const MidPoint_type& x)
    {
      this->MidPoint_.set (x);
    }

    void PointConstructionMethodType::
    MidPoint (const MidPoint_optional& x)
    {
      this->MidPoint_ = x;
    }

    void PointConstructionMethodType::
    MidPoint (::std::auto_ptr< MidPoint_type > x)
    {
      this->MidPoint_.set (x);
    }

    const PointConstructionMethodType::MovePoint_optional& PointConstructionMethodType::
    MovePoint () const
    {
      return this->MovePoint_;
    }

    PointConstructionMethodType::MovePoint_optional& PointConstructionMethodType::
    MovePoint ()
    {
      return this->MovePoint_;
    }

    void PointConstructionMethodType::
    MovePoint (const MovePoint_type& x)
    {
      this->MovePoint_.set (x);
    }

    void PointConstructionMethodType::
    MovePoint (const MovePoint_optional& x)
    {
      this->MovePoint_ = x;
    }

    void PointConstructionMethodType::
    MovePoint (::std::auto_ptr< MovePoint_type > x)
    {
      this->MovePoint_.set (x);
    }

    const PointConstructionMethodType::MovePointVector_optional& PointConstructionMethodType::
    MovePointVector () const
    {
      return this->MovePointVector_;
    }

    PointConstructionMethodType::MovePointVector_optional& PointConstructionMethodType::
    MovePointVector ()
    {
      return this->MovePointVector_;
    }

    void PointConstructionMethodType::
    MovePointVector (const MovePointVector_type& x)
    {
      this->MovePointVector_.set (x);
    }

    void PointConstructionMethodType::
    MovePointVector (const MovePointVector_optional& x)
    {
      this->MovePointVector_ = x;
    }

    void PointConstructionMethodType::
    MovePointVector (::std::auto_ptr< MovePointVector_type > x)
    {
      this->MovePointVector_.set (x);
    }

    const PointConstructionMethodType::MovePointAxis_optional& PointConstructionMethodType::
    MovePointAxis () const
    {
      return this->MovePointAxis_;
    }

    PointConstructionMethodType::MovePointAxis_optional& PointConstructionMethodType::
    MovePointAxis ()
    {
      return this->MovePointAxis_;
    }

    void PointConstructionMethodType::
    MovePointAxis (const MovePointAxis_type& x)
    {
      this->MovePointAxis_.set (x);
    }

    void PointConstructionMethodType::
    MovePointAxis (const MovePointAxis_optional& x)
    {
      this->MovePointAxis_ = x;
    }

    void PointConstructionMethodType::
    MovePointAxis (::std::auto_ptr< MovePointAxis_type > x)
    {
      this->MovePointAxis_.set (x);
    }

    const PointConstructionMethodType::Extreme_optional& PointConstructionMethodType::
    Extreme () const
    {
      return this->Extreme_;
    }

    PointConstructionMethodType::Extreme_optional& PointConstructionMethodType::
    Extreme ()
    {
      return this->Extreme_;
    }

    void PointConstructionMethodType::
    Extreme (const Extreme_type& x)
    {
      this->Extreme_.set (x);
    }

    void PointConstructionMethodType::
    Extreme (const Extreme_optional& x)
    {
      this->Extreme_ = x;
    }

    void PointConstructionMethodType::
    Extreme (::std::auto_ptr< Extreme_type > x)
    {
      this->Extreme_.set (x);
    }


    // PointFeatureIntersectionType
    // 

    const PointFeatureIntersectionType::IntersectionFeature_sequence& PointFeatureIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_;
    }

    PointFeatureIntersectionType::IntersectionFeature_sequence& PointFeatureIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_;
    }

    void PointFeatureIntersectionType::
    IntersectionFeature (const IntersectionFeature_sequence& s)
    {
      this->IntersectionFeature_ = s;
    }


    // PointFeaturePierceType
    // 

    const PointFeaturePierceType::SurfaceFeature_type& PointFeaturePierceType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointFeaturePierceType::SurfaceFeature_type& PointFeaturePierceType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointFeaturePierceType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointFeaturePierceType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const PointFeaturePierceType::CurveFeature_type& PointFeaturePierceType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    PointFeaturePierceType::CurveFeature_type& PointFeaturePierceType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void PointFeaturePierceType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void PointFeaturePierceType::
    CurveFeature (::std::auto_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (x);
    }


    // PointFeatureProjectionType
    // 

    const PointFeatureProjectionType::ProjectionPlane_type& PointFeatureProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    PointFeatureProjectionType::ProjectionPlane_type& PointFeatureProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void PointFeatureProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void PointFeatureProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }

    const PointFeatureProjectionType::ProjectionFeature_type& PointFeatureProjectionType::
    ProjectionFeature () const
    {
      return this->ProjectionFeature_.get ();
    }

    PointFeatureProjectionType::ProjectionFeature_type& PointFeatureProjectionType::
    ProjectionFeature ()
    {
      return this->ProjectionFeature_.get ();
    }

    void PointFeatureProjectionType::
    ProjectionFeature (const ProjectionFeature_type& x)
    {
      this->ProjectionFeature_.set (x);
    }

    void PointFeatureProjectionType::
    ProjectionFeature (::std::auto_ptr< ProjectionFeature_type > x)
    {
      this->ProjectionFeature_.set (x);
    }


    // PointFeatureFromConeType
    // 

    const PointFeatureFromConeType::BaseCone_type& PointFeatureFromConeType::
    BaseCone () const
    {
      return this->BaseCone_.get ();
    }

    PointFeatureFromConeType::BaseCone_type& PointFeatureFromConeType::
    BaseCone ()
    {
      return this->BaseCone_.get ();
    }

    void PointFeatureFromConeType::
    BaseCone (const BaseCone_type& x)
    {
      this->BaseCone_.set (x);
    }

    void PointFeatureFromConeType::
    BaseCone (::std::auto_ptr< BaseCone_type > x)
    {
      this->BaseCone_.set (x);
    }


    // PointFeatureCopyType
    // 

    const PointFeatureCopyType::BasePointFeature_type& PointFeatureCopyType::
    BasePointFeature () const
    {
      return this->BasePointFeature_.get ();
    }

    PointFeatureCopyType::BasePointFeature_type& PointFeatureCopyType::
    BasePointFeature ()
    {
      return this->BasePointFeature_.get ();
    }

    void PointFeatureCopyType::
    BasePointFeature (const BasePointFeature_type& x)
    {
      this->BasePointFeature_.set (x);
    }

    void PointFeatureCopyType::
    BasePointFeature (::std::auto_ptr< BasePointFeature_type > x)
    {
      this->BasePointFeature_.set (x);
    }


    // PointFeatureTransformType
    // 

    const PointFeatureTransformType::BasePointFeature_type& PointFeatureTransformType::
    BasePointFeature () const
    {
      return this->BasePointFeature_.get ();
    }

    PointFeatureTransformType::BasePointFeature_type& PointFeatureTransformType::
    BasePointFeature ()
    {
      return this->BasePointFeature_.get ();
    }

    void PointFeatureTransformType::
    BasePointFeature (const BasePointFeature_type& x)
    {
      this->BasePointFeature_.set (x);
    }

    void PointFeatureTransformType::
    BasePointFeature (::std::auto_ptr< BasePointFeature_type > x)
    {
      this->BasePointFeature_.set (x);
    }

    const PointFeatureTransformType::Transformation_type& PointFeatureTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PointFeatureTransformType::Transformation_type& PointFeatureTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PointFeatureTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PointFeatureTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // PointFeatureFromScanType
    // 

    const PointFeatureFromScanType::SurfaceFeature_type& PointFeatureFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointFeatureFromScanType::SurfaceFeature_type& PointFeatureFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointFeatureFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointFeatureFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const PointFeatureFromScanType::SearchRadius_type& PointFeatureFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    PointFeatureFromScanType::SearchRadius_type& PointFeatureFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void PointFeatureFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void PointFeatureFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const PointFeatureFromScanType::RetrievalMethod_type& PointFeatureFromScanType::
    RetrievalMethod () const
    {
      return this->RetrievalMethod_.get ();
    }

    PointFeatureFromScanType::RetrievalMethod_type& PointFeatureFromScanType::
    RetrievalMethod ()
    {
      return this->RetrievalMethod_.get ();
    }

    void PointFeatureFromScanType::
    RetrievalMethod (const RetrievalMethod_type& x)
    {
      this->RetrievalMethod_.set (x);
    }

    void PointFeatureFromScanType::
    RetrievalMethod (::std::auto_ptr< RetrievalMethod_type > x)
    {
      this->RetrievalMethod_.set (x);
    }


    // PointFeatureCenterOfGravityType
    // 

    const PointFeatureCenterOfGravityType::BaseFeature_sequence& PointFeatureCenterOfGravityType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointFeatureCenterOfGravityType::BaseFeature_sequence& PointFeatureCenterOfGravityType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointFeatureCenterOfGravityType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PointFeatureMidPointType
    // 

    const PointFeatureMidPointType::BaseFeature_sequence& PointFeatureMidPointType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointFeatureMidPointType::BaseFeature_sequence& PointFeatureMidPointType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointFeatureMidPointType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PointFeatureCastType
    // 

    const PointFeatureCastType::BaseFeature_type& PointFeatureCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureCastType::BaseFeature_type& PointFeatureCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // PointFeatureMovePointType
    // 

    const PointFeatureMovePointType::BaseFeature_type& PointFeatureMovePointType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureMovePointType::BaseFeature_type& PointFeatureMovePointType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureMovePointType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureMovePointType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }

    const PointFeatureMovePointType::Offset_optional& PointFeatureMovePointType::
    Offset () const
    {
      return this->Offset_;
    }

    PointFeatureMovePointType::Offset_optional& PointFeatureMovePointType::
    Offset ()
    {
      return this->Offset_;
    }

    void PointFeatureMovePointType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void PointFeatureMovePointType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    void PointFeatureMovePointType::
    Offset (::std::auto_ptr< Offset_type > x)
    {
      this->Offset_.set (x);
    }

    const PointFeatureMovePointType::DirectionalOffset_optional& PointFeatureMovePointType::
    DirectionalOffset () const
    {
      return this->DirectionalOffset_;
    }

    PointFeatureMovePointType::DirectionalOffset_optional& PointFeatureMovePointType::
    DirectionalOffset ()
    {
      return this->DirectionalOffset_;
    }

    void PointFeatureMovePointType::
    DirectionalOffset (const DirectionalOffset_type& x)
    {
      this->DirectionalOffset_.set (x);
    }

    void PointFeatureMovePointType::
    DirectionalOffset (const DirectionalOffset_optional& x)
    {
      this->DirectionalOffset_ = x;
    }

    void PointFeatureMovePointType::
    DirectionalOffset (::std::auto_ptr< DirectionalOffset_type > x)
    {
      this->DirectionalOffset_.set (x);
    }


    // PointFeatureMovePointVectorType
    // 

    const PointFeatureMovePointVectorType::BaseFeature_type& PointFeatureMovePointVectorType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureMovePointVectorType::BaseFeature_type& PointFeatureMovePointVectorType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureMovePointVectorType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureMovePointVectorType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }

    const PointFeatureMovePointVectorType::Distance_type& PointFeatureMovePointVectorType::
    Distance () const
    {
      return this->Distance_.get ();
    }

    PointFeatureMovePointVectorType::Distance_type& PointFeatureMovePointVectorType::
    Distance ()
    {
      return this->Distance_.get ();
    }

    void PointFeatureMovePointVectorType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void PointFeatureMovePointVectorType::
    Distance (::std::auto_ptr< Distance_type > x)
    {
      this->Distance_.set (x);
    }

    const PointFeatureMovePointVectorType::Vector_type& PointFeatureMovePointVectorType::
    Vector () const
    {
      return this->Vector_.get ();
    }

    PointFeatureMovePointVectorType::Vector_type& PointFeatureMovePointVectorType::
    Vector ()
    {
      return this->Vector_.get ();
    }

    void PointFeatureMovePointVectorType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void PointFeatureMovePointVectorType::
    Vector (::std::auto_ptr< Vector_type > x)
    {
      this->Vector_.set (x);
    }


    // PointFeatureMovePointAxisType
    // 

    const PointFeatureMovePointAxisType::BaseLocationFeature_type& PointFeatureMovePointAxisType::
    BaseLocationFeature () const
    {
      return this->BaseLocationFeature_.get ();
    }

    PointFeatureMovePointAxisType::BaseLocationFeature_type& PointFeatureMovePointAxisType::
    BaseLocationFeature ()
    {
      return this->BaseLocationFeature_.get ();
    }

    void PointFeatureMovePointAxisType::
    BaseLocationFeature (const BaseLocationFeature_type& x)
    {
      this->BaseLocationFeature_.set (x);
    }

    void PointFeatureMovePointAxisType::
    BaseLocationFeature (::std::auto_ptr< BaseLocationFeature_type > x)
    {
      this->BaseLocationFeature_.set (x);
    }

    const PointFeatureMovePointAxisType::Distance_type& PointFeatureMovePointAxisType::
    Distance () const
    {
      return this->Distance_.get ();
    }

    PointFeatureMovePointAxisType::Distance_type& PointFeatureMovePointAxisType::
    Distance ()
    {
      return this->Distance_.get ();
    }

    void PointFeatureMovePointAxisType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void PointFeatureMovePointAxisType::
    Distance (::std::auto_ptr< Distance_type > x)
    {
      this->Distance_.set (x);
    }

    const PointFeatureMovePointAxisType::BaseAxisFeature_type& PointFeatureMovePointAxisType::
    BaseAxisFeature () const
    {
      return this->BaseAxisFeature_.get ();
    }

    PointFeatureMovePointAxisType::BaseAxisFeature_type& PointFeatureMovePointAxisType::
    BaseAxisFeature ()
    {
      return this->BaseAxisFeature_.get ();
    }

    void PointFeatureMovePointAxisType::
    BaseAxisFeature (const BaseAxisFeature_type& x)
    {
      this->BaseAxisFeature_.set (x);
    }

    void PointFeatureMovePointAxisType::
    BaseAxisFeature (::std::auto_ptr< BaseAxisFeature_type > x)
    {
      this->BaseAxisFeature_.set (x);
    }


    // PointFeatureExtremeType
    // 

    const PointFeatureExtremeType::BaseFeature_type& PointFeatureExtremeType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureExtremeType::BaseFeature_type& PointFeatureExtremeType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureExtremeType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureExtremeType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }

    const PointFeatureExtremeType::Minimum_type& PointFeatureExtremeType::
    Minimum () const
    {
      return this->Minimum_.get ();
    }

    PointFeatureExtremeType::Minimum_type& PointFeatureExtremeType::
    Minimum ()
    {
      return this->Minimum_.get ();
    }

    void PointFeatureExtremeType::
    Minimum (const Minimum_type& x)
    {
      this->Minimum_.set (x);
    }

    PointFeatureExtremeType::Minimum_type PointFeatureExtremeType::
    Minimum_default_value ()
    {
      return Minimum_type (false);
    }

    const PointFeatureExtremeType::BaseAxisFeature_optional& PointFeatureExtremeType::
    BaseAxisFeature () const
    {
      return this->BaseAxisFeature_;
    }

    PointFeatureExtremeType::BaseAxisFeature_optional& PointFeatureExtremeType::
    BaseAxisFeature ()
    {
      return this->BaseAxisFeature_;
    }

    void PointFeatureExtremeType::
    BaseAxisFeature (const BaseAxisFeature_type& x)
    {
      this->BaseAxisFeature_.set (x);
    }

    void PointFeatureExtremeType::
    BaseAxisFeature (const BaseAxisFeature_optional& x)
    {
      this->BaseAxisFeature_ = x;
    }

    void PointFeatureExtremeType::
    BaseAxisFeature (::std::auto_ptr< BaseAxisFeature_type > x)
    {
      this->BaseAxisFeature_.set (x);
    }

    const PointFeatureExtremeType::Vector_optional& PointFeatureExtremeType::
    Vector () const
    {
      return this->Vector_;
    }

    PointFeatureExtremeType::Vector_optional& PointFeatureExtremeType::
    Vector ()
    {
      return this->Vector_;
    }

    void PointFeatureExtremeType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void PointFeatureExtremeType::
    Vector (const Vector_optional& x)
    {
      this->Vector_ = x;
    }

    void PointFeatureExtremeType::
    Vector (::std::auto_ptr< Vector_type > x)
    {
      this->Vector_.set (x);
    }

    const PointFeatureExtremeType::Radial_optional& PointFeatureExtremeType::
    Radial () const
    {
      return this->Radial_;
    }

    PointFeatureExtremeType::Radial_optional& PointFeatureExtremeType::
    Radial ()
    {
      return this->Radial_;
    }

    void PointFeatureExtremeType::
    Radial (const Radial_type& x)
    {
      this->Radial_.set (x);
    }

    void PointFeatureExtremeType::
    Radial (const Radial_optional& x)
    {
      this->Radial_ = x;
    }

    void PointFeatureExtremeType::
    Radial (::std::auto_ptr< Radial_type > x)
    {
      this->Radial_.set (x);
    }

    const PointFeatureExtremeType::Radial_type& PointFeatureExtremeType::
    Radial_default_value ()
    {
      return Radial_default_value_;
    }

    const PointFeatureExtremeType::Xaxis_optional& PointFeatureExtremeType::
    Xaxis () const
    {
      return this->Xaxis_;
    }

    PointFeatureExtremeType::Xaxis_optional& PointFeatureExtremeType::
    Xaxis ()
    {
      return this->Xaxis_;
    }

    void PointFeatureExtremeType::
    Xaxis (const Xaxis_type& x)
    {
      this->Xaxis_.set (x);
    }

    void PointFeatureExtremeType::
    Xaxis (const Xaxis_optional& x)
    {
      this->Xaxis_ = x;
    }

    void PointFeatureExtremeType::
    Xaxis (::std::auto_ptr< Xaxis_type > x)
    {
      this->Xaxis_.set (x);
    }

    const PointFeatureExtremeType::Xaxis_type& PointFeatureExtremeType::
    Xaxis_default_value ()
    {
      return Xaxis_default_value_;
    }

    const PointFeatureExtremeType::Yaxis_optional& PointFeatureExtremeType::
    Yaxis () const
    {
      return this->Yaxis_;
    }

    PointFeatureExtremeType::Yaxis_optional& PointFeatureExtremeType::
    Yaxis ()
    {
      return this->Yaxis_;
    }

    void PointFeatureExtremeType::
    Yaxis (const Yaxis_type& x)
    {
      this->Yaxis_.set (x);
    }

    void PointFeatureExtremeType::
    Yaxis (const Yaxis_optional& x)
    {
      this->Yaxis_ = x;
    }

    void PointFeatureExtremeType::
    Yaxis (::std::auto_ptr< Yaxis_type > x)
    {
      this->Yaxis_.set (x);
    }

    const PointFeatureExtremeType::Yaxis_type& PointFeatureExtremeType::
    Yaxis_default_value ()
    {
      return Yaxis_default_value_;
    }

    const PointFeatureExtremeType::Zaxis_optional& PointFeatureExtremeType::
    Zaxis () const
    {
      return this->Zaxis_;
    }

    PointFeatureExtremeType::Zaxis_optional& PointFeatureExtremeType::
    Zaxis ()
    {
      return this->Zaxis_;
    }

    void PointFeatureExtremeType::
    Zaxis (const Zaxis_type& x)
    {
      this->Zaxis_.set (x);
    }

    void PointFeatureExtremeType::
    Zaxis (const Zaxis_optional& x)
    {
      this->Zaxis_ = x;
    }

    void PointFeatureExtremeType::
    Zaxis (::std::auto_ptr< Zaxis_type > x)
    {
      this->Zaxis_.set (x);
    }

    const PointFeatureExtremeType::Zaxis_type& PointFeatureExtremeType::
    Zaxis_default_value ()
    {
      return Zaxis_default_value_;
    }


    // PointCheckedType
    // 

    const PointCheckedType::Measured_optional& PointCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PointCheckedType::Measured_optional& PointCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PointCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PointCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PointCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const PointCheckedType::Constructed_optional& PointCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointCheckedType::Constructed_optional& PointCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // PointCheckedFeatureType
    // 

    const PointCheckedFeatureType::CheckDetails_optional& PointCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PointCheckedFeatureType::CheckDetails_optional& PointCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PointCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PointCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PointCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // PointActualDeterminationType
    // 

    const PointActualDeterminationType::Checked_optional& PointActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PointActualDeterminationType::Checked_optional& PointActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PointActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PointActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PointActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const PointActualDeterminationType::Set_optional& PointActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PointActualDeterminationType::Set_optional& PointActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PointActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PointActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PointActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // PointFeatureItemType
    // 

    const PointFeatureItemType::DeterminationMode_type& PointFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PointFeatureItemType::DeterminationMode_type& PointFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PointFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PointFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }


    // PointFeatureDefinitionType
    // 


    // PointFeatureNominalType
    // 

    const PointFeatureNominalType::Location_type& PointFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    PointFeatureNominalType::Location_type& PointFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void PointFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PointFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const PointFeatureNominalType::Normal_optional& PointFeatureNominalType::
    Normal () const
    {
      return this->Normal_;
    }

    PointFeatureNominalType::Normal_optional& PointFeatureNominalType::
    Normal ()
    {
      return this->Normal_;
    }

    void PointFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PointFeatureNominalType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void PointFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // PointFeatureActualType
    // 

    const PointFeatureActualType::Location_optional& PointFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    PointFeatureActualType::Location_optional& PointFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void PointFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PointFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void PointFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const PointFeatureActualType::Normal_optional& PointFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    PointFeatureActualType::Normal_optional& PointFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void PointFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PointFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void PointFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // SphereConstructionMethodType
    // 

    const SphereConstructionMethodType::BestFit_optional& SphereConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    SphereConstructionMethodType::BestFit_optional& SphereConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void SphereConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void SphereConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void SphereConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const SphereConstructionMethodType::Recompensated_optional& SphereConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    SphereConstructionMethodType::Recompensated_optional& SphereConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void SphereConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void SphereConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void SphereConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const SphereConstructionMethodType::Copy_optional& SphereConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    SphereConstructionMethodType::Copy_optional& SphereConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void SphereConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void SphereConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void SphereConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const SphereConstructionMethodType::Cast_optional& SphereConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    SphereConstructionMethodType::Cast_optional& SphereConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void SphereConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void SphereConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void SphereConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const SphereConstructionMethodType::Transform_optional& SphereConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    SphereConstructionMethodType::Transform_optional& SphereConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void SphereConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void SphereConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void SphereConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const SphereConstructionMethodType::FromScan_optional& SphereConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    SphereConstructionMethodType::FromScan_optional& SphereConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void SphereConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void SphereConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void SphereConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // SphereBestFitType
    // 

    const SphereBestFitType::BaseFeature_sequence& SphereBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    SphereBestFitType::BaseFeature_sequence& SphereBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void SphereBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // SphereRecompType
    // 

    const SphereRecompType::BaseFeaturePointList_type& SphereRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    SphereRecompType::BaseFeaturePointList_type& SphereRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void SphereRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void SphereRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // SphereCopyType
    // 

    const SphereCopyType::BaseSphere_type& SphereCopyType::
    BaseSphere () const
    {
      return this->BaseSphere_.get ();
    }

    SphereCopyType::BaseSphere_type& SphereCopyType::
    BaseSphere ()
    {
      return this->BaseSphere_.get ();
    }

    void SphereCopyType::
    BaseSphere (const BaseSphere_type& x)
    {
      this->BaseSphere_.set (x);
    }

    void SphereCopyType::
    BaseSphere (::std::auto_ptr< BaseSphere_type > x)
    {
      this->BaseSphere_.set (x);
    }


    // SphereCastType
    // 

    const SphereCastType::BaseFeature_type& SphereCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    SphereCastType::BaseFeature_type& SphereCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void SphereCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void SphereCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // SphereTransformType
    // 

    const SphereTransformType::BaseSphere_type& SphereTransformType::
    BaseSphere () const
    {
      return this->BaseSphere_.get ();
    }

    SphereTransformType::BaseSphere_type& SphereTransformType::
    BaseSphere ()
    {
      return this->BaseSphere_.get ();
    }

    void SphereTransformType::
    BaseSphere (const BaseSphere_type& x)
    {
      this->BaseSphere_.set (x);
    }

    void SphereTransformType::
    BaseSphere (::std::auto_ptr< BaseSphere_type > x)
    {
      this->BaseSphere_.set (x);
    }

    const SphereTransformType::Transformation_type& SphereTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    SphereTransformType::Transformation_type& SphereTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void SphereTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void SphereTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // SphereFromScanType
    // 

    const SphereFromScanType::SurfaceFeature_type& SphereFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    SphereFromScanType::SurfaceFeature_type& SphereFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void SphereFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void SphereFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const SphereFromScanType::SearchRadius_type& SphereFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    SphereFromScanType::SearchRadius_type& SphereFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void SphereFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void SphereFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const SphereFromScanType::Vector_optional& SphereFromScanType::
    Vector () const
    {
      return this->Vector_;
    }

    SphereFromScanType::Vector_optional& SphereFromScanType::
    Vector ()
    {
      return this->Vector_;
    }

    void SphereFromScanType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void SphereFromScanType::
    Vector (const Vector_optional& x)
    {
      this->Vector_ = x;
    }

    void SphereFromScanType::
    Vector (::std::auto_ptr< Vector_type > x)
    {
      this->Vector_.set (x);
    }


    // SphereCheckedType
    // 

    const SphereCheckedType::Measured_optional& SphereCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    SphereCheckedType::Measured_optional& SphereCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void SphereCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void SphereCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void SphereCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const SphereCheckedType::Constructed_optional& SphereCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SphereCheckedType::Constructed_optional& SphereCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SphereCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SphereCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SphereCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // SphereCheckedFeatureType
    // 

    const SphereCheckedFeatureType::CheckDetails_optional& SphereCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    SphereCheckedFeatureType::CheckDetails_optional& SphereCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void SphereCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void SphereCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void SphereCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // SphereActualDeterminationType
    // 

    const SphereActualDeterminationType::Checked_optional& SphereActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    SphereActualDeterminationType::Checked_optional& SphereActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void SphereActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void SphereActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void SphereActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const SphereActualDeterminationType::Set_optional& SphereActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    SphereActualDeterminationType::Set_optional& SphereActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void SphereActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void SphereActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void SphereActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // SphereFeatureItemType
    // 

    const SphereFeatureItemType::DeterminationMode_type& SphereFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    SphereFeatureItemType::DeterminationMode_type& SphereFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void SphereFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void SphereFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const SphereFeatureItemType::SubstituteFeatureAlgorithm_optional& SphereFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    SphereFeatureItemType::SubstituteFeatureAlgorithm_optional& SphereFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void SphereFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void SphereFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void SphereFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // SphereFeatureDefinitionType
    // 

    const SphereFeatureDefinitionType::InternalExternal_type& SphereFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    SphereFeatureDefinitionType::InternalExternal_type& SphereFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void SphereFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void SphereFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const SphereFeatureDefinitionType::Diameter_type& SphereFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    SphereFeatureDefinitionType::Diameter_type& SphereFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void SphereFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphereFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }


    // SphereFeatureNominalType
    // 

    const SphereFeatureNominalType::Location_type& SphereFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    SphereFeatureNominalType::Location_type& SphereFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void SphereFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphereFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const SphereFeatureNominalType::LatitudeLongitudeSweep_optional& SphereFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    SphereFeatureNominalType::LatitudeLongitudeSweep_optional& SphereFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void SphereFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void SphereFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void SphereFeatureNominalType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }


    // SphereFeatureActualType
    // 

    const SphereFeatureActualType::Location_optional& SphereFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    SphereFeatureActualType::Location_optional& SphereFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void SphereFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphereFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void SphereFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const SphereFeatureActualType::Diameter_optional& SphereFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    SphereFeatureActualType::Diameter_optional& SphereFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void SphereFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphereFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void SphereFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const SphereFeatureActualType::DiameterMin_optional& SphereFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    SphereFeatureActualType::DiameterMin_optional& SphereFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void SphereFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void SphereFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void SphereFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const SphereFeatureActualType::DiameterMax_optional& SphereFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    SphereFeatureActualType::DiameterMax_optional& SphereFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void SphereFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void SphereFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void SphereFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const SphereFeatureActualType::LatitudeLongitudeSweep_optional& SphereFeatureActualType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    SphereFeatureActualType::LatitudeLongitudeSweep_optional& SphereFeatureActualType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void SphereFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void SphereFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void SphereFeatureActualType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    const SphereFeatureActualType::Form_optional& SphereFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    SphereFeatureActualType::Form_optional& SphereFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void SphereFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void SphereFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void SphereFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // SphericalSegmentConstructionMethodType
    // 

    const SphericalSegmentConstructionMethodType::BestFit_optional& SphericalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    SphericalSegmentConstructionMethodType::BestFit_optional& SphericalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void SphericalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const SphericalSegmentConstructionMethodType::Recompensated_optional& SphericalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    SphericalSegmentConstructionMethodType::Recompensated_optional& SphericalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void SphericalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const SphericalSegmentConstructionMethodType::Copy_optional& SphericalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    SphericalSegmentConstructionMethodType::Copy_optional& SphericalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void SphericalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const SphericalSegmentConstructionMethodType::Cast_optional& SphericalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    SphericalSegmentConstructionMethodType::Cast_optional& SphericalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void SphericalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const SphericalSegmentConstructionMethodType::Transform_optional& SphericalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    SphericalSegmentConstructionMethodType::Transform_optional& SphericalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void SphericalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // SphericalSegmentBestFitType
    // 

    const SphericalSegmentBestFitType::BaseFeature_sequence& SphericalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    SphericalSegmentBestFitType::BaseFeature_sequence& SphericalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void SphericalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // SphericalSegmentRecompType
    // 

    const SphericalSegmentRecompType::BaseFeaturePointList_type& SphericalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    SphericalSegmentRecompType::BaseFeaturePointList_type& SphericalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void SphericalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void SphericalSegmentRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // SphericalSegmentCopyType
    // 

    const SphericalSegmentCopyType::BaseSphericalSegment_type& SphericalSegmentCopyType::
    BaseSphericalSegment () const
    {
      return this->BaseSphericalSegment_.get ();
    }

    SphericalSegmentCopyType::BaseSphericalSegment_type& SphericalSegmentCopyType::
    BaseSphericalSegment ()
    {
      return this->BaseSphericalSegment_.get ();
    }

    void SphericalSegmentCopyType::
    BaseSphericalSegment (const BaseSphericalSegment_type& x)
    {
      this->BaseSphericalSegment_.set (x);
    }

    void SphericalSegmentCopyType::
    BaseSphericalSegment (::std::auto_ptr< BaseSphericalSegment_type > x)
    {
      this->BaseSphericalSegment_.set (x);
    }


    // SphericalSegmentCastType
    // 

    const SphericalSegmentCastType::BaseFeature_type& SphericalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    SphericalSegmentCastType::BaseFeature_type& SphericalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void SphericalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void SphericalSegmentCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // SphericalSegmentTransformType
    // 

    const SphericalSegmentTransformType::BaseSphericalSegment_type& SphericalSegmentTransformType::
    BaseSphericalSegment () const
    {
      return this->BaseSphericalSegment_.get ();
    }

    SphericalSegmentTransformType::BaseSphericalSegment_type& SphericalSegmentTransformType::
    BaseSphericalSegment ()
    {
      return this->BaseSphericalSegment_.get ();
    }

    void SphericalSegmentTransformType::
    BaseSphericalSegment (const BaseSphericalSegment_type& x)
    {
      this->BaseSphericalSegment_.set (x);
    }

    void SphericalSegmentTransformType::
    BaseSphericalSegment (::std::auto_ptr< BaseSphericalSegment_type > x)
    {
      this->BaseSphericalSegment_.set (x);
    }

    const SphericalSegmentTransformType::Transformation_type& SphericalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    SphericalSegmentTransformType::Transformation_type& SphericalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void SphericalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void SphericalSegmentTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // SphericalSegmentCheckedType
    // 

    const SphericalSegmentCheckedType::Measured_optional& SphericalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    SphericalSegmentCheckedType::Measured_optional& SphericalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void SphericalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void SphericalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void SphericalSegmentCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const SphericalSegmentCheckedType::Constructed_optional& SphericalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SphericalSegmentCheckedType::Constructed_optional& SphericalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SphericalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SphericalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SphericalSegmentCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // SphericalSegmentCheckedFeatureType
    // 

    const SphericalSegmentCheckedFeatureType::CheckDetails_optional& SphericalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    SphericalSegmentCheckedFeatureType::CheckDetails_optional& SphericalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void SphericalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void SphericalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void SphericalSegmentCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // SphericalSegmentActualDeterminationType
    // 

    const SphericalSegmentActualDeterminationType::Checked_optional& SphericalSegmentActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    SphericalSegmentActualDeterminationType::Checked_optional& SphericalSegmentActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void SphericalSegmentActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void SphericalSegmentActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void SphericalSegmentActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const SphericalSegmentActualDeterminationType::Set_optional& SphericalSegmentActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    SphericalSegmentActualDeterminationType::Set_optional& SphericalSegmentActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void SphericalSegmentActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void SphericalSegmentActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void SphericalSegmentActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // SphericalSegmentFeatureItemType
    // 

    const SphericalSegmentFeatureItemType::DeterminationMode_type& SphericalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    SphericalSegmentFeatureItemType::DeterminationMode_type& SphericalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void SphericalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void SphericalSegmentFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const SphericalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& SphericalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    SphericalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& SphericalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void SphericalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void SphericalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void SphericalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // SphericalSegmentFeatureDefinitionType
    // 

    const SphericalSegmentFeatureDefinitionType::InternalExternal_type& SphericalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    SphericalSegmentFeatureDefinitionType::InternalExternal_type& SphericalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void SphericalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void SphericalSegmentFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const SphericalSegmentFeatureDefinitionType::Diameter_type& SphericalSegmentFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    SphericalSegmentFeatureDefinitionType::Diameter_type& SphericalSegmentFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void SphericalSegmentFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphericalSegmentFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }


    // SphericalSegmentFeatureNominalType
    // 

    const SphericalSegmentFeatureNominalType::Location_type& SphericalSegmentFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    SphericalSegmentFeatureNominalType::Location_type& SphericalSegmentFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void SphericalSegmentFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphericalSegmentFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const SphericalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    SphericalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    void SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }


    // SphericalSegmentFeatureActualType
    // 

    const SphericalSegmentFeatureActualType::Location_optional& SphericalSegmentFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    SphericalSegmentFeatureActualType::Location_optional& SphericalSegmentFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void SphericalSegmentFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void SphericalSegmentFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const SphericalSegmentFeatureActualType::Diameter_optional& SphericalSegmentFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    SphericalSegmentFeatureActualType::Diameter_optional& SphericalSegmentFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void SphericalSegmentFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void SphericalSegmentFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const SphericalSegmentFeatureActualType::DiameterMin_optional& SphericalSegmentFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    SphericalSegmentFeatureActualType::DiameterMin_optional& SphericalSegmentFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void SphericalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void SphericalSegmentFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const SphericalSegmentFeatureActualType::DiameterMax_optional& SphericalSegmentFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    SphericalSegmentFeatureActualType::DiameterMax_optional& SphericalSegmentFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void SphericalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void SphericalSegmentFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const SphericalSegmentFeatureActualType::LatitudeLongitudeSweep_optional& SphericalSegmentFeatureActualType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    SphericalSegmentFeatureActualType::LatitudeLongitudeSweep_optional& SphericalSegmentFeatureActualType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void SphericalSegmentFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void SphericalSegmentFeatureActualType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    const SphericalSegmentFeatureActualType::Form_optional& SphericalSegmentFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    SphericalSegmentFeatureActualType::Form_optional& SphericalSegmentFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void SphericalSegmentFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void SphericalSegmentFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // SurfaceOfRevolutionConstructionMethodType
    // 

    const SurfaceOfRevolutionConstructionMethodType::BestFit_optional& SurfaceOfRevolutionConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    SurfaceOfRevolutionConstructionMethodType::BestFit_optional& SurfaceOfRevolutionConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const SurfaceOfRevolutionConstructionMethodType::Recompensated_optional& SurfaceOfRevolutionConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    SurfaceOfRevolutionConstructionMethodType::Recompensated_optional& SurfaceOfRevolutionConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const SurfaceOfRevolutionConstructionMethodType::Copy_optional& SurfaceOfRevolutionConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    SurfaceOfRevolutionConstructionMethodType::Copy_optional& SurfaceOfRevolutionConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const SurfaceOfRevolutionConstructionMethodType::Cast_optional& SurfaceOfRevolutionConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    SurfaceOfRevolutionConstructionMethodType::Cast_optional& SurfaceOfRevolutionConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const SurfaceOfRevolutionConstructionMethodType::Transform_optional& SurfaceOfRevolutionConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    SurfaceOfRevolutionConstructionMethodType::Transform_optional& SurfaceOfRevolutionConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // SurfaceOfRevolutionBestFitType
    // 

    const SurfaceOfRevolutionBestFitType::BaseFeature_sequence& SurfaceOfRevolutionBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    SurfaceOfRevolutionBestFitType::BaseFeature_sequence& SurfaceOfRevolutionBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void SurfaceOfRevolutionBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // SurfaceOfRevolutionRecompType
    // 

    const SurfaceOfRevolutionRecompType::BaseFeaturePointList_type& SurfaceOfRevolutionRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    SurfaceOfRevolutionRecompType::BaseFeaturePointList_type& SurfaceOfRevolutionRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void SurfaceOfRevolutionRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void SurfaceOfRevolutionRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // SurfaceOfRevolutionCopyType
    // 

    const SurfaceOfRevolutionCopyType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution () const
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    SurfaceOfRevolutionCopyType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution ()
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    void SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution (const BaseSurfaceOfRevolution_type& x)
    {
      this->BaseSurfaceOfRevolution_.set (x);
    }

    void SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution (::std::auto_ptr< BaseSurfaceOfRevolution_type > x)
    {
      this->BaseSurfaceOfRevolution_.set (x);
    }


    // SurfaceOfRevolutionCastType
    // 

    const SurfaceOfRevolutionCastType::BaseFeature_type& SurfaceOfRevolutionCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    SurfaceOfRevolutionCastType::BaseFeature_type& SurfaceOfRevolutionCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void SurfaceOfRevolutionCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void SurfaceOfRevolutionCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // SurfaceOfRevolutionTransformType
    // 

    const SurfaceOfRevolutionTransformType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution () const
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    SurfaceOfRevolutionTransformType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution ()
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    void SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution (const BaseSurfaceOfRevolution_type& x)
    {
      this->BaseSurfaceOfRevolution_.set (x);
    }

    void SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution (::std::auto_ptr< BaseSurfaceOfRevolution_type > x)
    {
      this->BaseSurfaceOfRevolution_.set (x);
    }

    const SurfaceOfRevolutionTransformType::Transformation_type& SurfaceOfRevolutionTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    SurfaceOfRevolutionTransformType::Transformation_type& SurfaceOfRevolutionTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void SurfaceOfRevolutionTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void SurfaceOfRevolutionTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // SurfaceOfRevolutionCheckedType
    // 

    const SurfaceOfRevolutionCheckedType::Measured_optional& SurfaceOfRevolutionCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    SurfaceOfRevolutionCheckedType::Measured_optional& SurfaceOfRevolutionCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void SurfaceOfRevolutionCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void SurfaceOfRevolutionCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void SurfaceOfRevolutionCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const SurfaceOfRevolutionCheckedType::Constructed_optional& SurfaceOfRevolutionCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SurfaceOfRevolutionCheckedType::Constructed_optional& SurfaceOfRevolutionCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SurfaceOfRevolutionCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SurfaceOfRevolutionCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SurfaceOfRevolutionCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // SurfaceOfRevolutionCheckedFeatureType
    // 

    const SurfaceOfRevolutionCheckedFeatureType::CheckDetails_optional& SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    SurfaceOfRevolutionCheckedFeatureType::CheckDetails_optional& SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // SurfaceOfRevolutionActualDeterminationType
    // 

    const SurfaceOfRevolutionActualDeterminationType::Checked_optional& SurfaceOfRevolutionActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    SurfaceOfRevolutionActualDeterminationType::Checked_optional& SurfaceOfRevolutionActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const SurfaceOfRevolutionActualDeterminationType::Set_optional& SurfaceOfRevolutionActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    SurfaceOfRevolutionActualDeterminationType::Set_optional& SurfaceOfRevolutionActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // SurfaceOfRevolutionFeatureItemType
    // 

    const SurfaceOfRevolutionFeatureItemType::DeterminationMode_type& SurfaceOfRevolutionFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    SurfaceOfRevolutionFeatureItemType::DeterminationMode_type& SurfaceOfRevolutionFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void SurfaceOfRevolutionFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void SurfaceOfRevolutionFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const SurfaceOfRevolutionFeatureItemType::SubstituteFeatureAlgorithm_optional& SurfaceOfRevolutionFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    SurfaceOfRevolutionFeatureItemType::SubstituteFeatureAlgorithm_optional& SurfaceOfRevolutionFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void SurfaceOfRevolutionFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void SurfaceOfRevolutionFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void SurfaceOfRevolutionFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // SurfaceOfRevolutionFeatureDefinitionType
    // 

    const SurfaceOfRevolutionFeatureDefinitionType::InternalExternal_type& SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    SurfaceOfRevolutionFeatureDefinitionType::InternalExternal_type& SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const SurfaceOfRevolutionFeatureDefinitionType::Length_optional& SurfaceOfRevolutionFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    SurfaceOfRevolutionFeatureDefinitionType::Length_optional& SurfaceOfRevolutionFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }


    // SurfaceOfRevolutionFeatureNominalType
    // 

    const SurfaceOfRevolutionFeatureNominalType::Axis_type& SurfaceOfRevolutionFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    SurfaceOfRevolutionFeatureNominalType::Axis_type& SurfaceOfRevolutionFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const SurfaceOfRevolutionFeatureNominalType::Sweep_optional& SurfaceOfRevolutionFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_;
    }

    SurfaceOfRevolutionFeatureNominalType::Sweep_optional& SurfaceOfRevolutionFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const SurfaceOfRevolutionFeatureNominalType::ReferenceFeatureNominalId_type& SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId () const
    {
      return this->ReferenceFeatureNominalId_.get ();
    }

    SurfaceOfRevolutionFeatureNominalType::ReferenceFeatureNominalId_type& SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId ()
    {
      return this->ReferenceFeatureNominalId_.get ();
    }

    void SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId (const ReferenceFeatureNominalId_type& x)
    {
      this->ReferenceFeatureNominalId_.set (x);
    }

    void SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId (::std::auto_ptr< ReferenceFeatureNominalId_type > x)
    {
      this->ReferenceFeatureNominalId_.set (x);
    }


    // SurfaceOfRevolutionFeatureActualType
    // 

    const SurfaceOfRevolutionFeatureActualType::Axis_optional& SurfaceOfRevolutionFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    SurfaceOfRevolutionFeatureActualType::Axis_optional& SurfaceOfRevolutionFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void SurfaceOfRevolutionFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const SurfaceOfRevolutionFeatureActualType::Sweep_optional& SurfaceOfRevolutionFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    SurfaceOfRevolutionFeatureActualType::Sweep_optional& SurfaceOfRevolutionFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void SurfaceOfRevolutionFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const SurfaceOfRevolutionFeatureActualType::Length_optional& SurfaceOfRevolutionFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    SurfaceOfRevolutionFeatureActualType::Length_optional& SurfaceOfRevolutionFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void SurfaceOfRevolutionFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const SurfaceOfRevolutionFeatureActualType::Form_optional& SurfaceOfRevolutionFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    SurfaceOfRevolutionFeatureActualType::Form_optional& SurfaceOfRevolutionFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void SurfaceOfRevolutionFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // ThreadedFeatureConstructionMethodType
    // 

    const ThreadedFeatureConstructionMethodType::BestFit_optional& ThreadedFeatureConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ThreadedFeatureConstructionMethodType::BestFit_optional& ThreadedFeatureConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ThreadedFeatureConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ThreadedFeatureConstructionMethodType::Recompensated_optional& ThreadedFeatureConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ThreadedFeatureConstructionMethodType::Recompensated_optional& ThreadedFeatureConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ThreadedFeatureConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ThreadedFeatureConstructionMethodType::Copy_optional& ThreadedFeatureConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ThreadedFeatureConstructionMethodType::Copy_optional& ThreadedFeatureConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ThreadedFeatureConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ThreadedFeatureConstructionMethodType::Cast_optional& ThreadedFeatureConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ThreadedFeatureConstructionMethodType::Cast_optional& ThreadedFeatureConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ThreadedFeatureConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ThreadedFeatureConstructionMethodType::Transform_optional& ThreadedFeatureConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ThreadedFeatureConstructionMethodType::Transform_optional& ThreadedFeatureConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ThreadedFeatureConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const ThreadedFeatureConstructionMethodType::FromCylinder_optional& ThreadedFeatureConstructionMethodType::
    FromCylinder () const
    {
      return this->FromCylinder_;
    }

    ThreadedFeatureConstructionMethodType::FromCylinder_optional& ThreadedFeatureConstructionMethodType::
    FromCylinder ()
    {
      return this->FromCylinder_;
    }

    void ThreadedFeatureConstructionMethodType::
    FromCylinder (const FromCylinder_type& x)
    {
      this->FromCylinder_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    FromCylinder (const FromCylinder_optional& x)
    {
      this->FromCylinder_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    FromCylinder (::std::auto_ptr< FromCylinder_type > x)
    {
      this->FromCylinder_.set (x);
    }


    // ThreadedFeatureBestFitType
    // 

    const ThreadedFeatureBestFitType::BaseFeature_sequence& ThreadedFeatureBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ThreadedFeatureBestFitType::BaseFeature_sequence& ThreadedFeatureBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ThreadedFeatureBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ThreadedFeatureRecompType
    // 

    const ThreadedFeatureRecompType::BaseFeaturePointList_type& ThreadedFeatureRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ThreadedFeatureRecompType::BaseFeaturePointList_type& ThreadedFeatureRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ThreadedFeatureRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ThreadedFeatureRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ThreadedFeatureCopyType
    // 

    const ThreadedFeatureCopyType::BaseThreadedFeature_type& ThreadedFeatureCopyType::
    BaseThreadedFeature () const
    {
      return this->BaseThreadedFeature_.get ();
    }

    ThreadedFeatureCopyType::BaseThreadedFeature_type& ThreadedFeatureCopyType::
    BaseThreadedFeature ()
    {
      return this->BaseThreadedFeature_.get ();
    }

    void ThreadedFeatureCopyType::
    BaseThreadedFeature (const BaseThreadedFeature_type& x)
    {
      this->BaseThreadedFeature_.set (x);
    }

    void ThreadedFeatureCopyType::
    BaseThreadedFeature (::std::auto_ptr< BaseThreadedFeature_type > x)
    {
      this->BaseThreadedFeature_.set (x);
    }


    // ThreadedFeatureCastType
    // 

    const ThreadedFeatureCastType::BaseFeature_type& ThreadedFeatureCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ThreadedFeatureCastType::BaseFeature_type& ThreadedFeatureCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ThreadedFeatureCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ThreadedFeatureCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ThreadedFeatureTransformType
    // 

    const ThreadedFeatureTransformType::BaseThreadedFeature_type& ThreadedFeatureTransformType::
    BaseThreadedFeature () const
    {
      return this->BaseThreadedFeature_.get ();
    }

    ThreadedFeatureTransformType::BaseThreadedFeature_type& ThreadedFeatureTransformType::
    BaseThreadedFeature ()
    {
      return this->BaseThreadedFeature_.get ();
    }

    void ThreadedFeatureTransformType::
    BaseThreadedFeature (const BaseThreadedFeature_type& x)
    {
      this->BaseThreadedFeature_.set (x);
    }

    void ThreadedFeatureTransformType::
    BaseThreadedFeature (::std::auto_ptr< BaseThreadedFeature_type > x)
    {
      this->BaseThreadedFeature_.set (x);
    }

    const ThreadedFeatureTransformType::Transformation_type& ThreadedFeatureTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ThreadedFeatureTransformType::Transformation_type& ThreadedFeatureTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ThreadedFeatureTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ThreadedFeatureTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ThreadedFeatureFromCylinderType
    // 

    const ThreadedFeatureFromCylinderType::BaseCylinder_type& ThreadedFeatureFromCylinderType::
    BaseCylinder () const
    {
      return this->BaseCylinder_.get ();
    }

    ThreadedFeatureFromCylinderType::BaseCylinder_type& ThreadedFeatureFromCylinderType::
    BaseCylinder ()
    {
      return this->BaseCylinder_.get ();
    }

    void ThreadedFeatureFromCylinderType::
    BaseCylinder (const BaseCylinder_type& x)
    {
      this->BaseCylinder_.set (x);
    }

    void ThreadedFeatureFromCylinderType::
    BaseCylinder (::std::auto_ptr< BaseCylinder_type > x)
    {
      this->BaseCylinder_.set (x);
    }

    const ThreadedFeatureFromCylinderType::Offset_optional& ThreadedFeatureFromCylinderType::
    Offset () const
    {
      return this->Offset_;
    }

    ThreadedFeatureFromCylinderType::Offset_optional& ThreadedFeatureFromCylinderType::
    Offset ()
    {
      return this->Offset_;
    }

    void ThreadedFeatureFromCylinderType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void ThreadedFeatureFromCylinderType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    void ThreadedFeatureFromCylinderType::
    Offset (::std::auto_ptr< Offset_type > x)
    {
      this->Offset_.set (x);
    }


    // ThreadedFeatureCheckedType
    // 

    const ThreadedFeatureCheckedType::Measured_optional& ThreadedFeatureCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ThreadedFeatureCheckedType::Measured_optional& ThreadedFeatureCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ThreadedFeatureCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ThreadedFeatureCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ThreadedFeatureCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ThreadedFeatureCheckedType::Constructed_optional& ThreadedFeatureCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ThreadedFeatureCheckedType::Constructed_optional& ThreadedFeatureCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ThreadedFeatureCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ThreadedFeatureCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ThreadedFeatureCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ThreadedFeatureCheckedFeatureType
    // 

    const ThreadedFeatureCheckedFeatureType::CheckDetails_optional& ThreadedFeatureCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ThreadedFeatureCheckedFeatureType::CheckDetails_optional& ThreadedFeatureCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ThreadedFeatureCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ThreadedFeatureCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ThreadedFeatureCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ThreadedFeatureActualDeterminationType
    // 

    const ThreadedFeatureActualDeterminationType::Checked_optional& ThreadedFeatureActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ThreadedFeatureActualDeterminationType::Checked_optional& ThreadedFeatureActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ThreadedFeatureActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ThreadedFeatureActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ThreadedFeatureActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ThreadedFeatureActualDeterminationType::Set_optional& ThreadedFeatureActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ThreadedFeatureActualDeterminationType::Set_optional& ThreadedFeatureActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ThreadedFeatureActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ThreadedFeatureActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ThreadedFeatureActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ThreadedFeatureItemType
    // 

    const ThreadedFeatureItemType::DeterminationMode_type& ThreadedFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ThreadedFeatureItemType::DeterminationMode_type& ThreadedFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ThreadedFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ThreadedFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ThreadedFeatureItemType::SubstituteFeatureAlgorithm_optional& ThreadedFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ThreadedFeatureItemType::SubstituteFeatureAlgorithm_optional& ThreadedFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ThreadedFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ThreadedFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ThreadedFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ThreadedFeatureDefinitionType
    // 

    const ThreadedFeatureDefinitionType::InternalExternal_type& ThreadedFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ThreadedFeatureDefinitionType::InternalExternal_type& ThreadedFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ThreadedFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ThreadedFeatureDefinitionType::ThreadSpecificationId_type& ThreadedFeatureDefinitionType::
    ThreadSpecificationId () const
    {
      return this->ThreadSpecificationId_.get ();
    }

    ThreadedFeatureDefinitionType::ThreadSpecificationId_type& ThreadedFeatureDefinitionType::
    ThreadSpecificationId ()
    {
      return this->ThreadSpecificationId_.get ();
    }

    void ThreadedFeatureDefinitionType::
    ThreadSpecificationId (const ThreadSpecificationId_type& x)
    {
      this->ThreadSpecificationId_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    ThreadSpecificationId (::std::auto_ptr< ThreadSpecificationId_type > x)
    {
      this->ThreadSpecificationId_.set (x);
    }

    const ThreadedFeatureDefinitionType::Length_optional& ThreadedFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    ThreadedFeatureDefinitionType::Length_optional& ThreadedFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void ThreadedFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ThreadedFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const ThreadedFeatureDefinitionType::Bottom_optional& ThreadedFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    ThreadedFeatureDefinitionType::Bottom_optional& ThreadedFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void ThreadedFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void ThreadedFeatureDefinitionType::
    Bottom (::std::auto_ptr< Bottom_type > x)
    {
      this->Bottom_.set (x);
    }


    // ThreadedFeatureNominalType
    // 

    const ThreadedFeatureNominalType::Axis_type& ThreadedFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    ThreadedFeatureNominalType::Axis_type& ThreadedFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void ThreadedFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ThreadedFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }


    // ThreadedFeatureActualType
    // 

    const ThreadedFeatureActualType::Axis_optional& ThreadedFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    ThreadedFeatureActualType::Axis_optional& ThreadedFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void ThreadedFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ThreadedFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void ThreadedFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const ThreadedFeatureActualType::PitchDiameter_optional& ThreadedFeatureActualType::
    PitchDiameter () const
    {
      return this->PitchDiameter_;
    }

    ThreadedFeatureActualType::PitchDiameter_optional& ThreadedFeatureActualType::
    PitchDiameter ()
    {
      return this->PitchDiameter_;
    }

    void ThreadedFeatureActualType::
    PitchDiameter (const PitchDiameter_type& x)
    {
      this->PitchDiameter_.set (x);
    }

    void ThreadedFeatureActualType::
    PitchDiameter (const PitchDiameter_optional& x)
    {
      this->PitchDiameter_ = x;
    }

    void ThreadedFeatureActualType::
    PitchDiameter (::std::auto_ptr< PitchDiameter_type > x)
    {
      this->PitchDiameter_.set (x);
    }

    const ThreadedFeatureActualType::FunctionalSize_optional& ThreadedFeatureActualType::
    FunctionalSize () const
    {
      return this->FunctionalSize_;
    }

    ThreadedFeatureActualType::FunctionalSize_optional& ThreadedFeatureActualType::
    FunctionalSize ()
    {
      return this->FunctionalSize_;
    }

    void ThreadedFeatureActualType::
    FunctionalSize (const FunctionalSize_type& x)
    {
      this->FunctionalSize_.set (x);
    }

    void ThreadedFeatureActualType::
    FunctionalSize (const FunctionalSize_optional& x)
    {
      this->FunctionalSize_ = x;
    }

    void ThreadedFeatureActualType::
    FunctionalSize (::std::auto_ptr< FunctionalSize_type > x)
    {
      this->FunctionalSize_.set (x);
    }

    const ThreadedFeatureActualType::Length_optional& ThreadedFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    ThreadedFeatureActualType::Length_optional& ThreadedFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void ThreadedFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ThreadedFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ThreadedFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }


    // ToroidalSegmentConstructionMethodType
    // 

    const ToroidalSegmentConstructionMethodType::BestFit_optional& ToroidalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ToroidalSegmentConstructionMethodType::BestFit_optional& ToroidalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ToroidalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ToroidalSegmentConstructionMethodType::Recompensated_optional& ToroidalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ToroidalSegmentConstructionMethodType::Recompensated_optional& ToroidalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ToroidalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ToroidalSegmentConstructionMethodType::Copy_optional& ToroidalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ToroidalSegmentConstructionMethodType::Copy_optional& ToroidalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ToroidalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ToroidalSegmentConstructionMethodType::Cast_optional& ToroidalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ToroidalSegmentConstructionMethodType::Cast_optional& ToroidalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ToroidalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ToroidalSegmentConstructionMethodType::Transform_optional& ToroidalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ToroidalSegmentConstructionMethodType::Transform_optional& ToroidalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ToroidalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // ToroidalSegmentBestFitType
    // 

    const ToroidalSegmentBestFitType::BaseFeature_sequence& ToroidalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ToroidalSegmentBestFitType::BaseFeature_sequence& ToroidalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ToroidalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ToroidalSegmentRecompType
    // 

    const ToroidalSegmentRecompType::BaseFeaturePointList_type& ToroidalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ToroidalSegmentRecompType::BaseFeaturePointList_type& ToroidalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ToroidalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ToroidalSegmentRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ToroidalSegmentCopyType
    // 

    const ToroidalSegmentCopyType::BaseToroidalSegment_type& ToroidalSegmentCopyType::
    BaseToroidalSegment () const
    {
      return this->BaseToroidalSegment_.get ();
    }

    ToroidalSegmentCopyType::BaseToroidalSegment_type& ToroidalSegmentCopyType::
    BaseToroidalSegment ()
    {
      return this->BaseToroidalSegment_.get ();
    }

    void ToroidalSegmentCopyType::
    BaseToroidalSegment (const BaseToroidalSegment_type& x)
    {
      this->BaseToroidalSegment_.set (x);
    }

    void ToroidalSegmentCopyType::
    BaseToroidalSegment (::std::auto_ptr< BaseToroidalSegment_type > x)
    {
      this->BaseToroidalSegment_.set (x);
    }


    // ToroidalSegmentCastType
    // 

    const ToroidalSegmentCastType::BaseFeature_type& ToroidalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ToroidalSegmentCastType::BaseFeature_type& ToroidalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ToroidalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ToroidalSegmentCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ToroidalSegmentTransformType
    // 

    const ToroidalSegmentTransformType::BaseToroidalSegment_type& ToroidalSegmentTransformType::
    BaseToroidalSegment () const
    {
      return this->BaseToroidalSegment_.get ();
    }

    ToroidalSegmentTransformType::BaseToroidalSegment_type& ToroidalSegmentTransformType::
    BaseToroidalSegment ()
    {
      return this->BaseToroidalSegment_.get ();
    }

    void ToroidalSegmentTransformType::
    BaseToroidalSegment (const BaseToroidalSegment_type& x)
    {
      this->BaseToroidalSegment_.set (x);
    }

    void ToroidalSegmentTransformType::
    BaseToroidalSegment (::std::auto_ptr< BaseToroidalSegment_type > x)
    {
      this->BaseToroidalSegment_.set (x);
    }

    const ToroidalSegmentTransformType::Transformation_type& ToroidalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ToroidalSegmentTransformType::Transformation_type& ToroidalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ToroidalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ToroidalSegmentTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ToroidalSegmentCheckedType
    // 

    const ToroidalSegmentCheckedType::Measured_optional& ToroidalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ToroidalSegmentCheckedType::Measured_optional& ToroidalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ToroidalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ToroidalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ToroidalSegmentCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ToroidalSegmentCheckedType::Constructed_optional& ToroidalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ToroidalSegmentCheckedType::Constructed_optional& ToroidalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ToroidalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ToroidalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ToroidalSegmentCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ToroidalSegmentCheckedFeatureType
    // 

    const ToroidalSegmentCheckedFeatureType::CheckDetails_optional& ToroidalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ToroidalSegmentCheckedFeatureType::CheckDetails_optional& ToroidalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ToroidalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ToroidalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ToroidalSegmentCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ToroidalSegmentActualDeterminationType
    // 

    const ToroidalSegmentActualDeterminationType::Checked_optional& ToroidalSegmentActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ToroidalSegmentActualDeterminationType::Checked_optional& ToroidalSegmentActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ToroidalSegmentActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ToroidalSegmentActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ToroidalSegmentActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ToroidalSegmentActualDeterminationType::Set_optional& ToroidalSegmentActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ToroidalSegmentActualDeterminationType::Set_optional& ToroidalSegmentActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ToroidalSegmentActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ToroidalSegmentActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ToroidalSegmentActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ToroidalSegmentFeatureItemType
    // 

    const ToroidalSegmentFeatureItemType::DeterminationMode_type& ToroidalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ToroidalSegmentFeatureItemType::DeterminationMode_type& ToroidalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ToroidalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ToroidalSegmentFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ToroidalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& ToroidalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ToroidalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& ToroidalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ToroidalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ToroidalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ToroidalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ToroidalSegmentFeatureDefinitionType
    // 

    const ToroidalSegmentFeatureDefinitionType::InternalExternal_type& ToroidalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ToroidalSegmentFeatureDefinitionType::InternalExternal_type& ToroidalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ToroidalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ToroidalSegmentFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ToroidalSegmentFeatureDefinitionType::MinorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MinorDiameter () const
    {
      return this->MinorDiameter_.get ();
    }

    ToroidalSegmentFeatureDefinitionType::MinorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MinorDiameter ()
    {
      return this->MinorDiameter_.get ();
    }

    void ToroidalSegmentFeatureDefinitionType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureDefinitionType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }

    const ToroidalSegmentFeatureDefinitionType::MajorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MajorDiameter () const
    {
      return this->MajorDiameter_.get ();
    }

    ToroidalSegmentFeatureDefinitionType::MajorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MajorDiameter ()
    {
      return this->MajorDiameter_.get ();
    }

    void ToroidalSegmentFeatureDefinitionType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureDefinitionType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }


    // ToroidalSegmentFeatureNominalType
    // 

    const ToroidalSegmentFeatureNominalType::Location_type& ToroidalSegmentFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    ToroidalSegmentFeatureNominalType::Location_type& ToroidalSegmentFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void ToroidalSegmentFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void ToroidalSegmentFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const ToroidalSegmentFeatureNominalType::AxisVector_type& ToroidalSegmentFeatureNominalType::
    AxisVector () const
    {
      return this->AxisVector_.get ();
    }

    ToroidalSegmentFeatureNominalType::AxisVector_type& ToroidalSegmentFeatureNominalType::
    AxisVector ()
    {
      return this->AxisVector_.get ();
    }

    void ToroidalSegmentFeatureNominalType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void ToroidalSegmentFeatureNominalType::
    AxisVector (::std::auto_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (x);
    }

    const ToroidalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    ToroidalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    void ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }


    // ToroidalSegmentFeatureActualType
    // 

    const ToroidalSegmentFeatureActualType::Location_optional& ToroidalSegmentFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    ToroidalSegmentFeatureActualType::Location_optional& ToroidalSegmentFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void ToroidalSegmentFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const ToroidalSegmentFeatureActualType::AxisVector_optional& ToroidalSegmentFeatureActualType::
    AxisVector () const
    {
      return this->AxisVector_;
    }

    ToroidalSegmentFeatureActualType::AxisVector_optional& ToroidalSegmentFeatureActualType::
    AxisVector ()
    {
      return this->AxisVector_;
    }

    void ToroidalSegmentFeatureActualType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    AxisVector (const AxisVector_optional& x)
    {
      this->AxisVector_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    AxisVector (::std::auto_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (x);
    }

    const ToroidalSegmentFeatureActualType::MinorDiameter_optional& ToroidalSegmentFeatureActualType::
    MinorDiameter () const
    {
      return this->MinorDiameter_;
    }

    ToroidalSegmentFeatureActualType::MinorDiameter_optional& ToroidalSegmentFeatureActualType::
    MinorDiameter ()
    {
      return this->MinorDiameter_;
    }

    void ToroidalSegmentFeatureActualType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    MinorDiameter (const MinorDiameter_optional& x)
    {
      this->MinorDiameter_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }

    const ToroidalSegmentFeatureActualType::MajorDiameter_optional& ToroidalSegmentFeatureActualType::
    MajorDiameter () const
    {
      return this->MajorDiameter_;
    }

    ToroidalSegmentFeatureActualType::MajorDiameter_optional& ToroidalSegmentFeatureActualType::
    MajorDiameter ()
    {
      return this->MajorDiameter_;
    }

    void ToroidalSegmentFeatureActualType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    MajorDiameter (const MajorDiameter_optional& x)
    {
      this->MajorDiameter_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }

    const ToroidalSegmentFeatureActualType::LatitudeLongitudeSweep_optional& ToroidalSegmentFeatureActualType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    ToroidalSegmentFeatureActualType::LatitudeLongitudeSweep_optional& ToroidalSegmentFeatureActualType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void ToroidalSegmentFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    const ToroidalSegmentFeatureActualType::Form_optional& ToroidalSegmentFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ToroidalSegmentFeatureActualType::Form_optional& ToroidalSegmentFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ToroidalSegmentFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // TorusConstructionMethodType
    // 

    const TorusConstructionMethodType::BestFit_optional& TorusConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    TorusConstructionMethodType::BestFit_optional& TorusConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void TorusConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void TorusConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void TorusConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const TorusConstructionMethodType::Recompensated_optional& TorusConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    TorusConstructionMethodType::Recompensated_optional& TorusConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void TorusConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void TorusConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void TorusConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const TorusConstructionMethodType::Copy_optional& TorusConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    TorusConstructionMethodType::Copy_optional& TorusConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void TorusConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void TorusConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void TorusConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const TorusConstructionMethodType::Cast_optional& TorusConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    TorusConstructionMethodType::Cast_optional& TorusConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void TorusConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void TorusConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void TorusConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const TorusConstructionMethodType::Transform_optional& TorusConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    TorusConstructionMethodType::Transform_optional& TorusConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void TorusConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void TorusConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void TorusConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const TorusConstructionMethodType::FromScan_optional& TorusConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    TorusConstructionMethodType::FromScan_optional& TorusConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void TorusConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void TorusConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void TorusConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // TorusBestFitType
    // 

    const TorusBestFitType::BaseFeature_sequence& TorusBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    TorusBestFitType::BaseFeature_sequence& TorusBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void TorusBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // TorusRecompType
    // 

    const TorusRecompType::BaseFeaturePointList_type& TorusRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    TorusRecompType::BaseFeaturePointList_type& TorusRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void TorusRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void TorusRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // TorusCopyType
    // 

    const TorusCopyType::BaseTorus_type& TorusCopyType::
    BaseTorus () const
    {
      return this->BaseTorus_.get ();
    }

    TorusCopyType::BaseTorus_type& TorusCopyType::
    BaseTorus ()
    {
      return this->BaseTorus_.get ();
    }

    void TorusCopyType::
    BaseTorus (const BaseTorus_type& x)
    {
      this->BaseTorus_.set (x);
    }

    void TorusCopyType::
    BaseTorus (::std::auto_ptr< BaseTorus_type > x)
    {
      this->BaseTorus_.set (x);
    }


    // TorusCastType
    // 

    const TorusCastType::BaseFeature_type& TorusCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    TorusCastType::BaseFeature_type& TorusCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void TorusCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void TorusCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // TorusTransformType
    // 

    const TorusTransformType::BaseTorus_type& TorusTransformType::
    BaseTorus () const
    {
      return this->BaseTorus_.get ();
    }

    TorusTransformType::BaseTorus_type& TorusTransformType::
    BaseTorus ()
    {
      return this->BaseTorus_.get ();
    }

    void TorusTransformType::
    BaseTorus (const BaseTorus_type& x)
    {
      this->BaseTorus_.set (x);
    }

    void TorusTransformType::
    BaseTorus (::std::auto_ptr< BaseTorus_type > x)
    {
      this->BaseTorus_.set (x);
    }

    const TorusTransformType::Transformation_type& TorusTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    TorusTransformType::Transformation_type& TorusTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void TorusTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void TorusTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // TorusFromScanType
    // 

    const TorusFromScanType::SurfaceFeature_type& TorusFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    TorusFromScanType::SurfaceFeature_type& TorusFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void TorusFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void TorusFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const TorusFromScanType::SearchRadius_type& TorusFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    TorusFromScanType::SearchRadius_type& TorusFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void TorusFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void TorusFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // TorusCheckedType
    // 

    const TorusCheckedType::Measured_optional& TorusCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    TorusCheckedType::Measured_optional& TorusCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void TorusCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void TorusCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void TorusCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const TorusCheckedType::Constructed_optional& TorusCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    TorusCheckedType::Constructed_optional& TorusCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void TorusCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void TorusCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void TorusCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // TorusCheckedFeatureType
    // 

    const TorusCheckedFeatureType::CheckDetails_optional& TorusCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    TorusCheckedFeatureType::CheckDetails_optional& TorusCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void TorusCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void TorusCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void TorusCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // TorusActualDeterminationType
    // 

    const TorusActualDeterminationType::Checked_optional& TorusActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    TorusActualDeterminationType::Checked_optional& TorusActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void TorusActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void TorusActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void TorusActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const TorusActualDeterminationType::Set_optional& TorusActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    TorusActualDeterminationType::Set_optional& TorusActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void TorusActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void TorusActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void TorusActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // TorusFeatureItemType
    // 

    const TorusFeatureItemType::DeterminationMode_type& TorusFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    TorusFeatureItemType::DeterminationMode_type& TorusFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void TorusFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void TorusFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const TorusFeatureItemType::SubstituteFeatureAlgorithm_optional& TorusFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    TorusFeatureItemType::SubstituteFeatureAlgorithm_optional& TorusFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void TorusFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void TorusFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void TorusFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // TorusFeatureDefinitionType
    // 

    const TorusFeatureDefinitionType::InternalExternal_type& TorusFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    TorusFeatureDefinitionType::InternalExternal_type& TorusFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void TorusFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void TorusFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const TorusFeatureDefinitionType::MinorDiameter_type& TorusFeatureDefinitionType::
    MinorDiameter () const
    {
      return this->MinorDiameter_.get ();
    }

    TorusFeatureDefinitionType::MinorDiameter_type& TorusFeatureDefinitionType::
    MinorDiameter ()
    {
      return this->MinorDiameter_.get ();
    }

    void TorusFeatureDefinitionType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void TorusFeatureDefinitionType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }

    const TorusFeatureDefinitionType::MajorDiameter_type& TorusFeatureDefinitionType::
    MajorDiameter () const
    {
      return this->MajorDiameter_.get ();
    }

    TorusFeatureDefinitionType::MajorDiameter_type& TorusFeatureDefinitionType::
    MajorDiameter ()
    {
      return this->MajorDiameter_.get ();
    }

    void TorusFeatureDefinitionType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void TorusFeatureDefinitionType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }


    // TorusFeatureNominalType
    // 

    const TorusFeatureNominalType::Location_type& TorusFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    TorusFeatureNominalType::Location_type& TorusFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void TorusFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void TorusFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const TorusFeatureNominalType::AxisVector_type& TorusFeatureNominalType::
    AxisVector () const
    {
      return this->AxisVector_.get ();
    }

    TorusFeatureNominalType::AxisVector_type& TorusFeatureNominalType::
    AxisVector ()
    {
      return this->AxisVector_.get ();
    }

    void TorusFeatureNominalType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void TorusFeatureNominalType::
    AxisVector (::std::auto_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (x);
    }

    const TorusFeatureNominalType::LatitudeLongitudeSweep_optional& TorusFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    TorusFeatureNominalType::LatitudeLongitudeSweep_optional& TorusFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void TorusFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void TorusFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void TorusFeatureNominalType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }


    // TorusFeatureActualType
    // 

    const TorusFeatureActualType::Location_optional& TorusFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    TorusFeatureActualType::Location_optional& TorusFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void TorusFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void TorusFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void TorusFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const TorusFeatureActualType::AxisVector_optional& TorusFeatureActualType::
    AxisVector () const
    {
      return this->AxisVector_;
    }

    TorusFeatureActualType::AxisVector_optional& TorusFeatureActualType::
    AxisVector ()
    {
      return this->AxisVector_;
    }

    void TorusFeatureActualType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void TorusFeatureActualType::
    AxisVector (const AxisVector_optional& x)
    {
      this->AxisVector_ = x;
    }

    void TorusFeatureActualType::
    AxisVector (::std::auto_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (x);
    }

    const TorusFeatureActualType::MinorDiameter_optional& TorusFeatureActualType::
    MinorDiameter () const
    {
      return this->MinorDiameter_;
    }

    TorusFeatureActualType::MinorDiameter_optional& TorusFeatureActualType::
    MinorDiameter ()
    {
      return this->MinorDiameter_;
    }

    void TorusFeatureActualType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void TorusFeatureActualType::
    MinorDiameter (const MinorDiameter_optional& x)
    {
      this->MinorDiameter_ = x;
    }

    void TorusFeatureActualType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }

    const TorusFeatureActualType::MajorDiameter_optional& TorusFeatureActualType::
    MajorDiameter () const
    {
      return this->MajorDiameter_;
    }

    TorusFeatureActualType::MajorDiameter_optional& TorusFeatureActualType::
    MajorDiameter ()
    {
      return this->MajorDiameter_;
    }

    void TorusFeatureActualType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void TorusFeatureActualType::
    MajorDiameter (const MajorDiameter_optional& x)
    {
      this->MajorDiameter_ = x;
    }

    void TorusFeatureActualType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }

    const TorusFeatureActualType::LatitudeLongitudeSweep_optional& TorusFeatureActualType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    TorusFeatureActualType::LatitudeLongitudeSweep_optional& TorusFeatureActualType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void TorusFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void TorusFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void TorusFeatureActualType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    const TorusFeatureActualType::Form_optional& TorusFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    TorusFeatureActualType::Form_optional& TorusFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void TorusFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void TorusFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void TorusFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // CompositeFeatureItemBaseType
    // 


    // CompositeFeatureDefinitionBaseType
    // 


    // CompositeFeatureNominalBaseType
    // 

    const CompositeFeatureNominalBaseType::FeatureNominalIds_type& CompositeFeatureNominalBaseType::
    FeatureNominalIds () const
    {
      return this->FeatureNominalIds_.get ();
    }

    CompositeFeatureNominalBaseType::FeatureNominalIds_type& CompositeFeatureNominalBaseType::
    FeatureNominalIds ()
    {
      return this->FeatureNominalIds_.get ();
    }

    void CompositeFeatureNominalBaseType::
    FeatureNominalIds (const FeatureNominalIds_type& x)
    {
      this->FeatureNominalIds_.set (x);
    }

    void CompositeFeatureNominalBaseType::
    FeatureNominalIds (::std::auto_ptr< FeatureNominalIds_type > x)
    {
      this->FeatureNominalIds_.set (x);
    }


    // CompositeFeatureActualBaseType
    // 


    // CompoundFeatureItemType
    // 

    const CompoundFeatureItemType::SubstituteFeatureAlgorithm_optional& CompoundFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    CompoundFeatureItemType::SubstituteFeatureAlgorithm_optional& CompoundFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void CompoundFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void CompoundFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void CompoundFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // CompoundFeatureDefinitionType
    // 


    // CompoundFeatureNominalType
    // 

    const CompoundFeatureNominalType::Location_type& CompoundFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    CompoundFeatureNominalType::Location_type& CompoundFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void CompoundFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CompoundFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CompoundFeatureNominalType::Direction_type& CompoundFeatureNominalType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    CompoundFeatureNominalType::Direction_type& CompoundFeatureNominalType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void CompoundFeatureNominalType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void CompoundFeatureNominalType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }

    const CompoundFeatureNominalType::CompoundFeatureForm_type& CompoundFeatureNominalType::
    CompoundFeatureForm () const
    {
      return this->CompoundFeatureForm_.get ();
    }

    CompoundFeatureNominalType::CompoundFeatureForm_type& CompoundFeatureNominalType::
    CompoundFeatureForm ()
    {
      return this->CompoundFeatureForm_.get ();
    }

    void CompoundFeatureNominalType::
    CompoundFeatureForm (const CompoundFeatureForm_type& x)
    {
      this->CompoundFeatureForm_.set (x);
    }

    void CompoundFeatureNominalType::
    CompoundFeatureForm (::std::auto_ptr< CompoundFeatureForm_type > x)
    {
      this->CompoundFeatureForm_.set (x);
    }


    // CompoundFeatureActualType
    // 

    const CompoundFeatureActualType::Location_optional& CompoundFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    CompoundFeatureActualType::Location_optional& CompoundFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void CompoundFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CompoundFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void CompoundFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CompoundFeatureActualType::Direction_optional& CompoundFeatureActualType::
    Direction () const
    {
      return this->Direction_;
    }

    CompoundFeatureActualType::Direction_optional& CompoundFeatureActualType::
    Direction ()
    {
      return this->Direction_;
    }

    void CompoundFeatureActualType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void CompoundFeatureActualType::
    Direction (const Direction_optional& x)
    {
      this->Direction_ = x;
    }

    void CompoundFeatureActualType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }


    // PatternFeatureItemType
    // 


    // PatternFeatureDefinitionType
    // 


    // PatternFeatureNominalType
    // 


    // PatternFeatureActualType
    // 


    // ProfileGroupFeatureItemType
    // 


    // ProfileGroupFeatureDefinitionType
    // 


    // ProfileGroupFeatureNominalType
    // 


    // ProfileGroupFeatureActualType
    // 


    // RunoutGroupFeatureItemType
    // 


    // RunoutGroupFeatureDefinitionType
    // 


    // RunoutGroupFeatureNominalType
    // 


    // RunoutGroupFeatureActualType
    // 


    // FeatureAspectsListsType
    // 

    const FeatureAspectsListsType::FeatureDefinitions_optional& FeatureAspectsListsType::
    FeatureDefinitions () const
    {
      return this->FeatureDefinitions_;
    }

    FeatureAspectsListsType::FeatureDefinitions_optional& FeatureAspectsListsType::
    FeatureDefinitions ()
    {
      return this->FeatureDefinitions_;
    }

    void FeatureAspectsListsType::
    FeatureDefinitions (const FeatureDefinitions_type& x)
    {
      this->FeatureDefinitions_.set (x);
    }

    void FeatureAspectsListsType::
    FeatureDefinitions (const FeatureDefinitions_optional& x)
    {
      this->FeatureDefinitions_ = x;
    }

    void FeatureAspectsListsType::
    FeatureDefinitions (::std::auto_ptr< FeatureDefinitions_type > x)
    {
      this->FeatureDefinitions_.set (x);
    }

    const FeatureAspectsListsType::FeatureNominals_optional& FeatureAspectsListsType::
    FeatureNominals () const
    {
      return this->FeatureNominals_;
    }

    FeatureAspectsListsType::FeatureNominals_optional& FeatureAspectsListsType::
    FeatureNominals ()
    {
      return this->FeatureNominals_;
    }

    void FeatureAspectsListsType::
    FeatureNominals (const FeatureNominals_type& x)
    {
      this->FeatureNominals_.set (x);
    }

    void FeatureAspectsListsType::
    FeatureNominals (const FeatureNominals_optional& x)
    {
      this->FeatureNominals_ = x;
    }

    void FeatureAspectsListsType::
    FeatureNominals (::std::auto_ptr< FeatureNominals_type > x)
    {
      this->FeatureNominals_.set (x);
    }

    const FeatureAspectsListsType::FeatureItems_optional& FeatureAspectsListsType::
    FeatureItems () const
    {
      return this->FeatureItems_;
    }

    FeatureAspectsListsType::FeatureItems_optional& FeatureAspectsListsType::
    FeatureItems ()
    {
      return this->FeatureItems_;
    }

    void FeatureAspectsListsType::
    FeatureItems (const FeatureItems_type& x)
    {
      this->FeatureItems_.set (x);
    }

    void FeatureAspectsListsType::
    FeatureItems (const FeatureItems_optional& x)
    {
      this->FeatureItems_ = x;
    }

    void FeatureAspectsListsType::
    FeatureItems (::std::auto_ptr< FeatureItems_type > x)
    {
      this->FeatureItems_.set (x);
    }


    // MeasuredFeaturesType
    // 

    const MeasuredFeaturesType::FeatureActuals_type& MeasuredFeaturesType::
    FeatureActuals () const
    {
      return this->FeatureActuals_.get ();
    }

    MeasuredFeaturesType::FeatureActuals_type& MeasuredFeaturesType::
    FeatureActuals ()
    {
      return this->FeatureActuals_.get ();
    }

    void MeasuredFeaturesType::
    FeatureActuals (const FeatureActuals_type& x)
    {
      this->FeatureActuals_.set (x);
    }

    void MeasuredFeaturesType::
    FeatureActuals (::std::auto_ptr< FeatureActuals_type > x)
    {
      this->FeatureActuals_.set (x);
    }


    // FeatureDefinitionsType
    // 

    const FeatureDefinitionsType::FeatureDefinition_sequence& FeatureDefinitionsType::
    FeatureDefinition () const
    {
      return this->FeatureDefinition_;
    }

    FeatureDefinitionsType::FeatureDefinition_sequence& FeatureDefinitionsType::
    FeatureDefinition ()
    {
      return this->FeatureDefinition_;
    }

    void FeatureDefinitionsType::
    FeatureDefinition (const FeatureDefinition_sequence& s)
    {
      this->FeatureDefinition_ = s;
    }


    // FeatureNominalsType
    // 

    const FeatureNominalsType::FeatureNominal_sequence& FeatureNominalsType::
    FeatureNominal () const
    {
      return this->FeatureNominal_;
    }

    FeatureNominalsType::FeatureNominal_sequence& FeatureNominalsType::
    FeatureNominal ()
    {
      return this->FeatureNominal_;
    }

    void FeatureNominalsType::
    FeatureNominal (const FeatureNominal_sequence& s)
    {
      this->FeatureNominal_ = s;
    }


    // FeatureItemsType
    // 

    const FeatureItemsType::FeatureItem_sequence& FeatureItemsType::
    FeatureItem () const
    {
      return this->FeatureItem_;
    }

    FeatureItemsType::FeatureItem_sequence& FeatureItemsType::
    FeatureItem ()
    {
      return this->FeatureItem_;
    }

    void FeatureItemsType::
    FeatureItem (const FeatureItem_sequence& s)
    {
      this->FeatureItem_ = s;
    }


    // FeatureActualsType
    // 

    const FeatureActualsType::FeatureActual_sequence& FeatureActualsType::
    FeatureActual () const
    {
      return this->FeatureActual_;
    }

    FeatureActualsType::FeatureActual_sequence& FeatureActualsType::
    FeatureActual ()
    {
      return this->FeatureActual_;
    }

    void FeatureActualsType::
    FeatureActual (const FeatureActual_sequence& s)
    {
      this->FeatureActual_ = s;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace xsd
{
  namespace qif2
  {
    // FeatureBaseType
    //

    FeatureBaseType::
    FeatureBaseType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    FeatureBaseType::
    FeatureBaseType (const FeatureBaseType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    FeatureBaseType::
    FeatureBaseType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void FeatureBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    FeatureBaseType* FeatureBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureBaseType (*this, f, c);
    }

    FeatureBaseType::
    ~FeatureBaseType ()
    {
    }

    // FeatureItemBaseType
    //

    FeatureItemBaseType::
    FeatureItemBaseType (const id_type& id,
                         const FeatureName_type& FeatureName)
    : ::xsd::qif2::FeatureBaseType (id),
      FeatureNominalId_ (::xml_schema::flags (), this),
      ParentFeatureItemId_ (::xml_schema::flags (), this),
      FeatureName_ (FeatureName, ::xml_schema::flags (), this),
      QPId_ (::xml_schema::flags (), this),
      NotableEventIds_ (::xml_schema::flags (), this),
      CoordinateSystemId_ (::xml_schema::flags (), this)
    {
    }

    FeatureItemBaseType::
    FeatureItemBaseType (const FeatureItemBaseType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (x, f, c),
      FeatureNominalId_ (x.FeatureNominalId_, f, this),
      ParentFeatureItemId_ (x.ParentFeatureItemId_, f, this),
      FeatureName_ (x.FeatureName_, f, this),
      QPId_ (x.QPId_, f, this),
      NotableEventIds_ (x.NotableEventIds_, f, this),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this)
    {
    }

    FeatureItemBaseType::
    FeatureItemBaseType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (e, f | ::xml_schema::flags::base, c),
      FeatureNominalId_ (f, this),
      ParentFeatureItemId_ (f, this),
      FeatureName_ (f, this),
      QPId_ (f, this),
      NotableEventIds_ (f, this),
      CoordinateSystemId_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void FeatureItemBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureNominalId
        //
        if (n.name () == "FeatureNominalId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureNominalId_type > r (
            FeatureNominalId_traits::create (i, f, this));

          if (!this->FeatureNominalId_)
          {
            this->FeatureNominalId_.set (r);
            continue;
          }
        }

        // ParentFeatureItemId
        //
        if (n.name () == "ParentFeatureItemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ParentFeatureItemId_type > r (
            ParentFeatureItemId_traits::create (i, f, this));

          if (!this->ParentFeatureItemId_)
          {
            this->ParentFeatureItemId_.set (r);
            continue;
          }
        }

        // FeatureName
        //
        if (n.name () == "FeatureName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureName_type > r (
            FeatureName_traits::create (i, f, this));

          if (!FeatureName_.present ())
          {
            this->FeatureName_.set (r);
            continue;
          }
        }

        // QPId
        //
        if (n.name () == "QPId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< QPId_type > r (
            QPId_traits::create (i, f, this));

          if (!this->QPId_)
          {
            this->QPId_.set (r);
            continue;
          }
        }

        // NotableEventIds
        //
        if (n.name () == "NotableEventIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NotableEventIds_type > r (
            NotableEventIds_traits::create (i, f, this));

          if (!this->NotableEventIds_)
          {
            this->NotableEventIds_.set (r);
            continue;
          }
        }

        // CoordinateSystemId
        //
        if (n.name () == "CoordinateSystemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!this->CoordinateSystemId_)
          {
            this->CoordinateSystemId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FeatureItemBaseType* FeatureItemBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureItemBaseType (*this, f, c);
    }

    FeatureItemBaseType::
    ~FeatureItemBaseType ()
    {
    }

    // FeatureDefinitionBaseType
    //

    FeatureDefinitionBaseType::
    FeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif2::FeatureBaseType (id)
    {
    }

    FeatureDefinitionBaseType::
    FeatureDefinitionBaseType (const FeatureDefinitionBaseType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (x, f, c)
    {
    }

    FeatureDefinitionBaseType::
    FeatureDefinitionBaseType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (e, f, c)
    {
    }

    FeatureDefinitionBaseType* FeatureDefinitionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureDefinitionBaseType (*this, f, c);
    }

    FeatureDefinitionBaseType::
    ~FeatureDefinitionBaseType ()
    {
    }

    // PointListNominalType
    //

    PointListNominalType::
    PointListNominalType ()
    : ::xml_schema::type (),
      MeasurePoint_ (::xml_schema::flags (), this),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    PointListNominalType::
    PointListNominalType (const PointListNominalType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasurePoint_ (x.MeasurePoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    PointListNominalType::
    PointListNominalType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasurePoint_ (f, this),
      linearUnit_ (f, this),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this),
      validity_ (f, this),
      xDecimalPlaces_ (f, this),
      xSignificantFigures_ (f, this),
      xValidity_ (f, this),
      yDecimalPlaces_ (f, this),
      ySignificantFigures_ (f, this),
      yValidity_ (f, this),
      zDecimalPlaces_ (f, this),
      zSignificantFigures_ (f, this),
      zValidity_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointListNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MeasurePoint
        //
        if (n.name () == "MeasurePoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurePoint_type > r (
            MeasurePoint_traits::create (i, f, this));

          this->MeasurePoint_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validity_type > r (
            validity_traits::create (i, f, this));

          this->validity_.set (r);
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< xValidity_type > r (
            xValidity_traits::create (i, f, this));

          this->xValidity_.set (r);
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< yValidity_type > r (
            yValidity_traits::create (i, f, this));

          this->yValidity_.set (r);
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< zValidity_type > r (
            zValidity_traits::create (i, f, this));

          this->zValidity_.set (r);
          continue;
        }
      }
    }

    PointListNominalType* PointListNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointListNominalType (*this, f, c);
    }

    PointListNominalType::
    ~PointListNominalType ()
    {
    }

    // FeatureNominalBaseType
    //

    FeatureNominalBaseType::
    FeatureNominalBaseType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif2::FeatureBaseType (id),
      Name_ (::xml_schema::flags (), this),
      PointList_ (::xml_schema::flags (), this),
      FeatureDefinitionId_ (FeatureDefinitionId, ::xml_schema::flags (), this),
      EntityInternalIds_ (::xml_schema::flags (), this),
      EntityExternalIds_ (::xml_schema::flags (), this)
    {
    }

    FeatureNominalBaseType::
    FeatureNominalBaseType (const FeatureNominalBaseType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (x, f, c),
      Name_ (x.Name_, f, this),
      PointList_ (x.PointList_, f, this),
      FeatureDefinitionId_ (x.FeatureDefinitionId_, f, this),
      EntityInternalIds_ (x.EntityInternalIds_, f, this),
      EntityExternalIds_ (x.EntityExternalIds_, f, this)
    {
    }

    FeatureNominalBaseType::
    FeatureNominalBaseType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (e, f | ::xml_schema::flags::base, c),
      Name_ (f, this),
      PointList_ (f, this),
      FeatureDefinitionId_ (f, this),
      EntityInternalIds_ (f, this),
      EntityExternalIds_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void FeatureNominalBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (r);
            continue;
          }
        }

        // PointList
        //
        if (n.name () == "PointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointList_type > r (
            PointList_traits::create (i, f, this));

          if (!this->PointList_)
          {
            this->PointList_.set (r);
            continue;
          }
        }

        // FeatureDefinitionId
        //
        if (n.name () == "FeatureDefinitionId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureDefinitionId_type > r (
            FeatureDefinitionId_traits::create (i, f, this));

          if (!FeatureDefinitionId_.present ())
          {
            this->FeatureDefinitionId_.set (r);
            continue;
          }
        }

        // EntityInternalIds
        //
        if (n.name () == "EntityInternalIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EntityInternalIds_type > r (
            EntityInternalIds_traits::create (i, f, this));

          if (!this->EntityInternalIds_)
          {
            this->EntityInternalIds_.set (r);
            continue;
          }
        }

        // EntityExternalIds
        //
        if (n.name () == "EntityExternalIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EntityExternalIds_type > r (
            EntityExternalIds_traits::create (i, f, this));

          if (!this->EntityExternalIds_)
          {
            this->EntityExternalIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureDefinitionId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FeatureNominalBaseType* FeatureNominalBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureNominalBaseType (*this, f, c);
    }

    FeatureNominalBaseType::
    ~FeatureNominalBaseType ()
    {
    }

    // PointListActualType
    //

    PointListActualType::
    PointListActualType ()
    : ::xml_schema::type (),
      MeasurePoint_ (::xml_schema::flags (), this),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this),
      combinedUncertainty_ (::xml_schema::flags (), this),
      meanError_ (::xml_schema::flags (), this),
      xCombinedUncertainty_ (::xml_schema::flags (), this),
      xMeanError_ (::xml_schema::flags (), this),
      yCombinedUncertainty_ (::xml_schema::flags (), this),
      yMeanError_ (::xml_schema::flags (), this),
      zCombinedUncertainty_ (::xml_schema::flags (), this),
      zMeanError_ (::xml_schema::flags (), this)
    {
    }

    PointListActualType::
    PointListActualType (const PointListActualType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasurePoint_ (x.MeasurePoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this),
      xCombinedUncertainty_ (x.xCombinedUncertainty_, f, this),
      xMeanError_ (x.xMeanError_, f, this),
      yCombinedUncertainty_ (x.yCombinedUncertainty_, f, this),
      yMeanError_ (x.yMeanError_, f, this),
      zCombinedUncertainty_ (x.zCombinedUncertainty_, f, this),
      zMeanError_ (x.zMeanError_, f, this)
    {
    }

    PointListActualType::
    PointListActualType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasurePoint_ (f, this),
      linearUnit_ (f, this),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this),
      validity_ (f, this),
      xDecimalPlaces_ (f, this),
      xSignificantFigures_ (f, this),
      xValidity_ (f, this),
      yDecimalPlaces_ (f, this),
      ySignificantFigures_ (f, this),
      yValidity_ (f, this),
      zDecimalPlaces_ (f, this),
      zSignificantFigures_ (f, this),
      zValidity_ (f, this),
      combinedUncertainty_ (f, this),
      meanError_ (f, this),
      xCombinedUncertainty_ (f, this),
      xMeanError_ (f, this),
      yCombinedUncertainty_ (f, this),
      yMeanError_ (f, this),
      zCombinedUncertainty_ (f, this),
      zMeanError_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointListActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MeasurePoint
        //
        if (n.name () == "MeasurePoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurePoint_type > r (
            MeasurePoint_traits::create (i, f, this));

          this->MeasurePoint_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validity_type > r (
            validity_traits::create (i, f, this));

          this->validity_.set (r);
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< xValidity_type > r (
            xValidity_traits::create (i, f, this));

          this->xValidity_.set (r);
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< yValidity_type > r (
            yValidity_traits::create (i, f, this));

          this->yValidity_.set (r);
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< zValidity_type > r (
            zValidity_traits::create (i, f, this));

          this->zValidity_.set (r);
          continue;
        }

        if (n.name () == "combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->xCombinedUncertainty_.set (xCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xMeanError" && n.namespace_ ().empty ())
        {
          this->xMeanError_.set (xMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->yCombinedUncertainty_.set (yCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yMeanError" && n.namespace_ ().empty ())
        {
          this->yMeanError_.set (yMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->zCombinedUncertainty_.set (zCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zMeanError" && n.namespace_ ().empty ())
        {
          this->zMeanError_.set (zMeanError_traits::create (i, f, this));
          continue;
        }
      }
    }

    PointListActualType* PointListActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointListActualType (*this, f, c);
    }

    PointListActualType::
    ~PointListActualType ()
    {
    }

    // FeatureActualBaseType
    //

    FeatureActualBaseType::
    FeatureActualBaseType (const id_type& id,
                           const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureBaseType (id),
      PointList_ (::xml_schema::flags (), this),
      FeatureItemId_ (FeatureItemId, ::xml_schema::flags (), this),
      ActualComponentId_ (::xml_schema::flags (), this),
      ManufacturingProcessId_ (::xml_schema::flags (), this),
      MeasurementDeviceIds_ (::xml_schema::flags (), this),
      NotedEventIds_ (::xml_schema::flags (), this)
    {
    }

    FeatureActualBaseType::
    FeatureActualBaseType (const id_type& id,
                           ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureBaseType (id),
      PointList_ (::xml_schema::flags (), this),
      FeatureItemId_ (FeatureItemId, ::xml_schema::flags (), this),
      ActualComponentId_ (::xml_schema::flags (), this),
      ManufacturingProcessId_ (::xml_schema::flags (), this),
      MeasurementDeviceIds_ (::xml_schema::flags (), this),
      NotedEventIds_ (::xml_schema::flags (), this)
    {
    }

    FeatureActualBaseType::
    FeatureActualBaseType (const FeatureActualBaseType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (x, f, c),
      PointList_ (x.PointList_, f, this),
      FeatureItemId_ (x.FeatureItemId_, f, this),
      ActualComponentId_ (x.ActualComponentId_, f, this),
      ManufacturingProcessId_ (x.ManufacturingProcessId_, f, this),
      MeasurementDeviceIds_ (x.MeasurementDeviceIds_, f, this),
      NotedEventIds_ (x.NotedEventIds_, f, this)
    {
    }

    FeatureActualBaseType::
    FeatureActualBaseType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (e, f | ::xml_schema::flags::base, c),
      PointList_ (f, this),
      FeatureItemId_ (f, this),
      ActualComponentId_ (f, this),
      ManufacturingProcessId_ (f, this),
      MeasurementDeviceIds_ (f, this),
      NotedEventIds_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void FeatureActualBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointList
        //
        if (n.name () == "PointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointList_type > r (
            PointList_traits::create (i, f, this));

          if (!this->PointList_)
          {
            this->PointList_.set (r);
            continue;
          }
        }

        // FeatureItemId
        //
        if (n.name () == "FeatureItemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureItemId_type > r (
            FeatureItemId_traits::create (i, f, this));

          if (!FeatureItemId_.present ())
          {
            this->FeatureItemId_.set (r);
            continue;
          }
        }

        // ActualComponentId
        //
        if (n.name () == "ActualComponentId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ActualComponentId_type > r (
            ActualComponentId_traits::create (i, f, this));

          if (!this->ActualComponentId_)
          {
            this->ActualComponentId_.set (r);
            continue;
          }
        }

        // ManufacturingProcessId
        //
        if (n.name () == "ManufacturingProcessId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ManufacturingProcessId_type > r (
            ManufacturingProcessId_traits::create (i, f, this));

          if (!this->ManufacturingProcessId_)
          {
            this->ManufacturingProcessId_.set (r);
            continue;
          }
        }

        // MeasurementDeviceIds
        //
        if (n.name () == "MeasurementDeviceIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurementDeviceIds_type > r (
            MeasurementDeviceIds_traits::create (i, f, this));

          if (!this->MeasurementDeviceIds_)
          {
            this->MeasurementDeviceIds_.set (r);
            continue;
          }
        }

        // NotedEventIds
        //
        if (n.name () == "NotedEventIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NotedEventIds_type > r (
            NotedEventIds_traits::create (i, f, this));

          if (!this->NotedEventIds_)
          {
            this->NotedEventIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureItemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureItemId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FeatureActualBaseType* FeatureActualBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureActualBaseType (*this, f, c);
    }

    FeatureActualBaseType::
    ~FeatureActualBaseType ()
    {
    }

    // SetFeatureType
    //

    SetFeatureType::
    SetFeatureType ()
    : ::xml_schema::type ()
    {
    }

    SetFeatureType::
    SetFeatureType (const SetFeatureType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    SetFeatureType::
    SetFeatureType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    SetFeatureType::
    SetFeatureType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    SetFeatureType::
    SetFeatureType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    SetFeatureType* SetFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SetFeatureType (*this, f, c);
    }

    SetFeatureType::
    ~SetFeatureType ()
    {
    }

    // MeasuredFeatureType
    //

    MeasuredFeatureType::
    MeasuredFeatureType ()
    : ::xml_schema::type (),
      PointList_ (::xml_schema::flags (), this)
    {
    }

    MeasuredFeatureType::
    MeasuredFeatureType (const MeasuredFeatureType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointList_ (x.PointList_, f, this)
    {
    }

    MeasuredFeatureType::
    MeasuredFeatureType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void MeasuredFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointList
        //
        if (n.name () == "PointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointList_type > r (
            PointList_traits::create (i, f, this));

          if (!this->PointList_)
          {
            this->PointList_.set (r);
            continue;
          }
        }

        break;
      }
    }

    MeasuredFeatureType* MeasuredFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredFeatureType (*this, f, c);
    }

    MeasuredFeatureType::
    ~MeasuredFeatureType ()
    {
    }

    // ConstructionMethodBaseType
    //

    ConstructionMethodBaseType::
    ConstructionMethodBaseType ()
    : ::xml_schema::type (),
      NominalsCalculated_ (::xml_schema::flags (), this)
    {
    }

    ConstructionMethodBaseType::
    ConstructionMethodBaseType (const ConstructionMethodBaseType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NominalsCalculated_ (x.NominalsCalculated_, f, this)
    {
    }

    ConstructionMethodBaseType::
    ConstructionMethodBaseType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NominalsCalculated_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConstructionMethodBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // NominalsCalculated
        //
        if (n.name () == "NominalsCalculated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->NominalsCalculated_)
          {
            this->NominalsCalculated_.set (NominalsCalculated_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    ConstructionMethodBaseType* ConstructionMethodBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConstructionMethodBaseType (*this, f, c);
    }

    ConstructionMethodBaseType::
    ~ConstructionMethodBaseType ()
    {
    }

    // PointRangeType
    //

    PointRangeType::
    PointRangeType (const Start_type& Start,
                    const Stop_type& Stop)
    : ::xml_schema::type (),
      Start_ (Start, ::xml_schema::flags (), this),
      Stop_ (Stop, ::xml_schema::flags (), this)
    {
    }

    PointRangeType::
    PointRangeType (const PointRangeType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Start_ (x.Start_, f, this),
      Stop_ (x.Stop_, f, this)
    {
    }

    PointRangeType::
    PointRangeType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Start_ (f, this),
      Stop_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointRangeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Start
        //
        if (n.name () == "Start" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!Start_.present ())
          {
            this->Start_.set (Start_traits::create (i, f, this));
            continue;
          }
        }

        // Stop
        //
        if (n.name () == "Stop" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!Stop_.present ())
          {
            this->Stop_.set (Stop_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Start_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Start",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Stop_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Stop",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointRangeType* PointRangeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointRangeType (*this, f, c);
    }

    PointRangeType::
    ~PointRangeType ()
    {
    }

    // PointIndexType
    //

    const PointIndexType::All_type PointIndexType::All_default_value_ (
      "All");

    PointIndexType::
    PointIndexType ()
    : ::xml_schema::type (),
      Single_ (::xml_schema::flags (), this),
      Range_ (::xml_schema::flags (), this),
      All_ (::xml_schema::flags (), this)
    {
    }

    PointIndexType::
    PointIndexType (const PointIndexType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Single_ (x.Single_, f, this),
      Range_ (x.Range_, f, this),
      All_ (x.All_, f, this)
    {
    }

    PointIndexType::
    PointIndexType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Single_ (f, this),
      Range_ (f, this),
      All_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointIndexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Single
        //
        if (n.name () == "Single" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->Single_)
          {
            this->Single_.set (Single_traits::create (i, f, this));
            continue;
          }
        }

        // Range
        //
        if (n.name () == "Range" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Range_type > r (
            Range_traits::create (i, f, this));

          if (!this->Range_)
          {
            this->Range_.set (r);
            continue;
          }
        }

        // All
        //
        if (n.name () == "All" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< All_type > r (
            All_traits::create (i, f, this));

          if (!this->All_)
          {
            this->All_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointIndexType* PointIndexType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointIndexType (*this, f, c);
    }

    PointIndexType::
    ~PointIndexType ()
    {
    }

    // BaseFeaturePointSetType
    //

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (const FeatureItemId_type& FeatureItemId,
                             const PointIndex_type& PointIndex,
                             const ReferencedComponent_type& ReferencedComponent,
                             const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      FeatureItemId_ (FeatureItemId, ::xml_schema::flags (), this),
      PointIndex_ (PointIndex, ::xml_schema::flags (), this),
      ReferencedComponent_ (ReferencedComponent, ::xml_schema::flags (), this),
      SequenceNumber_ (SequenceNumber, ::xml_schema::flags (), this)
    {
    }

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (::std::auto_ptr< FeatureItemId_type >& FeatureItemId,
                             ::std::auto_ptr< PointIndex_type >& PointIndex,
                             const ReferencedComponent_type& ReferencedComponent,
                             const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      FeatureItemId_ (FeatureItemId, ::xml_schema::flags (), this),
      PointIndex_ (PointIndex, ::xml_schema::flags (), this),
      ReferencedComponent_ (ReferencedComponent, ::xml_schema::flags (), this),
      SequenceNumber_ (SequenceNumber, ::xml_schema::flags (), this)
    {
    }

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (const BaseFeaturePointSetType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureItemId_ (x.FeatureItemId_, f, this),
      PointIndex_ (x.PointIndex_, f, this),
      ReferencedComponent_ (x.ReferencedComponent_, f, this),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureItemId_ (f, this),
      PointIndex_ (f, this),
      ReferencedComponent_ (f, this),
      SequenceNumber_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void BaseFeaturePointSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureItemId
        //
        if (n.name () == "FeatureItemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureItemId_type > r (
            FeatureItemId_traits::create (i, f, this));

          if (!FeatureItemId_.present ())
          {
            this->FeatureItemId_.set (r);
            continue;
          }
        }

        // PointIndex
        //
        if (n.name () == "PointIndex" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointIndex_type > r (
            PointIndex_traits::create (i, f, this));

          if (!PointIndex_.present ())
          {
            this->PointIndex_.set (r);
            continue;
          }
        }

        // ReferencedComponent
        //
        if (n.name () == "ReferencedComponent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReferencedComponent_type > r (
            ReferencedComponent_traits::create (i, f, this));

          if (!ReferencedComponent_.present ())
          {
            this->ReferencedComponent_.set (r);
            continue;
          }
        }

        // SequenceNumber
        //
        if (n.name () == "SequenceNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (SequenceNumber_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!FeatureItemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureItemId",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointIndex_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointIndex",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ReferencedComponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ReferencedComponent",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SequenceNumber",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    BaseFeaturePointSetType* BaseFeaturePointSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BaseFeaturePointSetType (*this, f, c);
    }

    BaseFeaturePointSetType::
    ~BaseFeaturePointSetType ()
    {
    }

    // BaseFeaturePointListType
    //

    BaseFeaturePointListType::
    BaseFeaturePointListType ()
    : ::xml_schema::type (),
      BaseFeaturePointSet_ (::xml_schema::flags (), this)
    {
    }

    BaseFeaturePointListType::
    BaseFeaturePointListType (const BaseFeaturePointListType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BaseFeaturePointSet_ (x.BaseFeaturePointSet_, f, this)
    {
    }

    BaseFeaturePointListType::
    BaseFeaturePointListType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointSet_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void BaseFeaturePointListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointSet
        //
        if (n.name () == "BaseFeaturePointSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointSet_type > r (
            BaseFeaturePointSet_traits::create (i, f, this));

          this->BaseFeaturePointSet_.push_back (r);
          continue;
        }

        break;
      }
    }

    BaseFeaturePointListType* BaseFeaturePointListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BaseFeaturePointListType (*this, f, c);
    }

    BaseFeaturePointListType::
    ~BaseFeaturePointListType ()
    {
    }

    // TransformationReferenceType
    //

    TransformationReferenceType::
    TransformationReferenceType (const ReferencedComponent_type& ReferencedComponent,
                                 const CoordinateSystemId_type& CoordinateSystemId,
                                 const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      ReferencedComponent_ (ReferencedComponent, ::xml_schema::flags (), this),
      CoordinateSystemId_ (CoordinateSystemId, ::xml_schema::flags (), this),
      SequenceNumber_ (SequenceNumber, ::xml_schema::flags (), this)
    {
    }

    TransformationReferenceType::
    TransformationReferenceType (const ReferencedComponent_type& ReferencedComponent,
                                 ::std::auto_ptr< CoordinateSystemId_type >& CoordinateSystemId,
                                 const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      ReferencedComponent_ (ReferencedComponent, ::xml_schema::flags (), this),
      CoordinateSystemId_ (CoordinateSystemId, ::xml_schema::flags (), this),
      SequenceNumber_ (SequenceNumber, ::xml_schema::flags (), this)
    {
    }

    TransformationReferenceType::
    TransformationReferenceType (const TransformationReferenceType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ReferencedComponent_ (x.ReferencedComponent_, f, this),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    TransformationReferenceType::
    TransformationReferenceType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ReferencedComponent_ (f, this),
      CoordinateSystemId_ (f, this),
      SequenceNumber_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TransformationReferenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ReferencedComponent
        //
        if (n.name () == "ReferencedComponent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReferencedComponent_type > r (
            ReferencedComponent_traits::create (i, f, this));

          if (!ReferencedComponent_.present ())
          {
            this->ReferencedComponent_.set (r);
            continue;
          }
        }

        // CoordinateSystemId
        //
        if (n.name () == "CoordinateSystemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!CoordinateSystemId_.present ())
          {
            this->CoordinateSystemId_.set (r);
            continue;
          }
        }

        // SequenceNumber
        //
        if (n.name () == "SequenceNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (SequenceNumber_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!ReferencedComponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ReferencedComponent",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CoordinateSystemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CoordinateSystemId",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SequenceNumber",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TransformationReferenceType* TransformationReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformationReferenceType (*this, f, c);
    }

    TransformationReferenceType::
    ~TransformationReferenceType ()
    {
    }

    // ArcConstructionMethodType
    //

    ArcConstructionMethodType::
    ArcConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Projection_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this),
      Extract_ (::xml_schema::flags (), this)
    {
    }

    ArcConstructionMethodType::
    ArcConstructionMethodType (const ArcConstructionMethodType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    ArcConstructionMethodType::
    ArcConstructionMethodType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Projection_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this),
      FromScan_ (f, this),
      Extract_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        // Extract
        //
        if (n.name () == "Extract" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcConstructionMethodType* ArcConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcConstructionMethodType (*this, f, c);
    }

    ArcConstructionMethodType::
    ~ArcConstructionMethodType ()
    {
    }

    // ArcBestFitType
    //

    ArcBestFitType::
    ArcBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    ArcBestFitType::
    ArcBestFitType (const ArcBestFitType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ArcBestFitType::
    ArcBestFitType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ArcBestFitType* ArcBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcBestFitType (*this, f, c);
    }

    ArcBestFitType::
    ~ArcBestFitType ()
    {
    }

    // ArcRecompType
    //

    ArcRecompType::
    ArcRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ArcRecompType::
    ArcRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ArcRecompType::
    ArcRecompType (const ArcRecompType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ArcRecompType::
    ArcRecompType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcRecompType* ArcRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcRecompType (*this, f, c);
    }

    ArcRecompType::
    ~ArcRecompType ()
    {
    }

    // ArcProjectionType
    //

    ArcProjectionType::
    ArcProjectionType (const ProjectionArc_type& ProjectionArc,
                       const ProjectionPlane_type& ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionArc_ (ProjectionArc, ::xml_schema::flags (), this),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this)
    {
    }

    ArcProjectionType::
    ArcProjectionType (::std::auto_ptr< ProjectionArc_type >& ProjectionArc,
                       ::std::auto_ptr< ProjectionPlane_type >& ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionArc_ (ProjectionArc, ::xml_schema::flags (), this),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this)
    {
    }

    ArcProjectionType::
    ArcProjectionType (const ArcProjectionType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionArc_ (x.ProjectionArc_, f, this),
      ProjectionPlane_ (x.ProjectionPlane_, f, this)
    {
    }

    ArcProjectionType::
    ArcProjectionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionArc_ (f, this),
      ProjectionPlane_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionArc
        //
        if (n.name () == "ProjectionArc" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionArc_type > r (
            ProjectionArc_traits::create (i, f, this));

          if (!ProjectionArc_.present ())
          {
            this->ProjectionArc_.set (r);
            continue;
          }
        }

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionArc",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcProjectionType* ArcProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcProjectionType (*this, f, c);
    }

    ArcProjectionType::
    ~ArcProjectionType ()
    {
    }

    // ArcCopyType
    //

    ArcCopyType::
    ArcCopyType (const BaseArc_type& BaseArc)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseArc_ (BaseArc, ::xml_schema::flags (), this)
    {
    }

    ArcCopyType::
    ArcCopyType (::std::auto_ptr< BaseArc_type >& BaseArc)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseArc_ (BaseArc, ::xml_schema::flags (), this)
    {
    }

    ArcCopyType::
    ArcCopyType (const ArcCopyType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseArc_ (x.BaseArc_, f, this)
    {
    }

    ArcCopyType::
    ArcCopyType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseArc_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseArc
        //
        if (n.name () == "BaseArc" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseArc_type > r (
            BaseArc_traits::create (i, f, this));

          if (!BaseArc_.present ())
          {
            this->BaseArc_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseArc",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcCopyType* ArcCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCopyType (*this, f, c);
    }

    ArcCopyType::
    ~ArcCopyType ()
    {
    }

    // ArcCastType
    //

    ArcCastType::
    ArcCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ArcCastType::
    ArcCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ArcCastType::
    ArcCastType (const ArcCastType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ArcCastType::
    ArcCastType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcCastType* ArcCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCastType (*this, f, c);
    }

    ArcCastType::
    ~ArcCastType ()
    {
    }

    // ArcTransformType
    //

    ArcTransformType::
    ArcTransformType (const BaseArc_type& BaseArc,
                      const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseArc_ (BaseArc, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ArcTransformType::
    ArcTransformType (::std::auto_ptr< BaseArc_type >& BaseArc,
                      ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseArc_ (BaseArc, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ArcTransformType::
    ArcTransformType (const ArcTransformType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseArc_ (x.BaseArc_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ArcTransformType::
    ArcTransformType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseArc_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseArc
        //
        if (n.name () == "BaseArc" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseArc_type > r (
            BaseArc_traits::create (i, f, this));

          if (!BaseArc_.present ())
          {
            this->BaseArc_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseArc",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcTransformType* ArcTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcTransformType (*this, f, c);
    }

    ArcTransformType::
    ~ArcTransformType ()
    {
    }

    // ArcFromScanType
    //

    ArcFromScanType::
    ArcFromScanType (const SurfaceFeature_type& SurfaceFeature,
                     const SearchRadius_type& SearchRadius,
                     const Depth_type& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      Depth_ (Depth, ::xml_schema::flags (), this)
    {
    }

    ArcFromScanType::
    ArcFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                     ::std::auto_ptr< SearchRadius_type >& SearchRadius,
                     ::std::auto_ptr< Depth_type >& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      Depth_ (Depth, ::xml_schema::flags (), this)
    {
    }

    ArcFromScanType::
    ArcFromScanType (const ArcFromScanType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    ArcFromScanType::
    ArcFromScanType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this),
      Depth_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Depth",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcFromScanType* ArcFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcFromScanType (*this, f, c);
    }

    ArcFromScanType::
    ~ArcFromScanType ()
    {
    }

    // ArcExtractType
    //

    ArcExtractType::
    ArcExtractType (const CurveFeature_type& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, ::xml_schema::flags (), this)
    {
    }

    ArcExtractType::
    ArcExtractType (::std::auto_ptr< CurveFeature_type >& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, ::xml_schema::flags (), this)
    {
    }

    ArcExtractType::
    ArcExtractType (const ArcExtractType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    ArcExtractType::
    ArcExtractType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      CurveFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcExtractType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CurveFeature
        //
        if (n.name () == "CurveFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CurveFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcExtractType* ArcExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcExtractType (*this, f, c);
    }

    ArcExtractType::
    ~ArcExtractType ()
    {
    }

    // ArcCheckedType
    //

    ArcCheckedType::
    ArcCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    ArcCheckedType::
    ArcCheckedType (const ArcCheckedType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ArcCheckedType::
    ArcCheckedType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcCheckedType* ArcCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCheckedType (*this, f, c);
    }

    ArcCheckedType::
    ~ArcCheckedType ()
    {
    }

    // ArcCheckedFeatureType
    //

    ArcCheckedFeatureType::
    ArcCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    ArcCheckedFeatureType::
    ArcCheckedFeatureType (const ArcCheckedFeatureType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ArcCheckedFeatureType::
    ArcCheckedFeatureType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcCheckedFeatureType* ArcCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCheckedFeatureType (*this, f, c);
    }

    ArcCheckedFeatureType::
    ~ArcCheckedFeatureType ()
    {
    }

    // ArcActualDeterminationType
    //

    ArcActualDeterminationType::
    ArcActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    ArcActualDeterminationType::
    ArcActualDeterminationType (const ArcActualDeterminationType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ArcActualDeterminationType::
    ArcActualDeterminationType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ArcActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcActualDeterminationType* ArcActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcActualDeterminationType (*this, f, c);
    }

    ArcActualDeterminationType::
    ~ArcActualDeterminationType ()
    {
    }

    // ArcFeatureItemType
    //

    ArcFeatureItemType::
    ArcFeatureItemType (const id_type& id,
                        const FeatureName_type& FeatureName,
                        const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ArcFeatureItemType::
    ArcFeatureItemType (const id_type& id,
                        const FeatureName_type& FeatureName,
                        ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ArcFeatureItemType::
    ArcFeatureItemType (const ArcFeatureItemType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ArcFeatureItemType::
    ArcFeatureItemType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ArcFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcFeatureItemType* ArcFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcFeatureItemType (*this, f, c);
    }

    ArcFeatureItemType::
    ~ArcFeatureItemType ()
    {
    }

    // ArcFeatureDefinitionType
    //

    ArcFeatureDefinitionType::
    ArcFeatureDefinitionType (const id_type& id,
                              const InternalExternal_type& InternalExternal,
                              const Radius_type& Radius)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Radius_ (Radius, ::xml_schema::flags (), this)
    {
    }

    ArcFeatureDefinitionType::
    ArcFeatureDefinitionType (const id_type& id,
                              const InternalExternal_type& InternalExternal,
                              ::std::auto_ptr< Radius_type >& Radius)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Radius_ (Radius, ::xml_schema::flags (), this)
    {
    }

    ArcFeatureDefinitionType::
    ArcFeatureDefinitionType (const ArcFeatureDefinitionType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Radius_ (x.Radius_, f, this)
    {
    }

    ArcFeatureDefinitionType::
    ArcFeatureDefinitionType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Radius_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ArcFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Radius
        //
        if (n.name () == "Radius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Radius_type > r (
            Radius_traits::create (i, f, this));

          if (!Radius_.present ())
          {
            this->Radius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Radius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Radius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcFeatureDefinitionType* ArcFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcFeatureDefinitionType (*this, f, c);
    }

    ArcFeatureDefinitionType::
    ~ArcFeatureDefinitionType ()
    {
    }

    // ArcFeatureNominalType
    //

    ArcFeatureNominalType::
    ArcFeatureNominalType (const id_type& id,
                           const FeatureDefinitionId_type& FeatureDefinitionId,
                           const Location_type& Location,
                           const Sweep_type& Sweep,
                           const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Sweep_ (Sweep, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    ArcFeatureNominalType::
    ArcFeatureNominalType (const id_type& id,
                           const FeatureDefinitionId_type& FeatureDefinitionId,
                           ::std::auto_ptr< Location_type >& Location,
                           ::std::auto_ptr< Sweep_type >& Sweep,
                           ::std::auto_ptr< Normal_type >& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Sweep_ (Sweep, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    ArcFeatureNominalType::
    ArcFeatureNominalType (const ArcFeatureNominalType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    ArcFeatureNominalType::
    ArcFeatureNominalType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Sweep_ (f, this),
      Normal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ArcFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Sweep",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcFeatureNominalType* ArcFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcFeatureNominalType (*this, f, c);
    }

    ArcFeatureNominalType::
    ~ArcFeatureNominalType ()
    {
    }

    // ArcFeatureActualType
    //

    ArcFeatureActualType::
    ArcFeatureActualType (const id_type& id,
                          const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      Radius_ (::xml_schema::flags (), this),
      RadiusMin_ (::xml_schema::flags (), this),
      RadiusMax_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ArcFeatureActualType::
    ArcFeatureActualType (const id_type& id,
                          ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      Radius_ (::xml_schema::flags (), this),
      RadiusMin_ (::xml_schema::flags (), this),
      RadiusMax_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ArcFeatureActualType::
    ArcFeatureActualType (const ArcFeatureActualType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      Radius_ (x.Radius_, f, this),
      RadiusMin_ (x.RadiusMin_, f, this),
      RadiusMax_ (x.RadiusMax_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ArcFeatureActualType::
    ArcFeatureActualType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Normal_ (f, this),
      Radius_ (f, this),
      RadiusMin_ (f, this),
      RadiusMax_ (f, this),
      Sweep_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ArcFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // Radius
        //
        if (n.name () == "Radius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Radius_type > r (
            Radius_traits::create (i, f, this));

          if (!this->Radius_)
          {
            this->Radius_.set (r);
            continue;
          }
        }

        // RadiusMin
        //
        if (n.name () == "RadiusMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RadiusMin_type > r (
            RadiusMin_traits::create (i, f, this));

          if (!this->RadiusMin_)
          {
            this->RadiusMin_.set (r);
            continue;
          }
        }

        // RadiusMax
        //
        if (n.name () == "RadiusMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RadiusMax_type > r (
            RadiusMax_traits::create (i, f, this));

          if (!this->RadiusMax_)
          {
            this->RadiusMax_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcFeatureActualType* ArcFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcFeatureActualType (*this, f, c);
    }

    ArcFeatureActualType::
    ~ArcFeatureActualType ()
    {
    }

    // CircleConstructionMethodType
    //

    CircleConstructionMethodType::
    CircleConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Intersection_ (::xml_schema::flags (), this),
      Projection_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Tangent_ (::xml_schema::flags (), this),
      TangentThrough_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromCone_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this)
    {
    }

    CircleConstructionMethodType::
    CircleConstructionMethodType (const CircleConstructionMethodType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Tangent_ (x.Tangent_, f, this),
      TangentThrough_ (x.TangentThrough_, f, this),
      Transform_ (x.Transform_, f, this),
      FromCone_ (x.FromCone_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    CircleConstructionMethodType::
    CircleConstructionMethodType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Intersection_ (f, this),
      Projection_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Tangent_ (f, this),
      TangentThrough_ (f, this),
      Transform_ (f, this),
      FromCone_ (f, this),
      FromScan_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == "Intersection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Tangent
        //
        if (n.name () == "Tangent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Tangent_type > r (
            Tangent_traits::create (i, f, this));

          if (!this->Tangent_)
          {
            this->Tangent_.set (r);
            continue;
          }
        }

        // TangentThrough
        //
        if (n.name () == "TangentThrough" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentThrough_type > r (
            TangentThrough_traits::create (i, f, this));

          if (!this->TangentThrough_)
          {
            this->TangentThrough_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromCone
        //
        if (n.name () == "FromCone" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromCone_type > r (
            FromCone_traits::create (i, f, this));

          if (!this->FromCone_)
          {
            this->FromCone_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleConstructionMethodType* CircleConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleConstructionMethodType (*this, f, c);
    }

    CircleConstructionMethodType::
    ~CircleConstructionMethodType ()
    {
    }

    // CircleBestFitType
    //

    CircleBestFitType::
    CircleBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    CircleBestFitType::
    CircleBestFitType (const CircleBestFitType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CircleBestFitType::
    CircleBestFitType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    CircleBestFitType* CircleBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleBestFitType (*this, f, c);
    }

    CircleBestFitType::
    ~CircleBestFitType ()
    {
    }

    // CircleRecompType
    //

    CircleRecompType::
    CircleRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    CircleRecompType::
    CircleRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    CircleRecompType::
    CircleRecompType (const CircleRecompType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CircleRecompType::
    CircleRecompType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleRecompType* CircleRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleRecompType (*this, f, c);
    }

    CircleRecompType::
    ~CircleRecompType ()
    {
    }

    // CircleIntersectionType
    //

    CircleIntersectionType::
    CircleIntersectionType (const IntersectionPlane_type& IntersectionPlane,
                            const IntersectionFeature_type& IntersectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, ::xml_schema::flags (), this),
      IntersectionFeature_ (IntersectionFeature, ::xml_schema::flags (), this)
    {
    }

    CircleIntersectionType::
    CircleIntersectionType (::std::auto_ptr< IntersectionPlane_type >& IntersectionPlane,
                            ::std::auto_ptr< IntersectionFeature_type >& IntersectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, ::xml_schema::flags (), this),
      IntersectionFeature_ (IntersectionFeature, ::xml_schema::flags (), this)
    {
    }

    CircleIntersectionType::
    CircleIntersectionType (const CircleIntersectionType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      IntersectionPlane_ (x.IntersectionPlane_, f, this),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    CircleIntersectionType::
    CircleIntersectionType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionPlane_ (f, this),
      IntersectionFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IntersectionPlane
        //
        if (n.name () == "IntersectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IntersectionPlane_type > r (
            IntersectionPlane_traits::create (i, f, this));

          if (!IntersectionPlane_.present ())
          {
            this->IntersectionPlane_.set (r);
            continue;
          }
        }

        // IntersectionFeature
        //
        if (n.name () == "IntersectionFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          if (!IntersectionFeature_.present ())
          {
            this->IntersectionFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!IntersectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IntersectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!IntersectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IntersectionFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleIntersectionType* CircleIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleIntersectionType (*this, f, c);
    }

    CircleIntersectionType::
    ~CircleIntersectionType ()
    {
    }

    // CircleProjectionType
    //

    CircleProjectionType::
    CircleProjectionType (const ProjectionCircle_type& ProjectionCircle,
                          const ProjectionPlane_type& ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionCircle_ (ProjectionCircle, ::xml_schema::flags (), this),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this)
    {
    }

    CircleProjectionType::
    CircleProjectionType (::std::auto_ptr< ProjectionCircle_type >& ProjectionCircle,
                          ::std::auto_ptr< ProjectionPlane_type >& ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionCircle_ (ProjectionCircle, ::xml_schema::flags (), this),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this)
    {
    }

    CircleProjectionType::
    CircleProjectionType (const CircleProjectionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionCircle_ (x.ProjectionCircle_, f, this),
      ProjectionPlane_ (x.ProjectionPlane_, f, this)
    {
    }

    CircleProjectionType::
    CircleProjectionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionCircle_ (f, this),
      ProjectionPlane_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionCircle
        //
        if (n.name () == "ProjectionCircle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionCircle_type > r (
            ProjectionCircle_traits::create (i, f, this));

          if (!ProjectionCircle_.present ())
          {
            this->ProjectionCircle_.set (r);
            continue;
          }
        }

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionCircle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionCircle",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleProjectionType* CircleProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleProjectionType (*this, f, c);
    }

    CircleProjectionType::
    ~CircleProjectionType ()
    {
    }

    // CircleCopyType
    //

    CircleCopyType::
    CircleCopyType (const BaseCircle_type& BaseCircle)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCircle_ (BaseCircle, ::xml_schema::flags (), this)
    {
    }

    CircleCopyType::
    CircleCopyType (::std::auto_ptr< BaseCircle_type >& BaseCircle)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCircle_ (BaseCircle, ::xml_schema::flags (), this)
    {
    }

    CircleCopyType::
    CircleCopyType (const CircleCopyType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCircle_ (x.BaseCircle_, f, this)
    {
    }

    CircleCopyType::
    CircleCopyType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCircle_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCircle
        //
        if (n.name () == "BaseCircle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCircle_type > r (
            BaseCircle_traits::create (i, f, this));

          if (!BaseCircle_.present ())
          {
            this->BaseCircle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCircle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCircle",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleCopyType* CircleCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCopyType (*this, f, c);
    }

    CircleCopyType::
    ~CircleCopyType ()
    {
    }

    // CircleCastType
    //

    CircleCastType::
    CircleCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    CircleCastType::
    CircleCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    CircleCastType::
    CircleCastType (const CircleCastType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CircleCastType::
    CircleCastType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleCastType* CircleCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCastType (*this, f, c);
    }

    CircleCastType::
    ~CircleCastType ()
    {
    }

    // CircleTangentType
    //

    CircleTangentType::
    CircleTangentType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (::xml_schema::flags (), this)
    {
    }

    CircleTangentType::
    CircleTangentType (const CircleTangentType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this)
    {
    }

    CircleTangentType::
    CircleTangentType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleTangentType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TangentFeature
        //
        if (n.name () == "TangentFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          this->TangentFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    CircleTangentType* CircleTangentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleTangentType (*this, f, c);
    }

    CircleTangentType::
    ~CircleTangentType ()
    {
    }

    // CircleTangentThroughType
    //

    CircleTangentThroughType::
    CircleTangentThroughType (const TangentFeature_type& TangentFeature,
                              const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    CircleTangentThroughType::
    CircleTangentThroughType (::std::auto_ptr< TangentFeature_type >& TangentFeature,
                              ::std::auto_ptr< PointFeature_type >& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    CircleTangentThroughType::
    CircleTangentThroughType (const CircleTangentThroughType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    CircleTangentThroughType::
    CircleTangentThroughType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (f, this),
      PointFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleTangentThroughType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TangentFeature
        //
        if (n.name () == "TangentFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          if (!TangentFeature_.present ())
          {
            this->TangentFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!TangentFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TangentFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleTangentThroughType* CircleTangentThroughType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleTangentThroughType (*this, f, c);
    }

    CircleTangentThroughType::
    ~CircleTangentThroughType ()
    {
    }

    // CircleTransformType
    //

    CircleTransformType::
    CircleTransformType (const BaseCircle_type& BaseCircle,
                         const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCircle_ (BaseCircle, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    CircleTransformType::
    CircleTransformType (::std::auto_ptr< BaseCircle_type >& BaseCircle,
                         ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCircle_ (BaseCircle, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    CircleTransformType::
    CircleTransformType (const CircleTransformType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCircle_ (x.BaseCircle_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CircleTransformType::
    CircleTransformType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCircle_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCircle
        //
        if (n.name () == "BaseCircle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCircle_type > r (
            BaseCircle_traits::create (i, f, this));

          if (!BaseCircle_.present ())
          {
            this->BaseCircle_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCircle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCircle",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleTransformType* CircleTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleTransformType (*this, f, c);
    }

    CircleTransformType::
    ~CircleTransformType ()
    {
    }

    // CircleFromConeType
    //

    CircleFromConeType::
    CircleFromConeType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      Diameter_ (::xml_schema::flags (), this),
      Distance_ (::xml_schema::flags (), this)
    {
    }

    CircleFromConeType::
    CircleFromConeType (const CircleFromConeType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      Distance_ (x.Distance_, f, this)
    {
    }

    CircleFromConeType::
    CircleFromConeType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      Diameter_ (f, this),
      Distance_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleFromConeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Distance
        //
        if (n.name () == "Distance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!this->Distance_)
          {
            this->Distance_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleFromConeType* CircleFromConeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFromConeType (*this, f, c);
    }

    CircleFromConeType::
    ~CircleFromConeType ()
    {
    }

    // CircleFromScanType
    //

    CircleFromScanType::
    CircleFromScanType (const SurfaceFeature_type& SurfaceFeature,
                        const SearchRadius_type& SearchRadius,
                        const Depth_type& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      Depth_ (Depth, ::xml_schema::flags (), this)
    {
    }

    CircleFromScanType::
    CircleFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                        ::std::auto_ptr< SearchRadius_type >& SearchRadius,
                        ::std::auto_ptr< Depth_type >& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      Depth_ (Depth, ::xml_schema::flags (), this)
    {
    }

    CircleFromScanType::
    CircleFromScanType (const CircleFromScanType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    CircleFromScanType::
    CircleFromScanType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this),
      Depth_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Depth",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleFromScanType* CircleFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFromScanType (*this, f, c);
    }

    CircleFromScanType::
    ~CircleFromScanType ()
    {
    }

    // CircleCheckedType
    //

    CircleCheckedType::
    CircleCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    CircleCheckedType::
    CircleCheckedType (const CircleCheckedType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CircleCheckedType::
    CircleCheckedType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleCheckedType* CircleCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCheckedType (*this, f, c);
    }

    CircleCheckedType::
    ~CircleCheckedType ()
    {
    }

    // CircleCheckedFeatureType
    //

    CircleCheckedFeatureType::
    CircleCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    CircleCheckedFeatureType::
    CircleCheckedFeatureType (const CircleCheckedFeatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CircleCheckedFeatureType::
    CircleCheckedFeatureType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleCheckedFeatureType* CircleCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCheckedFeatureType (*this, f, c);
    }

    CircleCheckedFeatureType::
    ~CircleCheckedFeatureType ()
    {
    }

    // CircleActualDeterminationType
    //

    CircleActualDeterminationType::
    CircleActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    CircleActualDeterminationType::
    CircleActualDeterminationType (const CircleActualDeterminationType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CircleActualDeterminationType::
    CircleActualDeterminationType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CircleActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleActualDeterminationType* CircleActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleActualDeterminationType (*this, f, c);
    }

    CircleActualDeterminationType::
    ~CircleActualDeterminationType ()
    {
    }

    // CircleFeatureItemType
    //

    CircleFeatureItemType::
    CircleFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    CircleFeatureItemType::
    CircleFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    CircleFeatureItemType::
    CircleFeatureItemType (const CircleFeatureItemType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    CircleFeatureItemType::
    CircleFeatureItemType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleFeatureItemType* CircleFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureItemType (*this, f, c);
    }

    CircleFeatureItemType::
    ~CircleFeatureItemType ()
    {
    }

    // CircleFeatureDefinitionType
    //

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this)
    {
    }

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 ::std::auto_ptr< Diameter_type >& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this)
    {
    }

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const CircleFeatureDefinitionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this)
    {
    }

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Diameter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleFeatureDefinitionType* CircleFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureDefinitionType (*this, f, c);
    }

    CircleFeatureDefinitionType::
    ~CircleFeatureDefinitionType ()
    {
    }

    // CircleFeatureNominalType
    //

    CircleFeatureNominalType::
    CircleFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              const Location_type& Location,
                              const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    CircleFeatureNominalType::
    CircleFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              ::std::auto_ptr< Location_type >& Location,
                              ::std::auto_ptr< Normal_type >& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    CircleFeatureNominalType::
    CircleFeatureNominalType (const CircleFeatureNominalType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    CircleFeatureNominalType::
    CircleFeatureNominalType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Normal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleFeatureNominalType* CircleFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureNominalType (*this, f, c);
    }

    CircleFeatureNominalType::
    ~CircleFeatureNominalType ()
    {
    }

    // CircleFeatureActualType
    //

    CircleFeatureActualType::
    CircleFeatureActualType (const id_type& id,
                             const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    CircleFeatureActualType::
    CircleFeatureActualType (const id_type& id,
                             ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    CircleFeatureActualType::
    CircleFeatureActualType (const CircleFeatureActualType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    CircleFeatureActualType::
    CircleFeatureActualType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Normal_ (f, this),
      Diameter_ (f, this),
      DiameterMin_ (f, this),
      DiameterMax_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleFeatureActualType* CircleFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureActualType (*this, f, c);
    }

    CircleFeatureActualType::
    ~CircleFeatureActualType ()
    {
    }

    // ConeConstructionMethodType
    //

    ConeConstructionMethodType::
    ConeConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this)
    {
    }

    ConeConstructionMethodType::
    ConeConstructionMethodType (const ConeConstructionMethodType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    ConeConstructionMethodType::
    ConeConstructionMethodType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this),
      FromScan_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConeConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConeConstructionMethodType* ConeConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeConstructionMethodType (*this, f, c);
    }

    ConeConstructionMethodType::
    ~ConeConstructionMethodType ()
    {
    }

    // ConeBestFitType
    //

    ConeBestFitType::
    ConeBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    ConeBestFitType::
    ConeBestFitType (const ConeBestFitType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ConeBestFitType::
    ConeBestFitType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConeBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ConeBestFitType* ConeBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeBestFitType (*this, f, c);
    }

    ConeBestFitType::
    ~ConeBestFitType ()
    {
    }

    // ConeRecompType
    //

    ConeRecompType::
    ConeRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ConeRecompType::
    ConeRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ConeRecompType::
    ConeRecompType (const ConeRecompType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ConeRecompType::
    ConeRecompType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConeRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeRecompType* ConeRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeRecompType (*this, f, c);
    }

    ConeRecompType::
    ~ConeRecompType ()
    {
    }

    // ConeCopyType
    //

    ConeCopyType::
    ConeCopyType (const BaseCone_type& BaseCone)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, ::xml_schema::flags (), this)
    {
    }

    ConeCopyType::
    ConeCopyType (::std::auto_ptr< BaseCone_type >& BaseCone)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, ::xml_schema::flags (), this)
    {
    }

    ConeCopyType::
    ConeCopyType (const ConeCopyType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCone_ (x.BaseCone_, f, this)
    {
    }

    ConeCopyType::
    ConeCopyType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCone_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConeCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCone
        //
        if (n.name () == "BaseCone" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCone_type > r (
            BaseCone_traits::create (i, f, this));

          if (!BaseCone_.present ())
          {
            this->BaseCone_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCone_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCone",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeCopyType* ConeCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCopyType (*this, f, c);
    }

    ConeCopyType::
    ~ConeCopyType ()
    {
    }

    // ConeCastType
    //

    ConeCastType::
    ConeCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ConeCastType::
    ConeCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ConeCastType::
    ConeCastType (const ConeCastType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ConeCastType::
    ConeCastType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConeCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeCastType* ConeCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCastType (*this, f, c);
    }

    ConeCastType::
    ~ConeCastType ()
    {
    }

    // ConeTransformType
    //

    ConeTransformType::
    ConeTransformType (const BaseCone_type& BaseCone,
                       const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ConeTransformType::
    ConeTransformType (::std::auto_ptr< BaseCone_type >& BaseCone,
                       ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ConeTransformType::
    ConeTransformType (const ConeTransformType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCone_ (x.BaseCone_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ConeTransformType::
    ConeTransformType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCone_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConeTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCone
        //
        if (n.name () == "BaseCone" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCone_type > r (
            BaseCone_traits::create (i, f, this));

          if (!BaseCone_.present ())
          {
            this->BaseCone_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCone_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCone",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeTransformType* ConeTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeTransformType (*this, f, c);
    }

    ConeTransformType::
    ~ConeTransformType ()
    {
    }

    // ConeFromScanType
    //

    ConeFromScanType::
    ConeFromScanType (const SurfaceFeature_type& SurfaceFeature,
                      const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    ConeFromScanType::
    ConeFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                      ::std::auto_ptr< SearchRadius_type >& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    ConeFromScanType::
    ConeFromScanType (const ConeFromScanType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    ConeFromScanType::
    ConeFromScanType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConeFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeFromScanType* ConeFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFromScanType (*this, f, c);
    }

    ConeFromScanType::
    ~ConeFromScanType ()
    {
    }

    // ConeCheckedType
    //

    ConeCheckedType::
    ConeCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    ConeCheckedType::
    ConeCheckedType (const ConeCheckedType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ConeCheckedType::
    ConeCheckedType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConeCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConeCheckedType* ConeCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCheckedType (*this, f, c);
    }

    ConeCheckedType::
    ~ConeCheckedType ()
    {
    }

    // ConeCheckedFeatureType
    //

    ConeCheckedFeatureType::
    ConeCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    ConeCheckedFeatureType::
    ConeCheckedFeatureType (const ConeCheckedFeatureType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ConeCheckedFeatureType::
    ConeCheckedFeatureType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConeCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConeCheckedFeatureType* ConeCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCheckedFeatureType (*this, f, c);
    }

    ConeCheckedFeatureType::
    ~ConeCheckedFeatureType ()
    {
    }

    // ConeActualDeterminationType
    //

    ConeActualDeterminationType::
    ConeActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    ConeActualDeterminationType::
    ConeActualDeterminationType (const ConeActualDeterminationType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ConeActualDeterminationType::
    ConeActualDeterminationType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConeActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConeActualDeterminationType* ConeActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeActualDeterminationType (*this, f, c);
    }

    ConeActualDeterminationType::
    ~ConeActualDeterminationType ()
    {
    }

    // ConeFeatureItemType
    //

    ConeFeatureItemType::
    ConeFeatureItemType (const id_type& id,
                         const FeatureName_type& FeatureName,
                         const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ConeFeatureItemType::
    ConeFeatureItemType (const id_type& id,
                         const FeatureName_type& FeatureName,
                         ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ConeFeatureItemType::
    ConeFeatureItemType (const ConeFeatureItemType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ConeFeatureItemType::
    ConeFeatureItemType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeFeatureItemType* ConeFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureItemType (*this, f, c);
    }

    ConeFeatureItemType::
    ~ConeFeatureItemType ()
    {
    }

    // ConeFeatureDefinitionType
    //

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const id_type& id,
                               const InternalExternal_type& InternalExternal,
                               const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this),
      HalfAngle_ (::xml_schema::flags (), this),
      FullAngle_ (::xml_schema::flags (), this),
      LargeEndDistance_ (::xml_schema::flags (), this),
      SmallEndDistance_ (::xml_schema::flags (), this)
    {
    }

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const id_type& id,
                               const InternalExternal_type& InternalExternal,
                               ::std::auto_ptr< Diameter_type >& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this),
      HalfAngle_ (::xml_schema::flags (), this),
      FullAngle_ (::xml_schema::flags (), this),
      LargeEndDistance_ (::xml_schema::flags (), this),
      SmallEndDistance_ (::xml_schema::flags (), this)
    {
    }

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const ConeFeatureDefinitionType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this)
    {
    }

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Diameter_ (f, this),
      HalfAngle_ (f, this),
      FullAngle_ (f, this),
      LargeEndDistance_ (f, this),
      SmallEndDistance_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == "HalfAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (r);
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == "FullAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (r);
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == "LargeEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (r);
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == "SmallEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeFeatureDefinitionType* ConeFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureDefinitionType (*this, f, c);
    }

    ConeFeatureDefinitionType::
    ~ConeFeatureDefinitionType ()
    {
    }

    // ConeFeatureNominalType
    //

    ConeFeatureNominalType::
    ConeFeatureNominalType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId,
                            const Axis_type& Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this)
    {
    }

    ConeFeatureNominalType::
    ConeFeatureNominalType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId,
                            ::std::auto_ptr< Axis_type >& Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this)
    {
    }

    ConeFeatureNominalType::
    ConeFeatureNominalType (const ConeFeatureNominalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this)
    {
    }

    ConeFeatureNominalType::
    ConeFeatureNominalType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Sweep_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeFeatureNominalType* ConeFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureNominalType (*this, f, c);
    }

    ConeFeatureNominalType::
    ~ConeFeatureNominalType ()
    {
    }

    // ConeFeatureActualType
    //

    ConeFeatureActualType::
    ConeFeatureActualType (const id_type& id,
                           const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      HalfAngle_ (::xml_schema::flags (), this),
      FullAngle_ (::xml_schema::flags (), this),
      SmallEndDistance_ (::xml_schema::flags (), this),
      LargeEndDistance_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ConeFeatureActualType::
    ConeFeatureActualType (const id_type& id,
                           ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      HalfAngle_ (::xml_schema::flags (), this),
      FullAngle_ (::xml_schema::flags (), this),
      SmallEndDistance_ (::xml_schema::flags (), this),
      LargeEndDistance_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ConeFeatureActualType::
    ConeFeatureActualType (const ConeFeatureActualType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ConeFeatureActualType::
    ConeFeatureActualType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Diameter_ (f, this),
      DiameterMin_ (f, this),
      DiameterMax_ (f, this),
      HalfAngle_ (f, this),
      FullAngle_ (f, this),
      SmallEndDistance_ (f, this),
      LargeEndDistance_ (f, this),
      Sweep_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == "HalfAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (r);
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == "FullAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (r);
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == "SmallEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (r);
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == "LargeEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConeFeatureActualType* ConeFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureActualType (*this, f, c);
    }

    ConeFeatureActualType::
    ~ConeFeatureActualType ()
    {
    }

    // ConicalSegmentConstructionMethodType
    //

    ConicalSegmentConstructionMethodType::
    ConicalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentConstructionMethodType::
    ConicalSegmentConstructionMethodType (const ConicalSegmentConstructionMethodType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ConicalSegmentConstructionMethodType::
    ConicalSegmentConstructionMethodType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentConstructionMethodType* ConicalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentConstructionMethodType (*this, f, c);
    }

    ConicalSegmentConstructionMethodType::
    ~ConicalSegmentConstructionMethodType ()
    {
    }

    // ConicalSegmentBestFitType
    //

    ConicalSegmentBestFitType::
    ConicalSegmentBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentBestFitType::
    ConicalSegmentBestFitType (const ConicalSegmentBestFitType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ConicalSegmentBestFitType::
    ConicalSegmentBestFitType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ConicalSegmentBestFitType* ConicalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentBestFitType (*this, f, c);
    }

    ConicalSegmentBestFitType::
    ~ConicalSegmentBestFitType ()
    {
    }

    // ConicalSegmentRecompType
    //

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (const ConicalSegmentRecompType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentRecompType* ConicalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentRecompType (*this, f, c);
    }

    ConicalSegmentRecompType::
    ~ConicalSegmentRecompType ()
    {
    }

    // ConicalSegmentCopyType
    //

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (const BaseConicalSegment_type& BaseConicalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseConicalSegment_ (BaseConicalSegment, ::xml_schema::flags (), this)
    {
    }

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (::std::auto_ptr< BaseConicalSegment_type >& BaseConicalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseConicalSegment_ (BaseConicalSegment, ::xml_schema::flags (), this)
    {
    }

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (const ConicalSegmentCopyType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseConicalSegment_ (x.BaseConicalSegment_, f, this)
    {
    }

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseConicalSegment_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseConicalSegment
        //
        if (n.name () == "BaseConicalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseConicalSegment_type > r (
            BaseConicalSegment_traits::create (i, f, this));

          if (!BaseConicalSegment_.present ())
          {
            this->BaseConicalSegment_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseConicalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseConicalSegment",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentCopyType* ConicalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCopyType (*this, f, c);
    }

    ConicalSegmentCopyType::
    ~ConicalSegmentCopyType ()
    {
    }

    // ConicalSegmentCastType
    //

    ConicalSegmentCastType::
    ConicalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ConicalSegmentCastType::
    ConicalSegmentCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ConicalSegmentCastType::
    ConicalSegmentCastType (const ConicalSegmentCastType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ConicalSegmentCastType::
    ConicalSegmentCastType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentCastType* ConicalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCastType (*this, f, c);
    }

    ConicalSegmentCastType::
    ~ConicalSegmentCastType ()
    {
    }

    // ConicalSegmentTransformType
    //

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (const BaseConicalSegment_type& BaseConicalSegment,
                                 const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseConicalSegment_ (BaseConicalSegment, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (::std::auto_ptr< BaseConicalSegment_type >& BaseConicalSegment,
                                 ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseConicalSegment_ (BaseConicalSegment, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (const ConicalSegmentTransformType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseConicalSegment_ (x.BaseConicalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseConicalSegment_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseConicalSegment
        //
        if (n.name () == "BaseConicalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseConicalSegment_type > r (
            BaseConicalSegment_traits::create (i, f, this));

          if (!BaseConicalSegment_.present ())
          {
            this->BaseConicalSegment_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseConicalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseConicalSegment",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentTransformType* ConicalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentTransformType (*this, f, c);
    }

    ConicalSegmentTransformType::
    ~ConicalSegmentTransformType ()
    {
    }

    // ConicalSegmentCheckedType
    //

    ConicalSegmentCheckedType::
    ConicalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentCheckedType::
    ConicalSegmentCheckedType (const ConicalSegmentCheckedType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ConicalSegmentCheckedType::
    ConicalSegmentCheckedType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentCheckedType* ConicalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCheckedType (*this, f, c);
    }

    ConicalSegmentCheckedType::
    ~ConicalSegmentCheckedType ()
    {
    }

    // ConicalSegmentCheckedFeatureType
    //

    ConicalSegmentCheckedFeatureType::
    ConicalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentCheckedFeatureType::
    ConicalSegmentCheckedFeatureType (const ConicalSegmentCheckedFeatureType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ConicalSegmentCheckedFeatureType::
    ConicalSegmentCheckedFeatureType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentCheckedFeatureType* ConicalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCheckedFeatureType (*this, f, c);
    }

    ConicalSegmentCheckedFeatureType::
    ~ConicalSegmentCheckedFeatureType ()
    {
    }

    // ConicalSegmentActualDeterminationType
    //

    ConicalSegmentActualDeterminationType::
    ConicalSegmentActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentActualDeterminationType::
    ConicalSegmentActualDeterminationType (const ConicalSegmentActualDeterminationType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ConicalSegmentActualDeterminationType::
    ConicalSegmentActualDeterminationType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentActualDeterminationType* ConicalSegmentActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentActualDeterminationType (*this, f, c);
    }

    ConicalSegmentActualDeterminationType::
    ~ConicalSegmentActualDeterminationType ()
    {
    }

    // ConicalSegmentFeatureItemType
    //

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const id_type& id,
                                   const FeatureName_type& FeatureName,
                                   const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const id_type& id,
                                   const FeatureName_type& FeatureName,
                                   ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const ConicalSegmentFeatureItemType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentFeatureItemType* ConicalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureItemType (*this, f, c);
    }

    ConicalSegmentFeatureItemType::
    ~ConicalSegmentFeatureItemType ()
    {
    }

    // ConicalSegmentFeatureDefinitionType
    //

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const id_type& id,
                                         const InternalExternal_type& InternalExternal,
                                         const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this),
      HalfAngle_ (::xml_schema::flags (), this),
      FullAngle_ (::xml_schema::flags (), this),
      LargeEndDistance_ (::xml_schema::flags (), this),
      SmallEndDistance_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const id_type& id,
                                         const InternalExternal_type& InternalExternal,
                                         ::std::auto_ptr< Diameter_type >& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this),
      HalfAngle_ (::xml_schema::flags (), this),
      FullAngle_ (::xml_schema::flags (), this),
      LargeEndDistance_ (::xml_schema::flags (), this),
      SmallEndDistance_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const ConicalSegmentFeatureDefinitionType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this)
    {
    }

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Diameter_ (f, this),
      HalfAngle_ (f, this),
      FullAngle_ (f, this),
      LargeEndDistance_ (f, this),
      SmallEndDistance_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == "HalfAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (r);
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == "FullAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (r);
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == "LargeEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (r);
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == "SmallEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentFeatureDefinitionType* ConicalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureDefinitionType (*this, f, c);
    }

    ConicalSegmentFeatureDefinitionType::
    ~ConicalSegmentFeatureDefinitionType ()
    {
    }

    // ConicalSegmentFeatureNominalType
    //

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const id_type& id,
                                      const FeatureDefinitionId_type& FeatureDefinitionId,
                                      const Axis_type& Axis,
                                      const Sweep_type& Sweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Sweep_ (Sweep, ::xml_schema::flags (), this)
    {
    }

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const id_type& id,
                                      const FeatureDefinitionId_type& FeatureDefinitionId,
                                      ::std::auto_ptr< Axis_type >& Axis,
                                      ::std::auto_ptr< Sweep_type >& Sweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Sweep_ (Sweep, ::xml_schema::flags (), this)
    {
    }

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const ConicalSegmentFeatureNominalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this)
    {
    }

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Sweep_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Sweep",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentFeatureNominalType* ConicalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureNominalType (*this, f, c);
    }

    ConicalSegmentFeatureNominalType::
    ~ConicalSegmentFeatureNominalType ()
    {
    }

    // ConicalSegmentFeatureActualType
    //

    ConicalSegmentFeatureActualType::
    ConicalSegmentFeatureActualType (const id_type& id,
                                     const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      HalfAngle_ (::xml_schema::flags (), this),
      FullAngle_ (::xml_schema::flags (), this),
      SmallEndDistance_ (::xml_schema::flags (), this),
      LargeEndDistance_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentFeatureActualType::
    ConicalSegmentFeatureActualType (const id_type& id,
                                     ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      HalfAngle_ (::xml_schema::flags (), this),
      FullAngle_ (::xml_schema::flags (), this),
      SmallEndDistance_ (::xml_schema::flags (), this),
      LargeEndDistance_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ConicalSegmentFeatureActualType::
    ConicalSegmentFeatureActualType (const ConicalSegmentFeatureActualType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ConicalSegmentFeatureActualType::
    ConicalSegmentFeatureActualType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Diameter_ (f, this),
      DiameterMin_ (f, this),
      DiameterMax_ (f, this),
      HalfAngle_ (f, this),
      FullAngle_ (f, this),
      SmallEndDistance_ (f, this),
      LargeEndDistance_ (f, this),
      Sweep_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == "HalfAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (r);
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == "FullAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (r);
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == "SmallEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (r);
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == "LargeEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentFeatureActualType* ConicalSegmentFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureActualType (*this, f, c);
    }

    ConicalSegmentFeatureActualType::
    ~ConicalSegmentFeatureActualType ()
    {
    }

    // CuboidConstructionMethodType
    //

    CuboidConstructionMethodType::
    CuboidConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this)
    {
    }

    CuboidConstructionMethodType::
    CuboidConstructionMethodType (const CuboidConstructionMethodType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    CuboidConstructionMethodType::
    CuboidConstructionMethodType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CuboidConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidConstructionMethodType* CuboidConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidConstructionMethodType (*this, f, c);
    }

    CuboidConstructionMethodType::
    ~CuboidConstructionMethodType ()
    {
    }

    // CuboidBestFitType
    //

    CuboidBestFitType::
    CuboidBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    CuboidBestFitType::
    CuboidBestFitType (const CuboidBestFitType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CuboidBestFitType::
    CuboidBestFitType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CuboidBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    CuboidBestFitType* CuboidBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidBestFitType (*this, f, c);
    }

    CuboidBestFitType::
    ~CuboidBestFitType ()
    {
    }

    // CuboidRecompType
    //

    CuboidRecompType::
    CuboidRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    CuboidRecompType::
    CuboidRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    CuboidRecompType::
    CuboidRecompType (const CuboidRecompType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CuboidRecompType::
    CuboidRecompType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CuboidRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidRecompType* CuboidRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidRecompType (*this, f, c);
    }

    CuboidRecompType::
    ~CuboidRecompType ()
    {
    }

    // CuboidCopyType
    //

    CuboidCopyType::
    CuboidCopyType (const BaseCuboid_type& BaseCuboid)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCuboid_ (BaseCuboid, ::xml_schema::flags (), this)
    {
    }

    CuboidCopyType::
    CuboidCopyType (::std::auto_ptr< BaseCuboid_type >& BaseCuboid)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCuboid_ (BaseCuboid, ::xml_schema::flags (), this)
    {
    }

    CuboidCopyType::
    CuboidCopyType (const CuboidCopyType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCuboid_ (x.BaseCuboid_, f, this)
    {
    }

    CuboidCopyType::
    CuboidCopyType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCuboid_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CuboidCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCuboid
        //
        if (n.name () == "BaseCuboid" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCuboid_type > r (
            BaseCuboid_traits::create (i, f, this));

          if (!BaseCuboid_.present ())
          {
            this->BaseCuboid_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCuboid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCuboid",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidCopyType* CuboidCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidCopyType (*this, f, c);
    }

    CuboidCopyType::
    ~CuboidCopyType ()
    {
    }

    // CuboidCastType
    //

    CuboidCastType::
    CuboidCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    CuboidCastType::
    CuboidCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    CuboidCastType::
    CuboidCastType (const CuboidCastType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CuboidCastType::
    CuboidCastType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CuboidCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidCastType* CuboidCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidCastType (*this, f, c);
    }

    CuboidCastType::
    ~CuboidCastType ()
    {
    }

    // CuboidTransformType
    //

    CuboidTransformType::
    CuboidTransformType (const BaseCuboid_type& BaseCuboid,
                         const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCuboid_ (BaseCuboid, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    CuboidTransformType::
    CuboidTransformType (::std::auto_ptr< BaseCuboid_type >& BaseCuboid,
                         ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCuboid_ (BaseCuboid, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    CuboidTransformType::
    CuboidTransformType (const CuboidTransformType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCuboid_ (x.BaseCuboid_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CuboidTransformType::
    CuboidTransformType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCuboid_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CuboidTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCuboid
        //
        if (n.name () == "BaseCuboid" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCuboid_type > r (
            BaseCuboid_traits::create (i, f, this));

          if (!BaseCuboid_.present ())
          {
            this->BaseCuboid_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCuboid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCuboid",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidTransformType* CuboidTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidTransformType (*this, f, c);
    }

    CuboidTransformType::
    ~CuboidTransformType ()
    {
    }

    // CuboidCheckedType
    //

    CuboidCheckedType::
    CuboidCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    CuboidCheckedType::
    CuboidCheckedType (const CuboidCheckedType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CuboidCheckedType::
    CuboidCheckedType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CuboidCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidCheckedType* CuboidCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidCheckedType (*this, f, c);
    }

    CuboidCheckedType::
    ~CuboidCheckedType ()
    {
    }

    // CuboidCheckedFeatureType
    //

    CuboidCheckedFeatureType::
    CuboidCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    CuboidCheckedFeatureType::
    CuboidCheckedFeatureType (const CuboidCheckedFeatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CuboidCheckedFeatureType::
    CuboidCheckedFeatureType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CuboidCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidCheckedFeatureType* CuboidCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidCheckedFeatureType (*this, f, c);
    }

    CuboidCheckedFeatureType::
    ~CuboidCheckedFeatureType ()
    {
    }

    // CuboidActualDeterminationType
    //

    CuboidActualDeterminationType::
    CuboidActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    CuboidActualDeterminationType::
    CuboidActualDeterminationType (const CuboidActualDeterminationType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CuboidActualDeterminationType::
    CuboidActualDeterminationType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CuboidActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidActualDeterminationType* CuboidActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidActualDeterminationType (*this, f, c);
    }

    CuboidActualDeterminationType::
    ~CuboidActualDeterminationType ()
    {
    }

    // CuboidFeatureItemType
    //

    CuboidFeatureItemType::
    CuboidFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    CuboidFeatureItemType::
    CuboidFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    CuboidFeatureItemType::
    CuboidFeatureItemType (const CuboidFeatureItemType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    CuboidFeatureItemType::
    CuboidFeatureItemType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CuboidFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidFeatureItemType* CuboidFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidFeatureItemType (*this, f, c);
    }

    CuboidFeatureItemType::
    ~CuboidFeatureItemType ()
    {
    }

    // CuboidFeatureDefinitionType
    //

    CuboidFeatureDefinitionType::
    CuboidFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 const Length_type& Length,
                                 const Width_type& Width,
                                 const Height_type& Height)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Length_ (Length, ::xml_schema::flags (), this),
      Width_ (Width, ::xml_schema::flags (), this),
      Height_ (Height, ::xml_schema::flags (), this)
    {
    }

    CuboidFeatureDefinitionType::
    CuboidFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 ::std::auto_ptr< Length_type >& Length,
                                 ::std::auto_ptr< Width_type >& Width,
                                 ::std::auto_ptr< Height_type >& Height)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Length_ (Length, ::xml_schema::flags (), this),
      Width_ (Width, ::xml_schema::flags (), this),
      Height_ (Height, ::xml_schema::flags (), this)
    {
    }

    CuboidFeatureDefinitionType::
    CuboidFeatureDefinitionType (const CuboidFeatureDefinitionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Length_ (x.Length_, f, this),
      Width_ (x.Width_, f, this),
      Height_ (x.Height_, f, this)
    {
    }

    CuboidFeatureDefinitionType::
    CuboidFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Length_ (f, this),
      Width_ (f, this),
      Height_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CuboidFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (r);
            continue;
          }
        }

        // Height
        //
        if (n.name () == "Height" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Height_type > r (
            Height_traits::create (i, f, this));

          if (!Height_.present ())
          {
            this->Height_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Length",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Width",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Height_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Height",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidFeatureDefinitionType* CuboidFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidFeatureDefinitionType (*this, f, c);
    }

    CuboidFeatureDefinitionType::
    ~CuboidFeatureDefinitionType ()
    {
    }

    // CuboidFeatureNominalType
    //

    CuboidFeatureNominalType::
    CuboidFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              const Location_type& Location,
                              const LengthVector_type& LengthVector,
                              const HeightVector_type& HeightVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      LengthVector_ (LengthVector, ::xml_schema::flags (), this),
      HeightVector_ (HeightVector, ::xml_schema::flags (), this)
    {
    }

    CuboidFeatureNominalType::
    CuboidFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              ::std::auto_ptr< Location_type >& Location,
                              ::std::auto_ptr< LengthVector_type >& LengthVector,
                              ::std::auto_ptr< HeightVector_type >& HeightVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      LengthVector_ (LengthVector, ::xml_schema::flags (), this),
      HeightVector_ (HeightVector, ::xml_schema::flags (), this)
    {
    }

    CuboidFeatureNominalType::
    CuboidFeatureNominalType (const CuboidFeatureNominalType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      HeightVector_ (x.HeightVector_, f, this)
    {
    }

    CuboidFeatureNominalType::
    CuboidFeatureNominalType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      LengthVector_ (f, this),
      HeightVector_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CuboidFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == "LengthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!LengthVector_.present ())
          {
            this->LengthVector_.set (r);
            continue;
          }
        }

        // HeightVector
        //
        if (n.name () == "HeightVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HeightVector_type > r (
            HeightVector_traits::create (i, f, this));

          if (!HeightVector_.present ())
          {
            this->HeightVector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!LengthVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LengthVector",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!HeightVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "HeightVector",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidFeatureNominalType* CuboidFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidFeatureNominalType (*this, f, c);
    }

    CuboidFeatureNominalType::
    ~CuboidFeatureNominalType ()
    {
    }

    // CuboidFeatureActualType
    //

    CuboidFeatureActualType::
    CuboidFeatureActualType (const id_type& id,
                             const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      LengthMax_ (::xml_schema::flags (), this),
      LengthMin_ (::xml_schema::flags (), this),
      LengthVector_ (::xml_schema::flags (), this),
      Width_ (::xml_schema::flags (), this),
      WidthMax_ (::xml_schema::flags (), this),
      WidthMin_ (::xml_schema::flags (), this),
      Height_ (::xml_schema::flags (), this),
      HeightMax_ (::xml_schema::flags (), this),
      HeightMin_ (::xml_schema::flags (), this),
      HeightVector_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    CuboidFeatureActualType::
    CuboidFeatureActualType (const id_type& id,
                             ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      LengthMax_ (::xml_schema::flags (), this),
      LengthMin_ (::xml_schema::flags (), this),
      LengthVector_ (::xml_schema::flags (), this),
      Width_ (::xml_schema::flags (), this),
      WidthMax_ (::xml_schema::flags (), this),
      WidthMin_ (::xml_schema::flags (), this),
      Height_ (::xml_schema::flags (), this),
      HeightMax_ (::xml_schema::flags (), this),
      HeightMin_ (::xml_schema::flags (), this),
      HeightVector_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    CuboidFeatureActualType::
    CuboidFeatureActualType (const CuboidFeatureActualType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Length_ (x.Length_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      Width_ (x.Width_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      Height_ (x.Height_, f, this),
      HeightMax_ (x.HeightMax_, f, this),
      HeightMin_ (x.HeightMin_, f, this),
      HeightVector_ (x.HeightVector_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    CuboidFeatureActualType::
    CuboidFeatureActualType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Length_ (f, this),
      LengthMax_ (f, this),
      LengthMin_ (f, this),
      LengthVector_ (f, this),
      Width_ (f, this),
      WidthMax_ (f, this),
      WidthMin_ (f, this),
      Height_ (f, this),
      HeightMax_ (f, this),
      HeightMin_ (f, this),
      HeightVector_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CuboidFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == "LengthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (r);
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == "LengthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (r);
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == "LengthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!this->LengthVector_)
          {
            this->LengthVector_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (r);
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == "WidthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (r);
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == "WidthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (r);
            continue;
          }
        }

        // Height
        //
        if (n.name () == "Height" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Height_type > r (
            Height_traits::create (i, f, this));

          if (!this->Height_)
          {
            this->Height_.set (r);
            continue;
          }
        }

        // HeightMax
        //
        if (n.name () == "HeightMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HeightMax_type > r (
            HeightMax_traits::create (i, f, this));

          if (!this->HeightMax_)
          {
            this->HeightMax_.set (r);
            continue;
          }
        }

        // HeightMin
        //
        if (n.name () == "HeightMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HeightMin_type > r (
            HeightMin_traits::create (i, f, this));

          if (!this->HeightMin_)
          {
            this->HeightMin_.set (r);
            continue;
          }
        }

        // HeightVector
        //
        if (n.name () == "HeightVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HeightVector_type > r (
            HeightVector_traits::create (i, f, this));

          if (!this->HeightVector_)
          {
            this->HeightVector_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidFeatureActualType* CuboidFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidFeatureActualType (*this, f, c);
    }

    CuboidFeatureActualType::
    ~CuboidFeatureActualType ()
    {
    }

    // CylinderConstructionMethodType
    //

    CylinderConstructionMethodType::
    CylinderConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this)
    {
    }

    CylinderConstructionMethodType::
    CylinderConstructionMethodType (const CylinderConstructionMethodType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    CylinderConstructionMethodType::
    CylinderConstructionMethodType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this),
      FromScan_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylinderConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderConstructionMethodType* CylinderConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderConstructionMethodType (*this, f, c);
    }

    CylinderConstructionMethodType::
    ~CylinderConstructionMethodType ()
    {
    }

    // CylinderBestFitType
    //

    CylinderBestFitType::
    CylinderBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    CylinderBestFitType::
    CylinderBestFitType (const CylinderBestFitType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CylinderBestFitType::
    CylinderBestFitType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylinderBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    CylinderBestFitType* CylinderBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderBestFitType (*this, f, c);
    }

    CylinderBestFitType::
    ~CylinderBestFitType ()
    {
    }

    // CylinderRecompType
    //

    CylinderRecompType::
    CylinderRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    CylinderRecompType::
    CylinderRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    CylinderRecompType::
    CylinderRecompType (const CylinderRecompType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CylinderRecompType::
    CylinderRecompType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylinderRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderRecompType* CylinderRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderRecompType (*this, f, c);
    }

    CylinderRecompType::
    ~CylinderRecompType ()
    {
    }

    // CylinderCopyType
    //

    CylinderCopyType::
    CylinderCopyType (const BaseCylinder_type& BaseCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, ::xml_schema::flags (), this)
    {
    }

    CylinderCopyType::
    CylinderCopyType (::std::auto_ptr< BaseCylinder_type >& BaseCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, ::xml_schema::flags (), this)
    {
    }

    CylinderCopyType::
    CylinderCopyType (const CylinderCopyType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCylinder_ (x.BaseCylinder_, f, this)
    {
    }

    CylinderCopyType::
    CylinderCopyType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylinder_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylinderCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCylinder
        //
        if (n.name () == "BaseCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCylinder_type > r (
            BaseCylinder_traits::create (i, f, this));

          if (!BaseCylinder_.present ())
          {
            this->BaseCylinder_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCylinder",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderCopyType* CylinderCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCopyType (*this, f, c);
    }

    CylinderCopyType::
    ~CylinderCopyType ()
    {
    }

    // CylinderCastType
    //

    CylinderCastType::
    CylinderCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    CylinderCastType::
    CylinderCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    CylinderCastType::
    CylinderCastType (const CylinderCastType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CylinderCastType::
    CylinderCastType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylinderCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderCastType* CylinderCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCastType (*this, f, c);
    }

    CylinderCastType::
    ~CylinderCastType ()
    {
    }

    // CylinderTransformType
    //

    CylinderTransformType::
    CylinderTransformType (const BaseCylinder_type& BaseCylinder,
                           const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    CylinderTransformType::
    CylinderTransformType (::std::auto_ptr< BaseCylinder_type >& BaseCylinder,
                           ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    CylinderTransformType::
    CylinderTransformType (const CylinderTransformType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCylinder_ (x.BaseCylinder_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CylinderTransformType::
    CylinderTransformType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylinder_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylinderTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCylinder
        //
        if (n.name () == "BaseCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCylinder_type > r (
            BaseCylinder_traits::create (i, f, this));

          if (!BaseCylinder_.present ())
          {
            this->BaseCylinder_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCylinder",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderTransformType* CylinderTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderTransformType (*this, f, c);
    }

    CylinderTransformType::
    ~CylinderTransformType ()
    {
    }

    // CylinderFromScanType
    //

    CylinderFromScanType::
    CylinderFromScanType (const SurfaceFeature_type& SurfaceFeature,
                          const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    CylinderFromScanType::
    CylinderFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                          ::std::auto_ptr< SearchRadius_type >& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    CylinderFromScanType::
    CylinderFromScanType (const CylinderFromScanType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    CylinderFromScanType::
    CylinderFromScanType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylinderFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderFromScanType* CylinderFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFromScanType (*this, f, c);
    }

    CylinderFromScanType::
    ~CylinderFromScanType ()
    {
    }

    // CylinderCheckedType
    //

    CylinderCheckedType::
    CylinderCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    CylinderCheckedType::
    CylinderCheckedType (const CylinderCheckedType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CylinderCheckedType::
    CylinderCheckedType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylinderCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderCheckedType* CylinderCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCheckedType (*this, f, c);
    }

    CylinderCheckedType::
    ~CylinderCheckedType ()
    {
    }

    // CylinderCheckedFeatureType
    //

    CylinderCheckedFeatureType::
    CylinderCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    CylinderCheckedFeatureType::
    CylinderCheckedFeatureType (const CylinderCheckedFeatureType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CylinderCheckedFeatureType::
    CylinderCheckedFeatureType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylinderCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderCheckedFeatureType* CylinderCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCheckedFeatureType (*this, f, c);
    }

    CylinderCheckedFeatureType::
    ~CylinderCheckedFeatureType ()
    {
    }

    // CylinderActualDeterminationType
    //

    CylinderActualDeterminationType::
    CylinderActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    CylinderActualDeterminationType::
    CylinderActualDeterminationType (const CylinderActualDeterminationType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CylinderActualDeterminationType::
    CylinderActualDeterminationType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylinderActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderActualDeterminationType* CylinderActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderActualDeterminationType (*this, f, c);
    }

    CylinderActualDeterminationType::
    ~CylinderActualDeterminationType ()
    {
    }

    // CylinderFeatureItemType
    //

    CylinderFeatureItemType::
    CylinderFeatureItemType (const id_type& id,
                             const FeatureName_type& FeatureName,
                             const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    CylinderFeatureItemType::
    CylinderFeatureItemType (const id_type& id,
                             const FeatureName_type& FeatureName,
                             ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    CylinderFeatureItemType::
    CylinderFeatureItemType (const CylinderFeatureItemType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    CylinderFeatureItemType::
    CylinderFeatureItemType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderFeatureItemType* CylinderFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureItemType (*this, f, c);
    }

    CylinderFeatureItemType::
    ~CylinderFeatureItemType ()
    {
    }

    // CylinderFeatureDefinitionType
    //

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Bottom_ (::xml_schema::flags (), this)
    {
    }

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   ::std::auto_ptr< Diameter_type >& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Bottom_ (::xml_schema::flags (), this)
    {
    }

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const CylinderFeatureDefinitionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      Bottom_ (x.Bottom_, f, this)
    {
    }

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Diameter_ (f, this),
      Length_ (f, this),
      Bottom_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == "Bottom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderFeatureDefinitionType* CylinderFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureDefinitionType (*this, f, c);
    }

    CylinderFeatureDefinitionType::
    ~CylinderFeatureDefinitionType ()
    {
    }

    // CylinderFeatureNominalType
    //

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                const Axis_type& Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this)
    {
    }

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                ::std::auto_ptr< Axis_type >& Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this)
    {
    }

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const CylinderFeatureNominalType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this)
    {
    }

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Sweep_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderFeatureNominalType* CylinderFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureNominalType (*this, f, c);
    }

    CylinderFeatureNominalType::
    ~CylinderFeatureNominalType ()
    {
    }

    // CylinderFeatureActualType
    //

    CylinderFeatureActualType::
    CylinderFeatureActualType (const id_type& id,
                               const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    CylinderFeatureActualType::
    CylinderFeatureActualType (const id_type& id,
                               ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    CylinderFeatureActualType::
    CylinderFeatureActualType (const CylinderFeatureActualType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    CylinderFeatureActualType::
    CylinderFeatureActualType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Diameter_ (f, this),
      Length_ (f, this),
      DiameterMin_ (f, this),
      DiameterMax_ (f, this),
      Sweep_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderFeatureActualType* CylinderFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureActualType (*this, f, c);
    }

    CylinderFeatureActualType::
    ~CylinderFeatureActualType ()
    {
    }

    // CylindricalSegmentConstructionMethodType
    //

    CylindricalSegmentConstructionMethodType::
    CylindricalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentConstructionMethodType::
    CylindricalSegmentConstructionMethodType (const CylindricalSegmentConstructionMethodType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    CylindricalSegmentConstructionMethodType::
    CylindricalSegmentConstructionMethodType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentConstructionMethodType* CylindricalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentConstructionMethodType (*this, f, c);
    }

    CylindricalSegmentConstructionMethodType::
    ~CylindricalSegmentConstructionMethodType ()
    {
    }

    // CylindricalSegmentBestFitType
    //

    CylindricalSegmentBestFitType::
    CylindricalSegmentBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentBestFitType::
    CylindricalSegmentBestFitType (const CylindricalSegmentBestFitType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CylindricalSegmentBestFitType::
    CylindricalSegmentBestFitType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    CylindricalSegmentBestFitType* CylindricalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentBestFitType (*this, f, c);
    }

    CylindricalSegmentBestFitType::
    ~CylindricalSegmentBestFitType ()
    {
    }

    // CylindricalSegmentRecompType
    //

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (const CylindricalSegmentRecompType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentRecompType* CylindricalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentRecompType (*this, f, c);
    }

    CylindricalSegmentRecompType::
    ~CylindricalSegmentRecompType ()
    {
    }

    // CylindricalSegmentCopyType
    //

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (const BaseCylindricalSegment_type& BaseCylindricalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (BaseCylindricalSegment, ::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (::std::auto_ptr< BaseCylindricalSegment_type >& BaseCylindricalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (BaseCylindricalSegment, ::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (const CylindricalSegmentCopyType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCylindricalSegment_ (x.BaseCylindricalSegment_, f, this)
    {
    }

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylindricalSegment_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCylindricalSegment
        //
        if (n.name () == "BaseCylindricalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCylindricalSegment_type > r (
            BaseCylindricalSegment_traits::create (i, f, this));

          if (!BaseCylindricalSegment_.present ())
          {
            this->BaseCylindricalSegment_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCylindricalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCylindricalSegment",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentCopyType* CylindricalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCopyType (*this, f, c);
    }

    CylindricalSegmentCopyType::
    ~CylindricalSegmentCopyType ()
    {
    }

    // CylindricalSegmentCastType
    //

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (const CylindricalSegmentCastType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentCastType* CylindricalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCastType (*this, f, c);
    }

    CylindricalSegmentCastType::
    ~CylindricalSegmentCastType ()
    {
    }

    // CylindricalSegmentTransformType
    //

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (const BaseCylindricalSegment_type& BaseCylindricalSegment,
                                     const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (BaseCylindricalSegment, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (::std::auto_ptr< BaseCylindricalSegment_type >& BaseCylindricalSegment,
                                     ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (BaseCylindricalSegment, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (const CylindricalSegmentTransformType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCylindricalSegment_ (x.BaseCylindricalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylindricalSegment_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCylindricalSegment
        //
        if (n.name () == "BaseCylindricalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCylindricalSegment_type > r (
            BaseCylindricalSegment_traits::create (i, f, this));

          if (!BaseCylindricalSegment_.present ())
          {
            this->BaseCylindricalSegment_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCylindricalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCylindricalSegment",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentTransformType* CylindricalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentTransformType (*this, f, c);
    }

    CylindricalSegmentTransformType::
    ~CylindricalSegmentTransformType ()
    {
    }

    // CylindricalSegmentCheckedType
    //

    CylindricalSegmentCheckedType::
    CylindricalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentCheckedType::
    CylindricalSegmentCheckedType (const CylindricalSegmentCheckedType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CylindricalSegmentCheckedType::
    CylindricalSegmentCheckedType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentCheckedType* CylindricalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCheckedType (*this, f, c);
    }

    CylindricalSegmentCheckedType::
    ~CylindricalSegmentCheckedType ()
    {
    }

    // CylindricalSegmentCheckedFeatureType
    //

    CylindricalSegmentCheckedFeatureType::
    CylindricalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentCheckedFeatureType::
    CylindricalSegmentCheckedFeatureType (const CylindricalSegmentCheckedFeatureType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CylindricalSegmentCheckedFeatureType::
    CylindricalSegmentCheckedFeatureType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentCheckedFeatureType* CylindricalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCheckedFeatureType (*this, f, c);
    }

    CylindricalSegmentCheckedFeatureType::
    ~CylindricalSegmentCheckedFeatureType ()
    {
    }

    // CylindricalSegmentActualDeterminationType
    //

    CylindricalSegmentActualDeterminationType::
    CylindricalSegmentActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentActualDeterminationType::
    CylindricalSegmentActualDeterminationType (const CylindricalSegmentActualDeterminationType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CylindricalSegmentActualDeterminationType::
    CylindricalSegmentActualDeterminationType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentActualDeterminationType* CylindricalSegmentActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentActualDeterminationType (*this, f, c);
    }

    CylindricalSegmentActualDeterminationType::
    ~CylindricalSegmentActualDeterminationType ()
    {
    }

    // CylindricalSegmentFeatureItemType
    //

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const id_type& id,
                                       const FeatureName_type& FeatureName,
                                       const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const id_type& id,
                                       const FeatureName_type& FeatureName,
                                       ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const CylindricalSegmentFeatureItemType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentFeatureItemType* CylindricalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureItemType (*this, f, c);
    }

    CylindricalSegmentFeatureItemType::
    ~CylindricalSegmentFeatureItemType ()
    {
    }

    // CylindricalSegmentFeatureDefinitionType
    //

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const id_type& id,
                                             const InternalExternal_type& InternalExternal,
                                             const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Bottom_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const id_type& id,
                                             const InternalExternal_type& InternalExternal,
                                             ::std::auto_ptr< Diameter_type >& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Bottom_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const CylindricalSegmentFeatureDefinitionType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      Bottom_ (x.Bottom_, f, this)
    {
    }

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Diameter_ (f, this),
      Length_ (f, this),
      Bottom_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == "Bottom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentFeatureDefinitionType* CylindricalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureDefinitionType (*this, f, c);
    }

    CylindricalSegmentFeatureDefinitionType::
    ~CylindricalSegmentFeatureDefinitionType ()
    {
    }

    // CylindricalSegmentFeatureNominalType
    //

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const id_type& id,
                                          const FeatureDefinitionId_type& FeatureDefinitionId,
                                          const Axis_type& Axis,
                                          const Sweep_type& Sweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Sweep_ (Sweep, ::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const id_type& id,
                                          const FeatureDefinitionId_type& FeatureDefinitionId,
                                          ::std::auto_ptr< Axis_type >& Axis,
                                          ::std::auto_ptr< Sweep_type >& Sweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Sweep_ (Sweep, ::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const CylindricalSegmentFeatureNominalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this)
    {
    }

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Sweep_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Sweep",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentFeatureNominalType* CylindricalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureNominalType (*this, f, c);
    }

    CylindricalSegmentFeatureNominalType::
    ~CylindricalSegmentFeatureNominalType ()
    {
    }

    // CylindricalSegmentFeatureActualType
    //

    CylindricalSegmentFeatureActualType::
    CylindricalSegmentFeatureActualType (const id_type& id,
                                         const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentFeatureActualType::
    CylindricalSegmentFeatureActualType (const id_type& id,
                                         ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    CylindricalSegmentFeatureActualType::
    CylindricalSegmentFeatureActualType (const CylindricalSegmentFeatureActualType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    CylindricalSegmentFeatureActualType::
    CylindricalSegmentFeatureActualType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Diameter_ (f, this),
      Length_ (f, this),
      DiameterMin_ (f, this),
      DiameterMax_ (f, this),
      Sweep_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentFeatureActualType* CylindricalSegmentFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureActualType (*this, f, c);
    }

    CylindricalSegmentFeatureActualType::
    ~CylindricalSegmentFeatureActualType ()
    {
    }

    // EdgePointConstructionMethodType
    //

    EdgePointConstructionMethodType::
    EdgePointConstructionMethodType ()
    : ::xml_schema::type (),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this)
    {
    }

    EdgePointConstructionMethodType::
    EdgePointConstructionMethodType (const EdgePointConstructionMethodType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    EdgePointConstructionMethodType::
    EdgePointConstructionMethodType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this),
      FromScan_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EdgePointConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EdgePointConstructionMethodType* EdgePointConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointConstructionMethodType (*this, f, c);
    }

    EdgePointConstructionMethodType::
    ~EdgePointConstructionMethodType ()
    {
    }

    // EdgePointCopyType
    //

    EdgePointCopyType::
    EdgePointCopyType (const BaseEdgePoint_type& BaseEdgePoint)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEdgePoint_ (BaseEdgePoint, ::xml_schema::flags (), this)
    {
    }

    EdgePointCopyType::
    EdgePointCopyType (::std::auto_ptr< BaseEdgePoint_type >& BaseEdgePoint)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEdgePoint_ (BaseEdgePoint, ::xml_schema::flags (), this)
    {
    }

    EdgePointCopyType::
    EdgePointCopyType (const EdgePointCopyType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseEdgePoint_ (x.BaseEdgePoint_, f, this)
    {
    }

    EdgePointCopyType::
    EdgePointCopyType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEdgePoint_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EdgePointCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseEdgePoint
        //
        if (n.name () == "BaseEdgePoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseEdgePoint_type > r (
            BaseEdgePoint_traits::create (i, f, this));

          if (!BaseEdgePoint_.present ())
          {
            this->BaseEdgePoint_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseEdgePoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseEdgePoint",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointCopyType* EdgePointCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCopyType (*this, f, c);
    }

    EdgePointCopyType::
    ~EdgePointCopyType ()
    {
    }

    // EdgePointCastType
    //

    EdgePointCastType::
    EdgePointCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    EdgePointCastType::
    EdgePointCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    EdgePointCastType::
    EdgePointCastType (const EdgePointCastType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    EdgePointCastType::
    EdgePointCastType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EdgePointCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointCastType* EdgePointCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCastType (*this, f, c);
    }

    EdgePointCastType::
    ~EdgePointCastType ()
    {
    }

    // EdgePointTransformType
    //

    EdgePointTransformType::
    EdgePointTransformType (const BaseEdgePoint_type& BaseEdgePoint,
                            const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEdgePoint_ (BaseEdgePoint, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    EdgePointTransformType::
    EdgePointTransformType (::std::auto_ptr< BaseEdgePoint_type >& BaseEdgePoint,
                            ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEdgePoint_ (BaseEdgePoint, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    EdgePointTransformType::
    EdgePointTransformType (const EdgePointTransformType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseEdgePoint_ (x.BaseEdgePoint_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    EdgePointTransformType::
    EdgePointTransformType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEdgePoint_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EdgePointTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseEdgePoint
        //
        if (n.name () == "BaseEdgePoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseEdgePoint_type > r (
            BaseEdgePoint_traits::create (i, f, this));

          if (!BaseEdgePoint_.present ())
          {
            this->BaseEdgePoint_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseEdgePoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseEdgePoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointTransformType* EdgePointTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointTransformType (*this, f, c);
    }

    EdgePointTransformType::
    ~EdgePointTransformType ()
    {
    }

    // EdgePointFromScanType
    //

    EdgePointFromScanType::
    EdgePointFromScanType (const SurfaceFeature_type& SurfaceFeature,
                           const SearchRadius_type& SearchRadius,
                           const PatchRadius_type& PatchRadius,
                           const Distance_type& Distance,
                           const Depth_type& Depth,
                           const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      PatchRadius_ (PatchRadius, ::xml_schema::flags (), this),
      Distance_ (Distance, ::xml_schema::flags (), this),
      Depth_ (Depth, ::xml_schema::flags (), this),
      RetrievalMethod_ (RetrievalMethod, ::xml_schema::flags (), this)
    {
    }

    EdgePointFromScanType::
    EdgePointFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                           ::std::auto_ptr< SearchRadius_type >& SearchRadius,
                           ::std::auto_ptr< PatchRadius_type >& PatchRadius,
                           ::std::auto_ptr< Distance_type >& Distance,
                           ::std::auto_ptr< Depth_type >& Depth,
                           const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      PatchRadius_ (PatchRadius, ::xml_schema::flags (), this),
      Distance_ (Distance, ::xml_schema::flags (), this),
      Depth_ (Depth, ::xml_schema::flags (), this),
      RetrievalMethod_ (RetrievalMethod, ::xml_schema::flags (), this)
    {
    }

    EdgePointFromScanType::
    EdgePointFromScanType (const EdgePointFromScanType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      PatchRadius_ (x.PatchRadius_, f, this),
      Distance_ (x.Distance_, f, this),
      Depth_ (x.Depth_, f, this),
      RetrievalMethod_ (x.RetrievalMethod_, f, this)
    {
    }

    EdgePointFromScanType::
    EdgePointFromScanType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this),
      PatchRadius_ (f, this),
      Distance_ (f, this),
      Depth_ (f, this),
      RetrievalMethod_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EdgePointFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // PatchRadius
        //
        if (n.name () == "PatchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PatchRadius_type > r (
            PatchRadius_traits::create (i, f, this));

          if (!PatchRadius_.present ())
          {
            this->PatchRadius_.set (r);
            continue;
          }
        }

        // Distance
        //
        if (n.name () == "Distance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!Distance_.present ())
          {
            this->Distance_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (r);
            continue;
          }
        }

        // RetrievalMethod
        //
        if (n.name () == "RetrievalMethod" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RetrievalMethod_type > r (
            RetrievalMethod_traits::create (i, f, this));

          if (!RetrievalMethod_.present ())
          {
            this->RetrievalMethod_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PatchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PatchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Distance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Distance",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Depth",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RetrievalMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RetrievalMethod",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointFromScanType* EdgePointFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFromScanType (*this, f, c);
    }

    EdgePointFromScanType::
    ~EdgePointFromScanType ()
    {
    }

    // EdgePointCheckedType
    //

    EdgePointCheckedType::
    EdgePointCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    EdgePointCheckedType::
    EdgePointCheckedType (const EdgePointCheckedType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    EdgePointCheckedType::
    EdgePointCheckedType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EdgePointCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EdgePointCheckedType* EdgePointCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCheckedType (*this, f, c);
    }

    EdgePointCheckedType::
    ~EdgePointCheckedType ()
    {
    }

    // EdgePointCheckedFeatureType
    //

    EdgePointCheckedFeatureType::
    EdgePointCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    EdgePointCheckedFeatureType::
    EdgePointCheckedFeatureType (const EdgePointCheckedFeatureType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    EdgePointCheckedFeatureType::
    EdgePointCheckedFeatureType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EdgePointCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EdgePointCheckedFeatureType* EdgePointCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCheckedFeatureType (*this, f, c);
    }

    EdgePointCheckedFeatureType::
    ~EdgePointCheckedFeatureType ()
    {
    }

    // EdgePointActualDeterminationType
    //

    EdgePointActualDeterminationType::
    EdgePointActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    EdgePointActualDeterminationType::
    EdgePointActualDeterminationType (const EdgePointActualDeterminationType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    EdgePointActualDeterminationType::
    EdgePointActualDeterminationType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EdgePointActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EdgePointActualDeterminationType* EdgePointActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointActualDeterminationType (*this, f, c);
    }

    EdgePointActualDeterminationType::
    ~EdgePointActualDeterminationType ()
    {
    }

    // EdgePointFeatureItemType
    //

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const id_type& id,
                              const FeatureName_type& FeatureName,
                              const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this)
    {
    }

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const id_type& id,
                              const FeatureName_type& FeatureName,
                              ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this)
    {
    }

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const EdgePointFeatureItemType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointFeatureItemType* EdgePointFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureItemType (*this, f, c);
    }

    EdgePointFeatureItemType::
    ~EdgePointFeatureItemType ()
    {
    }

    // EdgePointFeatureDefinitionType
    //

    EdgePointFeatureDefinitionType::
    EdgePointFeatureDefinitionType (const id_type& id,
                                    const InternalExternal_type& InternalExternal)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this)
    {
    }

    EdgePointFeatureDefinitionType::
    EdgePointFeatureDefinitionType (const EdgePointFeatureDefinitionType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this)
    {
    }

    EdgePointFeatureDefinitionType::
    EdgePointFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointFeatureDefinitionType* EdgePointFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureDefinitionType (*this, f, c);
    }

    EdgePointFeatureDefinitionType::
    ~EdgePointFeatureDefinitionType ()
    {
    }

    // EdgePointFeatureNominalType
    //

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const id_type& id,
                                 const FeatureDefinitionId_type& FeatureDefinitionId,
                                 const Location_type& Location,
                                 const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this),
      AdjacentNormal_ (::xml_schema::flags (), this)
    {
    }

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const id_type& id,
                                 const FeatureDefinitionId_type& FeatureDefinitionId,
                                 ::std::auto_ptr< Location_type >& Location,
                                 ::std::auto_ptr< Normal_type >& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this),
      AdjacentNormal_ (::xml_schema::flags (), this)
    {
    }

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const EdgePointFeatureNominalType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      AdjacentNormal_ (x.AdjacentNormal_, f, this)
    {
    }

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Normal_ (f, this),
      AdjacentNormal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // AdjacentNormal
        //
        if (n.name () == "AdjacentNormal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AdjacentNormal_type > r (
            AdjacentNormal_traits::create (i, f, this));

          if (!this->AdjacentNormal_)
          {
            this->AdjacentNormal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointFeatureNominalType* EdgePointFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureNominalType (*this, f, c);
    }

    EdgePointFeatureNominalType::
    ~EdgePointFeatureNominalType ()
    {
    }

    // EdgePointFeatureActualType
    //

    EdgePointFeatureActualType::
    EdgePointFeatureActualType (const id_type& id,
                                const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      AdjacentNormal_ (::xml_schema::flags (), this)
    {
    }

    EdgePointFeatureActualType::
    EdgePointFeatureActualType (const id_type& id,
                                ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      AdjacentNormal_ (::xml_schema::flags (), this)
    {
    }

    EdgePointFeatureActualType::
    EdgePointFeatureActualType (const EdgePointFeatureActualType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      AdjacentNormal_ (x.AdjacentNormal_, f, this)
    {
    }

    EdgePointFeatureActualType::
    EdgePointFeatureActualType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Normal_ (f, this),
      AdjacentNormal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // AdjacentNormal
        //
        if (n.name () == "AdjacentNormal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AdjacentNormal_type > r (
            AdjacentNormal_traits::create (i, f, this));

          if (!this->AdjacentNormal_)
          {
            this->AdjacentNormal_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EdgePointFeatureActualType* EdgePointFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureActualType (*this, f, c);
    }

    EdgePointFeatureActualType::
    ~EdgePointFeatureActualType ()
    {
    }

    // EllipseConstructionMethodType
    //

    EllipseConstructionMethodType::
    EllipseConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Intersection_ (::xml_schema::flags (), this),
      Projection_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this)
    {
    }

    EllipseConstructionMethodType::
    EllipseConstructionMethodType (const EllipseConstructionMethodType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    EllipseConstructionMethodType::
    EllipseConstructionMethodType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Intersection_ (f, this),
      Projection_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this),
      FromScan_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == "Intersection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipseConstructionMethodType* EllipseConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseConstructionMethodType (*this, f, c);
    }

    EllipseConstructionMethodType::
    ~EllipseConstructionMethodType ()
    {
    }

    // EllipseBestFitType
    //

    EllipseBestFitType::
    EllipseBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    EllipseBestFitType::
    EllipseBestFitType (const EllipseBestFitType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    EllipseBestFitType::
    EllipseBestFitType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    EllipseBestFitType* EllipseBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseBestFitType (*this, f, c);
    }

    EllipseBestFitType::
    ~EllipseBestFitType ()
    {
    }

    // EllipseRecompType
    //

    EllipseRecompType::
    EllipseRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    EllipseRecompType::
    EllipseRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    EllipseRecompType::
    EllipseRecompType (const EllipseRecompType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    EllipseRecompType::
    EllipseRecompType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseRecompType* EllipseRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseRecompType (*this, f, c);
    }

    EllipseRecompType::
    ~EllipseRecompType ()
    {
    }

    // EllipseProjectionType
    //

    EllipseProjectionType::
    EllipseProjectionType (const ProjectionFeature_type& ProjectionFeature,
                           const ProjectionPlane_type& ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionFeature_ (ProjectionFeature, ::xml_schema::flags (), this),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this)
    {
    }

    EllipseProjectionType::
    EllipseProjectionType (::std::auto_ptr< ProjectionFeature_type >& ProjectionFeature,
                           ::std::auto_ptr< ProjectionPlane_type >& ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionFeature_ (ProjectionFeature, ::xml_schema::flags (), this),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this)
    {
    }

    EllipseProjectionType::
    EllipseProjectionType (const EllipseProjectionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionFeature_ (x.ProjectionFeature_, f, this),
      ProjectionPlane_ (x.ProjectionPlane_, f, this)
    {
    }

    EllipseProjectionType::
    EllipseProjectionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionFeature_ (f, this),
      ProjectionPlane_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionFeature
        //
        if (n.name () == "ProjectionFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionFeature_type > r (
            ProjectionFeature_traits::create (i, f, this));

          if (!ProjectionFeature_.present ())
          {
            this->ProjectionFeature_.set (r);
            continue;
          }
        }

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseProjectionType* EllipseProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseProjectionType (*this, f, c);
    }

    EllipseProjectionType::
    ~EllipseProjectionType ()
    {
    }

    // EllipseIntersectionType
    //

    EllipseIntersectionType::
    EllipseIntersectionType (const IntersectionPlane_type& IntersectionPlane,
                             const IntersectionFeature_type& IntersectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, ::xml_schema::flags (), this),
      IntersectionFeature_ (IntersectionFeature, ::xml_schema::flags (), this)
    {
    }

    EllipseIntersectionType::
    EllipseIntersectionType (::std::auto_ptr< IntersectionPlane_type >& IntersectionPlane,
                             ::std::auto_ptr< IntersectionFeature_type >& IntersectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, ::xml_schema::flags (), this),
      IntersectionFeature_ (IntersectionFeature, ::xml_schema::flags (), this)
    {
    }

    EllipseIntersectionType::
    EllipseIntersectionType (const EllipseIntersectionType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      IntersectionPlane_ (x.IntersectionPlane_, f, this),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    EllipseIntersectionType::
    EllipseIntersectionType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionPlane_ (f, this),
      IntersectionFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IntersectionPlane
        //
        if (n.name () == "IntersectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IntersectionPlane_type > r (
            IntersectionPlane_traits::create (i, f, this));

          if (!IntersectionPlane_.present ())
          {
            this->IntersectionPlane_.set (r);
            continue;
          }
        }

        // IntersectionFeature
        //
        if (n.name () == "IntersectionFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          if (!IntersectionFeature_.present ())
          {
            this->IntersectionFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!IntersectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IntersectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!IntersectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IntersectionFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseIntersectionType* EllipseIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseIntersectionType (*this, f, c);
    }

    EllipseIntersectionType::
    ~EllipseIntersectionType ()
    {
    }

    // EllipseCopyType
    //

    EllipseCopyType::
    EllipseCopyType (const BaseEllipse_type& BaseEllipse)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEllipse_ (BaseEllipse, ::xml_schema::flags (), this)
    {
    }

    EllipseCopyType::
    EllipseCopyType (::std::auto_ptr< BaseEllipse_type >& BaseEllipse)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEllipse_ (BaseEllipse, ::xml_schema::flags (), this)
    {
    }

    EllipseCopyType::
    EllipseCopyType (const EllipseCopyType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseEllipse_ (x.BaseEllipse_, f, this)
    {
    }

    EllipseCopyType::
    EllipseCopyType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEllipse_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseEllipse
        //
        if (n.name () == "BaseEllipse" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseEllipse_type > r (
            BaseEllipse_traits::create (i, f, this));

          if (!BaseEllipse_.present ())
          {
            this->BaseEllipse_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseEllipse_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseEllipse",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseCopyType* EllipseCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCopyType (*this, f, c);
    }

    EllipseCopyType::
    ~EllipseCopyType ()
    {
    }

    // EllipseCastType
    //

    EllipseCastType::
    EllipseCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    EllipseCastType::
    EllipseCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    EllipseCastType::
    EllipseCastType (const EllipseCastType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    EllipseCastType::
    EllipseCastType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseCastType* EllipseCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCastType (*this, f, c);
    }

    EllipseCastType::
    ~EllipseCastType ()
    {
    }

    // EllipseTransformType
    //

    EllipseTransformType::
    EllipseTransformType (const BaseEllipse_type& BaseEllipse,
                          const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEllipse_ (BaseEllipse, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    EllipseTransformType::
    EllipseTransformType (::std::auto_ptr< BaseEllipse_type >& BaseEllipse,
                          ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEllipse_ (BaseEllipse, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    EllipseTransformType::
    EllipseTransformType (const EllipseTransformType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseEllipse_ (x.BaseEllipse_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    EllipseTransformType::
    EllipseTransformType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEllipse_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseEllipse
        //
        if (n.name () == "BaseEllipse" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseEllipse_type > r (
            BaseEllipse_traits::create (i, f, this));

          if (!BaseEllipse_.present ())
          {
            this->BaseEllipse_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseEllipse_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseEllipse",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseTransformType* EllipseTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseTransformType (*this, f, c);
    }

    EllipseTransformType::
    ~EllipseTransformType ()
    {
    }

    // EllipseFromScanType
    //

    EllipseFromScanType::
    EllipseFromScanType (const SurfaceFeature_type& SurfaceFeature,
                         const SearchRadius_type& SearchRadius,
                         const Depth_type& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      Depth_ (Depth, ::xml_schema::flags (), this)
    {
    }

    EllipseFromScanType::
    EllipseFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                         ::std::auto_ptr< SearchRadius_type >& SearchRadius,
                         ::std::auto_ptr< Depth_type >& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      Depth_ (Depth, ::xml_schema::flags (), this)
    {
    }

    EllipseFromScanType::
    EllipseFromScanType (const EllipseFromScanType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    EllipseFromScanType::
    EllipseFromScanType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this),
      Depth_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Depth",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseFromScanType* EllipseFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFromScanType (*this, f, c);
    }

    EllipseFromScanType::
    ~EllipseFromScanType ()
    {
    }

    // EllipseCheckedType
    //

    EllipseCheckedType::
    EllipseCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    EllipseCheckedType::
    EllipseCheckedType (const EllipseCheckedType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    EllipseCheckedType::
    EllipseCheckedType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipseCheckedType* EllipseCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCheckedType (*this, f, c);
    }

    EllipseCheckedType::
    ~EllipseCheckedType ()
    {
    }

    // EllipseCheckedFeatureType
    //

    EllipseCheckedFeatureType::
    EllipseCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    EllipseCheckedFeatureType::
    EllipseCheckedFeatureType (const EllipseCheckedFeatureType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    EllipseCheckedFeatureType::
    EllipseCheckedFeatureType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipseCheckedFeatureType* EllipseCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCheckedFeatureType (*this, f, c);
    }

    EllipseCheckedFeatureType::
    ~EllipseCheckedFeatureType ()
    {
    }

    // EllipseActualDeterminationType
    //

    EllipseActualDeterminationType::
    EllipseActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    EllipseActualDeterminationType::
    EllipseActualDeterminationType (const EllipseActualDeterminationType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    EllipseActualDeterminationType::
    EllipseActualDeterminationType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void EllipseActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipseActualDeterminationType* EllipseActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseActualDeterminationType (*this, f, c);
    }

    EllipseActualDeterminationType::
    ~EllipseActualDeterminationType ()
    {
    }

    // EllipseFeatureItemType
    //

    EllipseFeatureItemType::
    EllipseFeatureItemType (const id_type& id,
                            const FeatureName_type& FeatureName,
                            const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    EllipseFeatureItemType::
    EllipseFeatureItemType (const id_type& id,
                            const FeatureName_type& FeatureName,
                            ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    EllipseFeatureItemType::
    EllipseFeatureItemType (const EllipseFeatureItemType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    EllipseFeatureItemType::
    EllipseFeatureItemType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseFeatureItemType* EllipseFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureItemType (*this, f, c);
    }

    EllipseFeatureItemType::
    ~EllipseFeatureItemType ()
    {
    }

    // EllipseFeatureDefinitionType
    //

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const id_type& id,
                                  const InternalExternal_type& InternalExternal,
                                  const MajorDiameter_type& MajorDiameter,
                                  const MinorDiameter_type& MinorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      MajorDiameter_ (MajorDiameter, ::xml_schema::flags (), this),
      MinorDiameter_ (MinorDiameter, ::xml_schema::flags (), this)
    {
    }

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const id_type& id,
                                  const InternalExternal_type& InternalExternal,
                                  ::std::auto_ptr< MajorDiameter_type >& MajorDiameter,
                                  ::std::auto_ptr< MinorDiameter_type >& MinorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      MajorDiameter_ (MajorDiameter, ::xml_schema::flags (), this),
      MinorDiameter_ (MinorDiameter, ::xml_schema::flags (), this)
    {
    }

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const EllipseFeatureDefinitionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this)
    {
    }

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      MajorDiameter_ (f, this),
      MinorDiameter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!MajorDiameter_.present ())
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!MinorDiameter_.present ())
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MajorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MajorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MinorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MinorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseFeatureDefinitionType* EllipseFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureDefinitionType (*this, f, c);
    }

    EllipseFeatureDefinitionType::
    ~EllipseFeatureDefinitionType ()
    {
    }

    // EllipseFeatureNominalType
    //

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId,
                               const Axis_type& Axis,
                               const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId,
                               ::std::auto_ptr< Axis_type >& Axis,
                               ::std::auto_ptr< Normal_type >& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const EllipseFeatureNominalType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Normal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseFeatureNominalType* EllipseFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureNominalType (*this, f, c);
    }

    EllipseFeatureNominalType::
    ~EllipseFeatureNominalType ()
    {
    }

    // EllipseFeatureActualType
    //

    EllipseFeatureActualType::
    EllipseFeatureActualType (const id_type& id,
                              const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      MajorDiameter_ (::xml_schema::flags (), this),
      MinorDiameter_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    EllipseFeatureActualType::
    EllipseFeatureActualType (const id_type& id,
                              ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      MajorDiameter_ (::xml_schema::flags (), this),
      MinorDiameter_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    EllipseFeatureActualType::
    EllipseFeatureActualType (const EllipseFeatureActualType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Normal_ (x.Normal_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    EllipseFeatureActualType::
    EllipseFeatureActualType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Normal_ (f, this),
      MajorDiameter_ (f, this),
      MinorDiameter_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!this->MajorDiameter_)
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!this->MinorDiameter_)
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipseFeatureActualType* EllipseFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureActualType (*this, f, c);
    }

    EllipseFeatureActualType::
    ~EllipseFeatureActualType ()
    {
    }

    // ElongatedCylinderConstructionMethodType
    //

    ElongatedCylinderConstructionMethodType::
    ElongatedCylinderConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderConstructionMethodType::
    ElongatedCylinderConstructionMethodType (const ElongatedCylinderConstructionMethodType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ElongatedCylinderConstructionMethodType::
    ElongatedCylinderConstructionMethodType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderConstructionMethodType* ElongatedCylinderConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderConstructionMethodType (*this, f, c);
    }

    ElongatedCylinderConstructionMethodType::
    ~ElongatedCylinderConstructionMethodType ()
    {
    }

    // ElongatedCylinderBestFitType
    //

    ElongatedCylinderBestFitType::
    ElongatedCylinderBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderBestFitType::
    ElongatedCylinderBestFitType (const ElongatedCylinderBestFitType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ElongatedCylinderBestFitType::
    ElongatedCylinderBestFitType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ElongatedCylinderBestFitType* ElongatedCylinderBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderBestFitType (*this, f, c);
    }

    ElongatedCylinderBestFitType::
    ~ElongatedCylinderBestFitType ()
    {
    }

    // ElongatedCylinderRecompType
    //

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (const ElongatedCylinderRecompType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderRecompType* ElongatedCylinderRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderRecompType (*this, f, c);
    }

    ElongatedCylinderRecompType::
    ~ElongatedCylinderRecompType ()
    {
    }

    // ElongatedCylinderCopyType
    //

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (const BaseElongatedCylinder_type& BaseElongatedCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (BaseElongatedCylinder, ::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (::std::auto_ptr< BaseElongatedCylinder_type >& BaseElongatedCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (BaseElongatedCylinder, ::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (const ElongatedCylinderCopyType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseElongatedCylinder_ (x.BaseElongatedCylinder_, f, this)
    {
    }

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseElongatedCylinder_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseElongatedCylinder
        //
        if (n.name () == "BaseElongatedCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseElongatedCylinder_type > r (
            BaseElongatedCylinder_traits::create (i, f, this));

          if (!BaseElongatedCylinder_.present ())
          {
            this->BaseElongatedCylinder_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseElongatedCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseElongatedCylinder",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderCopyType* ElongatedCylinderCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCopyType (*this, f, c);
    }

    ElongatedCylinderCopyType::
    ~ElongatedCylinderCopyType ()
    {
    }

    // ElongatedCylinderCastType
    //

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (const ElongatedCylinderCastType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderCastType* ElongatedCylinderCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCastType (*this, f, c);
    }

    ElongatedCylinderCastType::
    ~ElongatedCylinderCastType ()
    {
    }

    // ElongatedCylinderTransformType
    //

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (const BaseElongatedCylinder_type& BaseElongatedCylinder,
                                    const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (BaseElongatedCylinder, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (::std::auto_ptr< BaseElongatedCylinder_type >& BaseElongatedCylinder,
                                    ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (BaseElongatedCylinder, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (const ElongatedCylinderTransformType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseElongatedCylinder_ (x.BaseElongatedCylinder_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseElongatedCylinder_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseElongatedCylinder
        //
        if (n.name () == "BaseElongatedCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseElongatedCylinder_type > r (
            BaseElongatedCylinder_traits::create (i, f, this));

          if (!BaseElongatedCylinder_.present ())
          {
            this->BaseElongatedCylinder_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseElongatedCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseElongatedCylinder",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderTransformType* ElongatedCylinderTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderTransformType (*this, f, c);
    }

    ElongatedCylinderTransformType::
    ~ElongatedCylinderTransformType ()
    {
    }

    // ElongatedCylinderCheckedType
    //

    ElongatedCylinderCheckedType::
    ElongatedCylinderCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderCheckedType::
    ElongatedCylinderCheckedType (const ElongatedCylinderCheckedType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ElongatedCylinderCheckedType::
    ElongatedCylinderCheckedType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderCheckedType* ElongatedCylinderCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCheckedType (*this, f, c);
    }

    ElongatedCylinderCheckedType::
    ~ElongatedCylinderCheckedType ()
    {
    }

    // ElongatedCylinderCheckedFeatureType
    //

    ElongatedCylinderCheckedFeatureType::
    ElongatedCylinderCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderCheckedFeatureType::
    ElongatedCylinderCheckedFeatureType (const ElongatedCylinderCheckedFeatureType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ElongatedCylinderCheckedFeatureType::
    ElongatedCylinderCheckedFeatureType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderCheckedFeatureType* ElongatedCylinderCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCheckedFeatureType (*this, f, c);
    }

    ElongatedCylinderCheckedFeatureType::
    ~ElongatedCylinderCheckedFeatureType ()
    {
    }

    // ElongatedCylinderActualDeterminationType
    //

    ElongatedCylinderActualDeterminationType::
    ElongatedCylinderActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderActualDeterminationType::
    ElongatedCylinderActualDeterminationType (const ElongatedCylinderActualDeterminationType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ElongatedCylinderActualDeterminationType::
    ElongatedCylinderActualDeterminationType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderActualDeterminationType* ElongatedCylinderActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderActualDeterminationType (*this, f, c);
    }

    ElongatedCylinderActualDeterminationType::
    ~ElongatedCylinderActualDeterminationType ()
    {
    }

    // ElongatedCylinderFeatureItemType
    //

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const id_type& id,
                                      const FeatureName_type& FeatureName,
                                      const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const id_type& id,
                                      const FeatureName_type& FeatureName,
                                      ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const ElongatedCylinderFeatureItemType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderFeatureItemType* ElongatedCylinderFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureItemType (*this, f, c);
    }

    ElongatedCylinderFeatureItemType::
    ~ElongatedCylinderFeatureItemType ()
    {
    }

    // ElongatedCylinderFeatureDefinitionType
    //

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const id_type& id,
                                            const InternalExternal_type& InternalExternal,
                                            const Diameter_type& Diameter,
                                            const Length_type& Length)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this),
      Length_ (Length, ::xml_schema::flags (), this),
      Width_ (::xml_schema::flags (), this),
      Depth_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const id_type& id,
                                            const InternalExternal_type& InternalExternal,
                                            ::std::auto_ptr< Diameter_type >& Diameter,
                                            ::std::auto_ptr< Length_type >& Length)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this),
      Length_ (Length, ::xml_schema::flags (), this),
      Width_ (::xml_schema::flags (), this),
      Depth_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const ElongatedCylinderFeatureDefinitionType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      Width_ (x.Width_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Diameter_ (f, this),
      Length_ (f, this),
      Width_ (f, this),
      Depth_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Length",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderFeatureDefinitionType* ElongatedCylinderFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureDefinitionType (*this, f, c);
    }

    ElongatedCylinderFeatureDefinitionType::
    ~ElongatedCylinderFeatureDefinitionType ()
    {
    }

    // ElongatedCylinderFeatureNominalType
    //

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const id_type& id,
                                         const FeatureDefinitionId_type& FeatureDefinitionId,
                                         const CenterPlane_type& CenterPlane,
                                         const DepthVector_type& DepthVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterPlane_ (CenterPlane, ::xml_schema::flags (), this),
      DepthVector_ (DepthVector, ::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const id_type& id,
                                         const FeatureDefinitionId_type& FeatureDefinitionId,
                                         ::std::auto_ptr< CenterPlane_type >& CenterPlane,
                                         ::std::auto_ptr< DepthVector_type >& DepthVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterPlane_ (CenterPlane, ::xml_schema::flags (), this),
      DepthVector_ (DepthVector, ::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const ElongatedCylinderFeatureNominalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      CenterPlane_ (x.CenterPlane_, f, this),
      DepthVector_ (x.DepthVector_, f, this)
    {
    }

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterPlane_ (f, this),
      DepthVector_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterPlane
        //
        if (n.name () == "CenterPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!CenterPlane_.present ())
          {
            this->CenterPlane_.set (r);
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == "DepthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!DepthVector_.present ())
          {
            this->DepthVector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CenterPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CenterPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!DepthVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DepthVector",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderFeatureNominalType* ElongatedCylinderFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureNominalType (*this, f, c);
    }

    ElongatedCylinderFeatureNominalType::
    ~ElongatedCylinderFeatureNominalType ()
    {
    }

    // ElongatedCylinderFeatureActualType
    //

    ElongatedCylinderFeatureActualType::
    ElongatedCylinderFeatureActualType (const id_type& id,
                                        const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      CenterPlane_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      LengthMax_ (::xml_schema::flags (), this),
      LengthMin_ (::xml_schema::flags (), this),
      Width_ (::xml_schema::flags (), this),
      WidthMax_ (::xml_schema::flags (), this),
      WidthMin_ (::xml_schema::flags (), this),
      Depth_ (::xml_schema::flags (), this),
      DepthMax_ (::xml_schema::flags (), this),
      DepthMin_ (::xml_schema::flags (), this),
      DepthVector_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderFeatureActualType::
    ElongatedCylinderFeatureActualType (const id_type& id,
                                        ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      CenterPlane_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      LengthMax_ (::xml_schema::flags (), this),
      LengthMin_ (::xml_schema::flags (), this),
      Width_ (::xml_schema::flags (), this),
      WidthMax_ (::xml_schema::flags (), this),
      WidthMin_ (::xml_schema::flags (), this),
      Depth_ (::xml_schema::flags (), this),
      DepthMax_ (::xml_schema::flags (), this),
      DepthMin_ (::xml_schema::flags (), this),
      DepthVector_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ElongatedCylinderFeatureActualType::
    ElongatedCylinderFeatureActualType (const ElongatedCylinderFeatureActualType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      CenterPlane_ (x.CenterPlane_, f, this),
      Length_ (x.Length_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      Width_ (x.Width_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      Depth_ (x.Depth_, f, this),
      DepthMax_ (x.DepthMax_, f, this),
      DepthMin_ (x.DepthMin_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ElongatedCylinderFeatureActualType::
    ElongatedCylinderFeatureActualType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Diameter_ (f, this),
      DiameterMin_ (f, this),
      DiameterMax_ (f, this),
      CenterPlane_ (f, this),
      Length_ (f, this),
      LengthMax_ (f, this),
      LengthMin_ (f, this),
      Width_ (f, this),
      WidthMax_ (f, this),
      WidthMin_ (f, this),
      Depth_ (f, this),
      DepthMax_ (f, this),
      DepthMin_ (f, this),
      DepthVector_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // CenterPlane
        //
        if (n.name () == "CenterPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!this->CenterPlane_)
          {
            this->CenterPlane_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == "LengthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (r);
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == "LengthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (r);
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == "WidthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (r);
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == "WidthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (r);
            continue;
          }
        }

        // DepthMax
        //
        if (n.name () == "DepthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthMax_type > r (
            DepthMax_traits::create (i, f, this));

          if (!this->DepthMax_)
          {
            this->DepthMax_.set (r);
            continue;
          }
        }

        // DepthMin
        //
        if (n.name () == "DepthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthMin_type > r (
            DepthMin_traits::create (i, f, this));

          if (!this->DepthMin_)
          {
            this->DepthMin_.set (r);
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == "DepthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!this->DepthVector_)
          {
            this->DepthVector_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderFeatureActualType* ElongatedCylinderFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureActualType (*this, f, c);
    }

    ElongatedCylinderFeatureActualType::
    ~ElongatedCylinderFeatureActualType ()
    {
    }

    // ExtrudedCrossSectionConstructionMethodType
    //

    ExtrudedCrossSectionConstructionMethodType::
    ExtrudedCrossSectionConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionConstructionMethodType::
    ExtrudedCrossSectionConstructionMethodType (const ExtrudedCrossSectionConstructionMethodType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ExtrudedCrossSectionConstructionMethodType::
    ExtrudedCrossSectionConstructionMethodType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionConstructionMethodType* ExtrudedCrossSectionConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionConstructionMethodType (*this, f, c);
    }

    ExtrudedCrossSectionConstructionMethodType::
    ~ExtrudedCrossSectionConstructionMethodType ()
    {
    }

    // ExtrudedCrossSectionBestFitType
    //

    ExtrudedCrossSectionBestFitType::
    ExtrudedCrossSectionBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionBestFitType::
    ExtrudedCrossSectionBestFitType (const ExtrudedCrossSectionBestFitType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ExtrudedCrossSectionBestFitType::
    ExtrudedCrossSectionBestFitType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ExtrudedCrossSectionBestFitType* ExtrudedCrossSectionBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionBestFitType (*this, f, c);
    }

    ExtrudedCrossSectionBestFitType::
    ~ExtrudedCrossSectionBestFitType ()
    {
    }

    // ExtrudedCrossSectionRecompType
    //

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (const ExtrudedCrossSectionRecompType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionRecompType* ExtrudedCrossSectionRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionRecompType (*this, f, c);
    }

    ExtrudedCrossSectionRecompType::
    ~ExtrudedCrossSectionRecompType ()
    {
    }

    // ExtrudedCrossSectionCopyType
    //

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (const BaseExtrudedCrossSection_type& BaseExtrudedCrossSection)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (BaseExtrudedCrossSection, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (::std::auto_ptr< BaseExtrudedCrossSection_type >& BaseExtrudedCrossSection)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (BaseExtrudedCrossSection, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (const ExtrudedCrossSectionCopyType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseExtrudedCrossSection_ (x.BaseExtrudedCrossSection_, f, this)
    {
    }

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseExtrudedCrossSection_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseExtrudedCrossSection
        //
        if (n.name () == "BaseExtrudedCrossSection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseExtrudedCrossSection_type > r (
            BaseExtrudedCrossSection_traits::create (i, f, this));

          if (!BaseExtrudedCrossSection_.present ())
          {
            this->BaseExtrudedCrossSection_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseExtrudedCrossSection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseExtrudedCrossSection",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionCopyType* ExtrudedCrossSectionCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCopyType (*this, f, c);
    }

    ExtrudedCrossSectionCopyType::
    ~ExtrudedCrossSectionCopyType ()
    {
    }

    // ExtrudedCrossSectionCastType
    //

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (const ExtrudedCrossSectionCastType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionCastType* ExtrudedCrossSectionCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCastType (*this, f, c);
    }

    ExtrudedCrossSectionCastType::
    ~ExtrudedCrossSectionCastType ()
    {
    }

    // ExtrudedCrossSectionTransformType
    //

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (const BaseExtrudedCrossSection_type& BaseExtrudedCrossSection,
                                       const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (BaseExtrudedCrossSection, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (::std::auto_ptr< BaseExtrudedCrossSection_type >& BaseExtrudedCrossSection,
                                       ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (BaseExtrudedCrossSection, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (const ExtrudedCrossSectionTransformType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseExtrudedCrossSection_ (x.BaseExtrudedCrossSection_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseExtrudedCrossSection_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseExtrudedCrossSection
        //
        if (n.name () == "BaseExtrudedCrossSection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseExtrudedCrossSection_type > r (
            BaseExtrudedCrossSection_traits::create (i, f, this));

          if (!BaseExtrudedCrossSection_.present ())
          {
            this->BaseExtrudedCrossSection_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseExtrudedCrossSection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseExtrudedCrossSection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionTransformType* ExtrudedCrossSectionTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionTransformType (*this, f, c);
    }

    ExtrudedCrossSectionTransformType::
    ~ExtrudedCrossSectionTransformType ()
    {
    }

    // ExtrudedCrossSectionCheckedType
    //

    ExtrudedCrossSectionCheckedType::
    ExtrudedCrossSectionCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionCheckedType::
    ExtrudedCrossSectionCheckedType (const ExtrudedCrossSectionCheckedType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ExtrudedCrossSectionCheckedType::
    ExtrudedCrossSectionCheckedType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionCheckedType* ExtrudedCrossSectionCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCheckedType (*this, f, c);
    }

    ExtrudedCrossSectionCheckedType::
    ~ExtrudedCrossSectionCheckedType ()
    {
    }

    // ExtrudedCrossSectionCheckedFeatureType
    //

    ExtrudedCrossSectionCheckedFeatureType::
    ExtrudedCrossSectionCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionCheckedFeatureType::
    ExtrudedCrossSectionCheckedFeatureType (const ExtrudedCrossSectionCheckedFeatureType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ExtrudedCrossSectionCheckedFeatureType::
    ExtrudedCrossSectionCheckedFeatureType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionCheckedFeatureType* ExtrudedCrossSectionCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCheckedFeatureType (*this, f, c);
    }

    ExtrudedCrossSectionCheckedFeatureType::
    ~ExtrudedCrossSectionCheckedFeatureType ()
    {
    }

    // ExtrudedCrossSectionActualDeterminationType
    //

    ExtrudedCrossSectionActualDeterminationType::
    ExtrudedCrossSectionActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionActualDeterminationType::
    ExtrudedCrossSectionActualDeterminationType (const ExtrudedCrossSectionActualDeterminationType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ExtrudedCrossSectionActualDeterminationType::
    ExtrudedCrossSectionActualDeterminationType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionActualDeterminationType* ExtrudedCrossSectionActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionActualDeterminationType (*this, f, c);
    }

    ExtrudedCrossSectionActualDeterminationType::
    ~ExtrudedCrossSectionActualDeterminationType ()
    {
    }

    // ExtrudedCrossSectionFeatureItemType
    //

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const id_type& id,
                                         const FeatureName_type& FeatureName,
                                         const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const id_type& id,
                                         const FeatureName_type& FeatureName,
                                         ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const ExtrudedCrossSectionFeatureItemType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionFeatureItemType* ExtrudedCrossSectionFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureItemType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureItemType::
    ~ExtrudedCrossSectionFeatureItemType ()
    {
    }

    // ExtrudedCrossSectionFeatureDefinitionType
    //

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const id_type& id,
                                               const InternalExternal_type& InternalExternal,
                                               const Length_type& Length)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Length_ (Length, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const id_type& id,
                                               const InternalExternal_type& InternalExternal,
                                               ::std::auto_ptr< Length_type >& Length)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Length_ (Length, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const ExtrudedCrossSectionFeatureDefinitionType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Length_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Length",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionFeatureDefinitionType* ExtrudedCrossSectionFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureDefinitionType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ~ExtrudedCrossSectionFeatureDefinitionType ()
    {
    }

    // ExtrudedCrossSectionFeatureNominalType
    //

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const id_type& id,
                                            const FeatureDefinitionId_type& FeatureDefinitionId,
                                            const Direction_type& Direction,
                                            const CrossSectionReferenceFeatureId_type& CrossSectionReferenceFeatureId)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Direction_ (Direction, ::xml_schema::flags (), this),
      CrossSectionReferenceFeatureId_ (CrossSectionReferenceFeatureId, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const id_type& id,
                                            const FeatureDefinitionId_type& FeatureDefinitionId,
                                            ::std::auto_ptr< Direction_type >& Direction,
                                            ::std::auto_ptr< CrossSectionReferenceFeatureId_type >& CrossSectionReferenceFeatureId)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Direction_ (Direction, ::xml_schema::flags (), this),
      CrossSectionReferenceFeatureId_ (CrossSectionReferenceFeatureId, ::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const ExtrudedCrossSectionFeatureNominalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Direction_ (x.Direction_, f, this),
      CrossSectionReferenceFeatureId_ (x.CrossSectionReferenceFeatureId_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Direction_ (f, this),
      CrossSectionReferenceFeatureId_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (r);
            continue;
          }
        }

        // CrossSectionReferenceFeatureId
        //
        if (n.name () == "CrossSectionReferenceFeatureId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CrossSectionReferenceFeatureId_type > r (
            CrossSectionReferenceFeatureId_traits::create (i, f, this));

          if (!CrossSectionReferenceFeatureId_.present ())
          {
            this->CrossSectionReferenceFeatureId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Direction",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CrossSectionReferenceFeatureId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CrossSectionReferenceFeatureId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionFeatureNominalType* ExtrudedCrossSectionFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureNominalType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureNominalType::
    ~ExtrudedCrossSectionFeatureNominalType ()
    {
    }

    // ExtrudedCrossSectionFeatureActualType
    //

    ExtrudedCrossSectionFeatureActualType::
    ExtrudedCrossSectionFeatureActualType (const id_type& id,
                                           const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Direction_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionFeatureActualType::
    ExtrudedCrossSectionFeatureActualType (const id_type& id,
                                           ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Direction_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ExtrudedCrossSectionFeatureActualType::
    ExtrudedCrossSectionFeatureActualType (const ExtrudedCrossSectionFeatureActualType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Direction_ (x.Direction_, f, this),
      Length_ (x.Length_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureActualType::
    ExtrudedCrossSectionFeatureActualType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Direction_ (f, this),
      Length_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!this->Direction_)
          {
            this->Direction_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionFeatureActualType* ExtrudedCrossSectionFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureActualType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureActualType::
    ~ExtrudedCrossSectionFeatureActualType ()
    {
    }

    // GenericFeatureItemType
    //

    GenericFeatureItemType::
    GenericFeatureItemType (const id_type& id,
                            const FeatureName_type& FeatureName)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName)
    {
    }

    GenericFeatureItemType::
    GenericFeatureItemType (const GenericFeatureItemType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c)
    {
    }

    GenericFeatureItemType::
    GenericFeatureItemType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f, c)
    {
    }

    GenericFeatureItemType* GenericFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GenericFeatureItemType (*this, f, c);
    }

    GenericFeatureItemType::
    ~GenericFeatureItemType ()
    {
    }

    // GenericFeatureDefinitionType
    //

    GenericFeatureDefinitionType::
    GenericFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    GenericFeatureDefinitionType::
    GenericFeatureDefinitionType (const GenericFeatureDefinitionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    GenericFeatureDefinitionType::
    GenericFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    GenericFeatureDefinitionType* GenericFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GenericFeatureDefinitionType (*this, f, c);
    }

    GenericFeatureDefinitionType::
    ~GenericFeatureDefinitionType ()
    {
    }

    // GenericFeatureNominalType
    //

    GenericFeatureNominalType::
    GenericFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (::xml_schema::flags (), this),
      ReferenceFeatureNominalId_ (::xml_schema::flags (), this)
    {
    }

    GenericFeatureNominalType::
    GenericFeatureNominalType (const GenericFeatureNominalType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      ReferenceFeatureNominalId_ (x.ReferenceFeatureNominalId_, f, this)
    {
    }

    GenericFeatureNominalType::
    GenericFeatureNominalType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      ReferenceFeatureNominalId_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void GenericFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // ReferenceFeatureNominalId
        //
        if (n.name () == "ReferenceFeatureNominalId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReferenceFeatureNominalId_type > r (
            ReferenceFeatureNominalId_traits::create (i, f, this));

          this->ReferenceFeatureNominalId_.push_back (r);
          continue;
        }

        break;
      }
    }

    GenericFeatureNominalType* GenericFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GenericFeatureNominalType (*this, f, c);
    }

    GenericFeatureNominalType::
    ~GenericFeatureNominalType ()
    {
    }

    // GenericFeatureActualType
    //

    GenericFeatureActualType::
    GenericFeatureActualType (const id_type& id,
                              const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId)
    {
    }

    GenericFeatureActualType::
    GenericFeatureActualType (const id_type& id,
                              ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId)
    {
    }

    GenericFeatureActualType::
    GenericFeatureActualType (const GenericFeatureActualType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c)
    {
    }

    GenericFeatureActualType::
    GenericFeatureActualType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f, c)
    {
    }

    GenericFeatureActualType* GenericFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GenericFeatureActualType (*this, f, c);
    }

    GenericFeatureActualType::
    ~GenericFeatureActualType ()
    {
    }

    // LineConstructionMethodType
    //

    LineConstructionMethodType::
    LineConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Midline_ (::xml_schema::flags (), this),
      Intersection_ (::xml_schema::flags (), this),
      Projection_ (::xml_schema::flags (), this),
      Perpendicular_ (::xml_schema::flags (), this),
      Parallel_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      TangentThrough_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      Extract_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this)
    {
    }

    LineConstructionMethodType::
    LineConstructionMethodType (const LineConstructionMethodType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Midline_ (x.Midline_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Perpendicular_ (x.Perpendicular_, f, this),
      Parallel_ (x.Parallel_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      TangentThrough_ (x.TangentThrough_, f, this),
      Transform_ (x.Transform_, f, this),
      Extract_ (x.Extract_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    LineConstructionMethodType::
    LineConstructionMethodType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Midline_ (f, this),
      Intersection_ (f, this),
      Projection_ (f, this),
      Perpendicular_ (f, this),
      Parallel_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      TangentThrough_ (f, this),
      Transform_ (f, this),
      Extract_ (f, this),
      FromScan_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Midline
        //
        if (n.name () == "Midline" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Midline_type > r (
            Midline_traits::create (i, f, this));

          if (!this->Midline_)
          {
            this->Midline_.set (r);
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == "Intersection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Perpendicular
        //
        if (n.name () == "Perpendicular" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Perpendicular_type > r (
            Perpendicular_traits::create (i, f, this));

          if (!this->Perpendicular_)
          {
            this->Perpendicular_.set (r);
            continue;
          }
        }

        // Parallel
        //
        if (n.name () == "Parallel" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Parallel_type > r (
            Parallel_traits::create (i, f, this));

          if (!this->Parallel_)
          {
            this->Parallel_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // TangentThrough
        //
        if (n.name () == "TangentThrough" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentThrough_type > r (
            TangentThrough_traits::create (i, f, this));

          if (!this->TangentThrough_)
          {
            this->TangentThrough_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // Extract
        //
        if (n.name () == "Extract" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LineConstructionMethodType* LineConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineConstructionMethodType (*this, f, c);
    }

    LineConstructionMethodType::
    ~LineConstructionMethodType ()
    {
    }

    // LineBestFitType
    //

    LineBestFitType::
    LineBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    LineBestFitType::
    LineBestFitType (const LineBestFitType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    LineBestFitType::
    LineBestFitType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    LineBestFitType* LineBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineBestFitType (*this, f, c);
    }

    LineBestFitType::
    ~LineBestFitType ()
    {
    }

    // LineRecompType
    //

    LineRecompType::
    LineRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    LineRecompType::
    LineRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    LineRecompType::
    LineRecompType (const LineRecompType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    LineRecompType::
    LineRecompType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineRecompType* LineRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineRecompType (*this, f, c);
    }

    LineRecompType::
    ~LineRecompType ()
    {
    }

    // LineMidlineType
    //

    LineMidlineType::
    LineMidlineType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLine_ (::xml_schema::flags (), this)
    {
    }

    LineMidlineType::
    LineMidlineType (const LineMidlineType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseLine_ (x.BaseLine_, f, this)
    {
    }

    LineMidlineType::
    LineMidlineType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLine_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineMidlineType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseLine
        //
        if (n.name () == "BaseLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseLine_type > r (
            BaseLine_traits::create (i, f, this));

          this->BaseLine_.push_back (r);
          continue;
        }

        break;
      }
    }

    LineMidlineType* LineMidlineType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineMidlineType (*this, f, c);
    }

    LineMidlineType::
    ~LineMidlineType ()
    {
    }

    // LineIntersectionType
    //

    LineIntersectionType::
    LineIntersectionType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (::xml_schema::flags (), this)
    {
    }

    LineIntersectionType::
    LineIntersectionType (const LineIntersectionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this)
    {
    }

    LineIntersectionType::
    LineIntersectionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePlane
        //
        if (n.name () == "BasePlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          this->BasePlane_.push_back (r);
          continue;
        }

        break;
      }
    }

    LineIntersectionType* LineIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineIntersectionType (*this, f, c);
    }

    LineIntersectionType::
    ~LineIntersectionType ()
    {
    }

    // LineProjectionType
    //

    LineProjectionType::
    LineProjectionType (const ProjectionPlane_type& ProjectionPlane,
                        const ProjectionLine_type& ProjectionLine)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this),
      ProjectionLine_ (ProjectionLine, ::xml_schema::flags (), this)
    {
    }

    LineProjectionType::
    LineProjectionType (::std::auto_ptr< ProjectionPlane_type >& ProjectionPlane,
                        ::std::auto_ptr< ProjectionLine_type >& ProjectionLine)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this),
      ProjectionLine_ (ProjectionLine, ::xml_schema::flags (), this)
    {
    }

    LineProjectionType::
    LineProjectionType (const LineProjectionType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionPlane_ (x.ProjectionPlane_, f, this),
      ProjectionLine_ (x.ProjectionLine_, f, this)
    {
    }

    LineProjectionType::
    LineProjectionType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionPlane_ (f, this),
      ProjectionLine_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        // ProjectionLine
        //
        if (n.name () == "ProjectionLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionLine_type > r (
            ProjectionLine_traits::create (i, f, this));

          if (!ProjectionLine_.present ())
          {
            this->ProjectionLine_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionLine",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineProjectionType* LineProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineProjectionType (*this, f, c);
    }

    LineProjectionType::
    ~LineProjectionType ()
    {
    }

    // LinePerpendicularType
    //

    LinePerpendicularType::
    LinePerpendicularType (const PerpendicularFeature_type& PerpendicularFeature,
                           const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      PerpendicularFeature_ (PerpendicularFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    LinePerpendicularType::
    LinePerpendicularType (::std::auto_ptr< PerpendicularFeature_type >& PerpendicularFeature,
                           ::std::auto_ptr< PointFeature_type >& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      PerpendicularFeature_ (PerpendicularFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    LinePerpendicularType::
    LinePerpendicularType (const LinePerpendicularType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      PerpendicularFeature_ (x.PerpendicularFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    LinePerpendicularType::
    LinePerpendicularType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      PerpendicularFeature_ (f, this),
      PointFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LinePerpendicularType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PerpendicularFeature
        //
        if (n.name () == "PerpendicularFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PerpendicularFeature_type > r (
            PerpendicularFeature_traits::create (i, f, this));

          if (!PerpendicularFeature_.present ())
          {
            this->PerpendicularFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!PerpendicularFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PerpendicularFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LinePerpendicularType* LinePerpendicularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinePerpendicularType (*this, f, c);
    }

    LinePerpendicularType::
    ~LinePerpendicularType ()
    {
    }

    // LineParallelType
    //

    LineParallelType::
    LineParallelType (const ParallelFeature_type& ParallelFeature,
                      const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ParallelFeature_ (ParallelFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    LineParallelType::
    LineParallelType (::std::auto_ptr< ParallelFeature_type >& ParallelFeature,
                      ::std::auto_ptr< PointFeature_type >& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ParallelFeature_ (ParallelFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    LineParallelType::
    LineParallelType (const LineParallelType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ParallelFeature_ (x.ParallelFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    LineParallelType::
    LineParallelType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ParallelFeature_ (f, this),
      PointFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineParallelType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ParallelFeature
        //
        if (n.name () == "ParallelFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ParallelFeature_type > r (
            ParallelFeature_traits::create (i, f, this));

          if (!ParallelFeature_.present ())
          {
            this->ParallelFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ParallelFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ParallelFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineParallelType* LineParallelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineParallelType (*this, f, c);
    }

    LineParallelType::
    ~LineParallelType ()
    {
    }

    // LineCopyType
    //

    LineCopyType::
    LineCopyType (const BaseLine_type& BaseLine)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLine_ (BaseLine, ::xml_schema::flags (), this)
    {
    }

    LineCopyType::
    LineCopyType (::std::auto_ptr< BaseLine_type >& BaseLine)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLine_ (BaseLine, ::xml_schema::flags (), this)
    {
    }

    LineCopyType::
    LineCopyType (const LineCopyType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseLine_ (x.BaseLine_, f, this)
    {
    }

    LineCopyType::
    LineCopyType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLine_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseLine
        //
        if (n.name () == "BaseLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseLine_type > r (
            BaseLine_traits::create (i, f, this));

          if (!BaseLine_.present ())
          {
            this->BaseLine_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseLine",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineCopyType* LineCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCopyType (*this, f, c);
    }

    LineCopyType::
    ~LineCopyType ()
    {
    }

    // LineCastType
    //

    LineCastType::
    LineCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    LineCastType::
    LineCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    LineCastType::
    LineCastType (const LineCastType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    LineCastType::
    LineCastType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineCastType* LineCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCastType (*this, f, c);
    }

    LineCastType::
    ~LineCastType ()
    {
    }

    // LineTangentThroughType
    //

    LineTangentThroughType::
    LineTangentThroughType (const TangentFeature_type& TangentFeature,
                            const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    LineTangentThroughType::
    LineTangentThroughType (::std::auto_ptr< TangentFeature_type >& TangentFeature,
                            ::std::auto_ptr< PointFeature_type >& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    LineTangentThroughType::
    LineTangentThroughType (const LineTangentThroughType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    LineTangentThroughType::
    LineTangentThroughType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (f, this),
      PointFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineTangentThroughType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TangentFeature
        //
        if (n.name () == "TangentFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          if (!TangentFeature_.present ())
          {
            this->TangentFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!TangentFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TangentFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineTangentThroughType* LineTangentThroughType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineTangentThroughType (*this, f, c);
    }

    LineTangentThroughType::
    ~LineTangentThroughType ()
    {
    }

    // LineTransformType
    //

    LineTransformType::
    LineTransformType (const BaseLine_type& BaseLine,
                       const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLine_ (BaseLine, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    LineTransformType::
    LineTransformType (::std::auto_ptr< BaseLine_type >& BaseLine,
                       ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLine_ (BaseLine, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    LineTransformType::
    LineTransformType (const LineTransformType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseLine_ (x.BaseLine_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    LineTransformType::
    LineTransformType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLine_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseLine
        //
        if (n.name () == "BaseLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseLine_type > r (
            BaseLine_traits::create (i, f, this));

          if (!BaseLine_.present ())
          {
            this->BaseLine_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseLine",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineTransformType* LineTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineTransformType (*this, f, c);
    }

    LineTransformType::
    ~LineTransformType ()
    {
    }

    // LineFromScanType
    //

    LineFromScanType::
    LineFromScanType (const SurfaceFeature_type& SurfaceFeature,
                      const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    LineFromScanType::
    LineFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                      ::std::auto_ptr< SearchRadius_type >& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    LineFromScanType::
    LineFromScanType (const LineFromScanType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    LineFromScanType::
    LineFromScanType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineFromScanType* LineFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFromScanType (*this, f, c);
    }

    LineFromScanType::
    ~LineFromScanType ()
    {
    }

    // LineExtractType
    //

    LineExtractType::
    LineExtractType (const CurveFeature_type& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, ::xml_schema::flags (), this)
    {
    }

    LineExtractType::
    LineExtractType (::std::auto_ptr< CurveFeature_type >& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, ::xml_schema::flags (), this)
    {
    }

    LineExtractType::
    LineExtractType (const LineExtractType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    LineExtractType::
    LineExtractType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      CurveFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineExtractType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CurveFeature
        //
        if (n.name () == "CurveFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CurveFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineExtractType* LineExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineExtractType (*this, f, c);
    }

    LineExtractType::
    ~LineExtractType ()
    {
    }

    // LineCheckedType
    //

    LineCheckedType::
    LineCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    LineCheckedType::
    LineCheckedType (const LineCheckedType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    LineCheckedType::
    LineCheckedType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LineCheckedType* LineCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCheckedType (*this, f, c);
    }

    LineCheckedType::
    ~LineCheckedType ()
    {
    }

    // LineCheckedFeatureType
    //

    LineCheckedFeatureType::
    LineCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    LineCheckedFeatureType::
    LineCheckedFeatureType (const LineCheckedFeatureType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    LineCheckedFeatureType::
    LineCheckedFeatureType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LineCheckedFeatureType* LineCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCheckedFeatureType (*this, f, c);
    }

    LineCheckedFeatureType::
    ~LineCheckedFeatureType ()
    {
    }

    // LineActualDeterminationType
    //

    LineActualDeterminationType::
    LineActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    LineActualDeterminationType::
    LineActualDeterminationType (const LineActualDeterminationType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    LineActualDeterminationType::
    LineActualDeterminationType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LineActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LineActualDeterminationType* LineActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineActualDeterminationType (*this, f, c);
    }

    LineActualDeterminationType::
    ~LineActualDeterminationType ()
    {
    }

    // LineFeatureItemType
    //

    LineFeatureItemType::
    LineFeatureItemType (const id_type& id,
                         const FeatureName_type& FeatureName,
                         const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    LineFeatureItemType::
    LineFeatureItemType (const id_type& id,
                         const FeatureName_type& FeatureName,
                         ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    LineFeatureItemType::
    LineFeatureItemType (const LineFeatureItemType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    LineFeatureItemType::
    LineFeatureItemType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void LineFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineFeatureItemType* LineFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureItemType (*this, f, c);
    }

    LineFeatureItemType::
    ~LineFeatureItemType ()
    {
    }

    // LineFeatureDefinitionType
    //

    LineFeatureDefinitionType::
    LineFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    LineFeatureDefinitionType::
    LineFeatureDefinitionType (const LineFeatureDefinitionType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    LineFeatureDefinitionType::
    LineFeatureDefinitionType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    LineFeatureDefinitionType* LineFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureDefinitionType (*this, f, c);
    }

    LineFeatureDefinitionType::
    ~LineFeatureDefinitionType ()
    {
    }

    // LineFeatureNominalType
    //

    LineFeatureNominalType::
    LineFeatureNominalType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId,
                            const Location_type& Location,
                            const Direction_type& Direction)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Direction_ (Direction, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this)
    {
    }

    LineFeatureNominalType::
    LineFeatureNominalType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId,
                            ::std::auto_ptr< Location_type >& Location,
                            ::std::auto_ptr< Direction_type >& Direction)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Direction_ (Direction, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this)
    {
    }

    LineFeatureNominalType::
    LineFeatureNominalType (const LineFeatureNominalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Direction_ (x.Direction_, f, this),
      Length_ (x.Length_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    LineFeatureNominalType::
    LineFeatureNominalType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Direction_ (f, this),
      Length_ (f, this),
      Normal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void LineFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Direction",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineFeatureNominalType* LineFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureNominalType (*this, f, c);
    }

    LineFeatureNominalType::
    ~LineFeatureNominalType ()
    {
    }

    // LineFeatureActualType
    //

    LineFeatureActualType::
    LineFeatureActualType (const id_type& id,
                           const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Direction_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    LineFeatureActualType::
    LineFeatureActualType (const id_type& id,
                           ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Direction_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    LineFeatureActualType::
    LineFeatureActualType (const LineFeatureActualType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Direction_ (x.Direction_, f, this),
      Length_ (x.Length_, f, this),
      Normal_ (x.Normal_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    LineFeatureActualType::
    LineFeatureActualType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Direction_ (f, this),
      Length_ (f, this),
      Normal_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void LineFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!this->Direction_)
          {
            this->Direction_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LineFeatureActualType* LineFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureActualType (*this, f, c);
    }

    LineFeatureActualType::
    ~LineFeatureActualType ()
    {
    }

    // OppositeLinesConstructionMethodType
    //

    OppositeLinesConstructionMethodType::
    OppositeLinesConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Projection_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesConstructionMethodType::
    OppositeLinesConstructionMethodType (const OppositeLinesConstructionMethodType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    OppositeLinesConstructionMethodType::
    OppositeLinesConstructionMethodType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Projection_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this),
      FromScan_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesConstructionMethodType* OppositeLinesConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesConstructionMethodType (*this, f, c);
    }

    OppositeLinesConstructionMethodType::
    ~OppositeLinesConstructionMethodType ()
    {
    }

    // OppositeLinesBestFitType
    //

    OppositeLinesBestFitType::
    OppositeLinesBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesBestFitType::
    OppositeLinesBestFitType (const OppositeLinesBestFitType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositeLinesBestFitType::
    OppositeLinesBestFitType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    OppositeLinesBestFitType* OppositeLinesBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesBestFitType (*this, f, c);
    }

    OppositeLinesBestFitType::
    ~OppositeLinesBestFitType ()
    {
    }

    // OppositeLinesRecompType
    //

    OppositeLinesRecompType::
    OppositeLinesRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesRecompType::
    OppositeLinesRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesRecompType::
    OppositeLinesRecompType (const OppositeLinesRecompType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    OppositeLinesRecompType::
    OppositeLinesRecompType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesRecompType* OppositeLinesRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesRecompType (*this, f, c);
    }

    OppositeLinesRecompType::
    ~OppositeLinesRecompType ()
    {
    }

    // OppositeLinesProjectionType
    //

    OppositeLinesProjectionType::
    OppositeLinesProjectionType (const ProjectionPlane_type& ProjectionPlane,
                                 const ProjectionOppositeLines_type& ProjectionOppositeLines)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this),
      ProjectionOppositeLines_ (ProjectionOppositeLines, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesProjectionType::
    OppositeLinesProjectionType (::std::auto_ptr< ProjectionPlane_type >& ProjectionPlane,
                                 ::std::auto_ptr< ProjectionOppositeLines_type >& ProjectionOppositeLines)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this),
      ProjectionOppositeLines_ (ProjectionOppositeLines, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesProjectionType::
    OppositeLinesProjectionType (const OppositeLinesProjectionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionPlane_ (x.ProjectionPlane_, f, this),
      ProjectionOppositeLines_ (x.ProjectionOppositeLines_, f, this)
    {
    }

    OppositeLinesProjectionType::
    OppositeLinesProjectionType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionPlane_ (f, this),
      ProjectionOppositeLines_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        // ProjectionOppositeLines
        //
        if (n.name () == "ProjectionOppositeLines" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionOppositeLines_type > r (
            ProjectionOppositeLines_traits::create (i, f, this));

          if (!ProjectionOppositeLines_.present ())
          {
            this->ProjectionOppositeLines_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionOppositeLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionOppositeLines",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesProjectionType* OppositeLinesProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesProjectionType (*this, f, c);
    }

    OppositeLinesProjectionType::
    ~OppositeLinesProjectionType ()
    {
    }

    // OppositeLinesCopyType
    //

    OppositeLinesCopyType::
    OppositeLinesCopyType (const BaseOppositeLines_type& BaseOppositeLines)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositeLines_ (BaseOppositeLines, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesCopyType::
    OppositeLinesCopyType (::std::auto_ptr< BaseOppositeLines_type >& BaseOppositeLines)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositeLines_ (BaseOppositeLines, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesCopyType::
    OppositeLinesCopyType (const OppositeLinesCopyType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseOppositeLines_ (x.BaseOppositeLines_, f, this)
    {
    }

    OppositeLinesCopyType::
    OppositeLinesCopyType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeLines_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseOppositeLines
        //
        if (n.name () == "BaseOppositeLines" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseOppositeLines_type > r (
            BaseOppositeLines_traits::create (i, f, this));

          if (!BaseOppositeLines_.present ())
          {
            this->BaseOppositeLines_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseOppositeLines",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesCopyType* OppositeLinesCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesCopyType (*this, f, c);
    }

    OppositeLinesCopyType::
    ~OppositeLinesCopyType ()
    {
    }

    // OppositeLinesCastType
    //

    OppositeLinesCastType::
    OppositeLinesCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesCastType::
    OppositeLinesCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesCastType::
    OppositeLinesCastType (const OppositeLinesCastType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositeLinesCastType::
    OppositeLinesCastType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesCastType* OppositeLinesCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesCastType (*this, f, c);
    }

    OppositeLinesCastType::
    ~OppositeLinesCastType ()
    {
    }

    // OppositeLinesTransformType
    //

    OppositeLinesTransformType::
    OppositeLinesTransformType (const BaseOppositeLines_type& BaseOppositeLines,
                                const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositeLines_ (BaseOppositeLines, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesTransformType::
    OppositeLinesTransformType (::std::auto_ptr< BaseOppositeLines_type >& BaseOppositeLines,
                                ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositeLines_ (BaseOppositeLines, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesTransformType::
    OppositeLinesTransformType (const OppositeLinesTransformType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseOppositeLines_ (x.BaseOppositeLines_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    OppositeLinesTransformType::
    OppositeLinesTransformType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeLines_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseOppositeLines
        //
        if (n.name () == "BaseOppositeLines" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseOppositeLines_type > r (
            BaseOppositeLines_traits::create (i, f, this));

          if (!BaseOppositeLines_.present ())
          {
            this->BaseOppositeLines_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseOppositeLines",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesTransformType* OppositeLinesTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesTransformType (*this, f, c);
    }

    OppositeLinesTransformType::
    ~OppositeLinesTransformType ()
    {
    }

    // OppositeLinesFromScanType
    //

    OppositeLinesFromScanType::
    OppositeLinesFromScanType (const SurfaceFeature_type& SurfaceFeature,
                               const SearchRadius_type& SearchRadius,
                               const Depth_type& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      Depth_ (Depth, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesFromScanType::
    OppositeLinesFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                               ::std::auto_ptr< SearchRadius_type >& SearchRadius,
                               ::std::auto_ptr< Depth_type >& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      Depth_ (Depth, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesFromScanType::
    OppositeLinesFromScanType (const OppositeLinesFromScanType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    OppositeLinesFromScanType::
    OppositeLinesFromScanType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this),
      Depth_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Depth",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesFromScanType* OppositeLinesFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesFromScanType (*this, f, c);
    }

    OppositeLinesFromScanType::
    ~OppositeLinesFromScanType ()
    {
    }

    // OppositeLinesCheckedType
    //

    OppositeLinesCheckedType::
    OppositeLinesCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesCheckedType::
    OppositeLinesCheckedType (const OppositeLinesCheckedType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositeLinesCheckedType::
    OppositeLinesCheckedType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesCheckedType* OppositeLinesCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesCheckedType (*this, f, c);
    }

    OppositeLinesCheckedType::
    ~OppositeLinesCheckedType ()
    {
    }

    // OppositeLinesCheckedFeatureType
    //

    OppositeLinesCheckedFeatureType::
    OppositeLinesCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesCheckedFeatureType::
    OppositeLinesCheckedFeatureType (const OppositeLinesCheckedFeatureType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    OppositeLinesCheckedFeatureType::
    OppositeLinesCheckedFeatureType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesCheckedFeatureType* OppositeLinesCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesCheckedFeatureType (*this, f, c);
    }

    OppositeLinesCheckedFeatureType::
    ~OppositeLinesCheckedFeatureType ()
    {
    }

    // OppositeLinesActualDeterminationType
    //

    OppositeLinesActualDeterminationType::
    OppositeLinesActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesActualDeterminationType::
    OppositeLinesActualDeterminationType (const OppositeLinesActualDeterminationType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    OppositeLinesActualDeterminationType::
    OppositeLinesActualDeterminationType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesActualDeterminationType* OppositeLinesActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesActualDeterminationType (*this, f, c);
    }

    OppositeLinesActualDeterminationType::
    ~OppositeLinesActualDeterminationType ()
    {
    }

    // OppositeLinesFeatureItemType
    //

    OppositeLinesFeatureItemType::
    OppositeLinesFeatureItemType (const id_type& id,
                                  const FeatureName_type& FeatureName,
                                  const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesFeatureItemType::
    OppositeLinesFeatureItemType (const id_type& id,
                                  const FeatureName_type& FeatureName,
                                  ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesFeatureItemType::
    OppositeLinesFeatureItemType (const OppositeLinesFeatureItemType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    OppositeLinesFeatureItemType::
    OppositeLinesFeatureItemType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void OppositeLinesFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesFeatureItemType* OppositeLinesFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesFeatureItemType (*this, f, c);
    }

    OppositeLinesFeatureItemType::
    ~OppositeLinesFeatureItemType ()
    {
    }

    // OppositeLinesFeatureDefinitionType
    //

    OppositeLinesFeatureDefinitionType::
    OppositeLinesFeatureDefinitionType (const id_type& id,
                                        const InternalExternal_type& InternalExternal,
                                        const Width_type& Width,
                                        const EndType_type& EndType)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Width_ (Width, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      EndType_ (EndType, ::xml_schema::flags (), this),
      TaperAngle_ (::xml_schema::flags (), this),
      SingleOpenEnd_ (::xml_schema::flags (), this),
      EndRadius1_ (::xml_schema::flags (), this),
      EndRadius2_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesFeatureDefinitionType::
    OppositeLinesFeatureDefinitionType (const id_type& id,
                                        const InternalExternal_type& InternalExternal,
                                        ::std::auto_ptr< Width_type >& Width,
                                        ::std::auto_ptr< EndType_type >& EndType)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Width_ (Width, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      EndType_ (EndType, ::xml_schema::flags (), this),
      TaperAngle_ (::xml_schema::flags (), this),
      SingleOpenEnd_ (::xml_schema::flags (), this),
      EndRadius1_ (::xml_schema::flags (), this),
      EndRadius2_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesFeatureDefinitionType::
    OppositeLinesFeatureDefinitionType (const OppositeLinesFeatureDefinitionType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Width_ (x.Width_, f, this),
      Length_ (x.Length_, f, this),
      EndType_ (x.EndType_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      SingleOpenEnd_ (x.SingleOpenEnd_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this)
    {
    }

    OppositeLinesFeatureDefinitionType::
    OppositeLinesFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Width_ (f, this),
      Length_ (f, this),
      EndType_ (f, this),
      TaperAngle_ (f, this),
      SingleOpenEnd_ (f, this),
      EndRadius1_ (f, this),
      EndRadius2_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void OppositeLinesFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // EndType
        //
        if (n.name () == "EndType" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndType_type > r (
            EndType_traits::create (i, f, this));

          if (!EndType_.present ())
          {
            this->EndType_.set (r);
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == "TaperAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!this->TaperAngle_)
          {
            this->TaperAngle_.set (r);
            continue;
          }
        }

        // SingleOpenEnd
        //
        if (n.name () == "SingleOpenEnd" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->SingleOpenEnd_)
          {
            this->SingleOpenEnd_.set (SingleOpenEnd_traits::create (i, f, this));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == "EndRadius1" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (r);
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == "EndRadius2" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Width",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!EndType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndType",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesFeatureDefinitionType* OppositeLinesFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesFeatureDefinitionType (*this, f, c);
    }

    OppositeLinesFeatureDefinitionType::
    ~OppositeLinesFeatureDefinitionType ()
    {
    }

    // OppositeLinesFeatureNominalType
    //

    OppositeLinesFeatureNominalType::
    OppositeLinesFeatureNominalType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId,
                                     const CenterLine_type& CenterLine,
                                     const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterLine_ (CenterLine, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesFeatureNominalType::
    OppositeLinesFeatureNominalType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId,
                                     ::std::auto_ptr< CenterLine_type >& CenterLine,
                                     ::std::auto_ptr< Normal_type >& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterLine_ (CenterLine, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this)
    {
    }

    OppositeLinesFeatureNominalType::
    OppositeLinesFeatureNominalType (const OppositeLinesFeatureNominalType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      CenterLine_ (x.CenterLine_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    OppositeLinesFeatureNominalType::
    OppositeLinesFeatureNominalType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterLine_ (f, this),
      Normal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void OppositeLinesFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterLine
        //
        if (n.name () == "CenterLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterLine_type > r (
            CenterLine_traits::create (i, f, this));

          if (!CenterLine_.present ())
          {
            this->CenterLine_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CenterLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CenterLine",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesFeatureNominalType* OppositeLinesFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesFeatureNominalType (*this, f, c);
    }

    OppositeLinesFeatureNominalType::
    ~OppositeLinesFeatureNominalType ()
    {
    }

    // OppositeLinesFeatureActualType
    //

    OppositeLinesFeatureActualType::
    OppositeLinesFeatureActualType (const id_type& id,
                                    const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      CenterLine_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      Width_ (::xml_schema::flags (), this),
      WidthMin_ (::xml_schema::flags (), this),
      WidthMax_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      LengthMin_ (::xml_schema::flags (), this),
      LengthMax_ (::xml_schema::flags (), this),
      TaperAngle_ (::xml_schema::flags (), this),
      EndRadius1_ (::xml_schema::flags (), this),
      EndRadius2_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesFeatureActualType::
    OppositeLinesFeatureActualType (const id_type& id,
                                    ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      CenterLine_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      Width_ (::xml_schema::flags (), this),
      WidthMin_ (::xml_schema::flags (), this),
      WidthMax_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      LengthMin_ (::xml_schema::flags (), this),
      LengthMax_ (::xml_schema::flags (), this),
      TaperAngle_ (::xml_schema::flags (), this),
      EndRadius1_ (::xml_schema::flags (), this),
      EndRadius2_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    OppositeLinesFeatureActualType::
    OppositeLinesFeatureActualType (const OppositeLinesFeatureActualType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      CenterLine_ (x.CenterLine_, f, this),
      Normal_ (x.Normal_, f, this),
      Width_ (x.Width_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      Length_ (x.Length_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    OppositeLinesFeatureActualType::
    OppositeLinesFeatureActualType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      CenterLine_ (f, this),
      Normal_ (f, this),
      Width_ (f, this),
      WidthMin_ (f, this),
      WidthMax_ (f, this),
      Length_ (f, this),
      LengthMin_ (f, this),
      LengthMax_ (f, this),
      TaperAngle_ (f, this),
      EndRadius1_ (f, this),
      EndRadius2_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void OppositeLinesFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterLine
        //
        if (n.name () == "CenterLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterLine_type > r (
            CenterLine_traits::create (i, f, this));

          if (!this->CenterLine_)
          {
            this->CenterLine_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (r);
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == "WidthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (r);
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == "WidthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == "LengthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (r);
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == "LengthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (r);
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == "TaperAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!this->TaperAngle_)
          {
            this->TaperAngle_.set (r);
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == "EndRadius1" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (r);
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == "EndRadius2" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesFeatureActualType* OppositeLinesFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesFeatureActualType (*this, f, c);
    }

    OppositeLinesFeatureActualType::
    ~OppositeLinesFeatureActualType ()
    {
    }

    // OppositePlanesConstructionMethodType
    //

    OppositePlanesConstructionMethodType::
    OppositePlanesConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesConstructionMethodType::
    OppositePlanesConstructionMethodType (const OppositePlanesConstructionMethodType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    OppositePlanesConstructionMethodType::
    OppositePlanesConstructionMethodType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this),
      FromScan_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesConstructionMethodType* OppositePlanesConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesConstructionMethodType (*this, f, c);
    }

    OppositePlanesConstructionMethodType::
    ~OppositePlanesConstructionMethodType ()
    {
    }

    // OppositePlanesBestFitType
    //

    OppositePlanesBestFitType::
    OppositePlanesBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesBestFitType::
    OppositePlanesBestFitType (const OppositePlanesBestFitType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositePlanesBestFitType::
    OppositePlanesBestFitType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    OppositePlanesBestFitType* OppositePlanesBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesBestFitType (*this, f, c);
    }

    OppositePlanesBestFitType::
    ~OppositePlanesBestFitType ()
    {
    }

    // OppositePlanesRecompType
    //

    OppositePlanesRecompType::
    OppositePlanesRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    OppositePlanesRecompType::
    OppositePlanesRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    OppositePlanesRecompType::
    OppositePlanesRecompType (const OppositePlanesRecompType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    OppositePlanesRecompType::
    OppositePlanesRecompType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesRecompType* OppositePlanesRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesRecompType (*this, f, c);
    }

    OppositePlanesRecompType::
    ~OppositePlanesRecompType ()
    {
    }

    // OppositePlanesCopyType
    //

    OppositePlanesCopyType::
    OppositePlanesCopyType (const BaseOppositePlanes_type& BaseOppositePlanes)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositePlanes_ (BaseOppositePlanes, ::xml_schema::flags (), this)
    {
    }

    OppositePlanesCopyType::
    OppositePlanesCopyType (::std::auto_ptr< BaseOppositePlanes_type >& BaseOppositePlanes)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositePlanes_ (BaseOppositePlanes, ::xml_schema::flags (), this)
    {
    }

    OppositePlanesCopyType::
    OppositePlanesCopyType (const OppositePlanesCopyType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseOppositePlanes_ (x.BaseOppositePlanes_, f, this)
    {
    }

    OppositePlanesCopyType::
    OppositePlanesCopyType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositePlanes_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseOppositePlanes
        //
        if (n.name () == "BaseOppositePlanes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseOppositePlanes_type > r (
            BaseOppositePlanes_traits::create (i, f, this));

          if (!BaseOppositePlanes_.present ())
          {
            this->BaseOppositePlanes_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseOppositePlanes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseOppositePlanes",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesCopyType* OppositePlanesCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesCopyType (*this, f, c);
    }

    OppositePlanesCopyType::
    ~OppositePlanesCopyType ()
    {
    }

    // OppositePlanesCastType
    //

    OppositePlanesCastType::
    OppositePlanesCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    OppositePlanesCastType::
    OppositePlanesCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    OppositePlanesCastType::
    OppositePlanesCastType (const OppositePlanesCastType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositePlanesCastType::
    OppositePlanesCastType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesCastType* OppositePlanesCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesCastType (*this, f, c);
    }

    OppositePlanesCastType::
    ~OppositePlanesCastType ()
    {
    }

    // OppositePlanesTransformType
    //

    OppositePlanesTransformType::
    OppositePlanesTransformType (const BaseOppositePlanes_type& BaseOppositePlanes,
                                 const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositePlanes_ (BaseOppositePlanes, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    OppositePlanesTransformType::
    OppositePlanesTransformType (::std::auto_ptr< BaseOppositePlanes_type >& BaseOppositePlanes,
                                 ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositePlanes_ (BaseOppositePlanes, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    OppositePlanesTransformType::
    OppositePlanesTransformType (const OppositePlanesTransformType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseOppositePlanes_ (x.BaseOppositePlanes_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    OppositePlanesTransformType::
    OppositePlanesTransformType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositePlanes_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseOppositePlanes
        //
        if (n.name () == "BaseOppositePlanes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseOppositePlanes_type > r (
            BaseOppositePlanes_traits::create (i, f, this));

          if (!BaseOppositePlanes_.present ())
          {
            this->BaseOppositePlanes_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseOppositePlanes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseOppositePlanes",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesTransformType* OppositePlanesTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesTransformType (*this, f, c);
    }

    OppositePlanesTransformType::
    ~OppositePlanesTransformType ()
    {
    }

    // OppositePlanesFromScanType
    //

    OppositePlanesFromScanType::
    OppositePlanesFromScanType (const SurfaceFeature_type& SurfaceFeature,
                                const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    OppositePlanesFromScanType::
    OppositePlanesFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                                ::std::auto_ptr< SearchRadius_type >& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    OppositePlanesFromScanType::
    OppositePlanesFromScanType (const OppositePlanesFromScanType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    OppositePlanesFromScanType::
    OppositePlanesFromScanType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesFromScanType* OppositePlanesFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesFromScanType (*this, f, c);
    }

    OppositePlanesFromScanType::
    ~OppositePlanesFromScanType ()
    {
    }

    // OppositePlanesCheckedType
    //

    OppositePlanesCheckedType::
    OppositePlanesCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesCheckedType::
    OppositePlanesCheckedType (const OppositePlanesCheckedType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositePlanesCheckedType::
    OppositePlanesCheckedType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesCheckedType* OppositePlanesCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesCheckedType (*this, f, c);
    }

    OppositePlanesCheckedType::
    ~OppositePlanesCheckedType ()
    {
    }

    // OppositePlanesCheckedFeatureType
    //

    OppositePlanesCheckedFeatureType::
    OppositePlanesCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesCheckedFeatureType::
    OppositePlanesCheckedFeatureType (const OppositePlanesCheckedFeatureType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    OppositePlanesCheckedFeatureType::
    OppositePlanesCheckedFeatureType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesCheckedFeatureType* OppositePlanesCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesCheckedFeatureType (*this, f, c);
    }

    OppositePlanesCheckedFeatureType::
    ~OppositePlanesCheckedFeatureType ()
    {
    }

    // OppositePlanesActualDeterminationType
    //

    OppositePlanesActualDeterminationType::
    OppositePlanesActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesActualDeterminationType::
    OppositePlanesActualDeterminationType (const OppositePlanesActualDeterminationType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    OppositePlanesActualDeterminationType::
    OppositePlanesActualDeterminationType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesActualDeterminationType* OppositePlanesActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesActualDeterminationType (*this, f, c);
    }

    OppositePlanesActualDeterminationType::
    ~OppositePlanesActualDeterminationType ()
    {
    }

    // OppositePlanesFeatureItemType
    //

    OppositePlanesFeatureItemType::
    OppositePlanesFeatureItemType (const id_type& id,
                                   const FeatureName_type& FeatureName,
                                   const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesFeatureItemType::
    OppositePlanesFeatureItemType (const id_type& id,
                                   const FeatureName_type& FeatureName,
                                   ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesFeatureItemType::
    OppositePlanesFeatureItemType (const OppositePlanesFeatureItemType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    OppositePlanesFeatureItemType::
    OppositePlanesFeatureItemType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void OppositePlanesFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesFeatureItemType* OppositePlanesFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesFeatureItemType (*this, f, c);
    }

    OppositePlanesFeatureItemType::
    ~OppositePlanesFeatureItemType ()
    {
    }

    // OppositePlanesFeatureDefinitionType
    //

    OppositePlanesFeatureDefinitionType::
    OppositePlanesFeatureDefinitionType (const id_type& id,
                                         const InternalExternal_type& InternalExternal,
                                         const Width_type& Width,
                                         const EndType_type& EndType)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Width_ (Width, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      EndType_ (EndType, ::xml_schema::flags (), this),
      Depth_ (::xml_schema::flags (), this),
      Bottom_ (::xml_schema::flags (), this),
      SingleOpenEnd_ (::xml_schema::flags (), this),
      EndRadius1_ (::xml_schema::flags (), this),
      EndRadius2_ (::xml_schema::flags (), this),
      TaperAngle_ (::xml_schema::flags (), this),
      DraftAngle_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesFeatureDefinitionType::
    OppositePlanesFeatureDefinitionType (const id_type& id,
                                         const InternalExternal_type& InternalExternal,
                                         ::std::auto_ptr< Width_type >& Width,
                                         ::std::auto_ptr< EndType_type >& EndType)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Width_ (Width, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      EndType_ (EndType, ::xml_schema::flags (), this),
      Depth_ (::xml_schema::flags (), this),
      Bottom_ (::xml_schema::flags (), this),
      SingleOpenEnd_ (::xml_schema::flags (), this),
      EndRadius1_ (::xml_schema::flags (), this),
      EndRadius2_ (::xml_schema::flags (), this),
      TaperAngle_ (::xml_schema::flags (), this),
      DraftAngle_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesFeatureDefinitionType::
    OppositePlanesFeatureDefinitionType (const OppositePlanesFeatureDefinitionType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Width_ (x.Width_, f, this),
      Length_ (x.Length_, f, this),
      EndType_ (x.EndType_, f, this),
      Depth_ (x.Depth_, f, this),
      Bottom_ (x.Bottom_, f, this),
      SingleOpenEnd_ (x.SingleOpenEnd_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      DraftAngle_ (x.DraftAngle_, f, this)
    {
    }

    OppositePlanesFeatureDefinitionType::
    OppositePlanesFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Width_ (f, this),
      Length_ (f, this),
      EndType_ (f, this),
      Depth_ (f, this),
      Bottom_ (f, this),
      SingleOpenEnd_ (f, this),
      EndRadius1_ (f, this),
      EndRadius2_ (f, this),
      TaperAngle_ (f, this),
      DraftAngle_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void OppositePlanesFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // EndType
        //
        if (n.name () == "EndType" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndType_type > r (
            EndType_traits::create (i, f, this));

          if (!EndType_.present ())
          {
            this->EndType_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (r);
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == "Bottom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (r);
            continue;
          }
        }

        // SingleOpenEnd
        //
        if (n.name () == "SingleOpenEnd" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->SingleOpenEnd_)
          {
            this->SingleOpenEnd_.set (SingleOpenEnd_traits::create (i, f, this));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == "EndRadius1" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (r);
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == "EndRadius2" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (r);
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == "TaperAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!this->TaperAngle_)
          {
            this->TaperAngle_.set (r);
            continue;
          }
        }

        // DraftAngle
        //
        if (n.name () == "DraftAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DraftAngle_type > r (
            DraftAngle_traits::create (i, f, this));

          if (!this->DraftAngle_)
          {
            this->DraftAngle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Width",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!EndType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndType",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesFeatureDefinitionType* OppositePlanesFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesFeatureDefinitionType (*this, f, c);
    }

    OppositePlanesFeatureDefinitionType::
    ~OppositePlanesFeatureDefinitionType ()
    {
    }

    // OppositePlanesFeatureNominalType
    //

    OppositePlanesFeatureNominalType::
    OppositePlanesFeatureNominalType (const id_type& id,
                                      const FeatureDefinitionId_type& FeatureDefinitionId,
                                      const CenterPlane_type& CenterPlane)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterPlane_ (CenterPlane, ::xml_schema::flags (), this),
      LengthVector_ (::xml_schema::flags (), this),
      DepthVector_ (::xml_schema::flags (), this),
      DraftVector_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesFeatureNominalType::
    OppositePlanesFeatureNominalType (const id_type& id,
                                      const FeatureDefinitionId_type& FeatureDefinitionId,
                                      ::std::auto_ptr< CenterPlane_type >& CenterPlane)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterPlane_ (CenterPlane, ::xml_schema::flags (), this),
      LengthVector_ (::xml_schema::flags (), this),
      DepthVector_ (::xml_schema::flags (), this),
      DraftVector_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesFeatureNominalType::
    OppositePlanesFeatureNominalType (const OppositePlanesFeatureNominalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      CenterPlane_ (x.CenterPlane_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      DraftVector_ (x.DraftVector_, f, this)
    {
    }

    OppositePlanesFeatureNominalType::
    OppositePlanesFeatureNominalType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterPlane_ (f, this),
      LengthVector_ (f, this),
      DepthVector_ (f, this),
      DraftVector_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void OppositePlanesFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterPlane
        //
        if (n.name () == "CenterPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!CenterPlane_.present ())
          {
            this->CenterPlane_.set (r);
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == "LengthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!this->LengthVector_)
          {
            this->LengthVector_.set (r);
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == "DepthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!this->DepthVector_)
          {
            this->DepthVector_.set (r);
            continue;
          }
        }

        // DraftVector
        //
        if (n.name () == "DraftVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DraftVector_type > r (
            DraftVector_traits::create (i, f, this));

          if (!this->DraftVector_)
          {
            this->DraftVector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CenterPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CenterPlane",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesFeatureNominalType* OppositePlanesFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesFeatureNominalType (*this, f, c);
    }

    OppositePlanesFeatureNominalType::
    ~OppositePlanesFeatureNominalType ()
    {
    }

    // OppositePlanesFeatureActualType
    //

    OppositePlanesFeatureActualType::
    OppositePlanesFeatureActualType (const id_type& id,
                                     const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      CenterPlane_ (::xml_schema::flags (), this),
      LengthVector_ (::xml_schema::flags (), this),
      DepthVector_ (::xml_schema::flags (), this),
      Width_ (::xml_schema::flags (), this),
      WidthMin_ (::xml_schema::flags (), this),
      WidthMax_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      LengthMin_ (::xml_schema::flags (), this),
      LengthMax_ (::xml_schema::flags (), this),
      Depth_ (::xml_schema::flags (), this),
      TaperAngle_ (::xml_schema::flags (), this),
      DraftAngle_ (::xml_schema::flags (), this),
      EndRadius1_ (::xml_schema::flags (), this),
      EndRadius2_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesFeatureActualType::
    OppositePlanesFeatureActualType (const id_type& id,
                                     ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      CenterPlane_ (::xml_schema::flags (), this),
      LengthVector_ (::xml_schema::flags (), this),
      DepthVector_ (::xml_schema::flags (), this),
      Width_ (::xml_schema::flags (), this),
      WidthMin_ (::xml_schema::flags (), this),
      WidthMax_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      LengthMin_ (::xml_schema::flags (), this),
      LengthMax_ (::xml_schema::flags (), this),
      Depth_ (::xml_schema::flags (), this),
      TaperAngle_ (::xml_schema::flags (), this),
      DraftAngle_ (::xml_schema::flags (), this),
      EndRadius1_ (::xml_schema::flags (), this),
      EndRadius2_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    OppositePlanesFeatureActualType::
    OppositePlanesFeatureActualType (const OppositePlanesFeatureActualType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      CenterPlane_ (x.CenterPlane_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      Width_ (x.Width_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      Length_ (x.Length_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      Depth_ (x.Depth_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      DraftAngle_ (x.DraftAngle_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    OppositePlanesFeatureActualType::
    OppositePlanesFeatureActualType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      CenterPlane_ (f, this),
      LengthVector_ (f, this),
      DepthVector_ (f, this),
      Width_ (f, this),
      WidthMin_ (f, this),
      WidthMax_ (f, this),
      Length_ (f, this),
      LengthMin_ (f, this),
      LengthMax_ (f, this),
      Depth_ (f, this),
      TaperAngle_ (f, this),
      DraftAngle_ (f, this),
      EndRadius1_ (f, this),
      EndRadius2_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void OppositePlanesFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterPlane
        //
        if (n.name () == "CenterPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!this->CenterPlane_)
          {
            this->CenterPlane_.set (r);
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == "LengthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!this->LengthVector_)
          {
            this->LengthVector_.set (r);
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == "DepthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!this->DepthVector_)
          {
            this->DepthVector_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (r);
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == "WidthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (r);
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == "WidthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == "LengthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (r);
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == "LengthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (r);
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == "TaperAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!this->TaperAngle_)
          {
            this->TaperAngle_.set (r);
            continue;
          }
        }

        // DraftAngle
        //
        if (n.name () == "DraftAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DraftAngle_type > r (
            DraftAngle_traits::create (i, f, this));

          if (!this->DraftAngle_)
          {
            this->DraftAngle_.set (r);
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == "EndRadius1" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (r);
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == "EndRadius2" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesFeatureActualType* OppositePlanesFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesFeatureActualType (*this, f, c);
    }

    OppositePlanesFeatureActualType::
    ~OppositePlanesFeatureActualType ()
    {
    }

    // PlaneConstructionMethodType
    //

    PlaneConstructionMethodType::
    PlaneConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Midplane_ (::xml_schema::flags (), this),
      Offset_ (::xml_schema::flags (), this),
      Perpendicular_ (::xml_schema::flags (), this),
      Parallel_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      TangentThrough_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      Extract_ (::xml_schema::flags (), this)
    {
    }

    PlaneConstructionMethodType::
    PlaneConstructionMethodType (const PlaneConstructionMethodType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Midplane_ (x.Midplane_, f, this),
      Offset_ (x.Offset_, f, this),
      Perpendicular_ (x.Perpendicular_, f, this),
      Parallel_ (x.Parallel_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      TangentThrough_ (x.TangentThrough_, f, this),
      Transform_ (x.Transform_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    PlaneConstructionMethodType::
    PlaneConstructionMethodType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Midplane_ (f, this),
      Offset_ (f, this),
      Perpendicular_ (f, this),
      Parallel_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      TangentThrough_ (f, this),
      Transform_ (f, this),
      Extract_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Midplane
        //
        if (n.name () == "Midplane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Midplane_type > r (
            Midplane_traits::create (i, f, this));

          if (!this->Midplane_)
          {
            this->Midplane_.set (r);
            continue;
          }
        }

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!this->Offset_)
          {
            this->Offset_.set (r);
            continue;
          }
        }

        // Perpendicular
        //
        if (n.name () == "Perpendicular" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Perpendicular_type > r (
            Perpendicular_traits::create (i, f, this));

          if (!this->Perpendicular_)
          {
            this->Perpendicular_.set (r);
            continue;
          }
        }

        // Parallel
        //
        if (n.name () == "Parallel" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Parallel_type > r (
            Parallel_traits::create (i, f, this));

          if (!this->Parallel_)
          {
            this->Parallel_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // TangentThrough
        //
        if (n.name () == "TangentThrough" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentThrough_type > r (
            TangentThrough_traits::create (i, f, this));

          if (!this->TangentThrough_)
          {
            this->TangentThrough_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // Extract
        //
        if (n.name () == "Extract" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlaneConstructionMethodType* PlaneConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneConstructionMethodType (*this, f, c);
    }

    PlaneConstructionMethodType::
    ~PlaneConstructionMethodType ()
    {
    }

    // PlaneBestFitType
    //

    PlaneBestFitType::
    PlaneBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    PlaneBestFitType::
    PlaneBestFitType (const PlaneBestFitType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PlaneBestFitType::
    PlaneBestFitType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PlaneBestFitType* PlaneBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneBestFitType (*this, f, c);
    }

    PlaneBestFitType::
    ~PlaneBestFitType ()
    {
    }

    // PlaneRecompType
    //

    PlaneRecompType::
    PlaneRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    PlaneRecompType::
    PlaneRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    PlaneRecompType::
    PlaneRecompType (const PlaneRecompType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    PlaneRecompType::
    PlaneRecompType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneRecompType* PlaneRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneRecompType (*this, f, c);
    }

    PlaneRecompType::
    ~PlaneRecompType ()
    {
    }

    // PlaneMidplaneType
    //

    PlaneMidplaneType::
    PlaneMidplaneType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (::xml_schema::flags (), this)
    {
    }

    PlaneMidplaneType::
    PlaneMidplaneType (const PlaneMidplaneType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this)
    {
    }

    PlaneMidplaneType::
    PlaneMidplaneType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneMidplaneType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePlane
        //
        if (n.name () == "BasePlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          this->BasePlane_.push_back (r);
          continue;
        }

        break;
      }
    }

    PlaneMidplaneType* PlaneMidplaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneMidplaneType (*this, f, c);
    }

    PlaneMidplaneType::
    ~PlaneMidplaneType ()
    {
    }

    // PlaneOffsetType
    //

    PlaneOffsetType::
    PlaneOffsetType (const BasePlane_type& BasePlane,
                     const Offset_type& Offset)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, ::xml_schema::flags (), this),
      Offset_ (Offset, ::xml_schema::flags (), this)
    {
    }

    PlaneOffsetType::
    PlaneOffsetType (::std::auto_ptr< BasePlane_type >& BasePlane,
                     ::std::auto_ptr< Offset_type >& Offset)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, ::xml_schema::flags (), this),
      Offset_ (Offset, ::xml_schema::flags (), this)
    {
    }

    PlaneOffsetType::
    PlaneOffsetType (const PlaneOffsetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this),
      Offset_ (x.Offset_, f, this)
    {
    }

    PlaneOffsetType::
    PlaneOffsetType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (f, this),
      Offset_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneOffsetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePlane
        //
        if (n.name () == "BasePlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          if (!BasePlane_.present ())
          {
            this->BasePlane_.set (r);
            continue;
          }
        }

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!Offset_.present ())
          {
            this->Offset_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Offset_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Offset",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneOffsetType* PlaneOffsetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneOffsetType (*this, f, c);
    }

    PlaneOffsetType::
    ~PlaneOffsetType ()
    {
    }

    // PlanePerpendicularType
    //

    PlanePerpendicularType::
    PlanePerpendicularType (const PerpendicularFeature_type& PerpendicularFeature,
                            const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      PerpendicularFeature_ (PerpendicularFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    PlanePerpendicularType::
    PlanePerpendicularType (::std::auto_ptr< PerpendicularFeature_type >& PerpendicularFeature,
                            ::std::auto_ptr< PointFeature_type >& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      PerpendicularFeature_ (PerpendicularFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    PlanePerpendicularType::
    PlanePerpendicularType (const PlanePerpendicularType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      PerpendicularFeature_ (x.PerpendicularFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    PlanePerpendicularType::
    PlanePerpendicularType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      PerpendicularFeature_ (f, this),
      PointFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlanePerpendicularType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PerpendicularFeature
        //
        if (n.name () == "PerpendicularFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PerpendicularFeature_type > r (
            PerpendicularFeature_traits::create (i, f, this));

          if (!PerpendicularFeature_.present ())
          {
            this->PerpendicularFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!PerpendicularFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PerpendicularFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlanePerpendicularType* PlanePerpendicularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlanePerpendicularType (*this, f, c);
    }

    PlanePerpendicularType::
    ~PlanePerpendicularType ()
    {
    }

    // PlaneParallelType
    //

    PlaneParallelType::
    PlaneParallelType (const ParallelFeature_type& ParallelFeature,
                       const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ParallelFeature_ (ParallelFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    PlaneParallelType::
    PlaneParallelType (::std::auto_ptr< ParallelFeature_type >& ParallelFeature,
                       ::std::auto_ptr< PointFeature_type >& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ParallelFeature_ (ParallelFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    PlaneParallelType::
    PlaneParallelType (const PlaneParallelType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ParallelFeature_ (x.ParallelFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    PlaneParallelType::
    PlaneParallelType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ParallelFeature_ (f, this),
      PointFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneParallelType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ParallelFeature
        //
        if (n.name () == "ParallelFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ParallelFeature_type > r (
            ParallelFeature_traits::create (i, f, this));

          if (!ParallelFeature_.present ())
          {
            this->ParallelFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ParallelFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ParallelFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneParallelType* PlaneParallelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneParallelType (*this, f, c);
    }

    PlaneParallelType::
    ~PlaneParallelType ()
    {
    }

    // PlaneCopyType
    //

    PlaneCopyType::
    PlaneCopyType (const BasePlane_type& BasePlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, ::xml_schema::flags (), this)
    {
    }

    PlaneCopyType::
    PlaneCopyType (::std::auto_ptr< BasePlane_type >& BasePlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, ::xml_schema::flags (), this)
    {
    }

    PlaneCopyType::
    PlaneCopyType (const PlaneCopyType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this)
    {
    }

    PlaneCopyType::
    PlaneCopyType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePlane
        //
        if (n.name () == "BasePlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          if (!BasePlane_.present ())
          {
            this->BasePlane_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePlane",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneCopyType* PlaneCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCopyType (*this, f, c);
    }

    PlaneCopyType::
    ~PlaneCopyType ()
    {
    }

    // PlaneCastType
    //

    PlaneCastType::
    PlaneCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    PlaneCastType::
    PlaneCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    PlaneCastType::
    PlaneCastType (const PlaneCastType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PlaneCastType::
    PlaneCastType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneCastType* PlaneCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCastType (*this, f, c);
    }

    PlaneCastType::
    ~PlaneCastType ()
    {
    }

    // PlaneTangentThroughType
    //

    PlaneTangentThroughType::
    PlaneTangentThroughType (const TangentFeature_type& TangentFeature,
                             const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    PlaneTangentThroughType::
    PlaneTangentThroughType (::std::auto_ptr< TangentFeature_type >& TangentFeature,
                             ::std::auto_ptr< PointFeature_type >& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, ::xml_schema::flags (), this),
      PointFeature_ (PointFeature, ::xml_schema::flags (), this)
    {
    }

    PlaneTangentThroughType::
    PlaneTangentThroughType (const PlaneTangentThroughType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    PlaneTangentThroughType::
    PlaneTangentThroughType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (f, this),
      PointFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneTangentThroughType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TangentFeature
        //
        if (n.name () == "TangentFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          if (!TangentFeature_.present ())
          {
            this->TangentFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!TangentFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TangentFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneTangentThroughType* PlaneTangentThroughType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneTangentThroughType (*this, f, c);
    }

    PlaneTangentThroughType::
    ~PlaneTangentThroughType ()
    {
    }

    // PlaneTransformType
    //

    PlaneTransformType::
    PlaneTransformType (const BasePlane_type& BasePlane,
                        const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    PlaneTransformType::
    PlaneTransformType (::std::auto_ptr< BasePlane_type >& BasePlane,
                        ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    PlaneTransformType::
    PlaneTransformType (const PlaneTransformType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PlaneTransformType::
    PlaneTransformType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePlane
        //
        if (n.name () == "BasePlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          if (!BasePlane_.present ())
          {
            this->BasePlane_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneTransformType* PlaneTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneTransformType (*this, f, c);
    }

    PlaneTransformType::
    ~PlaneTransformType ()
    {
    }

    // PlaneExtractType
    //

    PlaneExtractType::
    PlaneExtractType (const SurfaceFeature_type& SurfaceFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this)
    {
    }

    PlaneExtractType::
    PlaneExtractType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this)
    {
    }

    PlaneExtractType::
    PlaneExtractType (const PlaneExtractType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this)
    {
    }

    PlaneExtractType::
    PlaneExtractType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneExtractType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneExtractType* PlaneExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneExtractType (*this, f, c);
    }

    PlaneExtractType::
    ~PlaneExtractType ()
    {
    }

    // PlaneCheckedType
    //

    PlaneCheckedType::
    PlaneCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    PlaneCheckedType::
    PlaneCheckedType (const PlaneCheckedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PlaneCheckedType::
    PlaneCheckedType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlaneCheckedType* PlaneCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCheckedType (*this, f, c);
    }

    PlaneCheckedType::
    ~PlaneCheckedType ()
    {
    }

    // PlaneCheckedFeatureType
    //

    PlaneCheckedFeatureType::
    PlaneCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    PlaneCheckedFeatureType::
    PlaneCheckedFeatureType (const PlaneCheckedFeatureType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PlaneCheckedFeatureType::
    PlaneCheckedFeatureType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlaneCheckedFeatureType* PlaneCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCheckedFeatureType (*this, f, c);
    }

    PlaneCheckedFeatureType::
    ~PlaneCheckedFeatureType ()
    {
    }

    // PlaneActualDeterminationType
    //

    PlaneActualDeterminationType::
    PlaneActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    PlaneActualDeterminationType::
    PlaneActualDeterminationType (const PlaneActualDeterminationType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PlaneActualDeterminationType::
    PlaneActualDeterminationType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PlaneActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlaneActualDeterminationType* PlaneActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneActualDeterminationType (*this, f, c);
    }

    PlaneActualDeterminationType::
    ~PlaneActualDeterminationType ()
    {
    }

    // PlaneFeatureItemType
    //

    PlaneFeatureItemType::
    PlaneFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    PlaneFeatureItemType::
    PlaneFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    PlaneFeatureItemType::
    PlaneFeatureItemType (const PlaneFeatureItemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    PlaneFeatureItemType::
    PlaneFeatureItemType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PlaneFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneFeatureItemType* PlaneFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureItemType (*this, f, c);
    }

    PlaneFeatureItemType::
    ~PlaneFeatureItemType ()
    {
    }

    // PlaneFeatureDefinitionType
    //

    PlaneFeatureDefinitionType::
    PlaneFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    PlaneFeatureDefinitionType::
    PlaneFeatureDefinitionType (const PlaneFeatureDefinitionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    PlaneFeatureDefinitionType::
    PlaneFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    PlaneFeatureDefinitionType* PlaneFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureDefinitionType (*this, f, c);
    }

    PlaneFeatureDefinitionType::
    ~PlaneFeatureDefinitionType ()
    {
    }

    // PlaneFeatureNominalType
    //

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             const Location_type& Location,
                             const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this),
      PolyLine_ (::xml_schema::flags (), this)
    {
    }

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             ::std::auto_ptr< Location_type >& Location,
                             ::std::auto_ptr< Normal_type >& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Normal_ (Normal, ::xml_schema::flags (), this),
      PolyLine_ (::xml_schema::flags (), this)
    {
    }

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const PlaneFeatureNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      PolyLine_ (x.PolyLine_, f, this)
    {
    }

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Normal_ (f, this),
      PolyLine_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PlaneFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // PolyLine
        //
        if (n.name () == "PolyLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PolyLine_type > r (
            PolyLine_traits::create (i, f, this));

          if (!this->PolyLine_)
          {
            this->PolyLine_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneFeatureNominalType* PlaneFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureNominalType (*this, f, c);
    }

    PlaneFeatureNominalType::
    ~PlaneFeatureNominalType ()
    {
    }

    // PlaneFeatureActualType
    //

    PlaneFeatureActualType::
    PlaneFeatureActualType (const id_type& id,
                            const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      PolyLine_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    PlaneFeatureActualType::
    PlaneFeatureActualType (const id_type& id,
                            ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this),
      PolyLine_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    PlaneFeatureActualType::
    PlaneFeatureActualType (const PlaneFeatureActualType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      PolyLine_ (x.PolyLine_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    PlaneFeatureActualType::
    PlaneFeatureActualType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Normal_ (f, this),
      PolyLine_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PlaneFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // PolyLine
        //
        if (n.name () == "PolyLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PolyLine_type > r (
            PolyLine_traits::create (i, f, this));

          if (!this->PolyLine_)
          {
            this->PolyLine_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlaneFeatureActualType* PlaneFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureActualType (*this, f, c);
    }

    PlaneFeatureActualType::
    ~PlaneFeatureActualType ()
    {
    }

    // PointDefinedCurveConstructionMethodType
    //

    PointDefinedCurveConstructionMethodType::
    PointDefinedCurveConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this),
      Extract_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveConstructionMethodType::
    PointDefinedCurveConstructionMethodType (const PointDefinedCurveConstructionMethodType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    PointDefinedCurveConstructionMethodType::
    PointDefinedCurveConstructionMethodType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Transform_ (f, this),
      FromScan_ (f, this),
      Extract_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        // Extract
        //
        if (n.name () == "Extract" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveConstructionMethodType* PointDefinedCurveConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveConstructionMethodType (*this, f, c);
    }

    PointDefinedCurveConstructionMethodType::
    ~PointDefinedCurveConstructionMethodType ()
    {
    }

    // PointDefinedCurveBestFitType
    //

    PointDefinedCurveBestFitType::
    PointDefinedCurveBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveBestFitType::
    PointDefinedCurveBestFitType (const PointDefinedCurveBestFitType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointDefinedCurveBestFitType::
    PointDefinedCurveBestFitType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PointDefinedCurveBestFitType* PointDefinedCurveBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveBestFitType (*this, f, c);
    }

    PointDefinedCurveBestFitType::
    ~PointDefinedCurveBestFitType ()
    {
    }

    // PointDefinedCurveRecompType
    //

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (const PointDefinedCurveRecompType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveRecompType* PointDefinedCurveRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveRecompType (*this, f, c);
    }

    PointDefinedCurveRecompType::
    ~PointDefinedCurveRecompType ()
    {
    }

    // PointDefinedCurveCopyType
    //

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (const BasePointDefinedCurve_type& BasePointDefinedCurve)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (BasePointDefinedCurve, ::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (::std::auto_ptr< BasePointDefinedCurve_type >& BasePointDefinedCurve)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (BasePointDefinedCurve, ::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (const PointDefinedCurveCopyType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedCurve_ (x.BasePointDefinedCurve_, f, this)
    {
    }

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedCurve_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointDefinedCurve
        //
        if (n.name () == "BasePointDefinedCurve" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointDefinedCurve_type > r (
            BasePointDefinedCurve_traits::create (i, f, this));

          if (!BasePointDefinedCurve_.present ())
          {
            this->BasePointDefinedCurve_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedCurve_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointDefinedCurve",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveCopyType* PointDefinedCurveCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveCopyType (*this, f, c);
    }

    PointDefinedCurveCopyType::
    ~PointDefinedCurveCopyType ()
    {
    }

    // PointDefinedCurveTransformType
    //

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (const BasePointDefinedCurve_type& BasePointDefinedCurve,
                                    const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (BasePointDefinedCurve, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (::std::auto_ptr< BasePointDefinedCurve_type >& BasePointDefinedCurve,
                                    ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (BasePointDefinedCurve, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (const PointDefinedCurveTransformType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedCurve_ (x.BasePointDefinedCurve_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedCurve_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointDefinedCurve
        //
        if (n.name () == "BasePointDefinedCurve" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointDefinedCurve_type > r (
            BasePointDefinedCurve_traits::create (i, f, this));

          if (!BasePointDefinedCurve_.present ())
          {
            this->BasePointDefinedCurve_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedCurve_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointDefinedCurve",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveTransformType* PointDefinedCurveTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveTransformType (*this, f, c);
    }

    PointDefinedCurveTransformType::
    ~PointDefinedCurveTransformType ()
    {
    }

    // PointDefinedCurveFromScanType
    //

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (const SurfaceFeature_type& SurfaceFeature,
                                   const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                                   ::std::auto_ptr< SearchRadius_type >& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (const PointDefinedCurveFromScanType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveFromScanType* PointDefinedCurveFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFromScanType (*this, f, c);
    }

    PointDefinedCurveFromScanType::
    ~PointDefinedCurveFromScanType ()
    {
    }

    // PointDefinedCurveExtractType
    //

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (const CurveFeature_type& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, ::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (::std::auto_ptr< CurveFeature_type >& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, ::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (const PointDefinedCurveExtractType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      CurveFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveExtractType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CurveFeature
        //
        if (n.name () == "CurveFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CurveFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveExtractType* PointDefinedCurveExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveExtractType (*this, f, c);
    }

    PointDefinedCurveExtractType::
    ~PointDefinedCurveExtractType ()
    {
    }

    // PointDefinedCurveCheckedType
    //

    PointDefinedCurveCheckedType::
    PointDefinedCurveCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveCheckedType::
    PointDefinedCurveCheckedType (const PointDefinedCurveCheckedType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointDefinedCurveCheckedType::
    PointDefinedCurveCheckedType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveCheckedType* PointDefinedCurveCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveCheckedType (*this, f, c);
    }

    PointDefinedCurveCheckedType::
    ~PointDefinedCurveCheckedType ()
    {
    }

    // PointDefinedCurveCheckedFeatureType
    //

    PointDefinedCurveCheckedFeatureType::
    PointDefinedCurveCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveCheckedFeatureType::
    PointDefinedCurveCheckedFeatureType (const PointDefinedCurveCheckedFeatureType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PointDefinedCurveCheckedFeatureType::
    PointDefinedCurveCheckedFeatureType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveCheckedFeatureType* PointDefinedCurveCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveCheckedFeatureType (*this, f, c);
    }

    PointDefinedCurveCheckedFeatureType::
    ~PointDefinedCurveCheckedFeatureType ()
    {
    }

    // PointDefinedCurveActualDeterminationType
    //

    PointDefinedCurveActualDeterminationType::
    PointDefinedCurveActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveActualDeterminationType::
    PointDefinedCurveActualDeterminationType (const PointDefinedCurveActualDeterminationType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PointDefinedCurveActualDeterminationType::
    PointDefinedCurveActualDeterminationType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveActualDeterminationType* PointDefinedCurveActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveActualDeterminationType (*this, f, c);
    }

    PointDefinedCurveActualDeterminationType::
    ~PointDefinedCurveActualDeterminationType ()
    {
    }

    // PointDefinedCurveFeatureItemType
    //

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const id_type& id,
                                      const FeatureName_type& FeatureName,
                                      const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const id_type& id,
                                      const FeatureName_type& FeatureName,
                                      ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const PointDefinedCurveFeatureItemType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveFeatureItemType* PointDefinedCurveFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureItemType (*this, f, c);
    }

    PointDefinedCurveFeatureItemType::
    ~PointDefinedCurveFeatureItemType ()
    {
    }

    // PointDefinedCurveFeatureDefinitionType
    //

    PointDefinedCurveFeatureDefinitionType::
    PointDefinedCurveFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    PointDefinedCurveFeatureDefinitionType::
    PointDefinedCurveFeatureDefinitionType (const PointDefinedCurveFeatureDefinitionType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    PointDefinedCurveFeatureDefinitionType::
    PointDefinedCurveFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    PointDefinedCurveFeatureDefinitionType* PointDefinedCurveFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureDefinitionType (*this, f, c);
    }

    PointDefinedCurveFeatureDefinitionType::
    ~PointDefinedCurveFeatureDefinitionType ()
    {
    }

    // PointDefinedCurveFeatureNominalType
    //

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const id_type& id,
                                         const FeatureDefinitionId_type& FeatureDefinitionId,
                                         const DefiningPoints_type& DefiningPoints)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      DefiningPoints_ (DefiningPoints, ::xml_schema::flags (), this),
      Plane_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const id_type& id,
                                         const FeatureDefinitionId_type& FeatureDefinitionId,
                                         ::std::auto_ptr< DefiningPoints_type >& DefiningPoints)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      DefiningPoints_ (DefiningPoints, ::xml_schema::flags (), this),
      Plane_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const PointDefinedCurveFeatureNominalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this),
      Plane_ (x.Plane_, f, this)
    {
    }

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (f, this),
      Plane_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DefiningPoints
        //
        if (n.name () == "DefiningPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!DefiningPoints_.present ())
          {
            this->DefiningPoints_.set (r);
            continue;
          }
        }

        // Plane
        //
        if (n.name () == "Plane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Plane_type > r (
            Plane_traits::create (i, f, this));

          if (!this->Plane_)
          {
            this->Plane_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DefiningPoints_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefiningPoints",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveFeatureNominalType* PointDefinedCurveFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureNominalType (*this, f, c);
    }

    PointDefinedCurveFeatureNominalType::
    ~PointDefinedCurveFeatureNominalType ()
    {
    }

    // TargetPointsActualType
    //

    TargetPointsActualType::
    TargetPointsActualType ()
    : ::xml_schema::type (),
      TargetPoint_ (::xml_schema::flags (), this),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this),
      combinedUncertainty_ (::xml_schema::flags (), this),
      meanError_ (::xml_schema::flags (), this),
      xCombinedUncertainty_ (::xml_schema::flags (), this),
      xMeanError_ (::xml_schema::flags (), this),
      yCombinedUncertainty_ (::xml_schema::flags (), this),
      yMeanError_ (::xml_schema::flags (), this),
      zCombinedUncertainty_ (::xml_schema::flags (), this),
      zMeanError_ (::xml_schema::flags (), this)
    {
    }

    TargetPointsActualType::
    TargetPointsActualType (const TargetPointsActualType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TargetPoint_ (x.TargetPoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this),
      xCombinedUncertainty_ (x.xCombinedUncertainty_, f, this),
      xMeanError_ (x.xMeanError_, f, this),
      yCombinedUncertainty_ (x.yCombinedUncertainty_, f, this),
      yMeanError_ (x.yMeanError_, f, this),
      zCombinedUncertainty_ (x.zCombinedUncertainty_, f, this),
      zMeanError_ (x.zMeanError_, f, this)
    {
    }

    TargetPointsActualType::
    TargetPointsActualType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TargetPoint_ (f, this),
      linearUnit_ (f, this),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this),
      validity_ (f, this),
      xDecimalPlaces_ (f, this),
      xSignificantFigures_ (f, this),
      xValidity_ (f, this),
      yDecimalPlaces_ (f, this),
      ySignificantFigures_ (f, this),
      yValidity_ (f, this),
      zDecimalPlaces_ (f, this),
      zSignificantFigures_ (f, this),
      zValidity_ (f, this),
      combinedUncertainty_ (f, this),
      meanError_ (f, this),
      xCombinedUncertainty_ (f, this),
      xMeanError_ (f, this),
      yCombinedUncertainty_ (f, this),
      yMeanError_ (f, this),
      zCombinedUncertainty_ (f, this),
      zMeanError_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void TargetPointsActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TargetPoint
        //
        if (n.name () == "TargetPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TargetPoint_type > r (
            TargetPoint_traits::create (i, f, this));

          this->TargetPoint_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validity_type > r (
            validity_traits::create (i, f, this));

          this->validity_.set (r);
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< xValidity_type > r (
            xValidity_traits::create (i, f, this));

          this->xValidity_.set (r);
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< yValidity_type > r (
            yValidity_traits::create (i, f, this));

          this->yValidity_.set (r);
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< zValidity_type > r (
            zValidity_traits::create (i, f, this));

          this->zValidity_.set (r);
          continue;
        }

        if (n.name () == "combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->xCombinedUncertainty_.set (xCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xMeanError" && n.namespace_ ().empty ())
        {
          this->xMeanError_.set (xMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->yCombinedUncertainty_.set (yCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yMeanError" && n.namespace_ ().empty ())
        {
          this->yMeanError_.set (yMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->zCombinedUncertainty_.set (zCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zMeanError" && n.namespace_ ().empty ())
        {
          this->zMeanError_.set (zMeanError_traits::create (i, f, this));
          continue;
        }
      }
    }

    TargetPointsActualType* TargetPointsActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TargetPointsActualType (*this, f, c);
    }

    TargetPointsActualType::
    ~TargetPointsActualType ()
    {
    }

    // PointDefinedCurveFeatureActualType
    //

    PointDefinedCurveFeatureActualType::
    PointDefinedCurveFeatureActualType (const id_type& id,
                                        const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      DefiningPoints_ (::xml_schema::flags (), this),
      Plane_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveFeatureActualType::
    PointDefinedCurveFeatureActualType (const id_type& id,
                                        ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      DefiningPoints_ (::xml_schema::flags (), this),
      Plane_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedCurveFeatureActualType::
    PointDefinedCurveFeatureActualType (const PointDefinedCurveFeatureActualType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this),
      Plane_ (x.Plane_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    PointDefinedCurveFeatureActualType::
    PointDefinedCurveFeatureActualType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (f, this),
      Plane_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DefiningPoints
        //
        if (n.name () == "DefiningPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!this->DefiningPoints_)
          {
            this->DefiningPoints_.set (r);
            continue;
          }
        }

        // Plane
        //
        if (n.name () == "Plane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Plane_type > r (
            Plane_traits::create (i, f, this));

          if (!this->Plane_)
          {
            this->Plane_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveFeatureActualType* PointDefinedCurveFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureActualType (*this, f, c);
    }

    PointDefinedCurveFeatureActualType::
    ~PointDefinedCurveFeatureActualType ()
    {
    }

    // PointDefinedSurfaceConstructionMethodType
    //

    PointDefinedSurfaceConstructionMethodType::
    PointDefinedSurfaceConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      Extract_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceConstructionMethodType::
    PointDefinedSurfaceConstructionMethodType (const PointDefinedSurfaceConstructionMethodType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Transform_ (x.Transform_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    PointDefinedSurfaceConstructionMethodType::
    PointDefinedSurfaceConstructionMethodType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Transform_ (f, this),
      Extract_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // Extract
        //
        if (n.name () == "Extract" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceConstructionMethodType* PointDefinedSurfaceConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceConstructionMethodType (*this, f, c);
    }

    PointDefinedSurfaceConstructionMethodType::
    ~PointDefinedSurfaceConstructionMethodType ()
    {
    }

    // PointDefinedSurfaceBestFitType
    //

    PointDefinedSurfaceBestFitType::
    PointDefinedSurfaceBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceBestFitType::
    PointDefinedSurfaceBestFitType (const PointDefinedSurfaceBestFitType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointDefinedSurfaceBestFitType::
    PointDefinedSurfaceBestFitType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PointDefinedSurfaceBestFitType* PointDefinedSurfaceBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceBestFitType (*this, f, c);
    }

    PointDefinedSurfaceBestFitType::
    ~PointDefinedSurfaceBestFitType ()
    {
    }

    // PointDefinedSurfaceRecompType
    //

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (const PointDefinedSurfaceRecompType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceRecompType* PointDefinedSurfaceRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceRecompType (*this, f, c);
    }

    PointDefinedSurfaceRecompType::
    ~PointDefinedSurfaceRecompType ()
    {
    }

    // PointDefinedSurfaceCopyType
    //

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (const BasePointDefinedSurface_type& BasePointDefinedSurface)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (BasePointDefinedSurface, ::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (::std::auto_ptr< BasePointDefinedSurface_type >& BasePointDefinedSurface)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (BasePointDefinedSurface, ::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (const PointDefinedSurfaceCopyType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedSurface_ (x.BasePointDefinedSurface_, f, this)
    {
    }

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedSurface_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointDefinedSurface
        //
        if (n.name () == "BasePointDefinedSurface" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointDefinedSurface_type > r (
            BasePointDefinedSurface_traits::create (i, f, this));

          if (!BasePointDefinedSurface_.present ())
          {
            this->BasePointDefinedSurface_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedSurface_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointDefinedSurface",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceCopyType* PointDefinedSurfaceCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceCopyType (*this, f, c);
    }

    PointDefinedSurfaceCopyType::
    ~PointDefinedSurfaceCopyType ()
    {
    }

    // PointDefinedSurfaceTransformType
    //

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (const BasePointDefinedSurface_type& BasePointDefinedSurface,
                                      const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (BasePointDefinedSurface, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (::std::auto_ptr< BasePointDefinedSurface_type >& BasePointDefinedSurface,
                                      ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (BasePointDefinedSurface, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (const PointDefinedSurfaceTransformType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedSurface_ (x.BasePointDefinedSurface_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedSurface_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointDefinedSurface
        //
        if (n.name () == "BasePointDefinedSurface" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointDefinedSurface_type > r (
            BasePointDefinedSurface_traits::create (i, f, this));

          if (!BasePointDefinedSurface_.present ())
          {
            this->BasePointDefinedSurface_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedSurface_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointDefinedSurface",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceTransformType* PointDefinedSurfaceTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceTransformType (*this, f, c);
    }

    PointDefinedSurfaceTransformType::
    ~PointDefinedSurfaceTransformType ()
    {
    }

    // PointDefinedSurfaceExtractType
    //

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (const SurfaceFeature_type& SurfaceFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (const PointDefinedSurfaceExtractType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this)
    {
    }

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceExtractType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceExtractType* PointDefinedSurfaceExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceExtractType (*this, f, c);
    }

    PointDefinedSurfaceExtractType::
    ~PointDefinedSurfaceExtractType ()
    {
    }

    // PointDefinedSurfaceCheckedType
    //

    PointDefinedSurfaceCheckedType::
    PointDefinedSurfaceCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceCheckedType::
    PointDefinedSurfaceCheckedType (const PointDefinedSurfaceCheckedType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointDefinedSurfaceCheckedType::
    PointDefinedSurfaceCheckedType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceCheckedType* PointDefinedSurfaceCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceCheckedType (*this, f, c);
    }

    PointDefinedSurfaceCheckedType::
    ~PointDefinedSurfaceCheckedType ()
    {
    }

    // PointDefinedSurfaceCheckedFeatureType
    //

    PointDefinedSurfaceCheckedFeatureType::
    PointDefinedSurfaceCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceCheckedFeatureType::
    PointDefinedSurfaceCheckedFeatureType (const PointDefinedSurfaceCheckedFeatureType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PointDefinedSurfaceCheckedFeatureType::
    PointDefinedSurfaceCheckedFeatureType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceCheckedFeatureType* PointDefinedSurfaceCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceCheckedFeatureType (*this, f, c);
    }

    PointDefinedSurfaceCheckedFeatureType::
    ~PointDefinedSurfaceCheckedFeatureType ()
    {
    }

    // PointDefinedSurfaceActualDeterminationType
    //

    PointDefinedSurfaceActualDeterminationType::
    PointDefinedSurfaceActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceActualDeterminationType::
    PointDefinedSurfaceActualDeterminationType (const PointDefinedSurfaceActualDeterminationType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PointDefinedSurfaceActualDeterminationType::
    PointDefinedSurfaceActualDeterminationType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceActualDeterminationType* PointDefinedSurfaceActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceActualDeterminationType (*this, f, c);
    }

    PointDefinedSurfaceActualDeterminationType::
    ~PointDefinedSurfaceActualDeterminationType ()
    {
    }

    // PointDefinedSurfaceFeatureItemType
    //

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const id_type& id,
                                        const FeatureName_type& FeatureName,
                                        const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const id_type& id,
                                        const FeatureName_type& FeatureName,
                                        ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const PointDefinedSurfaceFeatureItemType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceFeatureItemType* PointDefinedSurfaceFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureItemType (*this, f, c);
    }

    PointDefinedSurfaceFeatureItemType::
    ~PointDefinedSurfaceFeatureItemType ()
    {
    }

    // PointDefinedSurfaceFeatureDefinitionType
    //

    PointDefinedSurfaceFeatureDefinitionType::
    PointDefinedSurfaceFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    PointDefinedSurfaceFeatureDefinitionType::
    PointDefinedSurfaceFeatureDefinitionType (const PointDefinedSurfaceFeatureDefinitionType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    PointDefinedSurfaceFeatureDefinitionType::
    PointDefinedSurfaceFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    PointDefinedSurfaceFeatureDefinitionType* PointDefinedSurfaceFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureDefinitionType (*this, f, c);
    }

    PointDefinedSurfaceFeatureDefinitionType::
    ~PointDefinedSurfaceFeatureDefinitionType ()
    {
    }

    // TargetPointsNominalType
    //

    TargetPointsNominalType::
    TargetPointsNominalType ()
    : ::xml_schema::type (),
      TargetPoint_ (::xml_schema::flags (), this),
      linearUnit_ (::xml_schema::flags (), this),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this),
      validity_ (::xml_schema::flags (), this),
      xDecimalPlaces_ (::xml_schema::flags (), this),
      xSignificantFigures_ (::xml_schema::flags (), this),
      xValidity_ (::xml_schema::flags (), this),
      yDecimalPlaces_ (::xml_schema::flags (), this),
      ySignificantFigures_ (::xml_schema::flags (), this),
      yValidity_ (::xml_schema::flags (), this),
      zDecimalPlaces_ (::xml_schema::flags (), this),
      zSignificantFigures_ (::xml_schema::flags (), this),
      zValidity_ (::xml_schema::flags (), this)
    {
    }

    TargetPointsNominalType::
    TargetPointsNominalType (const TargetPointsNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TargetPoint_ (x.TargetPoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    TargetPointsNominalType::
    TargetPointsNominalType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TargetPoint_ (f, this),
      linearUnit_ (f, this),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this),
      validity_ (f, this),
      xDecimalPlaces_ (f, this),
      xSignificantFigures_ (f, this),
      xValidity_ (f, this),
      yDecimalPlaces_ (f, this),
      ySignificantFigures_ (f, this),
      yValidity_ (f, this),
      zDecimalPlaces_ (f, this),
      zSignificantFigures_ (f, this),
      zValidity_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void TargetPointsNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TargetPoint
        //
        if (n.name () == "TargetPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TargetPoint_type > r (
            TargetPoint_traits::create (i, f, this));

          this->TargetPoint_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< validity_type > r (
            validity_traits::create (i, f, this));

          this->validity_.set (r);
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< xValidity_type > r (
            xValidity_traits::create (i, f, this));

          this->xValidity_.set (r);
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< yValidity_type > r (
            yValidity_traits::create (i, f, this));

          this->yValidity_.set (r);
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< zValidity_type > r (
            zValidity_traits::create (i, f, this));

          this->zValidity_.set (r);
          continue;
        }
      }
    }

    TargetPointsNominalType* TargetPointsNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TargetPointsNominalType (*this, f, c);
    }

    TargetPointsNominalType::
    ~TargetPointsNominalType ()
    {
    }

    // PointDefinedSurfaceFeatureNominalType
    //

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const id_type& id,
                                           const FeatureDefinitionId_type& FeatureDefinitionId,
                                           const DefiningPoints_type& DefiningPoints)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      DefiningPoints_ (DefiningPoints, ::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const id_type& id,
                                           const FeatureDefinitionId_type& FeatureDefinitionId,
                                           ::std::auto_ptr< DefiningPoints_type >& DefiningPoints)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      DefiningPoints_ (DefiningPoints, ::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const PointDefinedSurfaceFeatureNominalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this)
    {
    }

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DefiningPoints
        //
        if (n.name () == "DefiningPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!DefiningPoints_.present ())
          {
            this->DefiningPoints_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DefiningPoints_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefiningPoints",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceFeatureNominalType* PointDefinedSurfaceFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureNominalType (*this, f, c);
    }

    PointDefinedSurfaceFeatureNominalType::
    ~PointDefinedSurfaceFeatureNominalType ()
    {
    }

    // PointDefinedSurfaceFeatureActualType
    //

    PointDefinedSurfaceFeatureActualType::
    PointDefinedSurfaceFeatureActualType (const id_type& id,
                                          const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      DefiningPoints_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceFeatureActualType::
    PointDefinedSurfaceFeatureActualType (const id_type& id,
                                          ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      DefiningPoints_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    PointDefinedSurfaceFeatureActualType::
    PointDefinedSurfaceFeatureActualType (const PointDefinedSurfaceFeatureActualType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    PointDefinedSurfaceFeatureActualType::
    PointDefinedSurfaceFeatureActualType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DefiningPoints
        //
        if (n.name () == "DefiningPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!this->DefiningPoints_)
          {
            this->DefiningPoints_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceFeatureActualType* PointDefinedSurfaceFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureActualType (*this, f, c);
    }

    PointDefinedSurfaceFeatureActualType::
    ~PointDefinedSurfaceFeatureActualType ()
    {
    }

    // PointConstructionMethodType
    //

    PointConstructionMethodType::
    PointConstructionMethodType ()
    : ::xml_schema::type (),
      Intersection_ (::xml_schema::flags (), this),
      Projection_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromCone_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this),
      CenterOfGravity_ (::xml_schema::flags (), this),
      Pierce_ (::xml_schema::flags (), this),
      MidPoint_ (::xml_schema::flags (), this),
      MovePoint_ (::xml_schema::flags (), this),
      MovePointVector_ (::xml_schema::flags (), this),
      MovePointAxis_ (::xml_schema::flags (), this),
      Extreme_ (::xml_schema::flags (), this)
    {
    }

    PointConstructionMethodType::
    PointConstructionMethodType (const PointConstructionMethodType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromCone_ (x.FromCone_, f, this),
      FromScan_ (x.FromScan_, f, this),
      CenterOfGravity_ (x.CenterOfGravity_, f, this),
      Pierce_ (x.Pierce_, f, this),
      MidPoint_ (x.MidPoint_, f, this),
      MovePoint_ (x.MovePoint_, f, this),
      MovePointVector_ (x.MovePointVector_, f, this),
      MovePointAxis_ (x.MovePointAxis_, f, this),
      Extreme_ (x.Extreme_, f, this)
    {
    }

    PointConstructionMethodType::
    PointConstructionMethodType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Intersection_ (f, this),
      Projection_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this),
      FromCone_ (f, this),
      FromScan_ (f, this),
      CenterOfGravity_ (f, this),
      Pierce_ (f, this),
      MidPoint_ (f, this),
      MovePoint_ (f, this),
      MovePointVector_ (f, this),
      MovePointAxis_ (f, this),
      Extreme_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Intersection
        //
        if (n.name () == "Intersection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromCone
        //
        if (n.name () == "FromCone" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromCone_type > r (
            FromCone_traits::create (i, f, this));

          if (!this->FromCone_)
          {
            this->FromCone_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        // CenterOfGravity
        //
        if (n.name () == "CenterOfGravity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterOfGravity_type > r (
            CenterOfGravity_traits::create (i, f, this));

          if (!this->CenterOfGravity_)
          {
            this->CenterOfGravity_.set (r);
            continue;
          }
        }

        // Pierce
        //
        if (n.name () == "Pierce" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Pierce_type > r (
            Pierce_traits::create (i, f, this));

          if (!this->Pierce_)
          {
            this->Pierce_.set (r);
            continue;
          }
        }

        // MidPoint
        //
        if (n.name () == "MidPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MidPoint_type > r (
            MidPoint_traits::create (i, f, this));

          if (!this->MidPoint_)
          {
            this->MidPoint_.set (r);
            continue;
          }
        }

        // MovePoint
        //
        if (n.name () == "MovePoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MovePoint_type > r (
            MovePoint_traits::create (i, f, this));

          if (!this->MovePoint_)
          {
            this->MovePoint_.set (r);
            continue;
          }
        }

        // MovePointVector
        //
        if (n.name () == "MovePointVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MovePointVector_type > r (
            MovePointVector_traits::create (i, f, this));

          if (!this->MovePointVector_)
          {
            this->MovePointVector_.set (r);
            continue;
          }
        }

        // MovePointAxis
        //
        if (n.name () == "MovePointAxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MovePointAxis_type > r (
            MovePointAxis_traits::create (i, f, this));

          if (!this->MovePointAxis_)
          {
            this->MovePointAxis_.set (r);
            continue;
          }
        }

        // Extreme
        //
        if (n.name () == "Extreme" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extreme_type > r (
            Extreme_traits::create (i, f, this));

          if (!this->Extreme_)
          {
            this->Extreme_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointConstructionMethodType* PointConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointConstructionMethodType (*this, f, c);
    }

    PointConstructionMethodType::
    ~PointConstructionMethodType ()
    {
    }

    // PointFeatureIntersectionType
    //

    PointFeatureIntersectionType::
    PointFeatureIntersectionType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      IntersectionFeature_ (::xml_schema::flags (), this)
    {
    }

    PointFeatureIntersectionType::
    PointFeatureIntersectionType (const PointFeatureIntersectionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    PointFeatureIntersectionType::
    PointFeatureIntersectionType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IntersectionFeature
        //
        if (n.name () == "IntersectionFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          this->IntersectionFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PointFeatureIntersectionType* PointFeatureIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureIntersectionType (*this, f, c);
    }

    PointFeatureIntersectionType::
    ~PointFeatureIntersectionType ()
    {
    }

    // PointFeaturePierceType
    //

    PointFeaturePierceType::
    PointFeaturePierceType (const SurfaceFeature_type& SurfaceFeature,
                            const CurveFeature_type& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      CurveFeature_ (CurveFeature, ::xml_schema::flags (), this)
    {
    }

    PointFeaturePierceType::
    PointFeaturePierceType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                            ::std::auto_ptr< CurveFeature_type >& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      CurveFeature_ (CurveFeature, ::xml_schema::flags (), this)
    {
    }

    PointFeaturePierceType::
    PointFeaturePierceType (const PointFeaturePierceType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    PointFeaturePierceType::
    PointFeaturePierceType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      CurveFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeaturePierceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // CurveFeature
        //
        if (n.name () == "CurveFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CurveFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeaturePierceType* PointFeaturePierceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeaturePierceType (*this, f, c);
    }

    PointFeaturePierceType::
    ~PointFeaturePierceType ()
    {
    }

    // PointFeatureProjectionType
    //

    PointFeatureProjectionType::
    PointFeatureProjectionType (const ProjectionPlane_type& ProjectionPlane,
                                const ProjectionFeature_type& ProjectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this),
      ProjectionFeature_ (ProjectionFeature, ::xml_schema::flags (), this)
    {
    }

    PointFeatureProjectionType::
    PointFeatureProjectionType (::std::auto_ptr< ProjectionPlane_type >& ProjectionPlane,
                                ::std::auto_ptr< ProjectionFeature_type >& ProjectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, ::xml_schema::flags (), this),
      ProjectionFeature_ (ProjectionFeature, ::xml_schema::flags (), this)
    {
    }

    PointFeatureProjectionType::
    PointFeatureProjectionType (const PointFeatureProjectionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionPlane_ (x.ProjectionPlane_, f, this),
      ProjectionFeature_ (x.ProjectionFeature_, f, this)
    {
    }

    PointFeatureProjectionType::
    PointFeatureProjectionType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionPlane_ (f, this),
      ProjectionFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        // ProjectionFeature
        //
        if (n.name () == "ProjectionFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionFeature_type > r (
            ProjectionFeature_traits::create (i, f, this));

          if (!ProjectionFeature_.present ())
          {
            this->ProjectionFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureProjectionType* PointFeatureProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureProjectionType (*this, f, c);
    }

    PointFeatureProjectionType::
    ~PointFeatureProjectionType ()
    {
    }

    // PointFeatureFromConeType
    //

    PointFeatureFromConeType::
    PointFeatureFromConeType (const BaseCone_type& BaseCone)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, ::xml_schema::flags (), this)
    {
    }

    PointFeatureFromConeType::
    PointFeatureFromConeType (::std::auto_ptr< BaseCone_type >& BaseCone)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, ::xml_schema::flags (), this)
    {
    }

    PointFeatureFromConeType::
    PointFeatureFromConeType (const PointFeatureFromConeType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCone_ (x.BaseCone_, f, this)
    {
    }

    PointFeatureFromConeType::
    PointFeatureFromConeType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCone_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureFromConeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCone
        //
        if (n.name () == "BaseCone" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCone_type > r (
            BaseCone_traits::create (i, f, this));

          if (!BaseCone_.present ())
          {
            this->BaseCone_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCone_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCone",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureFromConeType* PointFeatureFromConeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureFromConeType (*this, f, c);
    }

    PointFeatureFromConeType::
    ~PointFeatureFromConeType ()
    {
    }

    // PointFeatureCopyType
    //

    PointFeatureCopyType::
    PointFeatureCopyType (const BasePointFeature_type& BasePointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointFeature_ (BasePointFeature, ::xml_schema::flags (), this)
    {
    }

    PointFeatureCopyType::
    PointFeatureCopyType (::std::auto_ptr< BasePointFeature_type >& BasePointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointFeature_ (BasePointFeature, ::xml_schema::flags (), this)
    {
    }

    PointFeatureCopyType::
    PointFeatureCopyType (const PointFeatureCopyType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointFeature_ (x.BasePointFeature_, f, this)
    {
    }

    PointFeatureCopyType::
    PointFeatureCopyType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointFeature
        //
        if (n.name () == "BasePointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointFeature_type > r (
            BasePointFeature_traits::create (i, f, this));

          if (!BasePointFeature_.present ())
          {
            this->BasePointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureCopyType* PointFeatureCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureCopyType (*this, f, c);
    }

    PointFeatureCopyType::
    ~PointFeatureCopyType ()
    {
    }

    // PointFeatureTransformType
    //

    PointFeatureTransformType::
    PointFeatureTransformType (const BasePointFeature_type& BasePointFeature,
                               const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointFeature_ (BasePointFeature, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    PointFeatureTransformType::
    PointFeatureTransformType (::std::auto_ptr< BasePointFeature_type >& BasePointFeature,
                               ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointFeature_ (BasePointFeature, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    PointFeatureTransformType::
    PointFeatureTransformType (const PointFeatureTransformType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointFeature_ (x.BasePointFeature_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PointFeatureTransformType::
    PointFeatureTransformType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointFeature_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointFeature
        //
        if (n.name () == "BasePointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointFeature_type > r (
            BasePointFeature_traits::create (i, f, this));

          if (!BasePointFeature_.present ())
          {
            this->BasePointFeature_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureTransformType* PointFeatureTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureTransformType (*this, f, c);
    }

    PointFeatureTransformType::
    ~PointFeatureTransformType ()
    {
    }

    // PointFeatureFromScanType
    //

    PointFeatureFromScanType::
    PointFeatureFromScanType (const SurfaceFeature_type& SurfaceFeature,
                              const SearchRadius_type& SearchRadius,
                              const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      RetrievalMethod_ (RetrievalMethod, ::xml_schema::flags (), this)
    {
    }

    PointFeatureFromScanType::
    PointFeatureFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                              ::std::auto_ptr< SearchRadius_type >& SearchRadius,
                              const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      RetrievalMethod_ (RetrievalMethod, ::xml_schema::flags (), this)
    {
    }

    PointFeatureFromScanType::
    PointFeatureFromScanType (const PointFeatureFromScanType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      RetrievalMethod_ (x.RetrievalMethod_, f, this)
    {
    }

    PointFeatureFromScanType::
    PointFeatureFromScanType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this),
      RetrievalMethod_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // RetrievalMethod
        //
        if (n.name () == "RetrievalMethod" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RetrievalMethod_type > r (
            RetrievalMethod_traits::create (i, f, this));

          if (!RetrievalMethod_.present ())
          {
            this->RetrievalMethod_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RetrievalMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RetrievalMethod",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureFromScanType* PointFeatureFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureFromScanType (*this, f, c);
    }

    PointFeatureFromScanType::
    ~PointFeatureFromScanType ()
    {
    }

    // PointFeatureCenterOfGravityType
    //

    PointFeatureCenterOfGravityType::
    PointFeatureCenterOfGravityType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    PointFeatureCenterOfGravityType::
    PointFeatureCenterOfGravityType (const PointFeatureCenterOfGravityType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointFeatureCenterOfGravityType::
    PointFeatureCenterOfGravityType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureCenterOfGravityType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PointFeatureCenterOfGravityType* PointFeatureCenterOfGravityType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureCenterOfGravityType (*this, f, c);
    }

    PointFeatureCenterOfGravityType::
    ~PointFeatureCenterOfGravityType ()
    {
    }

    // PointFeatureMidPointType
    //

    PointFeatureMidPointType::
    PointFeatureMidPointType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    PointFeatureMidPointType::
    PointFeatureMidPointType (const PointFeatureMidPointType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointFeatureMidPointType::
    PointFeatureMidPointType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMidPointType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PointFeatureMidPointType* PointFeatureMidPointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMidPointType (*this, f, c);
    }

    PointFeatureMidPointType::
    ~PointFeatureMidPointType ()
    {
    }

    // PointFeatureCastType
    //

    PointFeatureCastType::
    PointFeatureCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    PointFeatureCastType::
    PointFeatureCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    PointFeatureCastType::
    PointFeatureCastType (const PointFeatureCastType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointFeatureCastType::
    PointFeatureCastType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureCastType* PointFeatureCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureCastType (*this, f, c);
    }

    PointFeatureCastType::
    ~PointFeatureCastType ()
    {
    }

    // PointFeatureMovePointType
    //

    PointFeatureMovePointType::
    PointFeatureMovePointType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this),
      Offset_ (::xml_schema::flags (), this),
      DirectionalOffset_ (::xml_schema::flags (), this)
    {
    }

    PointFeatureMovePointType::
    PointFeatureMovePointType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this),
      Offset_ (::xml_schema::flags (), this),
      DirectionalOffset_ (::xml_schema::flags (), this)
    {
    }

    PointFeatureMovePointType::
    PointFeatureMovePointType (const PointFeatureMovePointType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      Offset_ (x.Offset_, f, this),
      DirectionalOffset_ (x.DirectionalOffset_, f, this)
    {
    }

    PointFeatureMovePointType::
    PointFeatureMovePointType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this),
      Offset_ (f, this),
      DirectionalOffset_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMovePointType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!this->Offset_)
          {
            this->Offset_.set (r);
            continue;
          }
        }

        // DirectionalOffset
        //
        if (n.name () == "DirectionalOffset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DirectionalOffset_type > r (
            DirectionalOffset_traits::create (i, f, this));

          if (!this->DirectionalOffset_)
          {
            this->DirectionalOffset_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureMovePointType* PointFeatureMovePointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMovePointType (*this, f, c);
    }

    PointFeatureMovePointType::
    ~PointFeatureMovePointType ()
    {
    }

    // PointFeatureMovePointVectorType
    //

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (const BaseFeature_type& BaseFeature,
                                     const Distance_type& Distance,
                                     const Vector_type& Vector)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this),
      Distance_ (Distance, ::xml_schema::flags (), this),
      Vector_ (Vector, ::xml_schema::flags (), this)
    {
    }

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (::std::auto_ptr< BaseFeature_type >& BaseFeature,
                                     ::std::auto_ptr< Distance_type >& Distance,
                                     ::std::auto_ptr< Vector_type >& Vector)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this),
      Distance_ (Distance, ::xml_schema::flags (), this),
      Vector_ (Vector, ::xml_schema::flags (), this)
    {
    }

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (const PointFeatureMovePointVectorType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      Distance_ (x.Distance_, f, this),
      Vector_ (x.Vector_, f, this)
    {
    }

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this),
      Distance_ (f, this),
      Vector_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMovePointVectorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        // Distance
        //
        if (n.name () == "Distance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!Distance_.present ())
          {
            this->Distance_.set (r);
            continue;
          }
        }

        // Vector
        //
        if (n.name () == "Vector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!Vector_.present ())
          {
            this->Vector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Distance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Distance",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Vector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Vector",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureMovePointVectorType* PointFeatureMovePointVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMovePointVectorType (*this, f, c);
    }

    PointFeatureMovePointVectorType::
    ~PointFeatureMovePointVectorType ()
    {
    }

    // PointFeatureMovePointAxisType
    //

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (const BaseLocationFeature_type& BaseLocationFeature,
                                   const Distance_type& Distance,
                                   const BaseAxisFeature_type& BaseAxisFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLocationFeature_ (BaseLocationFeature, ::xml_schema::flags (), this),
      Distance_ (Distance, ::xml_schema::flags (), this),
      BaseAxisFeature_ (BaseAxisFeature, ::xml_schema::flags (), this)
    {
    }

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (::std::auto_ptr< BaseLocationFeature_type >& BaseLocationFeature,
                                   ::std::auto_ptr< Distance_type >& Distance,
                                   ::std::auto_ptr< BaseAxisFeature_type >& BaseAxisFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLocationFeature_ (BaseLocationFeature, ::xml_schema::flags (), this),
      Distance_ (Distance, ::xml_schema::flags (), this),
      BaseAxisFeature_ (BaseAxisFeature, ::xml_schema::flags (), this)
    {
    }

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (const PointFeatureMovePointAxisType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseLocationFeature_ (x.BaseLocationFeature_, f, this),
      Distance_ (x.Distance_, f, this),
      BaseAxisFeature_ (x.BaseAxisFeature_, f, this)
    {
    }

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLocationFeature_ (f, this),
      Distance_ (f, this),
      BaseAxisFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMovePointAxisType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseLocationFeature
        //
        if (n.name () == "BaseLocationFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseLocationFeature_type > r (
            BaseLocationFeature_traits::create (i, f, this));

          if (!BaseLocationFeature_.present ())
          {
            this->BaseLocationFeature_.set (r);
            continue;
          }
        }

        // Distance
        //
        if (n.name () == "Distance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!Distance_.present ())
          {
            this->Distance_.set (r);
            continue;
          }
        }

        // BaseAxisFeature
        //
        if (n.name () == "BaseAxisFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseAxisFeature_type > r (
            BaseAxisFeature_traits::create (i, f, this));

          if (!BaseAxisFeature_.present ())
          {
            this->BaseAxisFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseLocationFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseLocationFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Distance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Distance",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!BaseAxisFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseAxisFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureMovePointAxisType* PointFeatureMovePointAxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMovePointAxisType (*this, f, c);
    }

    PointFeatureMovePointAxisType::
    ~PointFeatureMovePointAxisType ()
    {
    }

    // PointFeatureExtremeType
    //

    const PointFeatureExtremeType::Radial_type PointFeatureExtremeType::Radial_default_value_ (
      "Radial");

    const PointFeatureExtremeType::Xaxis_type PointFeatureExtremeType::Xaxis_default_value_ (
      "Xaxis");

    const PointFeatureExtremeType::Yaxis_type PointFeatureExtremeType::Yaxis_default_value_ (
      "Yaxis");

    const PointFeatureExtremeType::Zaxis_type PointFeatureExtremeType::Zaxis_default_value_ (
      "Zaxis");

    PointFeatureExtremeType::
    PointFeatureExtremeType (const BaseFeature_type& BaseFeature,
                             const Minimum_type& Minimum)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this),
      Minimum_ (Minimum, ::xml_schema::flags (), this),
      BaseAxisFeature_ (::xml_schema::flags (), this),
      Vector_ (::xml_schema::flags (), this),
      Radial_ (::xml_schema::flags (), this),
      Xaxis_ (::xml_schema::flags (), this),
      Yaxis_ (::xml_schema::flags (), this),
      Zaxis_ (::xml_schema::flags (), this)
    {
    }

    PointFeatureExtremeType::
    PointFeatureExtremeType (::std::auto_ptr< BaseFeature_type >& BaseFeature,
                             const Minimum_type& Minimum)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this),
      Minimum_ (Minimum, ::xml_schema::flags (), this),
      BaseAxisFeature_ (::xml_schema::flags (), this),
      Vector_ (::xml_schema::flags (), this),
      Radial_ (::xml_schema::flags (), this),
      Xaxis_ (::xml_schema::flags (), this),
      Yaxis_ (::xml_schema::flags (), this),
      Zaxis_ (::xml_schema::flags (), this)
    {
    }

    PointFeatureExtremeType::
    PointFeatureExtremeType (const PointFeatureExtremeType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      Minimum_ (x.Minimum_, f, this),
      BaseAxisFeature_ (x.BaseAxisFeature_, f, this),
      Vector_ (x.Vector_, f, this),
      Radial_ (x.Radial_, f, this),
      Xaxis_ (x.Xaxis_, f, this),
      Yaxis_ (x.Yaxis_, f, this),
      Zaxis_ (x.Zaxis_, f, this)
    {
    }

    PointFeatureExtremeType::
    PointFeatureExtremeType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this),
      Minimum_ (f, this),
      BaseAxisFeature_ (f, this),
      Vector_ (f, this),
      Radial_ (f, this),
      Xaxis_ (f, this),
      Yaxis_ (f, this),
      Zaxis_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointFeatureExtremeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        // Minimum
        //
        if (n.name () == "Minimum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!Minimum_.present ())
          {
            this->Minimum_.set (Minimum_traits::create (i, f, this));
            continue;
          }
        }

        // BaseAxisFeature
        //
        if (n.name () == "BaseAxisFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseAxisFeature_type > r (
            BaseAxisFeature_traits::create (i, f, this));

          if (!this->BaseAxisFeature_)
          {
            this->BaseAxisFeature_.set (r);
            continue;
          }
        }

        // Vector
        //
        if (n.name () == "Vector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!this->Vector_)
          {
            this->Vector_.set (r);
            continue;
          }
        }

        // Radial
        //
        if (n.name () == "Radial" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Radial_type > r (
            Radial_traits::create (i, f, this));

          if (!this->Radial_)
          {
            this->Radial_.set (r);
            continue;
          }
        }

        // Xaxis
        //
        if (n.name () == "Xaxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Xaxis_type > r (
            Xaxis_traits::create (i, f, this));

          if (!this->Xaxis_)
          {
            this->Xaxis_.set (r);
            continue;
          }
        }

        // Yaxis
        //
        if (n.name () == "Yaxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Yaxis_type > r (
            Yaxis_traits::create (i, f, this));

          if (!this->Yaxis_)
          {
            this->Yaxis_.set (r);
            continue;
          }
        }

        // Zaxis
        //
        if (n.name () == "Zaxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Zaxis_type > r (
            Zaxis_traits::create (i, f, this));

          if (!this->Zaxis_)
          {
            this->Zaxis_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Minimum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Minimum",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureExtremeType* PointFeatureExtremeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureExtremeType (*this, f, c);
    }

    PointFeatureExtremeType::
    ~PointFeatureExtremeType ()
    {
    }

    // PointCheckedType
    //

    PointCheckedType::
    PointCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    PointCheckedType::
    PointCheckedType (const PointCheckedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointCheckedType::
    PointCheckedType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointCheckedType* PointCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCheckedType (*this, f, c);
    }

    PointCheckedType::
    ~PointCheckedType ()
    {
    }

    // PointCheckedFeatureType
    //

    PointCheckedFeatureType::
    PointCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    PointCheckedFeatureType::
    PointCheckedFeatureType (const PointCheckedFeatureType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PointCheckedFeatureType::
    PointCheckedFeatureType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointCheckedFeatureType* PointCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCheckedFeatureType (*this, f, c);
    }

    PointCheckedFeatureType::
    ~PointCheckedFeatureType ()
    {
    }

    // PointActualDeterminationType
    //

    PointActualDeterminationType::
    PointActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    PointActualDeterminationType::
    PointActualDeterminationType (const PointActualDeterminationType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PointActualDeterminationType::
    PointActualDeterminationType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PointActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointActualDeterminationType* PointActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointActualDeterminationType (*this, f, c);
    }

    PointActualDeterminationType::
    ~PointActualDeterminationType ()
    {
    }

    // PointFeatureItemType
    //

    PointFeatureItemType::
    PointFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this)
    {
    }

    PointFeatureItemType::
    PointFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this)
    {
    }

    PointFeatureItemType::
    PointFeatureItemType (const PointFeatureItemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    PointFeatureItemType::
    PointFeatureItemType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureItemType* PointFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureItemType (*this, f, c);
    }

    PointFeatureItemType::
    ~PointFeatureItemType ()
    {
    }

    // PointFeatureDefinitionType
    //

    PointFeatureDefinitionType::
    PointFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    PointFeatureDefinitionType::
    PointFeatureDefinitionType (const PointFeatureDefinitionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    PointFeatureDefinitionType::
    PointFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    PointFeatureDefinitionType* PointFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureDefinitionType (*this, f, c);
    }

    PointFeatureDefinitionType::
    ~PointFeatureDefinitionType ()
    {
    }

    // PointFeatureNominalType
    //

    PointFeatureNominalType::
    PointFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             const Location_type& Location)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this)
    {
    }

    PointFeatureNominalType::
    PointFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             ::std::auto_ptr< Location_type >& Location)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this)
    {
    }

    PointFeatureNominalType::
    PointFeatureNominalType (const PointFeatureNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    PointFeatureNominalType::
    PointFeatureNominalType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Normal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureNominalType* PointFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureNominalType (*this, f, c);
    }

    PointFeatureNominalType::
    ~PointFeatureNominalType ()
    {
    }

    // PointFeatureActualType
    //

    PointFeatureActualType::
    PointFeatureActualType (const id_type& id,
                            const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this)
    {
    }

    PointFeatureActualType::
    PointFeatureActualType (const id_type& id,
                            ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Normal_ (::xml_schema::flags (), this)
    {
    }

    PointFeatureActualType::
    PointFeatureActualType (const PointFeatureActualType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    PointFeatureActualType::
    PointFeatureActualType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Normal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void PointFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointFeatureActualType* PointFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureActualType (*this, f, c);
    }

    PointFeatureActualType::
    ~PointFeatureActualType ()
    {
    }

    // SphereConstructionMethodType
    //

    SphereConstructionMethodType::
    SphereConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this)
    {
    }

    SphereConstructionMethodType::
    SphereConstructionMethodType (const SphereConstructionMethodType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    SphereConstructionMethodType::
    SphereConstructionMethodType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this),
      FromScan_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphereConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphereConstructionMethodType* SphereConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereConstructionMethodType (*this, f, c);
    }

    SphereConstructionMethodType::
    ~SphereConstructionMethodType ()
    {
    }

    // SphereBestFitType
    //

    SphereBestFitType::
    SphereBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    SphereBestFitType::
    SphereBestFitType (const SphereBestFitType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SphereBestFitType::
    SphereBestFitType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphereBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    SphereBestFitType* SphereBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereBestFitType (*this, f, c);
    }

    SphereBestFitType::
    ~SphereBestFitType ()
    {
    }

    // SphereRecompType
    //

    SphereRecompType::
    SphereRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    SphereRecompType::
    SphereRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    SphereRecompType::
    SphereRecompType (const SphereRecompType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    SphereRecompType::
    SphereRecompType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphereRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereRecompType* SphereRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereRecompType (*this, f, c);
    }

    SphereRecompType::
    ~SphereRecompType ()
    {
    }

    // SphereCopyType
    //

    SphereCopyType::
    SphereCopyType (const BaseSphere_type& BaseSphere)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphere_ (BaseSphere, ::xml_schema::flags (), this)
    {
    }

    SphereCopyType::
    SphereCopyType (::std::auto_ptr< BaseSphere_type >& BaseSphere)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphere_ (BaseSphere, ::xml_schema::flags (), this)
    {
    }

    SphereCopyType::
    SphereCopyType (const SphereCopyType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSphere_ (x.BaseSphere_, f, this)
    {
    }

    SphereCopyType::
    SphereCopyType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphere_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphereCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSphere
        //
        if (n.name () == "BaseSphere" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSphere_type > r (
            BaseSphere_traits::create (i, f, this));

          if (!BaseSphere_.present ())
          {
            this->BaseSphere_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSphere_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSphere",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereCopyType* SphereCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCopyType (*this, f, c);
    }

    SphereCopyType::
    ~SphereCopyType ()
    {
    }

    // SphereCastType
    //

    SphereCastType::
    SphereCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    SphereCastType::
    SphereCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    SphereCastType::
    SphereCastType (const SphereCastType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SphereCastType::
    SphereCastType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphereCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereCastType* SphereCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCastType (*this, f, c);
    }

    SphereCastType::
    ~SphereCastType ()
    {
    }

    // SphereTransformType
    //

    SphereTransformType::
    SphereTransformType (const BaseSphere_type& BaseSphere,
                         const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphere_ (BaseSphere, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    SphereTransformType::
    SphereTransformType (::std::auto_ptr< BaseSphere_type >& BaseSphere,
                         ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphere_ (BaseSphere, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    SphereTransformType::
    SphereTransformType (const SphereTransformType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSphere_ (x.BaseSphere_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    SphereTransformType::
    SphereTransformType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphere_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphereTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSphere
        //
        if (n.name () == "BaseSphere" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSphere_type > r (
            BaseSphere_traits::create (i, f, this));

          if (!BaseSphere_.present ())
          {
            this->BaseSphere_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSphere_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSphere",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereTransformType* SphereTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereTransformType (*this, f, c);
    }

    SphereTransformType::
    ~SphereTransformType ()
    {
    }

    // SphereFromScanType
    //

    SphereFromScanType::
    SphereFromScanType (const SurfaceFeature_type& SurfaceFeature,
                        const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      Vector_ (::xml_schema::flags (), this)
    {
    }

    SphereFromScanType::
    SphereFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                        ::std::auto_ptr< SearchRadius_type >& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this),
      Vector_ (::xml_schema::flags (), this)
    {
    }

    SphereFromScanType::
    SphereFromScanType (const SphereFromScanType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Vector_ (x.Vector_, f, this)
    {
    }

    SphereFromScanType::
    SphereFromScanType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this),
      Vector_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphereFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // Vector
        //
        if (n.name () == "Vector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!this->Vector_)
          {
            this->Vector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereFromScanType* SphereFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFromScanType (*this, f, c);
    }

    SphereFromScanType::
    ~SphereFromScanType ()
    {
    }

    // SphereCheckedType
    //

    SphereCheckedType::
    SphereCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    SphereCheckedType::
    SphereCheckedType (const SphereCheckedType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SphereCheckedType::
    SphereCheckedType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphereCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphereCheckedType* SphereCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCheckedType (*this, f, c);
    }

    SphereCheckedType::
    ~SphereCheckedType ()
    {
    }

    // SphereCheckedFeatureType
    //

    SphereCheckedFeatureType::
    SphereCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    SphereCheckedFeatureType::
    SphereCheckedFeatureType (const SphereCheckedFeatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    SphereCheckedFeatureType::
    SphereCheckedFeatureType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphereCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphereCheckedFeatureType* SphereCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCheckedFeatureType (*this, f, c);
    }

    SphereCheckedFeatureType::
    ~SphereCheckedFeatureType ()
    {
    }

    // SphereActualDeterminationType
    //

    SphereActualDeterminationType::
    SphereActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    SphereActualDeterminationType::
    SphereActualDeterminationType (const SphereActualDeterminationType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    SphereActualDeterminationType::
    SphereActualDeterminationType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphereActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphereActualDeterminationType* SphereActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereActualDeterminationType (*this, f, c);
    }

    SphereActualDeterminationType::
    ~SphereActualDeterminationType ()
    {
    }

    // SphereFeatureItemType
    //

    SphereFeatureItemType::
    SphereFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    SphereFeatureItemType::
    SphereFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    SphereFeatureItemType::
    SphereFeatureItemType (const SphereFeatureItemType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    SphereFeatureItemType::
    SphereFeatureItemType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereFeatureItemType* SphereFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureItemType (*this, f, c);
    }

    SphereFeatureItemType::
    ~SphereFeatureItemType ()
    {
    }

    // SphereFeatureDefinitionType
    //

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this)
    {
    }

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 ::std::auto_ptr< Diameter_type >& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this)
    {
    }

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const SphereFeatureDefinitionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this)
    {
    }

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Diameter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereFeatureDefinitionType* SphereFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureDefinitionType (*this, f, c);
    }

    SphereFeatureDefinitionType::
    ~SphereFeatureDefinitionType ()
    {
    }

    // SphereFeatureNominalType
    //

    SphereFeatureNominalType::
    SphereFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              const Location_type& Location)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this)
    {
    }

    SphereFeatureNominalType::
    SphereFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              ::std::auto_ptr< Location_type >& Location)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this)
    {
    }

    SphereFeatureNominalType::
    SphereFeatureNominalType (const SphereFeatureNominalType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this)
    {
    }

    SphereFeatureNominalType::
    SphereFeatureNominalType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      LatitudeLongitudeSweep_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereFeatureNominalType* SphereFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureNominalType (*this, f, c);
    }

    SphereFeatureNominalType::
    ~SphereFeatureNominalType ()
    {
    }

    // SphereFeatureActualType
    //

    SphereFeatureActualType::
    SphereFeatureActualType (const id_type& id,
                             const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    SphereFeatureActualType::
    SphereFeatureActualType (const id_type& id,
                             ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    SphereFeatureActualType::
    SphereFeatureActualType (const SphereFeatureActualType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    SphereFeatureActualType::
    SphereFeatureActualType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Diameter_ (f, this),
      DiameterMin_ (f, this),
      DiameterMax_ (f, this),
      LatitudeLongitudeSweep_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphereFeatureActualType* SphereFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureActualType (*this, f, c);
    }

    SphereFeatureActualType::
    ~SphereFeatureActualType ()
    {
    }

    // SphericalSegmentConstructionMethodType
    //

    SphericalSegmentConstructionMethodType::
    SphericalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this)
    {
    }

    SphericalSegmentConstructionMethodType::
    SphericalSegmentConstructionMethodType (const SphericalSegmentConstructionMethodType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    SphericalSegmentConstructionMethodType::
    SphericalSegmentConstructionMethodType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentConstructionMethodType* SphericalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentConstructionMethodType (*this, f, c);
    }

    SphericalSegmentConstructionMethodType::
    ~SphericalSegmentConstructionMethodType ()
    {
    }

    // SphericalSegmentBestFitType
    //

    SphericalSegmentBestFitType::
    SphericalSegmentBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    SphericalSegmentBestFitType::
    SphericalSegmentBestFitType (const SphericalSegmentBestFitType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SphericalSegmentBestFitType::
    SphericalSegmentBestFitType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    SphericalSegmentBestFitType* SphericalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentBestFitType (*this, f, c);
    }

    SphericalSegmentBestFitType::
    ~SphericalSegmentBestFitType ()
    {
    }

    // SphericalSegmentRecompType
    //

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (const SphericalSegmentRecompType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentRecompType* SphericalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentRecompType (*this, f, c);
    }

    SphericalSegmentRecompType::
    ~SphericalSegmentRecompType ()
    {
    }

    // SphericalSegmentCopyType
    //

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (const BaseSphericalSegment_type& BaseSphericalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (BaseSphericalSegment, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (::std::auto_ptr< BaseSphericalSegment_type >& BaseSphericalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (BaseSphericalSegment, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (const SphericalSegmentCopyType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSphericalSegment_ (x.BaseSphericalSegment_, f, this)
    {
    }

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphericalSegment_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSphericalSegment
        //
        if (n.name () == "BaseSphericalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSphericalSegment_type > r (
            BaseSphericalSegment_traits::create (i, f, this));

          if (!BaseSphericalSegment_.present ())
          {
            this->BaseSphericalSegment_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSphericalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSphericalSegment",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentCopyType* SphericalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCopyType (*this, f, c);
    }

    SphericalSegmentCopyType::
    ~SphericalSegmentCopyType ()
    {
    }

    // SphericalSegmentCastType
    //

    SphericalSegmentCastType::
    SphericalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentCastType::
    SphericalSegmentCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentCastType::
    SphericalSegmentCastType (const SphericalSegmentCastType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SphericalSegmentCastType::
    SphericalSegmentCastType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentCastType* SphericalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCastType (*this, f, c);
    }

    SphericalSegmentCastType::
    ~SphericalSegmentCastType ()
    {
    }

    // SphericalSegmentTransformType
    //

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (const BaseSphericalSegment_type& BaseSphericalSegment,
                                   const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (BaseSphericalSegment, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (::std::auto_ptr< BaseSphericalSegment_type >& BaseSphericalSegment,
                                   ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (BaseSphericalSegment, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (const SphericalSegmentTransformType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSphericalSegment_ (x.BaseSphericalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphericalSegment_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSphericalSegment
        //
        if (n.name () == "BaseSphericalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSphericalSegment_type > r (
            BaseSphericalSegment_traits::create (i, f, this));

          if (!BaseSphericalSegment_.present ())
          {
            this->BaseSphericalSegment_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSphericalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSphericalSegment",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentTransformType* SphericalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentTransformType (*this, f, c);
    }

    SphericalSegmentTransformType::
    ~SphericalSegmentTransformType ()
    {
    }

    // SphericalSegmentCheckedType
    //

    SphericalSegmentCheckedType::
    SphericalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    SphericalSegmentCheckedType::
    SphericalSegmentCheckedType (const SphericalSegmentCheckedType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SphericalSegmentCheckedType::
    SphericalSegmentCheckedType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentCheckedType* SphericalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCheckedType (*this, f, c);
    }

    SphericalSegmentCheckedType::
    ~SphericalSegmentCheckedType ()
    {
    }

    // SphericalSegmentCheckedFeatureType
    //

    SphericalSegmentCheckedFeatureType::
    SphericalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    SphericalSegmentCheckedFeatureType::
    SphericalSegmentCheckedFeatureType (const SphericalSegmentCheckedFeatureType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    SphericalSegmentCheckedFeatureType::
    SphericalSegmentCheckedFeatureType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentCheckedFeatureType* SphericalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCheckedFeatureType (*this, f, c);
    }

    SphericalSegmentCheckedFeatureType::
    ~SphericalSegmentCheckedFeatureType ()
    {
    }

    // SphericalSegmentActualDeterminationType
    //

    SphericalSegmentActualDeterminationType::
    SphericalSegmentActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    SphericalSegmentActualDeterminationType::
    SphericalSegmentActualDeterminationType (const SphericalSegmentActualDeterminationType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    SphericalSegmentActualDeterminationType::
    SphericalSegmentActualDeterminationType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentActualDeterminationType* SphericalSegmentActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentActualDeterminationType (*this, f, c);
    }

    SphericalSegmentActualDeterminationType::
    ~SphericalSegmentActualDeterminationType ()
    {
    }

    // SphericalSegmentFeatureItemType
    //

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const id_type& id,
                                     const FeatureName_type& FeatureName,
                                     const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const id_type& id,
                                     const FeatureName_type& FeatureName,
                                     ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const SphericalSegmentFeatureItemType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentFeatureItemType* SphericalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureItemType (*this, f, c);
    }

    SphericalSegmentFeatureItemType::
    ~SphericalSegmentFeatureItemType ()
    {
    }

    // SphericalSegmentFeatureDefinitionType
    //

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const id_type& id,
                                           const InternalExternal_type& InternalExternal,
                                           const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const id_type& id,
                                           const InternalExternal_type& InternalExternal,
                                           ::std::auto_ptr< Diameter_type >& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Diameter_ (Diameter, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const SphericalSegmentFeatureDefinitionType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this)
    {
    }

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Diameter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentFeatureDefinitionType* SphericalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureDefinitionType (*this, f, c);
    }

    SphericalSegmentFeatureDefinitionType::
    ~SphericalSegmentFeatureDefinitionType ()
    {
    }

    // SphericalSegmentFeatureNominalType
    //

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const id_type& id,
                                        const FeatureDefinitionId_type& FeatureDefinitionId,
                                        const Location_type& Location,
                                        const LatitudeLongitudeSweep_type& LatitudeLongitudeSweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const id_type& id,
                                        const FeatureDefinitionId_type& FeatureDefinitionId,
                                        ::std::auto_ptr< Location_type >& Location,
                                        ::std::auto_ptr< LatitudeLongitudeSweep_type >& LatitudeLongitudeSweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, ::xml_schema::flags (), this)
    {
    }

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const SphericalSegmentFeatureNominalType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this)
    {
    }

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      LatitudeLongitudeSweep_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!LatitudeLongitudeSweep_.present ())
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!LatitudeLongitudeSweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LatitudeLongitudeSweep",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentFeatureNominalType* SphericalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureNominalType (*this, f, c);
    }

    SphericalSegmentFeatureNominalType::
    ~SphericalSegmentFeatureNominalType ()
    {
    }

    // SphericalSegmentFeatureActualType
    //

    SphericalSegmentFeatureActualType::
    SphericalSegmentFeatureActualType (const id_type& id,
                                       const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    SphericalSegmentFeatureActualType::
    SphericalSegmentFeatureActualType (const id_type& id,
                                       ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Diameter_ (::xml_schema::flags (), this),
      DiameterMin_ (::xml_schema::flags (), this),
      DiameterMax_ (::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    SphericalSegmentFeatureActualType::
    SphericalSegmentFeatureActualType (const SphericalSegmentFeatureActualType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    SphericalSegmentFeatureActualType::
    SphericalSegmentFeatureActualType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Diameter_ (f, this),
      DiameterMin_ (f, this),
      DiameterMax_ (f, this),
      LatitudeLongitudeSweep_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentFeatureActualType* SphericalSegmentFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureActualType (*this, f, c);
    }

    SphericalSegmentFeatureActualType::
    ~SphericalSegmentFeatureActualType ()
    {
    }

    // SurfaceOfRevolutionConstructionMethodType
    //

    SurfaceOfRevolutionConstructionMethodType::
    SurfaceOfRevolutionConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionConstructionMethodType::
    SurfaceOfRevolutionConstructionMethodType (const SurfaceOfRevolutionConstructionMethodType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    SurfaceOfRevolutionConstructionMethodType::
    SurfaceOfRevolutionConstructionMethodType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionConstructionMethodType* SurfaceOfRevolutionConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionConstructionMethodType (*this, f, c);
    }

    SurfaceOfRevolutionConstructionMethodType::
    ~SurfaceOfRevolutionConstructionMethodType ()
    {
    }

    // SurfaceOfRevolutionBestFitType
    //

    SurfaceOfRevolutionBestFitType::
    SurfaceOfRevolutionBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionBestFitType::
    SurfaceOfRevolutionBestFitType (const SurfaceOfRevolutionBestFitType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SurfaceOfRevolutionBestFitType::
    SurfaceOfRevolutionBestFitType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    SurfaceOfRevolutionBestFitType* SurfaceOfRevolutionBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionBestFitType (*this, f, c);
    }

    SurfaceOfRevolutionBestFitType::
    ~SurfaceOfRevolutionBestFitType ()
    {
    }

    // SurfaceOfRevolutionRecompType
    //

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (const SurfaceOfRevolutionRecompType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionRecompType* SurfaceOfRevolutionRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionRecompType (*this, f, c);
    }

    SurfaceOfRevolutionRecompType::
    ~SurfaceOfRevolutionRecompType ()
    {
    }

    // SurfaceOfRevolutionCopyType
    //

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (const BaseSurfaceOfRevolution_type& BaseSurfaceOfRevolution)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (BaseSurfaceOfRevolution, ::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (::std::auto_ptr< BaseSurfaceOfRevolution_type >& BaseSurfaceOfRevolution)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (BaseSurfaceOfRevolution, ::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (const SurfaceOfRevolutionCopyType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSurfaceOfRevolution_ (x.BaseSurfaceOfRevolution_, f, this)
    {
    }

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSurfaceOfRevolution_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSurfaceOfRevolution
        //
        if (n.name () == "BaseSurfaceOfRevolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSurfaceOfRevolution_type > r (
            BaseSurfaceOfRevolution_traits::create (i, f, this));

          if (!BaseSurfaceOfRevolution_.present ())
          {
            this->BaseSurfaceOfRevolution_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSurfaceOfRevolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSurfaceOfRevolution",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionCopyType* SurfaceOfRevolutionCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCopyType (*this, f, c);
    }

    SurfaceOfRevolutionCopyType::
    ~SurfaceOfRevolutionCopyType ()
    {
    }

    // SurfaceOfRevolutionCastType
    //

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (const SurfaceOfRevolutionCastType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionCastType* SurfaceOfRevolutionCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCastType (*this, f, c);
    }

    SurfaceOfRevolutionCastType::
    ~SurfaceOfRevolutionCastType ()
    {
    }

    // SurfaceOfRevolutionTransformType
    //

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (const BaseSurfaceOfRevolution_type& BaseSurfaceOfRevolution,
                                      const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (BaseSurfaceOfRevolution, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (::std::auto_ptr< BaseSurfaceOfRevolution_type >& BaseSurfaceOfRevolution,
                                      ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (BaseSurfaceOfRevolution, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (const SurfaceOfRevolutionTransformType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSurfaceOfRevolution_ (x.BaseSurfaceOfRevolution_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSurfaceOfRevolution_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSurfaceOfRevolution
        //
        if (n.name () == "BaseSurfaceOfRevolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSurfaceOfRevolution_type > r (
            BaseSurfaceOfRevolution_traits::create (i, f, this));

          if (!BaseSurfaceOfRevolution_.present ())
          {
            this->BaseSurfaceOfRevolution_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSurfaceOfRevolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSurfaceOfRevolution",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionTransformType* SurfaceOfRevolutionTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionTransformType (*this, f, c);
    }

    SurfaceOfRevolutionTransformType::
    ~SurfaceOfRevolutionTransformType ()
    {
    }

    // SurfaceOfRevolutionCheckedType
    //

    SurfaceOfRevolutionCheckedType::
    SurfaceOfRevolutionCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionCheckedType::
    SurfaceOfRevolutionCheckedType (const SurfaceOfRevolutionCheckedType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SurfaceOfRevolutionCheckedType::
    SurfaceOfRevolutionCheckedType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionCheckedType* SurfaceOfRevolutionCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCheckedType (*this, f, c);
    }

    SurfaceOfRevolutionCheckedType::
    ~SurfaceOfRevolutionCheckedType ()
    {
    }

    // SurfaceOfRevolutionCheckedFeatureType
    //

    SurfaceOfRevolutionCheckedFeatureType::
    SurfaceOfRevolutionCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionCheckedFeatureType::
    SurfaceOfRevolutionCheckedFeatureType (const SurfaceOfRevolutionCheckedFeatureType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    SurfaceOfRevolutionCheckedFeatureType::
    SurfaceOfRevolutionCheckedFeatureType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionCheckedFeatureType* SurfaceOfRevolutionCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCheckedFeatureType (*this, f, c);
    }

    SurfaceOfRevolutionCheckedFeatureType::
    ~SurfaceOfRevolutionCheckedFeatureType ()
    {
    }

    // SurfaceOfRevolutionActualDeterminationType
    //

    SurfaceOfRevolutionActualDeterminationType::
    SurfaceOfRevolutionActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionActualDeterminationType::
    SurfaceOfRevolutionActualDeterminationType (const SurfaceOfRevolutionActualDeterminationType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    SurfaceOfRevolutionActualDeterminationType::
    SurfaceOfRevolutionActualDeterminationType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionActualDeterminationType* SurfaceOfRevolutionActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionActualDeterminationType (*this, f, c);
    }

    SurfaceOfRevolutionActualDeterminationType::
    ~SurfaceOfRevolutionActualDeterminationType ()
    {
    }

    // SurfaceOfRevolutionFeatureItemType
    //

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const id_type& id,
                                        const FeatureName_type& FeatureName,
                                        const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const id_type& id,
                                        const FeatureName_type& FeatureName,
                                        ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const SurfaceOfRevolutionFeatureItemType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionFeatureItemType* SurfaceOfRevolutionFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureItemType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureItemType::
    ~SurfaceOfRevolutionFeatureItemType ()
    {
    }

    // SurfaceOfRevolutionFeatureDefinitionType
    //

    SurfaceOfRevolutionFeatureDefinitionType::
    SurfaceOfRevolutionFeatureDefinitionType (const id_type& id,
                                              const InternalExternal_type& InternalExternal)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionFeatureDefinitionType::
    SurfaceOfRevolutionFeatureDefinitionType (const SurfaceOfRevolutionFeatureDefinitionType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureDefinitionType::
    SurfaceOfRevolutionFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      Length_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionFeatureDefinitionType* SurfaceOfRevolutionFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureDefinitionType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureDefinitionType::
    ~SurfaceOfRevolutionFeatureDefinitionType ()
    {
    }

    // SurfaceOfRevolutionFeatureNominalType
    //

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const id_type& id,
                                           const FeatureDefinitionId_type& FeatureDefinitionId,
                                           const Axis_type& Axis,
                                           const ReferenceFeatureNominalId_type& ReferenceFeatureNominalId)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      ReferenceFeatureNominalId_ (ReferenceFeatureNominalId, ::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const id_type& id,
                                           const FeatureDefinitionId_type& FeatureDefinitionId,
                                           ::std::auto_ptr< Axis_type >& Axis,
                                           ::std::auto_ptr< ReferenceFeatureNominalId_type >& ReferenceFeatureNominalId)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      ReferenceFeatureNominalId_ (ReferenceFeatureNominalId, ::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const SurfaceOfRevolutionFeatureNominalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this),
      ReferenceFeatureNominalId_ (x.ReferenceFeatureNominalId_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Sweep_ (f, this),
      ReferenceFeatureNominalId_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // ReferenceFeatureNominalId
        //
        if (n.name () == "ReferenceFeatureNominalId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReferenceFeatureNominalId_type > r (
            ReferenceFeatureNominalId_traits::create (i, f, this));

          if (!ReferenceFeatureNominalId_.present ())
          {
            this->ReferenceFeatureNominalId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ReferenceFeatureNominalId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ReferenceFeatureNominalId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionFeatureNominalType* SurfaceOfRevolutionFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureNominalType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureNominalType::
    ~SurfaceOfRevolutionFeatureNominalType ()
    {
    }

    // SurfaceOfRevolutionFeatureActualType
    //

    SurfaceOfRevolutionFeatureActualType::
    SurfaceOfRevolutionFeatureActualType (const id_type& id,
                                          const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionFeatureActualType::
    SurfaceOfRevolutionFeatureActualType (const id_type& id,
                                          ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      Sweep_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    SurfaceOfRevolutionFeatureActualType::
    SurfaceOfRevolutionFeatureActualType (const SurfaceOfRevolutionFeatureActualType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Length_ (x.Length_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureActualType::
    SurfaceOfRevolutionFeatureActualType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      Sweep_ (f, this),
      Length_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionFeatureActualType* SurfaceOfRevolutionFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureActualType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureActualType::
    ~SurfaceOfRevolutionFeatureActualType ()
    {
    }

    // ThreadedFeatureConstructionMethodType
    //

    ThreadedFeatureConstructionMethodType::
    ThreadedFeatureConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromCylinder_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureConstructionMethodType::
    ThreadedFeatureConstructionMethodType (const ThreadedFeatureConstructionMethodType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromCylinder_ (x.FromCylinder_, f, this)
    {
    }

    ThreadedFeatureConstructionMethodType::
    ThreadedFeatureConstructionMethodType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this),
      FromCylinder_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromCylinder
        //
        if (n.name () == "FromCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromCylinder_type > r (
            FromCylinder_traits::create (i, f, this));

          if (!this->FromCylinder_)
          {
            this->FromCylinder_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureConstructionMethodType* ThreadedFeatureConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureConstructionMethodType (*this, f, c);
    }

    ThreadedFeatureConstructionMethodType::
    ~ThreadedFeatureConstructionMethodType ()
    {
    }

    // ThreadedFeatureBestFitType
    //

    ThreadedFeatureBestFitType::
    ThreadedFeatureBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureBestFitType::
    ThreadedFeatureBestFitType (const ThreadedFeatureBestFitType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ThreadedFeatureBestFitType::
    ThreadedFeatureBestFitType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ThreadedFeatureBestFitType* ThreadedFeatureBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureBestFitType (*this, f, c);
    }

    ThreadedFeatureBestFitType::
    ~ThreadedFeatureBestFitType ()
    {
    }

    // ThreadedFeatureRecompType
    //

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (const ThreadedFeatureRecompType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureRecompType* ThreadedFeatureRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureRecompType (*this, f, c);
    }

    ThreadedFeatureRecompType::
    ~ThreadedFeatureRecompType ()
    {
    }

    // ThreadedFeatureCopyType
    //

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (const BaseThreadedFeature_type& BaseThreadedFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (BaseThreadedFeature, ::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (::std::auto_ptr< BaseThreadedFeature_type >& BaseThreadedFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (BaseThreadedFeature, ::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (const ThreadedFeatureCopyType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseThreadedFeature_ (x.BaseThreadedFeature_, f, this)
    {
    }

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseThreadedFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseThreadedFeature
        //
        if (n.name () == "BaseThreadedFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseThreadedFeature_type > r (
            BaseThreadedFeature_traits::create (i, f, this));

          if (!BaseThreadedFeature_.present ())
          {
            this->BaseThreadedFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseThreadedFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseThreadedFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureCopyType* ThreadedFeatureCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCopyType (*this, f, c);
    }

    ThreadedFeatureCopyType::
    ~ThreadedFeatureCopyType ()
    {
    }

    // ThreadedFeatureCastType
    //

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (const ThreadedFeatureCastType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureCastType* ThreadedFeatureCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCastType (*this, f, c);
    }

    ThreadedFeatureCastType::
    ~ThreadedFeatureCastType ()
    {
    }

    // ThreadedFeatureTransformType
    //

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (const BaseThreadedFeature_type& BaseThreadedFeature,
                                  const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (BaseThreadedFeature, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (::std::auto_ptr< BaseThreadedFeature_type >& BaseThreadedFeature,
                                  ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (BaseThreadedFeature, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (const ThreadedFeatureTransformType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseThreadedFeature_ (x.BaseThreadedFeature_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseThreadedFeature_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseThreadedFeature
        //
        if (n.name () == "BaseThreadedFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseThreadedFeature_type > r (
            BaseThreadedFeature_traits::create (i, f, this));

          if (!BaseThreadedFeature_.present ())
          {
            this->BaseThreadedFeature_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseThreadedFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseThreadedFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureTransformType* ThreadedFeatureTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureTransformType (*this, f, c);
    }

    ThreadedFeatureTransformType::
    ~ThreadedFeatureTransformType ()
    {
    }

    // ThreadedFeatureFromCylinderType
    //

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (const BaseCylinder_type& BaseCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, ::xml_schema::flags (), this),
      Offset_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (::std::auto_ptr< BaseCylinder_type >& BaseCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, ::xml_schema::flags (), this),
      Offset_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (const ThreadedFeatureFromCylinderType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCylinder_ (x.BaseCylinder_, f, this),
      Offset_ (x.Offset_, f, this)
    {
    }

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylinder_ (f, this),
      Offset_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureFromCylinderType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCylinder
        //
        if (n.name () == "BaseCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCylinder_type > r (
            BaseCylinder_traits::create (i, f, this));

          if (!BaseCylinder_.present ())
          {
            this->BaseCylinder_.set (r);
            continue;
          }
        }

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!this->Offset_)
          {
            this->Offset_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCylinder",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureFromCylinderType* ThreadedFeatureFromCylinderType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureFromCylinderType (*this, f, c);
    }

    ThreadedFeatureFromCylinderType::
    ~ThreadedFeatureFromCylinderType ()
    {
    }

    // ThreadedFeatureCheckedType
    //

    ThreadedFeatureCheckedType::
    ThreadedFeatureCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureCheckedType::
    ThreadedFeatureCheckedType (const ThreadedFeatureCheckedType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ThreadedFeatureCheckedType::
    ThreadedFeatureCheckedType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureCheckedType* ThreadedFeatureCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCheckedType (*this, f, c);
    }

    ThreadedFeatureCheckedType::
    ~ThreadedFeatureCheckedType ()
    {
    }

    // ThreadedFeatureCheckedFeatureType
    //

    ThreadedFeatureCheckedFeatureType::
    ThreadedFeatureCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureCheckedFeatureType::
    ThreadedFeatureCheckedFeatureType (const ThreadedFeatureCheckedFeatureType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ThreadedFeatureCheckedFeatureType::
    ThreadedFeatureCheckedFeatureType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureCheckedFeatureType* ThreadedFeatureCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCheckedFeatureType (*this, f, c);
    }

    ThreadedFeatureCheckedFeatureType::
    ~ThreadedFeatureCheckedFeatureType ()
    {
    }

    // ThreadedFeatureActualDeterminationType
    //

    ThreadedFeatureActualDeterminationType::
    ThreadedFeatureActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureActualDeterminationType::
    ThreadedFeatureActualDeterminationType (const ThreadedFeatureActualDeterminationType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ThreadedFeatureActualDeterminationType::
    ThreadedFeatureActualDeterminationType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureActualDeterminationType* ThreadedFeatureActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureActualDeterminationType (*this, f, c);
    }

    ThreadedFeatureActualDeterminationType::
    ~ThreadedFeatureActualDeterminationType ()
    {
    }

    // ThreadedFeatureItemType
    //

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const id_type& id,
                             const FeatureName_type& FeatureName,
                             const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const id_type& id,
                             const FeatureName_type& FeatureName,
                             ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const ThreadedFeatureItemType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureItemType* ThreadedFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureItemType (*this, f, c);
    }

    ThreadedFeatureItemType::
    ~ThreadedFeatureItemType ()
    {
    }

    // ThreadedFeatureDefinitionType
    //

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   const ThreadSpecificationId_type& ThreadSpecificationId)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      ThreadSpecificationId_ (ThreadSpecificationId, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Bottom_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   ::std::auto_ptr< ThreadSpecificationId_type >& ThreadSpecificationId)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      ThreadSpecificationId_ (ThreadSpecificationId, ::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this),
      Bottom_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const ThreadedFeatureDefinitionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      ThreadSpecificationId_ (x.ThreadSpecificationId_, f, this),
      Length_ (x.Length_, f, this),
      Bottom_ (x.Bottom_, f, this)
    {
    }

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      ThreadSpecificationId_ (f, this),
      Length_ (f, this),
      Bottom_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // ThreadSpecificationId
        //
        if (n.name () == "ThreadSpecificationId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThreadSpecificationId_type > r (
            ThreadSpecificationId_traits::create (i, f, this));

          if (!ThreadSpecificationId_.present ())
          {
            this->ThreadSpecificationId_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == "Bottom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ThreadSpecificationId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ThreadSpecificationId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureDefinitionType* ThreadedFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureDefinitionType (*this, f, c);
    }

    ThreadedFeatureDefinitionType::
    ~ThreadedFeatureDefinitionType ()
    {
    }

    // ThreadedFeatureNominalType
    //

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                const Axis_type& Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                ::std::auto_ptr< Axis_type >& Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, ::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const ThreadedFeatureNominalType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this)
    {
    }

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureNominalType* ThreadedFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureNominalType (*this, f, c);
    }

    ThreadedFeatureNominalType::
    ~ThreadedFeatureNominalType ()
    {
    }

    // ThreadedFeatureActualType
    //

    ThreadedFeatureActualType::
    ThreadedFeatureActualType (const id_type& id,
                               const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      PitchDiameter_ (::xml_schema::flags (), this),
      FunctionalSize_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureActualType::
    ThreadedFeatureActualType (const id_type& id,
                               ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (::xml_schema::flags (), this),
      PitchDiameter_ (::xml_schema::flags (), this),
      FunctionalSize_ (::xml_schema::flags (), this),
      Length_ (::xml_schema::flags (), this)
    {
    }

    ThreadedFeatureActualType::
    ThreadedFeatureActualType (const ThreadedFeatureActualType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      PitchDiameter_ (x.PitchDiameter_, f, this),
      FunctionalSize_ (x.FunctionalSize_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    ThreadedFeatureActualType::
    ThreadedFeatureActualType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (f, this),
      PitchDiameter_ (f, this),
      FunctionalSize_ (f, this),
      Length_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // PitchDiameter
        //
        if (n.name () == "PitchDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PitchDiameter_type > r (
            PitchDiameter_traits::create (i, f, this));

          if (!this->PitchDiameter_)
          {
            this->PitchDiameter_.set (r);
            continue;
          }
        }

        // FunctionalSize
        //
        if (n.name () == "FunctionalSize" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FunctionalSize_type > r (
            FunctionalSize_traits::create (i, f, this));

          if (!this->FunctionalSize_)
          {
            this->FunctionalSize_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureActualType* ThreadedFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureActualType (*this, f, c);
    }

    ThreadedFeatureActualType::
    ~ThreadedFeatureActualType ()
    {
    }

    // ToroidalSegmentConstructionMethodType
    //

    ToroidalSegmentConstructionMethodType::
    ToroidalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentConstructionMethodType::
    ToroidalSegmentConstructionMethodType (const ToroidalSegmentConstructionMethodType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ToroidalSegmentConstructionMethodType::
    ToroidalSegmentConstructionMethodType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentConstructionMethodType* ToroidalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentConstructionMethodType (*this, f, c);
    }

    ToroidalSegmentConstructionMethodType::
    ~ToroidalSegmentConstructionMethodType ()
    {
    }

    // ToroidalSegmentBestFitType
    //

    ToroidalSegmentBestFitType::
    ToroidalSegmentBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentBestFitType::
    ToroidalSegmentBestFitType (const ToroidalSegmentBestFitType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ToroidalSegmentBestFitType::
    ToroidalSegmentBestFitType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ToroidalSegmentBestFitType* ToroidalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentBestFitType (*this, f, c);
    }

    ToroidalSegmentBestFitType::
    ~ToroidalSegmentBestFitType ()
    {
    }

    // ToroidalSegmentRecompType
    //

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (const ToroidalSegmentRecompType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentRecompType* ToroidalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentRecompType (*this, f, c);
    }

    ToroidalSegmentRecompType::
    ~ToroidalSegmentRecompType ()
    {
    }

    // ToroidalSegmentCopyType
    //

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (const BaseToroidalSegment_type& BaseToroidalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (BaseToroidalSegment, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (::std::auto_ptr< BaseToroidalSegment_type >& BaseToroidalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (BaseToroidalSegment, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (const ToroidalSegmentCopyType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseToroidalSegment_ (x.BaseToroidalSegment_, f, this)
    {
    }

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseToroidalSegment_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseToroidalSegment
        //
        if (n.name () == "BaseToroidalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseToroidalSegment_type > r (
            BaseToroidalSegment_traits::create (i, f, this));

          if (!BaseToroidalSegment_.present ())
          {
            this->BaseToroidalSegment_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseToroidalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseToroidalSegment",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentCopyType* ToroidalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCopyType (*this, f, c);
    }

    ToroidalSegmentCopyType::
    ~ToroidalSegmentCopyType ()
    {
    }

    // ToroidalSegmentCastType
    //

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (const ToroidalSegmentCastType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentCastType* ToroidalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCastType (*this, f, c);
    }

    ToroidalSegmentCastType::
    ~ToroidalSegmentCastType ()
    {
    }

    // ToroidalSegmentTransformType
    //

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (const BaseToroidalSegment_type& BaseToroidalSegment,
                                  const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (BaseToroidalSegment, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (::std::auto_ptr< BaseToroidalSegment_type >& BaseToroidalSegment,
                                  ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (BaseToroidalSegment, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (const ToroidalSegmentTransformType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseToroidalSegment_ (x.BaseToroidalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseToroidalSegment_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseToroidalSegment
        //
        if (n.name () == "BaseToroidalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseToroidalSegment_type > r (
            BaseToroidalSegment_traits::create (i, f, this));

          if (!BaseToroidalSegment_.present ())
          {
            this->BaseToroidalSegment_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseToroidalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseToroidalSegment",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentTransformType* ToroidalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentTransformType (*this, f, c);
    }

    ToroidalSegmentTransformType::
    ~ToroidalSegmentTransformType ()
    {
    }

    // ToroidalSegmentCheckedType
    //

    ToroidalSegmentCheckedType::
    ToroidalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentCheckedType::
    ToroidalSegmentCheckedType (const ToroidalSegmentCheckedType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ToroidalSegmentCheckedType::
    ToroidalSegmentCheckedType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentCheckedType* ToroidalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCheckedType (*this, f, c);
    }

    ToroidalSegmentCheckedType::
    ~ToroidalSegmentCheckedType ()
    {
    }

    // ToroidalSegmentCheckedFeatureType
    //

    ToroidalSegmentCheckedFeatureType::
    ToroidalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentCheckedFeatureType::
    ToroidalSegmentCheckedFeatureType (const ToroidalSegmentCheckedFeatureType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ToroidalSegmentCheckedFeatureType::
    ToroidalSegmentCheckedFeatureType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentCheckedFeatureType* ToroidalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCheckedFeatureType (*this, f, c);
    }

    ToroidalSegmentCheckedFeatureType::
    ~ToroidalSegmentCheckedFeatureType ()
    {
    }

    // ToroidalSegmentActualDeterminationType
    //

    ToroidalSegmentActualDeterminationType::
    ToroidalSegmentActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentActualDeterminationType::
    ToroidalSegmentActualDeterminationType (const ToroidalSegmentActualDeterminationType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ToroidalSegmentActualDeterminationType::
    ToroidalSegmentActualDeterminationType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentActualDeterminationType* ToroidalSegmentActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentActualDeterminationType (*this, f, c);
    }

    ToroidalSegmentActualDeterminationType::
    ~ToroidalSegmentActualDeterminationType ()
    {
    }

    // ToroidalSegmentFeatureItemType
    //

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const id_type& id,
                                    const FeatureName_type& FeatureName,
                                    const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const id_type& id,
                                    const FeatureName_type& FeatureName,
                                    ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const ToroidalSegmentFeatureItemType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentFeatureItemType* ToroidalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureItemType (*this, f, c);
    }

    ToroidalSegmentFeatureItemType::
    ~ToroidalSegmentFeatureItemType ()
    {
    }

    // ToroidalSegmentFeatureDefinitionType
    //

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const id_type& id,
                                          const InternalExternal_type& InternalExternal,
                                          const MinorDiameter_type& MinorDiameter,
                                          const MajorDiameter_type& MajorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      MinorDiameter_ (MinorDiameter, ::xml_schema::flags (), this),
      MajorDiameter_ (MajorDiameter, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const id_type& id,
                                          const InternalExternal_type& InternalExternal,
                                          ::std::auto_ptr< MinorDiameter_type >& MinorDiameter,
                                          ::std::auto_ptr< MajorDiameter_type >& MajorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      MinorDiameter_ (MinorDiameter, ::xml_schema::flags (), this),
      MajorDiameter_ (MajorDiameter, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const ToroidalSegmentFeatureDefinitionType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this)
    {
    }

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      MinorDiameter_ (f, this),
      MajorDiameter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!MinorDiameter_.present ())
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!MajorDiameter_.present ())
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MinorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MinorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MajorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MajorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentFeatureDefinitionType* ToroidalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureDefinitionType (*this, f, c);
    }

    ToroidalSegmentFeatureDefinitionType::
    ~ToroidalSegmentFeatureDefinitionType ()
    {
    }

    // ToroidalSegmentFeatureNominalType
    //

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const id_type& id,
                                       const FeatureDefinitionId_type& FeatureDefinitionId,
                                       const Location_type& Location,
                                       const AxisVector_type& AxisVector,
                                       const LatitudeLongitudeSweep_type& LatitudeLongitudeSweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      AxisVector_ (AxisVector, ::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const id_type& id,
                                       const FeatureDefinitionId_type& FeatureDefinitionId,
                                       ::std::auto_ptr< Location_type >& Location,
                                       ::std::auto_ptr< AxisVector_type >& AxisVector,
                                       ::std::auto_ptr< LatitudeLongitudeSweep_type >& LatitudeLongitudeSweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      AxisVector_ (AxisVector, ::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, ::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const ToroidalSegmentFeatureNominalType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this)
    {
    }

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      AxisVector_ (f, this),
      LatitudeLongitudeSweep_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == "AxisVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!AxisVector_.present ())
          {
            this->AxisVector_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!LatitudeLongitudeSweep_.present ())
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!AxisVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AxisVector",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!LatitudeLongitudeSweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LatitudeLongitudeSweep",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentFeatureNominalType* ToroidalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureNominalType (*this, f, c);
    }

    ToroidalSegmentFeatureNominalType::
    ~ToroidalSegmentFeatureNominalType ()
    {
    }

    // ToroidalSegmentFeatureActualType
    //

    ToroidalSegmentFeatureActualType::
    ToroidalSegmentFeatureActualType (const id_type& id,
                                      const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      AxisVector_ (::xml_schema::flags (), this),
      MinorDiameter_ (::xml_schema::flags (), this),
      MajorDiameter_ (::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentFeatureActualType::
    ToroidalSegmentFeatureActualType (const id_type& id,
                                      ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      AxisVector_ (::xml_schema::flags (), this),
      MinorDiameter_ (::xml_schema::flags (), this),
      MajorDiameter_ (::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    ToroidalSegmentFeatureActualType::
    ToroidalSegmentFeatureActualType (const ToroidalSegmentFeatureActualType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ToroidalSegmentFeatureActualType::
    ToroidalSegmentFeatureActualType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      AxisVector_ (f, this),
      MinorDiameter_ (f, this),
      MajorDiameter_ (f, this),
      LatitudeLongitudeSweep_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == "AxisVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!this->AxisVector_)
          {
            this->AxisVector_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!this->MinorDiameter_)
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!this->MajorDiameter_)
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentFeatureActualType* ToroidalSegmentFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureActualType (*this, f, c);
    }

    ToroidalSegmentFeatureActualType::
    ~ToroidalSegmentFeatureActualType ()
    {
    }

    // TorusConstructionMethodType
    //

    TorusConstructionMethodType::
    TorusConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (::xml_schema::flags (), this),
      Recompensated_ (::xml_schema::flags (), this),
      Copy_ (::xml_schema::flags (), this),
      Cast_ (::xml_schema::flags (), this),
      Transform_ (::xml_schema::flags (), this),
      FromScan_ (::xml_schema::flags (), this)
    {
    }

    TorusConstructionMethodType::
    TorusConstructionMethodType (const TorusConstructionMethodType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    TorusConstructionMethodType::
    TorusConstructionMethodType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (f, this),
      Recompensated_ (f, this),
      Copy_ (f, this),
      Cast_ (f, this),
      Transform_ (f, this),
      FromScan_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TorusConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusConstructionMethodType* TorusConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusConstructionMethodType (*this, f, c);
    }

    TorusConstructionMethodType::
    ~TorusConstructionMethodType ()
    {
    }

    // TorusBestFitType
    //

    TorusBestFitType::
    TorusBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (::xml_schema::flags (), this)
    {
    }

    TorusBestFitType::
    TorusBestFitType (const TorusBestFitType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    TorusBestFitType::
    TorusBestFitType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TorusBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    TorusBestFitType* TorusBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusBestFitType (*this, f, c);
    }

    TorusBestFitType::
    ~TorusBestFitType ()
    {
    }

    // TorusRecompType
    //

    TorusRecompType::
    TorusRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    TorusRecompType::
    TorusRecompType (::std::auto_ptr< BaseFeaturePointList_type >& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, ::xml_schema::flags (), this)
    {
    }

    TorusRecompType::
    TorusRecompType (const TorusRecompType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    TorusRecompType::
    TorusRecompType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TorusRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusRecompType* TorusRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusRecompType (*this, f, c);
    }

    TorusRecompType::
    ~TorusRecompType ()
    {
    }

    // TorusCopyType
    //

    TorusCopyType::
    TorusCopyType (const BaseTorus_type& BaseTorus)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseTorus_ (BaseTorus, ::xml_schema::flags (), this)
    {
    }

    TorusCopyType::
    TorusCopyType (::std::auto_ptr< BaseTorus_type >& BaseTorus)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseTorus_ (BaseTorus, ::xml_schema::flags (), this)
    {
    }

    TorusCopyType::
    TorusCopyType (const TorusCopyType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseTorus_ (x.BaseTorus_, f, this)
    {
    }

    TorusCopyType::
    TorusCopyType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseTorus_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TorusCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseTorus
        //
        if (n.name () == "BaseTorus" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseTorus_type > r (
            BaseTorus_traits::create (i, f, this));

          if (!BaseTorus_.present ())
          {
            this->BaseTorus_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseTorus_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseTorus",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusCopyType* TorusCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCopyType (*this, f, c);
    }

    TorusCopyType::
    ~TorusCopyType ()
    {
    }

    // TorusCastType
    //

    TorusCastType::
    TorusCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    TorusCastType::
    TorusCastType (::std::auto_ptr< BaseFeature_type >& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, ::xml_schema::flags (), this)
    {
    }

    TorusCastType::
    TorusCastType (const TorusCastType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    TorusCastType::
    TorusCastType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TorusCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusCastType* TorusCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCastType (*this, f, c);
    }

    TorusCastType::
    ~TorusCastType ()
    {
    }

    // TorusTransformType
    //

    TorusTransformType::
    TorusTransformType (const BaseTorus_type& BaseTorus,
                        const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseTorus_ (BaseTorus, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    TorusTransformType::
    TorusTransformType (::std::auto_ptr< BaseTorus_type >& BaseTorus,
                        ::std::auto_ptr< Transformation_type >& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseTorus_ (BaseTorus, ::xml_schema::flags (), this),
      Transformation_ (Transformation, ::xml_schema::flags (), this)
    {
    }

    TorusTransformType::
    TorusTransformType (const TorusTransformType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseTorus_ (x.BaseTorus_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    TorusTransformType::
    TorusTransformType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseTorus_ (f, this),
      Transformation_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TorusTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseTorus
        //
        if (n.name () == "BaseTorus" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseTorus_type > r (
            BaseTorus_traits::create (i, f, this));

          if (!BaseTorus_.present ())
          {
            this->BaseTorus_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseTorus_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseTorus",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusTransformType* TorusTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusTransformType (*this, f, c);
    }

    TorusTransformType::
    ~TorusTransformType ()
    {
    }

    // TorusFromScanType
    //

    TorusFromScanType::
    TorusFromScanType (const SurfaceFeature_type& SurfaceFeature,
                       const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    TorusFromScanType::
    TorusFromScanType (::std::auto_ptr< SurfaceFeature_type >& SurfaceFeature,
                       ::std::auto_ptr< SearchRadius_type >& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, ::xml_schema::flags (), this),
      SearchRadius_ (SearchRadius, ::xml_schema::flags (), this)
    {
    }

    TorusFromScanType::
    TorusFromScanType (const TorusFromScanType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    TorusFromScanType::
    TorusFromScanType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (f, this),
      SearchRadius_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TorusFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusFromScanType* TorusFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFromScanType (*this, f, c);
    }

    TorusFromScanType::
    ~TorusFromScanType ()
    {
    }

    // TorusCheckedType
    //

    TorusCheckedType::
    TorusCheckedType ()
    : ::xml_schema::type (),
      Measured_ (::xml_schema::flags (), this),
      Constructed_ (::xml_schema::flags (), this)
    {
    }

    TorusCheckedType::
    TorusCheckedType (const TorusCheckedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    TorusCheckedType::
    TorusCheckedType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (f, this),
      Constructed_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TorusCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusCheckedType* TorusCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCheckedType (*this, f, c);
    }

    TorusCheckedType::
    ~TorusCheckedType ()
    {
    }

    // TorusCheckedFeatureType
    //

    TorusCheckedFeatureType::
    TorusCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (::xml_schema::flags (), this)
    {
    }

    TorusCheckedFeatureType::
    TorusCheckedFeatureType (const TorusCheckedFeatureType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    TorusCheckedFeatureType::
    TorusCheckedFeatureType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TorusCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusCheckedFeatureType* TorusCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCheckedFeatureType (*this, f, c);
    }

    TorusCheckedFeatureType::
    ~TorusCheckedFeatureType ()
    {
    }

    // TorusActualDeterminationType
    //

    TorusActualDeterminationType::
    TorusActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (::xml_schema::flags (), this),
      Set_ (::xml_schema::flags (), this)
    {
    }

    TorusActualDeterminationType::
    TorusActualDeterminationType (const TorusActualDeterminationType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    TorusActualDeterminationType::
    TorusActualDeterminationType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (f, this),
      Set_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TorusActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusActualDeterminationType* TorusActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusActualDeterminationType (*this, f, c);
    }

    TorusActualDeterminationType::
    ~TorusActualDeterminationType ()
    {
    }

    // TorusFeatureItemType
    //

    TorusFeatureItemType::
    TorusFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    TorusFeatureItemType::
    TorusFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          ::std::auto_ptr< DeterminationMode_type >& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, ::xml_schema::flags (), this),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    TorusFeatureItemType::
    TorusFeatureItemType (const TorusFeatureItemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    TorusFeatureItemType::
    TorusFeatureItemType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (f, this),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusFeatureItemType* TorusFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureItemType (*this, f, c);
    }

    TorusFeatureItemType::
    ~TorusFeatureItemType ()
    {
    }

    // TorusFeatureDefinitionType
    //

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const id_type& id,
                                const InternalExternal_type& InternalExternal,
                                const MinorDiameter_type& MinorDiameter,
                                const MajorDiameter_type& MajorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      MinorDiameter_ (MinorDiameter, ::xml_schema::flags (), this),
      MajorDiameter_ (MajorDiameter, ::xml_schema::flags (), this)
    {
    }

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const id_type& id,
                                const InternalExternal_type& InternalExternal,
                                ::std::auto_ptr< MinorDiameter_type >& MinorDiameter,
                                ::std::auto_ptr< MajorDiameter_type >& MajorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, ::xml_schema::flags (), this),
      MinorDiameter_ (MinorDiameter, ::xml_schema::flags (), this),
      MajorDiameter_ (MajorDiameter, ::xml_schema::flags (), this)
    {
    }

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const TorusFeatureDefinitionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this)
    {
    }

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (f, this),
      MinorDiameter_ (f, this),
      MajorDiameter_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!MinorDiameter_.present ())
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!MajorDiameter_.present ())
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MinorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MinorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MajorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MajorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusFeatureDefinitionType* TorusFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureDefinitionType (*this, f, c);
    }

    TorusFeatureDefinitionType::
    ~TorusFeatureDefinitionType ()
    {
    }

    // TorusFeatureNominalType
    //

    TorusFeatureNominalType::
    TorusFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             const Location_type& Location,
                             const AxisVector_type& AxisVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      AxisVector_ (AxisVector, ::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this)
    {
    }

    TorusFeatureNominalType::
    TorusFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             ::std::auto_ptr< Location_type >& Location,
                             ::std::auto_ptr< AxisVector_type >& AxisVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, ::xml_schema::flags (), this),
      AxisVector_ (AxisVector, ::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this)
    {
    }

    TorusFeatureNominalType::
    TorusFeatureNominalType (const TorusFeatureNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this)
    {
    }

    TorusFeatureNominalType::
    TorusFeatureNominalType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      AxisVector_ (f, this),
      LatitudeLongitudeSweep_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == "AxisVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!AxisVector_.present ())
          {
            this->AxisVector_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!AxisVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AxisVector",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusFeatureNominalType* TorusFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureNominalType (*this, f, c);
    }

    TorusFeatureNominalType::
    ~TorusFeatureNominalType ()
    {
    }

    // TorusFeatureActualType
    //

    TorusFeatureActualType::
    TorusFeatureActualType (const id_type& id,
                            const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      AxisVector_ (::xml_schema::flags (), this),
      MinorDiameter_ (::xml_schema::flags (), this),
      MajorDiameter_ (::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    TorusFeatureActualType::
    TorusFeatureActualType (const id_type& id,
                            ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      AxisVector_ (::xml_schema::flags (), this),
      MinorDiameter_ (::xml_schema::flags (), this),
      MajorDiameter_ (::xml_schema::flags (), this),
      LatitudeLongitudeSweep_ (::xml_schema::flags (), this),
      Form_ (::xml_schema::flags (), this)
    {
    }

    TorusFeatureActualType::
    TorusFeatureActualType (const TorusFeatureActualType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    TorusFeatureActualType::
    TorusFeatureActualType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      AxisVector_ (f, this),
      MinorDiameter_ (f, this),
      MajorDiameter_ (f, this),
      LatitudeLongitudeSweep_ (f, this),
      Form_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == "AxisVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!this->AxisVector_)
          {
            this->AxisVector_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!this->MinorDiameter_)
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!this->MajorDiameter_)
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusFeatureActualType* TorusFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureActualType (*this, f, c);
    }

    TorusFeatureActualType::
    ~TorusFeatureActualType ()
    {
    }

    // CompositeFeatureItemBaseType
    //

    CompositeFeatureItemBaseType::
    CompositeFeatureItemBaseType (const id_type& id,
                                  const FeatureName_type& FeatureName)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName)
    {
    }

    CompositeFeatureItemBaseType::
    CompositeFeatureItemBaseType (const CompositeFeatureItemBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c)
    {
    }

    CompositeFeatureItemBaseType::
    CompositeFeatureItemBaseType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f, c)
    {
    }

    CompositeFeatureItemBaseType* CompositeFeatureItemBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeFeatureItemBaseType (*this, f, c);
    }

    CompositeFeatureItemBaseType::
    ~CompositeFeatureItemBaseType ()
    {
    }

    // CompositeFeatureDefinitionBaseType
    //

    CompositeFeatureDefinitionBaseType::
    CompositeFeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    CompositeFeatureDefinitionBaseType::
    CompositeFeatureDefinitionBaseType (const CompositeFeatureDefinitionBaseType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    CompositeFeatureDefinitionBaseType::
    CompositeFeatureDefinitionBaseType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    CompositeFeatureDefinitionBaseType* CompositeFeatureDefinitionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeFeatureDefinitionBaseType (*this, f, c);
    }

    CompositeFeatureDefinitionBaseType::
    ~CompositeFeatureDefinitionBaseType ()
    {
    }

    // CompositeFeatureNominalBaseType
    //

    CompositeFeatureNominalBaseType::
    CompositeFeatureNominalBaseType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId,
                                     const FeatureNominalIds_type& FeatureNominalIds)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      FeatureNominalIds_ (FeatureNominalIds, ::xml_schema::flags (), this)
    {
    }

    CompositeFeatureNominalBaseType::
    CompositeFeatureNominalBaseType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId,
                                     ::std::auto_ptr< FeatureNominalIds_type >& FeatureNominalIds)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      FeatureNominalIds_ (FeatureNominalIds, ::xml_schema::flags (), this)
    {
    }

    CompositeFeatureNominalBaseType::
    CompositeFeatureNominalBaseType (const CompositeFeatureNominalBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      FeatureNominalIds_ (x.FeatureNominalIds_, f, this)
    {
    }

    CompositeFeatureNominalBaseType::
    CompositeFeatureNominalBaseType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      FeatureNominalIds_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CompositeFeatureNominalBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureNominalIds
        //
        if (n.name () == "FeatureNominalIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureNominalIds_type > r (
            FeatureNominalIds_traits::create (i, f, this));

          if (!FeatureNominalIds_.present ())
          {
            this->FeatureNominalIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureNominalIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureNominalIds",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CompositeFeatureNominalBaseType* CompositeFeatureNominalBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeFeatureNominalBaseType (*this, f, c);
    }

    CompositeFeatureNominalBaseType::
    ~CompositeFeatureNominalBaseType ()
    {
    }

    // CompositeFeatureActualBaseType
    //

    CompositeFeatureActualBaseType::
    CompositeFeatureActualBaseType (const id_type& id,
                                    const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId)
    {
    }

    CompositeFeatureActualBaseType::
    CompositeFeatureActualBaseType (const id_type& id,
                                    ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId)
    {
    }

    CompositeFeatureActualBaseType::
    CompositeFeatureActualBaseType (const CompositeFeatureActualBaseType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c)
    {
    }

    CompositeFeatureActualBaseType::
    CompositeFeatureActualBaseType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f, c)
    {
    }

    CompositeFeatureActualBaseType* CompositeFeatureActualBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeFeatureActualBaseType (*this, f, c);
    }

    CompositeFeatureActualBaseType::
    ~CompositeFeatureActualBaseType ()
    {
    }

    // CompoundFeatureItemType
    //

    CompoundFeatureItemType::
    CompoundFeatureItemType (const id_type& id,
                             const FeatureName_type& FeatureName)
    : ::xsd::qif2::CompositeFeatureItemBaseType (id,
                                                 FeatureName),
      SubstituteFeatureAlgorithm_ (::xml_schema::flags (), this)
    {
    }

    CompoundFeatureItemType::
    CompoundFeatureItemType (const CompoundFeatureItemType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (x, f, c),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    CompoundFeatureItemType::
    CompoundFeatureItemType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      SubstituteFeatureAlgorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CompoundFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::CompositeFeatureItemBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CompoundFeatureItemType* CompoundFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompoundFeatureItemType (*this, f, c);
    }

    CompoundFeatureItemType::
    ~CompoundFeatureItemType ()
    {
    }

    // CompoundFeatureDefinitionType
    //

    CompoundFeatureDefinitionType::
    CompoundFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (id)
    {
    }

    CompoundFeatureDefinitionType::
    CompoundFeatureDefinitionType (const CompoundFeatureDefinitionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (x, f, c)
    {
    }

    CompoundFeatureDefinitionType::
    CompoundFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (e, f, c)
    {
    }

    CompoundFeatureDefinitionType* CompoundFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompoundFeatureDefinitionType (*this, f, c);
    }

    CompoundFeatureDefinitionType::
    ~CompoundFeatureDefinitionType ()
    {
    }

    // CompoundFeatureNominalType
    //

    CompoundFeatureNominalType::
    CompoundFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                const FeatureNominalIds_type& FeatureNominalIds,
                                const Location_type& Location,
                                const Direction_type& Direction,
                                const CompoundFeatureForm_type& CompoundFeatureForm)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds),
      Location_ (Location, ::xml_schema::flags (), this),
      Direction_ (Direction, ::xml_schema::flags (), this),
      CompoundFeatureForm_ (CompoundFeatureForm, ::xml_schema::flags (), this)
    {
    }

    CompoundFeatureNominalType::
    CompoundFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                ::std::auto_ptr< FeatureNominalIds_type >& FeatureNominalIds,
                                ::std::auto_ptr< Location_type >& Location,
                                ::std::auto_ptr< Direction_type >& Direction,
                                const CompoundFeatureForm_type& CompoundFeatureForm)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds),
      Location_ (Location, ::xml_schema::flags (), this),
      Direction_ (Direction, ::xml_schema::flags (), this),
      CompoundFeatureForm_ (CompoundFeatureForm, ::xml_schema::flags (), this)
    {
    }

    CompoundFeatureNominalType::
    CompoundFeatureNominalType (const CompoundFeatureNominalType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Direction_ (x.Direction_, f, this),
      CompoundFeatureForm_ (x.CompoundFeatureForm_, f, this)
    {
    }

    CompoundFeatureNominalType::
    CompoundFeatureNominalType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Direction_ (f, this),
      CompoundFeatureForm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CompoundFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::CompositeFeatureNominalBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (r);
            continue;
          }
        }

        // CompoundFeatureForm
        //
        if (n.name () == "CompoundFeatureForm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CompoundFeatureForm_type > r (
            CompoundFeatureForm_traits::create (i, f, this));

          if (!CompoundFeatureForm_.present ())
          {
            this->CompoundFeatureForm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Direction",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CompoundFeatureForm_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CompoundFeatureForm",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CompoundFeatureNominalType* CompoundFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompoundFeatureNominalType (*this, f, c);
    }

    CompoundFeatureNominalType::
    ~CompoundFeatureNominalType ()
    {
    }

    // CompoundFeatureActualType
    //

    CompoundFeatureActualType::
    CompoundFeatureActualType (const id_type& id,
                               const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Direction_ (::xml_schema::flags (), this)
    {
    }

    CompoundFeatureActualType::
    CompoundFeatureActualType (const id_type& id,
                               ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId),
      Location_ (::xml_schema::flags (), this),
      Direction_ (::xml_schema::flags (), this)
    {
    }

    CompoundFeatureActualType::
    CompoundFeatureActualType (const CompoundFeatureActualType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Direction_ (x.Direction_, f, this)
    {
    }

    CompoundFeatureActualType::
    CompoundFeatureActualType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (f, this),
      Direction_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CompoundFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::CompositeFeatureActualBaseType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!this->Direction_)
          {
            this->Direction_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CompoundFeatureActualType* CompoundFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompoundFeatureActualType (*this, f, c);
    }

    CompoundFeatureActualType::
    ~CompoundFeatureActualType ()
    {
    }

    // PatternFeatureItemType
    //

    PatternFeatureItemType::
    PatternFeatureItemType (const id_type& id,
                            const FeatureName_type& FeatureName)
    : ::xsd::qif2::CompositeFeatureItemBaseType (id,
                                                 FeatureName)
    {
    }

    PatternFeatureItemType::
    PatternFeatureItemType (const PatternFeatureItemType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (x, f, c)
    {
    }

    PatternFeatureItemType::
    PatternFeatureItemType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (e, f, c)
    {
    }

    PatternFeatureItemType* PatternFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureItemType (*this, f, c);
    }

    PatternFeatureItemType::
    ~PatternFeatureItemType ()
    {
    }

    // PatternFeatureDefinitionType
    //

    PatternFeatureDefinitionType::
    PatternFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (id)
    {
    }

    PatternFeatureDefinitionType::
    PatternFeatureDefinitionType (const PatternFeatureDefinitionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (x, f, c)
    {
    }

    PatternFeatureDefinitionType::
    PatternFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (e, f, c)
    {
    }

    PatternFeatureDefinitionType* PatternFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureDefinitionType (*this, f, c);
    }

    PatternFeatureDefinitionType::
    ~PatternFeatureDefinitionType ()
    {
    }

    // PatternFeatureNominalType
    //

    PatternFeatureNominalType::
    PatternFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId,
                               const FeatureNominalIds_type& FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    PatternFeatureNominalType::
    PatternFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId,
                               ::std::auto_ptr< FeatureNominalIds_type >& FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    PatternFeatureNominalType::
    PatternFeatureNominalType (const PatternFeatureNominalType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (x, f, c)
    {
    }

    PatternFeatureNominalType::
    PatternFeatureNominalType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (e, f, c)
    {
    }

    PatternFeatureNominalType* PatternFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureNominalType (*this, f, c);
    }

    PatternFeatureNominalType::
    ~PatternFeatureNominalType ()
    {
    }

    // PatternFeatureActualType
    //

    PatternFeatureActualType::
    PatternFeatureActualType (const id_type& id,
                              const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    PatternFeatureActualType::
    PatternFeatureActualType (const id_type& id,
                              ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    PatternFeatureActualType::
    PatternFeatureActualType (const PatternFeatureActualType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (x, f, c)
    {
    }

    PatternFeatureActualType::
    PatternFeatureActualType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (e, f, c)
    {
    }

    PatternFeatureActualType* PatternFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureActualType (*this, f, c);
    }

    PatternFeatureActualType::
    ~PatternFeatureActualType ()
    {
    }

    // ProfileGroupFeatureItemType
    //

    ProfileGroupFeatureItemType::
    ProfileGroupFeatureItemType (const id_type& id,
                                 const FeatureName_type& FeatureName)
    : ::xsd::qif2::CompositeFeatureItemBaseType (id,
                                                 FeatureName)
    {
    }

    ProfileGroupFeatureItemType::
    ProfileGroupFeatureItemType (const ProfileGroupFeatureItemType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (x, f, c)
    {
    }

    ProfileGroupFeatureItemType::
    ProfileGroupFeatureItemType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (e, f, c)
    {
    }

    ProfileGroupFeatureItemType* ProfileGroupFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProfileGroupFeatureItemType (*this, f, c);
    }

    ProfileGroupFeatureItemType::
    ~ProfileGroupFeatureItemType ()
    {
    }

    // ProfileGroupFeatureDefinitionType
    //

    ProfileGroupFeatureDefinitionType::
    ProfileGroupFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (id)
    {
    }

    ProfileGroupFeatureDefinitionType::
    ProfileGroupFeatureDefinitionType (const ProfileGroupFeatureDefinitionType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (x, f, c)
    {
    }

    ProfileGroupFeatureDefinitionType::
    ProfileGroupFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (e, f, c)
    {
    }

    ProfileGroupFeatureDefinitionType* ProfileGroupFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProfileGroupFeatureDefinitionType (*this, f, c);
    }

    ProfileGroupFeatureDefinitionType::
    ~ProfileGroupFeatureDefinitionType ()
    {
    }

    // ProfileGroupFeatureNominalType
    //

    ProfileGroupFeatureNominalType::
    ProfileGroupFeatureNominalType (const id_type& id,
                                    const FeatureDefinitionId_type& FeatureDefinitionId,
                                    const FeatureNominalIds_type& FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    ProfileGroupFeatureNominalType::
    ProfileGroupFeatureNominalType (const id_type& id,
                                    const FeatureDefinitionId_type& FeatureDefinitionId,
                                    ::std::auto_ptr< FeatureNominalIds_type >& FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    ProfileGroupFeatureNominalType::
    ProfileGroupFeatureNominalType (const ProfileGroupFeatureNominalType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (x, f, c)
    {
    }

    ProfileGroupFeatureNominalType::
    ProfileGroupFeatureNominalType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (e, f, c)
    {
    }

    ProfileGroupFeatureNominalType* ProfileGroupFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProfileGroupFeatureNominalType (*this, f, c);
    }

    ProfileGroupFeatureNominalType::
    ~ProfileGroupFeatureNominalType ()
    {
    }

    // ProfileGroupFeatureActualType
    //

    ProfileGroupFeatureActualType::
    ProfileGroupFeatureActualType (const id_type& id,
                                   const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    ProfileGroupFeatureActualType::
    ProfileGroupFeatureActualType (const id_type& id,
                                   ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    ProfileGroupFeatureActualType::
    ProfileGroupFeatureActualType (const ProfileGroupFeatureActualType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (x, f, c)
    {
    }

    ProfileGroupFeatureActualType::
    ProfileGroupFeatureActualType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (e, f, c)
    {
    }

    ProfileGroupFeatureActualType* ProfileGroupFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProfileGroupFeatureActualType (*this, f, c);
    }

    ProfileGroupFeatureActualType::
    ~ProfileGroupFeatureActualType ()
    {
    }

    // RunoutGroupFeatureItemType
    //

    RunoutGroupFeatureItemType::
    RunoutGroupFeatureItemType (const id_type& id,
                                const FeatureName_type& FeatureName)
    : ::xsd::qif2::CompositeFeatureItemBaseType (id,
                                                 FeatureName)
    {
    }

    RunoutGroupFeatureItemType::
    RunoutGroupFeatureItemType (const RunoutGroupFeatureItemType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (x, f, c)
    {
    }

    RunoutGroupFeatureItemType::
    RunoutGroupFeatureItemType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (e, f, c)
    {
    }

    RunoutGroupFeatureItemType* RunoutGroupFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RunoutGroupFeatureItemType (*this, f, c);
    }

    RunoutGroupFeatureItemType::
    ~RunoutGroupFeatureItemType ()
    {
    }

    // RunoutGroupFeatureDefinitionType
    //

    RunoutGroupFeatureDefinitionType::
    RunoutGroupFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (id)
    {
    }

    RunoutGroupFeatureDefinitionType::
    RunoutGroupFeatureDefinitionType (const RunoutGroupFeatureDefinitionType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (x, f, c)
    {
    }

    RunoutGroupFeatureDefinitionType::
    RunoutGroupFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (e, f, c)
    {
    }

    RunoutGroupFeatureDefinitionType* RunoutGroupFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RunoutGroupFeatureDefinitionType (*this, f, c);
    }

    RunoutGroupFeatureDefinitionType::
    ~RunoutGroupFeatureDefinitionType ()
    {
    }

    // RunoutGroupFeatureNominalType
    //

    RunoutGroupFeatureNominalType::
    RunoutGroupFeatureNominalType (const id_type& id,
                                   const FeatureDefinitionId_type& FeatureDefinitionId,
                                   const FeatureNominalIds_type& FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    RunoutGroupFeatureNominalType::
    RunoutGroupFeatureNominalType (const id_type& id,
                                   const FeatureDefinitionId_type& FeatureDefinitionId,
                                   ::std::auto_ptr< FeatureNominalIds_type >& FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    RunoutGroupFeatureNominalType::
    RunoutGroupFeatureNominalType (const RunoutGroupFeatureNominalType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (x, f, c)
    {
    }

    RunoutGroupFeatureNominalType::
    RunoutGroupFeatureNominalType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (e, f, c)
    {
    }

    RunoutGroupFeatureNominalType* RunoutGroupFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RunoutGroupFeatureNominalType (*this, f, c);
    }

    RunoutGroupFeatureNominalType::
    ~RunoutGroupFeatureNominalType ()
    {
    }

    // RunoutGroupFeatureActualType
    //

    RunoutGroupFeatureActualType::
    RunoutGroupFeatureActualType (const id_type& id,
                                  const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    RunoutGroupFeatureActualType::
    RunoutGroupFeatureActualType (const id_type& id,
                                  ::std::auto_ptr< FeatureItemId_type >& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    RunoutGroupFeatureActualType::
    RunoutGroupFeatureActualType (const RunoutGroupFeatureActualType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (x, f, c)
    {
    }

    RunoutGroupFeatureActualType::
    RunoutGroupFeatureActualType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (e, f, c)
    {
    }

    RunoutGroupFeatureActualType* RunoutGroupFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RunoutGroupFeatureActualType (*this, f, c);
    }

    RunoutGroupFeatureActualType::
    ~RunoutGroupFeatureActualType ()
    {
    }

    // FeatureAspectsListsType
    //

    FeatureAspectsListsType::
    FeatureAspectsListsType ()
    : ::xml_schema::type (),
      FeatureDefinitions_ (::xml_schema::flags (), this),
      FeatureNominals_ (::xml_schema::flags (), this),
      FeatureItems_ (::xml_schema::flags (), this)
    {
    }

    FeatureAspectsListsType::
    FeatureAspectsListsType (const FeatureAspectsListsType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureDefinitions_ (x.FeatureDefinitions_, f, this),
      FeatureNominals_ (x.FeatureNominals_, f, this),
      FeatureItems_ (x.FeatureItems_, f, this)
    {
    }

    FeatureAspectsListsType::
    FeatureAspectsListsType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureDefinitions_ (f, this),
      FeatureNominals_ (f, this),
      FeatureItems_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void FeatureAspectsListsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureDefinitions
        //
        if (n.name () == "FeatureDefinitions" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureDefinitions_type > r (
            FeatureDefinitions_traits::create (i, f, this));

          if (!this->FeatureDefinitions_)
          {
            this->FeatureDefinitions_.set (r);
            continue;
          }
        }

        // FeatureNominals
        //
        if (n.name () == "FeatureNominals" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureNominals_type > r (
            FeatureNominals_traits::create (i, f, this));

          if (!this->FeatureNominals_)
          {
            this->FeatureNominals_.set (r);
            continue;
          }
        }

        // FeatureItems
        //
        if (n.name () == "FeatureItems" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureItems_type > r (
            FeatureItems_traits::create (i, f, this));

          if (!this->FeatureItems_)
          {
            this->FeatureItems_.set (r);
            continue;
          }
        }

        break;
      }
    }

    FeatureAspectsListsType* FeatureAspectsListsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureAspectsListsType (*this, f, c);
    }

    FeatureAspectsListsType::
    ~FeatureAspectsListsType ()
    {
    }

    // MeasuredFeaturesType
    //

    MeasuredFeaturesType::
    MeasuredFeaturesType (const FeatureActuals_type& FeatureActuals)
    : ::xml_schema::type (),
      FeatureActuals_ (FeatureActuals, ::xml_schema::flags (), this)
    {
    }

    MeasuredFeaturesType::
    MeasuredFeaturesType (::std::auto_ptr< FeatureActuals_type >& FeatureActuals)
    : ::xml_schema::type (),
      FeatureActuals_ (FeatureActuals, ::xml_schema::flags (), this)
    {
    }

    MeasuredFeaturesType::
    MeasuredFeaturesType (const MeasuredFeaturesType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureActuals_ (x.FeatureActuals_, f, this)
    {
    }

    MeasuredFeaturesType::
    MeasuredFeaturesType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureActuals_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void MeasuredFeaturesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureActuals
        //
        if (n.name () == "FeatureActuals" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureActuals_type > r (
            FeatureActuals_traits::create (i, f, this));

          if (!FeatureActuals_.present ())
          {
            this->FeatureActuals_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureActuals_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureActuals",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MeasuredFeaturesType* MeasuredFeaturesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredFeaturesType (*this, f, c);
    }

    MeasuredFeaturesType::
    ~MeasuredFeaturesType ()
    {
    }

    // FeatureDefinitionsType
    //

    FeatureDefinitionsType::
    FeatureDefinitionsType ()
    : ::xml_schema::type (),
      FeatureDefinition_ (::xml_schema::flags (), this)
    {
    }

    FeatureDefinitionsType::
    FeatureDefinitionsType (const FeatureDefinitionsType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureDefinition_ (x.FeatureDefinition_, f, this)
    {
    }

    FeatureDefinitionsType::
    FeatureDefinitionsType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureDefinition_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void FeatureDefinitionsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureDefinition
        //
        if (n.name () == "FeatureDefinition" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureDefinition_type > r (
            FeatureDefinition_traits::create (i, f, this));

          this->FeatureDefinition_.push_back (r);
          continue;
        }

        break;
      }
    }

    FeatureDefinitionsType* FeatureDefinitionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureDefinitionsType (*this, f, c);
    }

    FeatureDefinitionsType::
    ~FeatureDefinitionsType ()
    {
    }

    // FeatureNominalsType
    //

    FeatureNominalsType::
    FeatureNominalsType ()
    : ::xml_schema::type (),
      FeatureNominal_ (::xml_schema::flags (), this)
    {
    }

    FeatureNominalsType::
    FeatureNominalsType (const FeatureNominalsType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureNominal_ (x.FeatureNominal_, f, this)
    {
    }

    FeatureNominalsType::
    FeatureNominalsType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureNominal_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void FeatureNominalsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureNominal
        //
        if (n.name () == "FeatureNominal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureNominal_type > r (
            FeatureNominal_traits::create (i, f, this));

          this->FeatureNominal_.push_back (r);
          continue;
        }

        break;
      }
    }

    FeatureNominalsType* FeatureNominalsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureNominalsType (*this, f, c);
    }

    FeatureNominalsType::
    ~FeatureNominalsType ()
    {
    }

    // FeatureItemsType
    //

    FeatureItemsType::
    FeatureItemsType ()
    : ::xml_schema::type (),
      FeatureItem_ (::xml_schema::flags (), this)
    {
    }

    FeatureItemsType::
    FeatureItemsType (const FeatureItemsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureItem_ (x.FeatureItem_, f, this)
    {
    }

    FeatureItemsType::
    FeatureItemsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureItem_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void FeatureItemsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureItem
        //
        if (n.name () == "FeatureItem" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureItem_type > r (
            FeatureItem_traits::create (i, f, this));

          this->FeatureItem_.push_back (r);
          continue;
        }

        break;
      }
    }

    FeatureItemsType* FeatureItemsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureItemsType (*this, f, c);
    }

    FeatureItemsType::
    ~FeatureItemsType ()
    {
    }

    // FeatureActualsType
    //

    FeatureActualsType::
    FeatureActualsType ()
    : ::xml_schema::type (),
      FeatureActual_ (::xml_schema::flags (), this)
    {
    }

    FeatureActualsType::
    FeatureActualsType (const FeatureActualsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureActual_ (x.FeatureActual_, f, this)
    {
    }

    FeatureActualsType::
    FeatureActualsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureActual_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void FeatureActualsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureActual
        //
        if (n.name () == "FeatureActual" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureActual_type > r (
            FeatureActual_traits::create (i, f, this));

          this->FeatureActual_.push_back (r);
          continue;
        }

        break;
      }
    }

    FeatureActualsType* FeatureActualsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureActualsType (*this, f, c);
    }

    FeatureActualsType::
    ~FeatureActualsType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType > r (
        ::xsd::qif2::Features (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType > r (
        ::xsd::qif2::Features (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType > r (
        ::xsd::qif2::Features (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Features (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Features (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::Features (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Features (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Features (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::Features (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType > r (
        ::xsd::qif2::Features (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType > r (
        ::xsd::qif2::Features (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType > r (
        ::xsd::qif2::Features (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType > r (
          ::xsd::qif2::Features (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "Features" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FeatureAspectsListsType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Features",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType >
    Features (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "Features" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FeatureAspectsListsType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FeatureAspectsListsType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "Features",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType > r (
        ::xsd::qif2::MeasuredFeatures (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType > r (
        ::xsd::qif2::MeasuredFeatures (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType > r (
        ::xsd::qif2::MeasuredFeatures (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasuredFeatures (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasuredFeatures (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::MeasuredFeatures (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasuredFeatures (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasuredFeatures (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::MeasuredFeatures (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType > r (
        ::xsd::qif2::MeasuredFeatures (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType > r (
        ::xsd::qif2::MeasuredFeatures (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType > r (
        ::xsd::qif2::MeasuredFeatures (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType > r (
          ::xsd::qif2::MeasuredFeatures (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "MeasuredFeatures" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::MeasuredFeaturesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MeasuredFeatures",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType >
    MeasuredFeatures (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "MeasuredFeatures" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::MeasuredFeaturesType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::MeasuredFeaturesType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "MeasuredFeatures",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType > r (
        ::xsd::qif2::FeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType > r (
        ::xsd::qif2::FeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType > r (
        ::xsd::qif2::FeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType > r (
        ::xsd::qif2::FeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType > r (
        ::xsd::qif2::FeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType > r (
        ::xsd::qif2::FeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType > r (
          ::xsd::qif2::FeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FeatureDefinitionBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType >
    FeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "FeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FeatureDefinitionBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FeatureDefinitionBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType > r (
        ::xsd::qif2::ArcFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType > r (
        ::xsd::qif2::ArcFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType > r (
        ::xsd::qif2::ArcFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType > r (
        ::xsd::qif2::ArcFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType > r (
        ::xsd::qif2::ArcFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType > r (
        ::xsd::qif2::ArcFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType > r (
          ::xsd::qif2::ArcFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ArcFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ArcFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArcFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType >
    ArcFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ArcFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ArcFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ArcFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArcFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType > r (
        ::xsd::qif2::GenericFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType > r (
        ::xsd::qif2::GenericFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType > r (
        ::xsd::qif2::GenericFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (::xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType > r (
        ::xsd::qif2::GenericFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (::xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType > r (
        ::xsd::qif2::GenericFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType > r (
        ::xsd::qif2::GenericFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (const ::xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType > r (
          ::xsd::qif2::GenericFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "GenericFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::GenericFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GenericFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType >
    GenericFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "GenericFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::GenericFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::GenericFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GenericFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (const ::std::string& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType > r (
        ::xsd::qif2::CircleFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (const ::std::string& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType > r (
        ::xsd::qif2::CircleFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType > r (
        ::xsd::qif2::CircleFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (::xercesc::InputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType > r (
        ::xsd::qif2::CircleFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (::xercesc::InputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType > r (
        ::xsd::qif2::CircleFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType > r (
        ::xsd::qif2::CircleFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (const ::xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType > r (
          ::xsd::qif2::CircleFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CircleFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CircleFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CircleFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType >
    CircleFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CircleFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CircleFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CircleFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CircleFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType > r (
        ::xsd::qif2::CompoundFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType > r (
        ::xsd::qif2::CompoundFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (const ::std::string& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType > r (
        ::xsd::qif2::CompoundFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (::std::istream& is,
                               const ::std::string& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (::xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType > r (
        ::xsd::qif2::CompoundFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (::xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType > r (
        ::xsd::qif2::CompoundFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (::xercesc::InputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType > r (
        ::xsd::qif2::CompoundFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (const ::xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType > r (
          ::xsd::qif2::CompoundFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CompoundFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CompoundFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CompoundFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType >
    CompoundFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CompoundFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CompoundFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CompoundFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType > r (
        ::xsd::qif2::ConeFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType > r (
        ::xsd::qif2::ConeFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType > r (
        ::xsd::qif2::ConeFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType > r (
        ::xsd::qif2::ConeFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType > r (
        ::xsd::qif2::ConeFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType > r (
        ::xsd::qif2::ConeFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType > r (
          ::xsd::qif2::ConeFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ConeFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConeFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConeFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType >
    ConeFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ConeFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConeFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConeFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConeFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ConicalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ConicalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (const ::std::string& u,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ConicalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (::std::istream& is,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ConicalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ConicalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ConicalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (const ::xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType > r (
          ::xsd::qif2::ConicalSegmentFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ConicalSegmentFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConicalSegmentFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConicalSegmentFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    ConicalSegmentFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ConicalSegmentFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConicalSegmentFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConicalSegmentFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (const ::std::string& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType > r (
        ::xsd::qif2::CuboidFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (const ::std::string& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType > r (
        ::xsd::qif2::CuboidFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType > r (
        ::xsd::qif2::CuboidFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (::xercesc::InputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType > r (
        ::xsd::qif2::CuboidFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (::xercesc::InputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType > r (
        ::xsd::qif2::CuboidFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType > r (
        ::xsd::qif2::CuboidFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (const ::xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType > r (
          ::xsd::qif2::CuboidFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CuboidFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CuboidFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CuboidFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType >
    CuboidFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CuboidFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CuboidFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CuboidFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType > r (
        ::xsd::qif2::CylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType > r (
        ::xsd::qif2::CylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (const ::std::string& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType > r (
        ::xsd::qif2::CylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (::std::istream& is,
                               const ::std::string& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (::xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType > r (
        ::xsd::qif2::CylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (::xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType > r (
        ::xsd::qif2::CylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (::xercesc::InputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType > r (
        ::xsd::qif2::CylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (const ::xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType > r (
          ::xsd::qif2::CylinderFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CylinderFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylinderFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylinderFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType >
    CylinderFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CylinderFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylinderFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylinderFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (const ::std::string& u,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::CylindricalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (const ::std::string& u,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::CylindricalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (const ::std::string& u,
                                         ::xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::CylindricalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (::std::istream& is,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (::std::istream& is,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (::std::istream& is,
                                         ::xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (::std::istream& is,
                                         const ::std::string& sid,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (::std::istream& is,
                                         const ::std::string& sid,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (::std::istream& is,
                                         const ::std::string& sid,
                                         ::xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::CylindricalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                         ::xml_schema::error_handler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::CylindricalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                         ::xercesc::DOMErrorHandler& h,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::CylindricalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (const ::xercesc::DOMDocument& d,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType > r (
          ::xsd::qif2::CylindricalSegmentFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CylindricalSegmentFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylindricalSegmentFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    CylindricalSegmentFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                         ::xml_schema::flags f,
                                         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CylindricalSegmentFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylindricalSegmentFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylindricalSegmentFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType > r (
        ::xsd::qif2::EdgePointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType > r (
        ::xsd::qif2::EdgePointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (const ::std::string& u,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType > r (
        ::xsd::qif2::EdgePointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (::std::istream& is,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (::std::istream& is,
                                const ::std::string& sid,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (::xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType > r (
        ::xsd::qif2::EdgePointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (::xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType > r (
        ::xsd::qif2::EdgePointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (::xercesc::InputSource& i,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType > r (
        ::xsd::qif2::EdgePointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (const ::xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType > r (
          ::xsd::qif2::EdgePointFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "EdgePointFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgePointFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgePointFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType >
    EdgePointFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "EdgePointFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgePointFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgePointFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType > r (
        ::xsd::qif2::EllipseFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType > r (
        ::xsd::qif2::EllipseFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType > r (
        ::xsd::qif2::EllipseFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (::xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType > r (
        ::xsd::qif2::EllipseFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (::xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType > r (
        ::xsd::qif2::EllipseFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType > r (
        ::xsd::qif2::EllipseFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (const ::xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType > r (
          ::xsd::qif2::EllipseFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "EllipseFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EllipseFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EllipseFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType >
    EllipseFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "EllipseFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EllipseFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EllipseFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (const ::std::string& u,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType > r (
        ::xsd::qif2::ElongatedCylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (const ::std::string& u,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType > r (
        ::xsd::qif2::ElongatedCylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (const ::std::string& u,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType > r (
        ::xsd::qif2::ElongatedCylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (::std::istream& is,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (::std::istream& is,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (::std::istream& is,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (::xercesc::InputSource& i,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType > r (
        ::xsd::qif2::ElongatedCylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (::xercesc::InputSource& i,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType > r (
        ::xsd::qif2::ElongatedCylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (::xercesc::InputSource& i,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType > r (
        ::xsd::qif2::ElongatedCylinderFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (const ::xercesc::DOMDocument& d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType > r (
          ::xsd::qif2::ElongatedCylinderFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ElongatedCylinderFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ElongatedCylinderFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    ElongatedCylinderFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ElongatedCylinderFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ElongatedCylinderFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ElongatedCylinderFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (const ::std::string& u,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (const ::std::string& u,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (const ::std::string& u,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (::std::istream& is,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (::std::istream& is,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (::std::istream& is,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (::std::istream& is,
                                           const ::std::string& sid,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (::std::istream& is,
                                           const ::std::string& sid,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (::std::istream& is,
                                           const ::std::string& sid,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (::xercesc::InputSource& i,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (::xercesc::InputSource& i,
                                           ::xml_schema::error_handler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (::xercesc::InputSource& i,
                                           ::xercesc::DOMErrorHandler& h,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (const ::xercesc::DOMDocument& d,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType > r (
          ::xsd::qif2::ExtrudedCrossSectionFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ExtrudedCrossSectionFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ExtrudedCrossSectionFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    ExtrudedCrossSectionFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                           ::xml_schema::flags f,
                                           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ExtrudedCrossSectionFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ExtrudedCrossSectionFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType > r (
        ::xsd::qif2::LineFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType > r (
        ::xsd::qif2::LineFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType > r (
        ::xsd::qif2::LineFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType > r (
        ::xsd::qif2::LineFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType > r (
        ::xsd::qif2::LineFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType > r (
        ::xsd::qif2::LineFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType > r (
          ::xsd::qif2::LineFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "LineFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LineFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LineFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType >
    LineFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "LineFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LineFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LineFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LineFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType > r (
        ::xsd::qif2::OppositeLinesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType > r (
        ::xsd::qif2::OppositeLinesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (const ::std::string& u,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType > r (
        ::xsd::qif2::OppositeLinesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (::std::istream& is,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (::xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType > r (
        ::xsd::qif2::OppositeLinesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (::xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType > r (
        ::xsd::qif2::OppositeLinesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (::xercesc::InputSource& i,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType > r (
        ::xsd::qif2::OppositeLinesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (const ::xercesc::DOMDocument& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType > r (
          ::xsd::qif2::OppositeLinesFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "OppositeLinesFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositeLinesFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositeLinesFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    OppositeLinesFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "OppositeLinesFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositeLinesFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositeLinesFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType > r (
        ::xsd::qif2::OppositePlanesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType > r (
        ::xsd::qif2::OppositePlanesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (const ::std::string& u,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType > r (
        ::xsd::qif2::OppositePlanesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (::std::istream& is,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (::xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType > r (
        ::xsd::qif2::OppositePlanesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (::xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType > r (
        ::xsd::qif2::OppositePlanesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (::xercesc::InputSource& i,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType > r (
        ::xsd::qif2::OppositePlanesFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (const ::xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType > r (
          ::xsd::qif2::OppositePlanesFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "OppositePlanesFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositePlanesFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositePlanesFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    OppositePlanesFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "OppositePlanesFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositePlanesFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositePlanesFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType > r (
        ::xsd::qif2::PatternFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType > r (
        ::xsd::qif2::PatternFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType > r (
        ::xsd::qif2::PatternFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (::xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType > r (
        ::xsd::qif2::PatternFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (::xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType > r (
        ::xsd::qif2::PatternFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType > r (
        ::xsd::qif2::PatternFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (const ::xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType > r (
          ::xsd::qif2::PatternFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PatternFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PatternFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PatternFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType >
    PatternFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PatternFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PatternFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PatternFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PatternFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType > r (
        ::xsd::qif2::PlaneFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType > r (
        ::xsd::qif2::PlaneFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType > r (
        ::xsd::qif2::PlaneFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (::xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType > r (
        ::xsd::qif2::PlaneFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (::xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType > r (
        ::xsd::qif2::PlaneFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType > r (
        ::xsd::qif2::PlaneFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (const ::xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType > r (
          ::xsd::qif2::PlaneFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PlaneFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PlaneFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PlaneFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType >
    PlaneFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PlaneFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PlaneFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PlaneFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (const ::std::string& u,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedCurveFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (const ::std::string& u,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedCurveFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (const ::std::string& u,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedCurveFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (::std::istream& is,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (::std::istream& is,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (::std::istream& is,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (::xercesc::InputSource& i,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedCurveFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (::xercesc::InputSource& i,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedCurveFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (::xercesc::InputSource& i,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedCurveFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (const ::xercesc::DOMDocument& d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType > r (
          ::xsd::qif2::PointDefinedCurveFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointDefinedCurveFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedCurveFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    PointDefinedCurveFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointDefinedCurveFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedCurveFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedCurveFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (const ::std::string& u,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (const ::std::string& u,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (const ::std::string& u,
                                          ::xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (::std::istream& is,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (::std::istream& is,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (::std::istream& is,
                                          ::xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (::std::istream& is,
                                          const ::std::string& sid,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (::std::istream& is,
                                          const ::std::string& sid,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (::std::istream& is,
                                          const ::std::string& sid,
                                          ::xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (::xercesc::InputSource& i,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (::xercesc::InputSource& i,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (::xercesc::InputSource& i,
                                          ::xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (const ::xercesc::DOMDocument& d,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType > r (
          ::xsd::qif2::PointDefinedSurfaceFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointDefinedSurfaceFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedSurfaceFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    PointDefinedSurfaceFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointDefinedSurfaceFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedSurfaceFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType > r (
        ::xsd::qif2::PointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType > r (
        ::xsd::qif2::PointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType > r (
        ::xsd::qif2::PointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (::xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType > r (
        ::xsd::qif2::PointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (::xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType > r (
        ::xsd::qif2::PointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType > r (
        ::xsd::qif2::PointFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (const ::xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType > r (
          ::xsd::qif2::PointFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType >
    PointFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (const ::std::string& u,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType > r (
        ::xsd::qif2::ProfileGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (const ::std::string& u,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType > r (
        ::xsd::qif2::ProfileGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (const ::std::string& u,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType > r (
        ::xsd::qif2::ProfileGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (::std::istream& is,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (::std::istream& is,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (::std::istream& is,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (::xercesc::InputSource& i,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType > r (
        ::xsd::qif2::ProfileGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (::xercesc::InputSource& i,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType > r (
        ::xsd::qif2::ProfileGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (::xercesc::InputSource& i,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType > r (
        ::xsd::qif2::ProfileGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (const ::xercesc::DOMDocument& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType > r (
          ::xsd::qif2::ProfileGroupFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ProfileGroupFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ProfileGroupFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProfileGroupFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    ProfileGroupFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ProfileGroupFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ProfileGroupFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProfileGroupFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType > r (
        ::xsd::qif2::RunoutGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType > r (
        ::xsd::qif2::RunoutGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType > r (
        ::xsd::qif2::RunoutGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (::xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType > r (
        ::xsd::qif2::RunoutGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (::xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType > r (
        ::xsd::qif2::RunoutGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType > r (
        ::xsd::qif2::RunoutGroupFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (const ::xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType > r (
          ::xsd::qif2::RunoutGroupFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "RunoutGroupFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::RunoutGroupFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "RunoutGroupFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    RunoutGroupFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "RunoutGroupFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::RunoutGroupFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "RunoutGroupFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (const ::std::string& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType > r (
        ::xsd::qif2::SphereFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (const ::std::string& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType > r (
        ::xsd::qif2::SphereFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType > r (
        ::xsd::qif2::SphereFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (::xercesc::InputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType > r (
        ::xsd::qif2::SphereFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (::xercesc::InputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType > r (
        ::xsd::qif2::SphereFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType > r (
        ::xsd::qif2::SphereFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (const ::xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType > r (
          ::xsd::qif2::SphereFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SphereFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphereFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphereFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType >
    SphereFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SphereFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphereFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphereFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphereFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (const ::std::string& u,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::SphericalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (const ::std::string& u,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::SphericalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (const ::std::string& u,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::SphericalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (::std::istream& is,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (::std::istream& is,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (::std::istream& is,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::SphericalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::SphericalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::SphericalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (const ::xercesc::DOMDocument& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType > r (
          ::xsd::qif2::SphericalSegmentFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SphericalSegmentFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphericalSegmentFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphericalSegmentFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    SphericalSegmentFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SphericalSegmentFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphericalSegmentFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphericalSegmentFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (const ::std::string& u,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (const ::std::string& u,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (const ::std::string& u,
                                          ::xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (::std::istream& is,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (::std::istream& is,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (::std::istream& is,
                                          ::xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (::std::istream& is,
                                          const ::std::string& sid,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (::std::istream& is,
                                          const ::std::string& sid,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (::std::istream& is,
                                          const ::std::string& sid,
                                          ::xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (::xercesc::InputSource& i,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (::xercesc::InputSource& i,
                                          ::xml_schema::error_handler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (::xercesc::InputSource& i,
                                          ::xercesc::DOMErrorHandler& h,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (const ::xercesc::DOMDocument& d,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType > r (
          ::xsd::qif2::SurfaceOfRevolutionFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SurfaceOfRevolutionFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SurfaceOfRevolutionFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    SurfaceOfRevolutionFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                          ::xml_schema::flags f,
                                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SurfaceOfRevolutionFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SurfaceOfRevolutionFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType > r (
        ::xsd::qif2::ThreadedFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType > r (
        ::xsd::qif2::ThreadedFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (const ::std::string& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType > r (
        ::xsd::qif2::ThreadedFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (::std::istream& is,
                               const ::std::string& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (::xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType > r (
        ::xsd::qif2::ThreadedFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (::xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType > r (
        ::xsd::qif2::ThreadedFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (::xercesc::InputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType > r (
        ::xsd::qif2::ThreadedFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (const ::xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType > r (
          ::xsd::qif2::ThreadedFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ThreadedFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ThreadedFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThreadedFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType >
    ThreadedFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ThreadedFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ThreadedFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThreadedFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (const ::std::string& u,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ToroidalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (const ::std::string& u,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ToroidalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (const ::std::string& u,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ToroidalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (::std::istream& is,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (::std::istream& is,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (::std::istream& is,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ToroidalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ToroidalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (::xercesc::InputSource& i,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType > r (
        ::xsd::qif2::ToroidalSegmentFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (const ::xercesc::DOMDocument& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType > r (
          ::xsd::qif2::ToroidalSegmentFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ToroidalSegmentFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ToroidalSegmentFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    ToroidalSegmentFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ToroidalSegmentFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ToroidalSegmentFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ToroidalSegmentFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType > r (
        ::xsd::qif2::TorusFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType > r (
        ::xsd::qif2::TorusFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType > r (
        ::xsd::qif2::TorusFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureDefinition (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureDefinition (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (::xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType > r (
        ::xsd::qif2::TorusFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (::xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType > r (
        ::xsd::qif2::TorusFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType > r (
        ::xsd::qif2::TorusFeatureDefinition (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (const ::xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType > r (
          ::xsd::qif2::TorusFeatureDefinition (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "TorusFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TorusFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TorusFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType >
    TorusFeatureDefinition (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "TorusFeatureDefinition" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TorusFeatureDefinitionType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TorusFeatureDefinitionType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TorusFeatureDefinition",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType > r (
        ::xsd::qif2::FeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType > r (
        ::xsd::qif2::FeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType > r (
        ::xsd::qif2::FeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType > r (
        ::xsd::qif2::FeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType > r (
        ::xsd::qif2::FeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType > r (
        ::xsd::qif2::FeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType > r (
          ::xsd::qif2::FeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FeatureNominalBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType >
    FeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "FeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FeatureNominalBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FeatureNominalBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType > r (
        ::xsd::qif2::ArcFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType > r (
        ::xsd::qif2::ArcFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType > r (
        ::xsd::qif2::ArcFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType > r (
        ::xsd::qif2::ArcFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType > r (
        ::xsd::qif2::ArcFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType > r (
        ::xsd::qif2::ArcFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType > r (
          ::xsd::qif2::ArcFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ArcFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ArcFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArcFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType >
    ArcFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ArcFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ArcFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ArcFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArcFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType > r (
        ::xsd::qif2::GenericFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType > r (
        ::xsd::qif2::GenericFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType > r (
        ::xsd::qif2::GenericFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType > r (
        ::xsd::qif2::GenericFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType > r (
        ::xsd::qif2::GenericFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType > r (
        ::xsd::qif2::GenericFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType > r (
          ::xsd::qif2::GenericFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "GenericFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::GenericFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GenericFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType >
    GenericFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "GenericFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::GenericFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::GenericFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GenericFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType > r (
        ::xsd::qif2::CircleFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType > r (
        ::xsd::qif2::CircleFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType > r (
        ::xsd::qif2::CircleFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType > r (
        ::xsd::qif2::CircleFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType > r (
        ::xsd::qif2::CircleFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType > r (
        ::xsd::qif2::CircleFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType > r (
          ::xsd::qif2::CircleFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CircleFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CircleFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CircleFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType >
    CircleFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CircleFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CircleFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CircleFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CircleFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType > r (
        ::xsd::qif2::CompoundFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType > r (
        ::xsd::qif2::CompoundFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType > r (
        ::xsd::qif2::CompoundFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (::xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType > r (
        ::xsd::qif2::CompoundFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (::xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType > r (
        ::xsd::qif2::CompoundFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType > r (
        ::xsd::qif2::CompoundFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (const ::xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType > r (
          ::xsd::qif2::CompoundFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CompoundFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CompoundFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CompoundFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType >
    CompoundFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CompoundFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CompoundFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CompoundFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType > r (
        ::xsd::qif2::ConeFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType > r (
        ::xsd::qif2::ConeFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType > r (
        ::xsd::qif2::ConeFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType > r (
        ::xsd::qif2::ConeFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType > r (
        ::xsd::qif2::ConeFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType > r (
        ::xsd::qif2::ConeFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType > r (
          ::xsd::qif2::ConeFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ConeFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConeFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConeFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType >
    ConeFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ConeFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConeFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConeFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConeFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType > r (
        ::xsd::qif2::ConicalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType > r (
        ::xsd::qif2::ConicalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType > r (
        ::xsd::qif2::ConicalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (::xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType > r (
        ::xsd::qif2::ConicalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (::xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType > r (
        ::xsd::qif2::ConicalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType > r (
        ::xsd::qif2::ConicalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (const ::xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType > r (
          ::xsd::qif2::ConicalSegmentFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ConicalSegmentFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConicalSegmentFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConicalSegmentFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType >
    ConicalSegmentFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ConicalSegmentFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConicalSegmentFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConicalSegmentFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType > r (
        ::xsd::qif2::CuboidFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType > r (
        ::xsd::qif2::CuboidFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType > r (
        ::xsd::qif2::CuboidFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType > r (
        ::xsd::qif2::CuboidFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType > r (
        ::xsd::qif2::CuboidFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType > r (
        ::xsd::qif2::CuboidFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType > r (
          ::xsd::qif2::CuboidFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CuboidFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CuboidFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CuboidFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType >
    CuboidFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CuboidFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CuboidFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CuboidFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType > r (
        ::xsd::qif2::CylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType > r (
        ::xsd::qif2::CylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType > r (
        ::xsd::qif2::CylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (::xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType > r (
        ::xsd::qif2::CylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (::xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType > r (
        ::xsd::qif2::CylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType > r (
        ::xsd::qif2::CylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (const ::xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType > r (
          ::xsd::qif2::CylinderFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CylinderFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylinderFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylinderFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType >
    CylinderFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CylinderFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylinderFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylinderFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (const ::std::string& u,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType > r (
        ::xsd::qif2::CylindricalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (const ::std::string& u,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType > r (
        ::xsd::qif2::CylindricalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (const ::std::string& u,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType > r (
        ::xsd::qif2::CylindricalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (::std::istream& is,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (::std::istream& is,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (::std::istream& is,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (::xercesc::InputSource& i,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType > r (
        ::xsd::qif2::CylindricalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (::xercesc::InputSource& i,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType > r (
        ::xsd::qif2::CylindricalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (::xercesc::InputSource& i,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType > r (
        ::xsd::qif2::CylindricalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (const ::xercesc::DOMDocument& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType > r (
          ::xsd::qif2::CylindricalSegmentFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CylindricalSegmentFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylindricalSegmentFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylindricalSegmentFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    CylindricalSegmentFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CylindricalSegmentFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylindricalSegmentFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylindricalSegmentFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (const ::std::string& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType > r (
        ::xsd::qif2::EdgePointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (const ::std::string& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType > r (
        ::xsd::qif2::EdgePointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType > r (
        ::xsd::qif2::EdgePointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (::xercesc::InputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType > r (
        ::xsd::qif2::EdgePointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (::xercesc::InputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType > r (
        ::xsd::qif2::EdgePointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType > r (
        ::xsd::qif2::EdgePointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (const ::xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType > r (
          ::xsd::qif2::EdgePointFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "EdgePointFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgePointFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgePointFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType >
    EdgePointFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "EdgePointFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgePointFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgePointFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType > r (
        ::xsd::qif2::EllipseFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType > r (
        ::xsd::qif2::EllipseFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType > r (
        ::xsd::qif2::EllipseFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType > r (
        ::xsd::qif2::EllipseFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType > r (
        ::xsd::qif2::EllipseFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType > r (
        ::xsd::qif2::EllipseFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType > r (
          ::xsd::qif2::EllipseFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "EllipseFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EllipseFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EllipseFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType >
    EllipseFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "EllipseFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EllipseFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EllipseFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType > r (
        ::xsd::qif2::ElongatedCylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType > r (
        ::xsd::qif2::ElongatedCylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (const ::std::string& u,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType > r (
        ::xsd::qif2::ElongatedCylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (::std::istream& is,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (::xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType > r (
        ::xsd::qif2::ElongatedCylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (::xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType > r (
        ::xsd::qif2::ElongatedCylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (::xercesc::InputSource& i,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType > r (
        ::xsd::qif2::ElongatedCylinderFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (const ::xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType > r (
          ::xsd::qif2::ElongatedCylinderFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ElongatedCylinderFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ElongatedCylinderFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ElongatedCylinderFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    ElongatedCylinderFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ElongatedCylinderFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ElongatedCylinderFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ElongatedCylinderFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (const ::std::string& u,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (const ::std::string& u,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (const ::std::string& u,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (::std::istream& is,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (::std::istream& is,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (::std::istream& is,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (::std::istream& is,
                                        const ::std::string& sid,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (::xercesc::InputSource& i,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (::xercesc::InputSource& i,
                                        ::xml_schema::error_handler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (::xercesc::InputSource& i,
                                        ::xercesc::DOMErrorHandler& h,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (const ::xercesc::DOMDocument& d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType > r (
          ::xsd::qif2::ExtrudedCrossSectionFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ExtrudedCrossSectionFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ExtrudedCrossSectionFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    ExtrudedCrossSectionFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                        ::xml_schema::flags f,
                                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ExtrudedCrossSectionFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ExtrudedCrossSectionFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType > r (
        ::xsd::qif2::LineFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType > r (
        ::xsd::qif2::LineFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType > r (
        ::xsd::qif2::LineFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType > r (
        ::xsd::qif2::LineFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType > r (
        ::xsd::qif2::LineFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType > r (
        ::xsd::qif2::LineFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType > r (
          ::xsd::qif2::LineFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "LineFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LineFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LineFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType >
    LineFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "LineFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LineFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LineFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LineFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType > r (
        ::xsd::qif2::PatternFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType > r (
        ::xsd::qif2::PatternFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType > r (
        ::xsd::qif2::PatternFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType > r (
        ::xsd::qif2::PatternFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType > r (
        ::xsd::qif2::PatternFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType > r (
        ::xsd::qif2::PatternFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType > r (
          ::xsd::qif2::PatternFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PatternFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PatternFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PatternFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType >
    PatternFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PatternFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PatternFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PatternFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PatternFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType > r (
        ::xsd::qif2::PlaneFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType > r (
        ::xsd::qif2::PlaneFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType > r (
        ::xsd::qif2::PlaneFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType > r (
        ::xsd::qif2::PlaneFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType > r (
        ::xsd::qif2::PlaneFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType > r (
        ::xsd::qif2::PlaneFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType > r (
          ::xsd::qif2::PlaneFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PlaneFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PlaneFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PlaneFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType >
    PlaneFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PlaneFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PlaneFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PlaneFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType > r (
        ::xsd::qif2::PointDefinedCurveFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType > r (
        ::xsd::qif2::PointDefinedCurveFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (const ::std::string& u,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType > r (
        ::xsd::qif2::PointDefinedCurveFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (::std::istream& is,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (::xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType > r (
        ::xsd::qif2::PointDefinedCurveFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (::xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType > r (
        ::xsd::qif2::PointDefinedCurveFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (::xercesc::InputSource& i,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType > r (
        ::xsd::qif2::PointDefinedCurveFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (const ::xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType > r (
          ::xsd::qif2::PointDefinedCurveFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointDefinedCurveFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedCurveFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedCurveFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    PointDefinedCurveFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointDefinedCurveFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedCurveFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedCurveFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (const ::std::string& u,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (const ::std::string& u,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (const ::std::string& u,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (::std::istream& is,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (::std::istream& is,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (::std::istream& is,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (::xercesc::InputSource& i,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (::xercesc::InputSource& i,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (::xercesc::InputSource& i,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (const ::xercesc::DOMDocument& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType > r (
          ::xsd::qif2::PointDefinedSurfaceFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointDefinedSurfaceFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedSurfaceFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    PointDefinedSurfaceFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointDefinedSurfaceFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedSurfaceFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedSurfaceFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType > r (
        ::xsd::qif2::PointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType > r (
        ::xsd::qif2::PointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType > r (
        ::xsd::qif2::PointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType > r (
        ::xsd::qif2::PointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType > r (
        ::xsd::qif2::PointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType > r (
        ::xsd::qif2::PointFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType > r (
          ::xsd::qif2::PointFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType >
    PointFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType > r (
        ::xsd::qif2::OppositeLinesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType > r (
        ::xsd::qif2::OppositeLinesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (const ::std::string& u,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType > r (
        ::xsd::qif2::OppositeLinesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (::std::istream& is,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (::xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType > r (
        ::xsd::qif2::OppositeLinesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (::xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType > r (
        ::xsd::qif2::OppositeLinesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (::xercesc::InputSource& i,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType > r (
        ::xsd::qif2::OppositeLinesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (const ::xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType > r (
          ::xsd::qif2::OppositeLinesFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "OppositeLinesFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositeLinesFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositeLinesFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType >
    OppositeLinesFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "OppositeLinesFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositeLinesFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositeLinesFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType > r (
        ::xsd::qif2::OppositePlanesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType > r (
        ::xsd::qif2::OppositePlanesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType > r (
        ::xsd::qif2::OppositePlanesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (::xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType > r (
        ::xsd::qif2::OppositePlanesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (::xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType > r (
        ::xsd::qif2::OppositePlanesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType > r (
        ::xsd::qif2::OppositePlanesFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (const ::xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType > r (
          ::xsd::qif2::OppositePlanesFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "OppositePlanesFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositePlanesFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositePlanesFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType >
    OppositePlanesFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "OppositePlanesFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositePlanesFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositePlanesFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType > r (
        ::xsd::qif2::ProfileGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType > r (
        ::xsd::qif2::ProfileGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (const ::std::string& u,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType > r (
        ::xsd::qif2::ProfileGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (::std::istream& is,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (::std::istream& is,
                                const ::std::string& sid,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (::xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType > r (
        ::xsd::qif2::ProfileGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (::xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType > r (
        ::xsd::qif2::ProfileGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (::xercesc::InputSource& i,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType > r (
        ::xsd::qif2::ProfileGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (const ::xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType > r (
          ::xsd::qif2::ProfileGroupFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ProfileGroupFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ProfileGroupFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProfileGroupFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType >
    ProfileGroupFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ProfileGroupFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ProfileGroupFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProfileGroupFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType > r (
        ::xsd::qif2::RunoutGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType > r (
        ::xsd::qif2::RunoutGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (const ::std::string& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType > r (
        ::xsd::qif2::RunoutGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (::std::istream& is,
                               const ::std::string& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (::xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType > r (
        ::xsd::qif2::RunoutGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (::xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType > r (
        ::xsd::qif2::RunoutGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (::xercesc::InputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType > r (
        ::xsd::qif2::RunoutGroupFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (const ::xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType > r (
          ::xsd::qif2::RunoutGroupFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "RunoutGroupFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::RunoutGroupFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "RunoutGroupFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType >
    RunoutGroupFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "RunoutGroupFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::RunoutGroupFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "RunoutGroupFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType > r (
        ::xsd::qif2::SphereFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType > r (
        ::xsd::qif2::SphereFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType > r (
        ::xsd::qif2::SphereFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType > r (
        ::xsd::qif2::SphereFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType > r (
        ::xsd::qif2::SphereFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType > r (
        ::xsd::qif2::SphereFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType > r (
          ::xsd::qif2::SphereFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SphereFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphereFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphereFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType >
    SphereFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SphereFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphereFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphereFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphereFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType > r (
        ::xsd::qif2::SphericalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType > r (
        ::xsd::qif2::SphericalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (const ::std::string& u,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType > r (
        ::xsd::qif2::SphericalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (::std::istream& is,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (::xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType > r (
        ::xsd::qif2::SphericalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (::xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType > r (
        ::xsd::qif2::SphericalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (::xercesc::InputSource& i,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType > r (
        ::xsd::qif2::SphericalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (const ::xercesc::DOMDocument& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType > r (
          ::xsd::qif2::SphericalSegmentFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SphericalSegmentFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphericalSegmentFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphericalSegmentFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType >
    SphericalSegmentFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SphericalSegmentFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphericalSegmentFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphericalSegmentFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (const ::std::string& u,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (const ::std::string& u,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (const ::std::string& u,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (::std::istream& is,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (::std::istream& is,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (::std::istream& is,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (::xercesc::InputSource& i,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (::xercesc::InputSource& i,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (::xercesc::InputSource& i,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (const ::xercesc::DOMDocument& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType > r (
          ::xsd::qif2::SurfaceOfRevolutionFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SurfaceOfRevolutionFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SurfaceOfRevolutionFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    SurfaceOfRevolutionFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SurfaceOfRevolutionFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SurfaceOfRevolutionFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType > r (
        ::xsd::qif2::ThreadedFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType > r (
        ::xsd::qif2::ThreadedFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType > r (
        ::xsd::qif2::ThreadedFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (::xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType > r (
        ::xsd::qif2::ThreadedFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (::xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType > r (
        ::xsd::qif2::ThreadedFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType > r (
        ::xsd::qif2::ThreadedFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (const ::xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType > r (
          ::xsd::qif2::ThreadedFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ThreadedFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ThreadedFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThreadedFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType >
    ThreadedFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ThreadedFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ThreadedFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThreadedFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (const ::std::string& u,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType > r (
        ::xsd::qif2::ToroidalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (const ::std::string& u,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType > r (
        ::xsd::qif2::ToroidalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (const ::std::string& u,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType > r (
        ::xsd::qif2::ToroidalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (::std::istream& is,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (::std::istream& is,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (::std::istream& is,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (::xercesc::InputSource& i,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType > r (
        ::xsd::qif2::ToroidalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (::xercesc::InputSource& i,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType > r (
        ::xsd::qif2::ToroidalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (::xercesc::InputSource& i,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType > r (
        ::xsd::qif2::ToroidalSegmentFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (const ::xercesc::DOMDocument& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType > r (
          ::xsd::qif2::ToroidalSegmentFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ToroidalSegmentFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ToroidalSegmentFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ToroidalSegmentFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    ToroidalSegmentFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ToroidalSegmentFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ToroidalSegmentFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ToroidalSegmentFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType > r (
        ::xsd::qif2::TorusFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType > r (
        ::xsd::qif2::TorusFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType > r (
        ::xsd::qif2::TorusFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureNominal (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureNominal (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType > r (
        ::xsd::qif2::TorusFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType > r (
        ::xsd::qif2::TorusFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType > r (
        ::xsd::qif2::TorusFeatureNominal (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType > r (
          ::xsd::qif2::TorusFeatureNominal (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "TorusFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TorusFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TorusFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType >
    TorusFeatureNominal (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "TorusFeatureNominal" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TorusFeatureNominalType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TorusFeatureNominalType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TorusFeatureNominal",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType > r (
        ::xsd::qif2::FeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType > r (
        ::xsd::qif2::FeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType > r (
        ::xsd::qif2::FeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType > r (
        ::xsd::qif2::FeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType > r (
        ::xsd::qif2::FeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType > r (
        ::xsd::qif2::FeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType > r (
          ::xsd::qif2::FeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FeatureActualBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType >
    FeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "FeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FeatureActualBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FeatureActualBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType > r (
        ::xsd::qif2::ArcFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType > r (
        ::xsd::qif2::ArcFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType > r (
        ::xsd::qif2::ArcFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType > r (
        ::xsd::qif2::ArcFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType > r (
        ::xsd::qif2::ArcFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType > r (
        ::xsd::qif2::ArcFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType > r (
          ::xsd::qif2::ArcFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ArcFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ArcFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArcFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType >
    ArcFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ArcFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ArcFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ArcFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArcFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType > r (
        ::xsd::qif2::GenericFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType > r (
        ::xsd::qif2::GenericFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType > r (
        ::xsd::qif2::GenericFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType > r (
        ::xsd::qif2::GenericFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType > r (
        ::xsd::qif2::GenericFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType > r (
        ::xsd::qif2::GenericFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType > r (
          ::xsd::qif2::GenericFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "GenericFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::GenericFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GenericFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType >
    GenericFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "GenericFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::GenericFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::GenericFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GenericFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType > r (
        ::xsd::qif2::CircleFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType > r (
        ::xsd::qif2::CircleFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType > r (
        ::xsd::qif2::CircleFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType > r (
        ::xsd::qif2::CircleFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType > r (
        ::xsd::qif2::CircleFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType > r (
        ::xsd::qif2::CircleFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType > r (
          ::xsd::qif2::CircleFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CircleFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CircleFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CircleFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType >
    CircleFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CircleFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CircleFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CircleFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CircleFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType > r (
        ::xsd::qif2::CompoundFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType > r (
        ::xsd::qif2::CompoundFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType > r (
        ::xsd::qif2::CompoundFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType > r (
        ::xsd::qif2::CompoundFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType > r (
        ::xsd::qif2::CompoundFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType > r (
        ::xsd::qif2::CompoundFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType > r (
          ::xsd::qif2::CompoundFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CompoundFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CompoundFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CompoundFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType >
    CompoundFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CompoundFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CompoundFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CompoundFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType > r (
        ::xsd::qif2::ConeFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType > r (
        ::xsd::qif2::ConeFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType > r (
        ::xsd::qif2::ConeFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType > r (
        ::xsd::qif2::ConeFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType > r (
        ::xsd::qif2::ConeFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType > r (
        ::xsd::qif2::ConeFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType > r (
          ::xsd::qif2::ConeFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ConeFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConeFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConeFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType >
    ConeFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ConeFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConeFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConeFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConeFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType > r (
        ::xsd::qif2::ConicalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType > r (
        ::xsd::qif2::ConicalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (const ::std::string& u,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType > r (
        ::xsd::qif2::ConicalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (::std::istream& is,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (::xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType > r (
        ::xsd::qif2::ConicalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (::xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType > r (
        ::xsd::qif2::ConicalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (::xercesc::InputSource& i,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType > r (
        ::xsd::qif2::ConicalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (const ::xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType > r (
          ::xsd::qif2::ConicalSegmentFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ConicalSegmentFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConicalSegmentFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConicalSegmentFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType >
    ConicalSegmentFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ConicalSegmentFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConicalSegmentFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConicalSegmentFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType > r (
        ::xsd::qif2::CuboidFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType > r (
        ::xsd::qif2::CuboidFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType > r (
        ::xsd::qif2::CuboidFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType > r (
        ::xsd::qif2::CuboidFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType > r (
        ::xsd::qif2::CuboidFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType > r (
        ::xsd::qif2::CuboidFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType > r (
          ::xsd::qif2::CuboidFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CuboidFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CuboidFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CuboidFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType >
    CuboidFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CuboidFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CuboidFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CuboidFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType > r (
        ::xsd::qif2::CylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType > r (
        ::xsd::qif2::CylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType > r (
        ::xsd::qif2::CylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType > r (
        ::xsd::qif2::CylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType > r (
        ::xsd::qif2::CylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType > r (
        ::xsd::qif2::CylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType > r (
          ::xsd::qif2::CylinderFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CylinderFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylinderFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylinderFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType >
    CylinderFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CylinderFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylinderFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylinderFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType > r (
        ::xsd::qif2::CylindricalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType > r (
        ::xsd::qif2::CylindricalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (const ::std::string& u,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType > r (
        ::xsd::qif2::CylindricalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (::std::istream& is,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (::xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType > r (
        ::xsd::qif2::CylindricalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (::xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType > r (
        ::xsd::qif2::CylindricalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (::xercesc::InputSource& i,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType > r (
        ::xsd::qif2::CylindricalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (const ::xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType > r (
          ::xsd::qif2::CylindricalSegmentFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CylindricalSegmentFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylindricalSegmentFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylindricalSegmentFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType >
    CylindricalSegmentFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CylindricalSegmentFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylindricalSegmentFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylindricalSegmentFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType > r (
        ::xsd::qif2::EdgePointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType > r (
        ::xsd::qif2::EdgePointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType > r (
        ::xsd::qif2::EdgePointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (::xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType > r (
        ::xsd::qif2::EdgePointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (::xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType > r (
        ::xsd::qif2::EdgePointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType > r (
        ::xsd::qif2::EdgePointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (const ::xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType > r (
          ::xsd::qif2::EdgePointFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "EdgePointFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgePointFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgePointFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType >
    EdgePointFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "EdgePointFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgePointFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgePointFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType > r (
        ::xsd::qif2::EllipseFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType > r (
        ::xsd::qif2::EllipseFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType > r (
        ::xsd::qif2::EllipseFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType > r (
        ::xsd::qif2::EllipseFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType > r (
        ::xsd::qif2::EllipseFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType > r (
        ::xsd::qif2::EllipseFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType > r (
          ::xsd::qif2::EllipseFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "EllipseFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EllipseFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EllipseFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType >
    EllipseFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "EllipseFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EllipseFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EllipseFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType > r (
        ::xsd::qif2::ElongatedCylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType > r (
        ::xsd::qif2::ElongatedCylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (const ::std::string& u,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType > r (
        ::xsd::qif2::ElongatedCylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (::std::istream& is,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (::xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType > r (
        ::xsd::qif2::ElongatedCylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (::xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType > r (
        ::xsd::qif2::ElongatedCylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (::xercesc::InputSource& i,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType > r (
        ::xsd::qif2::ElongatedCylinderFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (const ::xercesc::DOMDocument& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType > r (
          ::xsd::qif2::ElongatedCylinderFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ElongatedCylinderFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ElongatedCylinderFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ElongatedCylinderFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType >
    ElongatedCylinderFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ElongatedCylinderFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ElongatedCylinderFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ElongatedCylinderFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (const ::std::string& u,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (const ::std::string& u,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (const ::std::string& u,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (::std::istream& is,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (::std::istream& is,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (::std::istream& is,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (::std::istream& is,
                                       const ::std::string& sid,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (::xercesc::InputSource& i,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (::xercesc::InputSource& i,
                                       ::xml_schema::error_handler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (::xercesc::InputSource& i,
                                       ::xercesc::DOMErrorHandler& h,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (const ::xercesc::DOMDocument& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType > r (
          ::xsd::qif2::ExtrudedCrossSectionFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ExtrudedCrossSectionFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ExtrudedCrossSectionFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    ExtrudedCrossSectionFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                       ::xml_schema::flags f,
                                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ExtrudedCrossSectionFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ExtrudedCrossSectionFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ExtrudedCrossSectionFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType > r (
        ::xsd::qif2::LineFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType > r (
        ::xsd::qif2::LineFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType > r (
        ::xsd::qif2::LineFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType > r (
        ::xsd::qif2::LineFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType > r (
        ::xsd::qif2::LineFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType > r (
        ::xsd::qif2::LineFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType > r (
          ::xsd::qif2::LineFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "LineFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LineFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LineFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType >
    LineFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "LineFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LineFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LineFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LineFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType > r (
        ::xsd::qif2::OppositeLinesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType > r (
        ::xsd::qif2::OppositeLinesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (const ::std::string& u,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType > r (
        ::xsd::qif2::OppositeLinesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (::std::istream& is,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (::std::istream& is,
                                const ::std::string& sid,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (::xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType > r (
        ::xsd::qif2::OppositeLinesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (::xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType > r (
        ::xsd::qif2::OppositeLinesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (::xercesc::InputSource& i,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType > r (
        ::xsd::qif2::OppositeLinesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (const ::xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType > r (
          ::xsd::qif2::OppositeLinesFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "OppositeLinesFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositeLinesFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositeLinesFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType >
    OppositeLinesFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "OppositeLinesFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositeLinesFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositeLinesFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType > r (
        ::xsd::qif2::OppositePlanesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType > r (
        ::xsd::qif2::OppositePlanesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (const ::std::string& u,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType > r (
        ::xsd::qif2::OppositePlanesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (::std::istream& is,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (::xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType > r (
        ::xsd::qif2::OppositePlanesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (::xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType > r (
        ::xsd::qif2::OppositePlanesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (::xercesc::InputSource& i,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType > r (
        ::xsd::qif2::OppositePlanesFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (const ::xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType > r (
          ::xsd::qif2::OppositePlanesFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "OppositePlanesFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositePlanesFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositePlanesFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType >
    OppositePlanesFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "OppositePlanesFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositePlanesFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositePlanesFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType > r (
        ::xsd::qif2::PatternFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType > r (
        ::xsd::qif2::PatternFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType > r (
        ::xsd::qif2::PatternFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType > r (
        ::xsd::qif2::PatternFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType > r (
        ::xsd::qif2::PatternFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType > r (
        ::xsd::qif2::PatternFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType > r (
          ::xsd::qif2::PatternFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PatternFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PatternFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PatternFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType >
    PatternFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PatternFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PatternFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PatternFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PatternFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType > r (
        ::xsd::qif2::PlaneFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType > r (
        ::xsd::qif2::PlaneFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType > r (
        ::xsd::qif2::PlaneFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType > r (
        ::xsd::qif2::PlaneFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType > r (
        ::xsd::qif2::PlaneFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType > r (
        ::xsd::qif2::PlaneFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType > r (
          ::xsd::qif2::PlaneFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PlaneFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PlaneFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PlaneFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType >
    PlaneFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PlaneFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PlaneFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PlaneFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType > r (
        ::xsd::qif2::PointDefinedCurveFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType > r (
        ::xsd::qif2::PointDefinedCurveFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (const ::std::string& u,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType > r (
        ::xsd::qif2::PointDefinedCurveFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (::std::istream& is,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (::xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType > r (
        ::xsd::qif2::PointDefinedCurveFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (::xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType > r (
        ::xsd::qif2::PointDefinedCurveFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (::xercesc::InputSource& i,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType > r (
        ::xsd::qif2::PointDefinedCurveFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (const ::xercesc::DOMDocument& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType > r (
          ::xsd::qif2::PointDefinedCurveFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointDefinedCurveFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedCurveFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedCurveFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType >
    PointDefinedCurveFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointDefinedCurveFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedCurveFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedCurveFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (const ::std::string& u,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (const ::std::string& u,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (const ::std::string& u,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (::std::istream& is,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (::std::istream& is,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (::std::istream& is,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (::xercesc::InputSource& i,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (::xercesc::InputSource& i,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (::xercesc::InputSource& i,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (const ::xercesc::DOMDocument& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType > r (
          ::xsd::qif2::PointDefinedSurfaceFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointDefinedSurfaceFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedSurfaceFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedSurfaceFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    PointDefinedSurfaceFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointDefinedSurfaceFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedSurfaceFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedSurfaceFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType > r (
        ::xsd::qif2::PointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType > r (
        ::xsd::qif2::PointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType > r (
        ::xsd::qif2::PointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType > r (
        ::xsd::qif2::PointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType > r (
        ::xsd::qif2::PointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType > r (
        ::xsd::qif2::PointFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType > r (
          ::xsd::qif2::PointFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType >
    PointFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType > r (
        ::xsd::qif2::ProfileGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType > r (
        ::xsd::qif2::ProfileGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (const ::std::string& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType > r (
        ::xsd::qif2::ProfileGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (::std::istream& is,
                               const ::std::string& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (::xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType > r (
        ::xsd::qif2::ProfileGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (::xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType > r (
        ::xsd::qif2::ProfileGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (::xercesc::InputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType > r (
        ::xsd::qif2::ProfileGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (const ::xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType > r (
          ::xsd::qif2::ProfileGroupFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ProfileGroupFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ProfileGroupFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProfileGroupFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType >
    ProfileGroupFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ProfileGroupFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ProfileGroupFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProfileGroupFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType > r (
        ::xsd::qif2::RunoutGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType > r (
        ::xsd::qif2::RunoutGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType > r (
        ::xsd::qif2::RunoutGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (::xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType > r (
        ::xsd::qif2::RunoutGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (::xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType > r (
        ::xsd::qif2::RunoutGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType > r (
        ::xsd::qif2::RunoutGroupFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (const ::xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType > r (
          ::xsd::qif2::RunoutGroupFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "RunoutGroupFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::RunoutGroupFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "RunoutGroupFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType >
    RunoutGroupFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "RunoutGroupFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::RunoutGroupFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "RunoutGroupFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType > r (
        ::xsd::qif2::SphereFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType > r (
        ::xsd::qif2::SphereFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType > r (
        ::xsd::qif2::SphereFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType > r (
        ::xsd::qif2::SphereFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType > r (
        ::xsd::qif2::SphereFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType > r (
        ::xsd::qif2::SphereFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType > r (
          ::xsd::qif2::SphereFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SphereFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphereFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphereFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType >
    SphereFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SphereFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphereFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphereFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphereFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (const ::std::string& u,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType > r (
        ::xsd::qif2::SphericalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (const ::std::string& u,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType > r (
        ::xsd::qif2::SphericalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (const ::std::string& u,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType > r (
        ::xsd::qif2::SphericalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (::std::istream& is,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (::std::istream& is,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (::std::istream& is,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (::xercesc::InputSource& i,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType > r (
        ::xsd::qif2::SphericalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (::xercesc::InputSource& i,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType > r (
        ::xsd::qif2::SphericalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (::xercesc::InputSource& i,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType > r (
        ::xsd::qif2::SphericalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (const ::xercesc::DOMDocument& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType > r (
          ::xsd::qif2::SphericalSegmentFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SphericalSegmentFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphericalSegmentFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphericalSegmentFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType >
    SphericalSegmentFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SphericalSegmentFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphericalSegmentFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphericalSegmentFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (const ::std::string& u,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (const ::std::string& u,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (const ::std::string& u,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (::std::istream& is,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (::std::istream& is,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (::std::istream& is,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (::std::istream& is,
                                      const ::std::string& sid,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (::xercesc::InputSource& i,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (::xercesc::InputSource& i,
                                      ::xml_schema::error_handler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (::xercesc::InputSource& i,
                                      ::xercesc::DOMErrorHandler& h,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (const ::xercesc::DOMDocument& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType > r (
          ::xsd::qif2::SurfaceOfRevolutionFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SurfaceOfRevolutionFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SurfaceOfRevolutionFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    SurfaceOfRevolutionFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                      ::xml_schema::flags f,
                                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SurfaceOfRevolutionFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SurfaceOfRevolutionFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SurfaceOfRevolutionFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (const ::std::string& u,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType > r (
        ::xsd::qif2::ThreadedFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (const ::std::string& u,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType > r (
        ::xsd::qif2::ThreadedFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (const ::std::string& u,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType > r (
        ::xsd::qif2::ThreadedFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (::std::istream& is,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (::std::istream& is,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (::std::istream& is,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (::std::istream& is,
                           const ::std::string& sid,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (::std::istream& is,
                           const ::std::string& sid,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (::xercesc::InputSource& i,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType > r (
        ::xsd::qif2::ThreadedFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (::xercesc::InputSource& i,
                           ::xml_schema::error_handler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType > r (
        ::xsd::qif2::ThreadedFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (::xercesc::InputSource& i,
                           ::xercesc::DOMErrorHandler& h,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType > r (
        ::xsd::qif2::ThreadedFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (const ::xercesc::DOMDocument& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType > r (
          ::xsd::qif2::ThreadedFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ThreadedFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ThreadedFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThreadedFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType >
    ThreadedFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                           ::xml_schema::flags f,
                           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ThreadedFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ThreadedFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThreadedFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType > r (
        ::xsd::qif2::ToroidalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType > r (
        ::xsd::qif2::ToroidalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType > r (
        ::xsd::qif2::ToroidalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (::xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType > r (
        ::xsd::qif2::ToroidalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (::xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType > r (
        ::xsd::qif2::ToroidalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType > r (
        ::xsd::qif2::ToroidalSegmentFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (const ::xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType > r (
          ::xsd::qif2::ToroidalSegmentFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ToroidalSegmentFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ToroidalSegmentFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ToroidalSegmentFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType >
    ToroidalSegmentFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ToroidalSegmentFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ToroidalSegmentFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ToroidalSegmentFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType > r (
        ::xsd::qif2::TorusFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType > r (
        ::xsd::qif2::TorusFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType > r (
        ::xsd::qif2::TorusFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureActual (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureActual (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType > r (
        ::xsd::qif2::TorusFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType > r (
        ::xsd::qif2::TorusFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType > r (
        ::xsd::qif2::TorusFeatureActual (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType > r (
          ::xsd::qif2::TorusFeatureActual (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "TorusFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TorusFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TorusFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType >
    TorusFeatureActual (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "TorusFeatureActual" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TorusFeatureActualType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TorusFeatureActualType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TorusFeatureActual",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType > r (
        ::xsd::qif2::FeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType > r (
        ::xsd::qif2::FeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType > r (
        ::xsd::qif2::FeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType > r (
        ::xsd::qif2::FeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType > r (
        ::xsd::qif2::FeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType > r (
        ::xsd::qif2::FeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType > r (
          ::xsd::qif2::FeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FeatureItemBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType >
    FeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "FeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FeatureItemBaseType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FeatureItemBaseType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (const ::std::string& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType > r (
        ::xsd::qif2::ArcFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (const ::std::string& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType > r (
        ::xsd::qif2::ArcFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (const ::std::string& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType > r (
        ::xsd::qif2::ArcFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ArcFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (::std::istream& is,
                    const ::std::string& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (::std::istream& is,
                    const ::std::string& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ArcFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType > r (
        ::xsd::qif2::ArcFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType > r (
        ::xsd::qif2::ArcFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType > r (
        ::xsd::qif2::ArcFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType > r (
          ::xsd::qif2::ArcFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ArcFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ArcFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArcFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType >
    ArcFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ArcFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ArcFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ArcFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ArcFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType > r (
        ::xsd::qif2::GenericFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType > r (
        ::xsd::qif2::GenericFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType > r (
        ::xsd::qif2::GenericFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::GenericFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::GenericFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType > r (
        ::xsd::qif2::GenericFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType > r (
        ::xsd::qif2::GenericFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType > r (
        ::xsd::qif2::GenericFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType > r (
          ::xsd::qif2::GenericFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "GenericFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::GenericFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GenericFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType >
    GenericFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "GenericFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::GenericFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::GenericFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "GenericFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType > r (
        ::xsd::qif2::CircleFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType > r (
        ::xsd::qif2::CircleFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType > r (
        ::xsd::qif2::CircleFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CircleFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CircleFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType > r (
        ::xsd::qif2::CircleFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType > r (
        ::xsd::qif2::CircleFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType > r (
        ::xsd::qif2::CircleFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType > r (
          ::xsd::qif2::CircleFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CircleFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CircleFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CircleFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType >
    CircleFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CircleFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CircleFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CircleFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CircleFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType > r (
        ::xsd::qif2::CompoundFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType > r (
        ::xsd::qif2::CompoundFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType > r (
        ::xsd::qif2::CompoundFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CompoundFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CompoundFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType > r (
        ::xsd::qif2::CompoundFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType > r (
        ::xsd::qif2::CompoundFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType > r (
        ::xsd::qif2::CompoundFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType > r (
          ::xsd::qif2::CompoundFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CompoundFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CompoundFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CompoundFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType >
    CompoundFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CompoundFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CompoundFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CompoundFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CompoundFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType > r (
        ::xsd::qif2::ConeFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType > r (
        ::xsd::qif2::ConeFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType > r (
        ::xsd::qif2::ConeFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConeFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConeFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType > r (
        ::xsd::qif2::ConeFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType > r (
        ::xsd::qif2::ConeFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType > r (
        ::xsd::qif2::ConeFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType > r (
          ::xsd::qif2::ConeFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ConeFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConeFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConeFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType >
    ConeFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ConeFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConeFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConeFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConeFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType > r (
        ::xsd::qif2::ConicalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType > r (
        ::xsd::qif2::ConicalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (const ::std::string& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType > r (
        ::xsd::qif2::ConicalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ConicalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (::std::istream& is,
                               const ::std::string& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ConicalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (::xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType > r (
        ::xsd::qif2::ConicalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (::xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType > r (
        ::xsd::qif2::ConicalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (::xercesc::InputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType > r (
        ::xsd::qif2::ConicalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (const ::xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType > r (
          ::xsd::qif2::ConicalSegmentFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ConicalSegmentFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConicalSegmentFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConicalSegmentFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType >
    ConicalSegmentFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ConicalSegmentFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ConicalSegmentFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ConicalSegmentFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ConicalSegmentFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType > r (
        ::xsd::qif2::CuboidFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType > r (
        ::xsd::qif2::CuboidFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType > r (
        ::xsd::qif2::CuboidFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CuboidFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CuboidFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType > r (
        ::xsd::qif2::CuboidFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType > r (
        ::xsd::qif2::CuboidFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType > r (
        ::xsd::qif2::CuboidFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType > r (
          ::xsd::qif2::CuboidFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CuboidFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CuboidFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CuboidFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType >
    CuboidFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CuboidFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CuboidFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CuboidFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CuboidFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType > r (
        ::xsd::qif2::CylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType > r (
        ::xsd::qif2::CylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType > r (
        ::xsd::qif2::CylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylinderFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylinderFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType > r (
        ::xsd::qif2::CylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType > r (
        ::xsd::qif2::CylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType > r (
        ::xsd::qif2::CylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType > r (
          ::xsd::qif2::CylinderFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CylinderFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylinderFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylinderFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType >
    CylinderFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CylinderFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylinderFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylinderFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylinderFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (const ::std::string& u,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType > r (
        ::xsd::qif2::CylindricalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (const ::std::string& u,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType > r (
        ::xsd::qif2::CylindricalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (const ::std::string& u,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType > r (
        ::xsd::qif2::CylindricalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (::std::istream& is,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (::std::istream& is,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (::std::istream& is,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::CylindricalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (::std::istream& is,
                                   const ::std::string& sid,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::CylindricalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (::xercesc::InputSource& i,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType > r (
        ::xsd::qif2::CylindricalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (::xercesc::InputSource& i,
                                   ::xml_schema::error_handler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType > r (
        ::xsd::qif2::CylindricalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (::xercesc::InputSource& i,
                                   ::xercesc::DOMErrorHandler& h,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType > r (
        ::xsd::qif2::CylindricalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (const ::xercesc::DOMDocument& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType > r (
          ::xsd::qif2::CylindricalSegmentFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "CylindricalSegmentFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylindricalSegmentFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylindricalSegmentFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType >
    CylindricalSegmentFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                   ::xml_schema::flags f,
                                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "CylindricalSegmentFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::CylindricalSegmentFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::CylindricalSegmentFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CylindricalSegmentFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (const ::std::string& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType > r (
        ::xsd::qif2::EdgePointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (const ::std::string& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType > r (
        ::xsd::qif2::EdgePointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (const ::std::string& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType > r (
        ::xsd::qif2::EdgePointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EdgePointFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (::std::istream& is,
                          const ::std::string& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (::std::istream& is,
                          const ::std::string& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EdgePointFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType > r (
        ::xsd::qif2::EdgePointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType > r (
        ::xsd::qif2::EdgePointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType > r (
        ::xsd::qif2::EdgePointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType > r (
          ::xsd::qif2::EdgePointFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "EdgePointFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgePointFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgePointFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType >
    EdgePointFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "EdgePointFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EdgePointFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EdgePointFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EdgePointFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType > r (
        ::xsd::qif2::EllipseFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType > r (
        ::xsd::qif2::EllipseFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType > r (
        ::xsd::qif2::EllipseFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::EllipseFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::EllipseFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType > r (
        ::xsd::qif2::EllipseFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType > r (
        ::xsd::qif2::EllipseFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType > r (
        ::xsd::qif2::EllipseFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType > r (
          ::xsd::qif2::EllipseFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "EllipseFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EllipseFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EllipseFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType >
    EllipseFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "EllipseFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::EllipseFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::EllipseFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EllipseFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType > r (
        ::xsd::qif2::ElongatedCylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType > r (
        ::xsd::qif2::ElongatedCylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType > r (
        ::xsd::qif2::ElongatedCylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ElongatedCylinderFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ElongatedCylinderFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (::xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType > r (
        ::xsd::qif2::ElongatedCylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (::xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType > r (
        ::xsd::qif2::ElongatedCylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType > r (
        ::xsd::qif2::ElongatedCylinderFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (const ::xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType > r (
          ::xsd::qif2::ElongatedCylinderFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ElongatedCylinderFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ElongatedCylinderFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ElongatedCylinderFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType >
    ElongatedCylinderFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ElongatedCylinderFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ElongatedCylinderFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ElongatedCylinderFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ElongatedCylinderFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (const ::std::string& u,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (const ::std::string& u,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (const ::std::string& u,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (::std::istream& is,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (::std::istream& is,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (::std::istream& is,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (::std::istream& is,
                                     const ::std::string& sid,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ExtrudedCrossSectionFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (::xercesc::InputSource& i,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (::xercesc::InputSource& i,
                                     ::xml_schema::error_handler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (::xercesc::InputSource& i,
                                     ::xercesc::DOMErrorHandler& h,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType > r (
        ::xsd::qif2::ExtrudedCrossSectionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (const ::xercesc::DOMDocument& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType > r (
          ::xsd::qif2::ExtrudedCrossSectionFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ExtrudedCrossSectionFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ExtrudedCrossSectionFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    ExtrudedCrossSectionFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                     ::xml_schema::flags f,
                                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ExtrudedCrossSectionFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ExtrudedCrossSectionFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ExtrudedCrossSectionFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (const ::std::string& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType > r (
        ::xsd::qif2::LineFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (const ::std::string& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType > r (
        ::xsd::qif2::LineFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (const ::std::string& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType > r (
        ::xsd::qif2::LineFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::LineFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (::std::istream& is,
                     const ::std::string& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (::std::istream& is,
                     const ::std::string& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::LineFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType > r (
        ::xsd::qif2::LineFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType > r (
        ::xsd::qif2::LineFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType > r (
        ::xsd::qif2::LineFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType > r (
          ::xsd::qif2::LineFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "LineFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LineFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LineFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType >
    LineFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "LineFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::LineFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::LineFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "LineFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (const ::std::string& u,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType > r (
        ::xsd::qif2::OppositeLinesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (const ::std::string& u,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType > r (
        ::xsd::qif2::OppositeLinesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (const ::std::string& u,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType > r (
        ::xsd::qif2::OppositeLinesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (::std::istream& is,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (::std::istream& is,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (::std::istream& is,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositeLinesFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (::std::istream& is,
                              const ::std::string& sid,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (::std::istream& is,
                              const ::std::string& sid,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositeLinesFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (::xercesc::InputSource& i,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType > r (
        ::xsd::qif2::OppositeLinesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (::xercesc::InputSource& i,
                              ::xml_schema::error_handler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType > r (
        ::xsd::qif2::OppositeLinesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (::xercesc::InputSource& i,
                              ::xercesc::DOMErrorHandler& h,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType > r (
        ::xsd::qif2::OppositeLinesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (const ::xercesc::DOMDocument& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType > r (
          ::xsd::qif2::OppositeLinesFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "OppositeLinesFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositeLinesFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositeLinesFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType >
    OppositeLinesFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                              ::xml_schema::flags f,
                              const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "OppositeLinesFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositeLinesFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositeLinesFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositeLinesFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (const ::std::string& u,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType > r (
        ::xsd::qif2::OppositePlanesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (const ::std::string& u,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType > r (
        ::xsd::qif2::OppositePlanesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (const ::std::string& u,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType > r (
        ::xsd::qif2::OppositePlanesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (::std::istream& is,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (::std::istream& is,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (::std::istream& is,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::OppositePlanesFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (::std::istream& is,
                               const ::std::string& sid,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (::std::istream& is,
                               const ::std::string& sid,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::OppositePlanesFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (::xercesc::InputSource& i,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType > r (
        ::xsd::qif2::OppositePlanesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (::xercesc::InputSource& i,
                               ::xml_schema::error_handler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType > r (
        ::xsd::qif2::OppositePlanesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (::xercesc::InputSource& i,
                               ::xercesc::DOMErrorHandler& h,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType > r (
        ::xsd::qif2::OppositePlanesFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (const ::xercesc::DOMDocument& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType > r (
          ::xsd::qif2::OppositePlanesFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "OppositePlanesFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositePlanesFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositePlanesFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType >
    OppositePlanesFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                               ::xml_schema::flags f,
                               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "OppositePlanesFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::OppositePlanesFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::OppositePlanesFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "OppositePlanesFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType > r (
        ::xsd::qif2::PatternFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType > r (
        ::xsd::qif2::PatternFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType > r (
        ::xsd::qif2::PatternFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PatternFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PatternFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType > r (
        ::xsd::qif2::PatternFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType > r (
        ::xsd::qif2::PatternFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType > r (
        ::xsd::qif2::PatternFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType > r (
          ::xsd::qif2::PatternFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PatternFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PatternFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PatternFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType >
    PatternFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PatternFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PatternFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PatternFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PatternFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType > r (
        ::xsd::qif2::PlaneFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType > r (
        ::xsd::qif2::PlaneFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType > r (
        ::xsd::qif2::PlaneFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PlaneFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PlaneFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType > r (
        ::xsd::qif2::PlaneFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType > r (
        ::xsd::qif2::PlaneFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType > r (
        ::xsd::qif2::PlaneFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType > r (
          ::xsd::qif2::PlaneFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PlaneFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PlaneFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PlaneFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType >
    PlaneFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PlaneFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PlaneFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PlaneFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PlaneFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (const ::std::string& u,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType > r (
        ::xsd::qif2::PointDefinedCurveFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (const ::std::string& u,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType > r (
        ::xsd::qif2::PointDefinedCurveFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType > r (
        ::xsd::qif2::PointDefinedCurveFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (::std::istream& is,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (::std::istream& is,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedCurveFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedCurveFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (::xercesc::InputSource& i,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType > r (
        ::xsd::qif2::PointDefinedCurveFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (::xercesc::InputSource& i,
                                  ::xml_schema::error_handler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType > r (
        ::xsd::qif2::PointDefinedCurveFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType > r (
        ::xsd::qif2::PointDefinedCurveFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (const ::xercesc::DOMDocument& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType > r (
          ::xsd::qif2::PointDefinedCurveFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointDefinedCurveFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedCurveFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedCurveFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType >
    PointDefinedCurveFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                  ::xml_schema::flags f,
                                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointDefinedCurveFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedCurveFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedCurveFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedCurveFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (const ::std::string& u,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (::std::istream& is,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointDefinedSurfaceFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointDefinedSurfaceFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (::xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (::xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (::xercesc::InputSource& i,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType > r (
        ::xsd::qif2::PointDefinedSurfaceFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (const ::xercesc::DOMDocument& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType > r (
          ::xsd::qif2::PointDefinedSurfaceFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointDefinedSurfaceFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedSurfaceFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedSurfaceFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    PointDefinedSurfaceFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointDefinedSurfaceFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointDefinedSurfaceFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointDefinedSurfaceFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointDefinedSurfaceFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType > r (
        ::xsd::qif2::PointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType > r (
        ::xsd::qif2::PointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType > r (
        ::xsd::qif2::PointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::PointFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::PointFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType > r (
        ::xsd::qif2::PointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType > r (
        ::xsd::qif2::PointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType > r (
        ::xsd::qif2::PointFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType > r (
          ::xsd::qif2::PointFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "PointFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType >
    PointFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "PointFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::PointFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::PointFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "PointFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (const ::std::string& u,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType > r (
        ::xsd::qif2::ProfileGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (const ::std::string& u,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType > r (
        ::xsd::qif2::ProfileGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (const ::std::string& u,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType > r (
        ::xsd::qif2::ProfileGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (::std::istream& is,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (::std::istream& is,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (::std::istream& is,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ProfileGroupFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (::std::istream& is,
                             const ::std::string& sid,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (::std::istream& is,
                             const ::std::string& sid,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ProfileGroupFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (::xercesc::InputSource& i,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType > r (
        ::xsd::qif2::ProfileGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (::xercesc::InputSource& i,
                             ::xml_schema::error_handler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType > r (
        ::xsd::qif2::ProfileGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (::xercesc::InputSource& i,
                             ::xercesc::DOMErrorHandler& h,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType > r (
        ::xsd::qif2::ProfileGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (const ::xercesc::DOMDocument& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType > r (
          ::xsd::qif2::ProfileGroupFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ProfileGroupFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ProfileGroupFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProfileGroupFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType >
    ProfileGroupFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                             ::xml_schema::flags f,
                             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ProfileGroupFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ProfileGroupFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ProfileGroupFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ProfileGroupFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (const ::std::string& u,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType > r (
        ::xsd::qif2::RunoutGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (const ::std::string& u,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType > r (
        ::xsd::qif2::RunoutGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType > r (
        ::xsd::qif2::RunoutGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (::std::istream& is,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (::std::istream& is,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::RunoutGroupFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::RunoutGroupFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (::xercesc::InputSource& i,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType > r (
        ::xsd::qif2::RunoutGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (::xercesc::InputSource& i,
                            ::xml_schema::error_handler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType > r (
        ::xsd::qif2::RunoutGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType > r (
        ::xsd::qif2::RunoutGroupFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (const ::xercesc::DOMDocument& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType > r (
          ::xsd::qif2::RunoutGroupFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "RunoutGroupFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::RunoutGroupFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "RunoutGroupFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType >
    RunoutGroupFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                            ::xml_schema::flags f,
                            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "RunoutGroupFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::RunoutGroupFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::RunoutGroupFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "RunoutGroupFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (const ::std::string& u,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType > r (
        ::xsd::qif2::SphereFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (const ::std::string& u,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType > r (
        ::xsd::qif2::SphereFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (const ::std::string& u,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType > r (
        ::xsd::qif2::SphereFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (::std::istream& is,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (::std::istream& is,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (::std::istream& is,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphereFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (::std::istream& is,
                       const ::std::string& sid,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (::std::istream& is,
                       const ::std::string& sid,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphereFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (::xercesc::InputSource& i,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType > r (
        ::xsd::qif2::SphereFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (::xercesc::InputSource& i,
                       ::xml_schema::error_handler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType > r (
        ::xsd::qif2::SphereFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (::xercesc::InputSource& i,
                       ::xercesc::DOMErrorHandler& h,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType > r (
        ::xsd::qif2::SphereFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (const ::xercesc::DOMDocument& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType > r (
          ::xsd::qif2::SphereFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SphereFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphereFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphereFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType >
    SphereFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                       ::xml_schema::flags f,
                       const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SphereFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphereFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphereFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphereFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (const ::std::string& u,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType > r (
        ::xsd::qif2::SphericalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (const ::std::string& u,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType > r (
        ::xsd::qif2::SphericalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (const ::std::string& u,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType > r (
        ::xsd::qif2::SphericalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (::std::istream& is,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (::std::istream& is,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (::std::istream& is,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SphericalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (::std::istream& is,
                                 const ::std::string& sid,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SphericalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (::xercesc::InputSource& i,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType > r (
        ::xsd::qif2::SphericalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (::xercesc::InputSource& i,
                                 ::xml_schema::error_handler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType > r (
        ::xsd::qif2::SphericalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (::xercesc::InputSource& i,
                                 ::xercesc::DOMErrorHandler& h,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType > r (
        ::xsd::qif2::SphericalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (const ::xercesc::DOMDocument& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType > r (
          ::xsd::qif2::SphericalSegmentFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SphericalSegmentFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphericalSegmentFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphericalSegmentFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType >
    SphericalSegmentFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                 ::xml_schema::flags f,
                                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SphericalSegmentFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SphericalSegmentFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SphericalSegmentFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SphericalSegmentFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (const ::std::string& u,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (const ::std::string& u,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (const ::std::string& u,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (::std::istream& is,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (::std::istream& is,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (::std::istream& is,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (::std::istream& is,
                                    const ::std::string& sid,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::SurfaceOfRevolutionFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (::xercesc::InputSource& i,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (::xercesc::InputSource& i,
                                    ::xml_schema::error_handler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (::xercesc::InputSource& i,
                                    ::xercesc::DOMErrorHandler& h,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType > r (
        ::xsd::qif2::SurfaceOfRevolutionFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (const ::xercesc::DOMDocument& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType > r (
          ::xsd::qif2::SurfaceOfRevolutionFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "SurfaceOfRevolutionFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SurfaceOfRevolutionFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    SurfaceOfRevolutionFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                    ::xml_schema::flags f,
                                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "SurfaceOfRevolutionFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::SurfaceOfRevolutionFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "SurfaceOfRevolutionFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (const ::std::string& u,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType > r (
        ::xsd::qif2::ThreadedFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (const ::std::string& u,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType > r (
        ::xsd::qif2::ThreadedFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (const ::std::string& u,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType > r (
        ::xsd::qif2::ThreadedFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (::std::istream& is,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (::std::istream& is,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (::std::istream& is,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ThreadedFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (::std::istream& is,
                         const ::std::string& sid,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (::std::istream& is,
                         const ::std::string& sid,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ThreadedFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (::xercesc::InputSource& i,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType > r (
        ::xsd::qif2::ThreadedFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (::xercesc::InputSource& i,
                         ::xml_schema::error_handler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType > r (
        ::xsd::qif2::ThreadedFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (::xercesc::InputSource& i,
                         ::xercesc::DOMErrorHandler& h,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType > r (
        ::xsd::qif2::ThreadedFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (const ::xercesc::DOMDocument& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType > r (
          ::xsd::qif2::ThreadedFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ThreadedFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ThreadedFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThreadedFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType >
    ThreadedFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                         ::xml_schema::flags f,
                         const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ThreadedFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ThreadedFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ThreadedFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ThreadedFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (const ::std::string& u,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType > r (
        ::xsd::qif2::ToroidalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (const ::std::string& u,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType > r (
        ::xsd::qif2::ToroidalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (const ::std::string& u,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType > r (
        ::xsd::qif2::ToroidalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (::std::istream& is,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (::std::istream& is,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (::std::istream& is,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::ToroidalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (::std::istream& is,
                                const ::std::string& sid,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (::std::istream& is,
                                const ::std::string& sid,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::ToroidalSegmentFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (::xercesc::InputSource& i,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType > r (
        ::xsd::qif2::ToroidalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (::xercesc::InputSource& i,
                                ::xml_schema::error_handler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType > r (
        ::xsd::qif2::ToroidalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (::xercesc::InputSource& i,
                                ::xercesc::DOMErrorHandler& h,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType > r (
        ::xsd::qif2::ToroidalSegmentFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (const ::xercesc::DOMDocument& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType > r (
          ::xsd::qif2::ToroidalSegmentFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "ToroidalSegmentFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ToroidalSegmentFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ToroidalSegmentFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType >
    ToroidalSegmentFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                                ::xml_schema::flags f,
                                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "ToroidalSegmentFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::ToroidalSegmentFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::ToroidalSegmentFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ToroidalSegmentFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType > r (
        ::xsd::qif2::TorusFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType > r (
        ::xsd::qif2::TorusFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType > r (
        ::xsd::qif2::TorusFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::TorusFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureItem (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::TorusFeatureItem (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType > r (
        ::xsd::qif2::TorusFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType > r (
        ::xsd::qif2::TorusFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType > r (
        ::xsd::qif2::TorusFeatureItem (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType > r (
          ::xsd::qif2::TorusFeatureItem (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "TorusFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TorusFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TorusFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType >
    TorusFeatureItem (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "TorusFeatureItem" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::TorusFeatureItemType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::TorusFeatureItemType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "TorusFeatureItem",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

