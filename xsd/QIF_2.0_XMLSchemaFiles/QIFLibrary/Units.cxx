// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Units.hxx"

namespace xsd
{
  namespace qif2
  {
    // PositiveDecimalType
    // 


    // NonNegativeDecimalType
    // 


    // UnitConversionType
    // 

    const UnitConversionType::Factor_type& UnitConversionType::
    Factor () const
    {
      return this->Factor_.get ();
    }

    UnitConversionType::Factor_type& UnitConversionType::
    Factor ()
    {
      return this->Factor_.get ();
    }

    void UnitConversionType::
    Factor (const Factor_type& x)
    {
      this->Factor_.set (x);
    }

    void UnitConversionType::
    Factor (::std::auto_ptr< Factor_type > x)
    {
      this->Factor_.set (x);
    }

    const UnitConversionType::Offset_optional& UnitConversionType::
    Offset () const
    {
      return this->Offset_;
    }

    UnitConversionType::Offset_optional& UnitConversionType::
    Offset ()
    {
      return this->Offset_;
    }

    void UnitConversionType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void UnitConversionType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    UnitConversionType::Offset_type UnitConversionType::
    Offset_default_value ()
    {
      return Offset_type (0.0);
    }


    // SpecifiedDecimalType
    // 

    const SpecifiedDecimalType::decimalPlaces_optional& SpecifiedDecimalType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    SpecifiedDecimalType::decimalPlaces_optional& SpecifiedDecimalType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void SpecifiedDecimalType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void SpecifiedDecimalType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const SpecifiedDecimalType::significantFigures_optional& SpecifiedDecimalType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    SpecifiedDecimalType::significantFigures_optional& SpecifiedDecimalType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void SpecifiedDecimalType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void SpecifiedDecimalType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }


    // ActualDecimalType
    // 

    const ActualDecimalType::combinedUncertainty_optional& ActualDecimalType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    ActualDecimalType::combinedUncertainty_optional& ActualDecimalType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void ActualDecimalType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void ActualDecimalType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    void ActualDecimalType::
    combinedUncertainty (::std::auto_ptr< combinedUncertainty_type > x)
    {
      this->combinedUncertainty_.set (x);
    }

    const ActualDecimalType::meanError_optional& ActualDecimalType::
    meanError () const
    {
      return this->meanError_;
    }

    ActualDecimalType::meanError_optional& ActualDecimalType::
    meanError ()
    {
      return this->meanError_;
    }

    void ActualDecimalType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void ActualDecimalType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    void ActualDecimalType::
    meanError (::std::auto_ptr< meanError_type > x)
    {
      this->meanError_.set (x);
    }


    // AngularUnitType
    // 

    const AngularUnitType::SIUnitName_optional& AngularUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    AngularUnitType::SIUnitName_optional& AngularUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void AngularUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void AngularUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void AngularUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const AngularUnitType::SIUnitName_type& AngularUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const AngularUnitType::UnitName_type& AngularUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    AngularUnitType::UnitName_type& AngularUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void AngularUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void AngularUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const AngularUnitType::UnitConversion_optional& AngularUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    AngularUnitType::UnitConversion_optional& AngularUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void AngularUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void AngularUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void AngularUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // AngularValueType
    // 

    const AngularValueType::angularUnit_optional& AngularValueType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    AngularValueType::angularUnit_optional& AngularValueType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void AngularValueType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void AngularValueType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void AngularValueType::
    angularUnit (::std::auto_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (x);
    }


    // ActualAngularValueType
    // 

    const ActualAngularValueType::angularUnit_optional& ActualAngularValueType::
    angularUnit () const
    {
      return this->angularUnit_;
    }

    ActualAngularValueType::angularUnit_optional& ActualAngularValueType::
    angularUnit ()
    {
      return this->angularUnit_;
    }

    void ActualAngularValueType::
    angularUnit (const angularUnit_type& x)
    {
      this->angularUnit_.set (x);
    }

    void ActualAngularValueType::
    angularUnit (const angularUnit_optional& x)
    {
      this->angularUnit_ = x;
    }

    void ActualAngularValueType::
    angularUnit (::std::auto_ptr< angularUnit_type > x)
    {
      this->angularUnit_.set (x);
    }


    // AreaUnitType
    // 

    const AreaUnitType::SIUnitName_optional& AreaUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    AreaUnitType::SIUnitName_optional& AreaUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void AreaUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void AreaUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void AreaUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const AreaUnitType::SIUnitName_type& AreaUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const AreaUnitType::UnitName_type& AreaUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    AreaUnitType::UnitName_type& AreaUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void AreaUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void AreaUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const AreaUnitType::UnitConversion_optional& AreaUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    AreaUnitType::UnitConversion_optional& AreaUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void AreaUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void AreaUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void AreaUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // AreaValueType
    // 

    const AreaValueType::areaUnit_optional& AreaValueType::
    areaUnit () const
    {
      return this->areaUnit_;
    }

    AreaValueType::areaUnit_optional& AreaValueType::
    areaUnit ()
    {
      return this->areaUnit_;
    }

    void AreaValueType::
    areaUnit (const areaUnit_type& x)
    {
      this->areaUnit_.set (x);
    }

    void AreaValueType::
    areaUnit (const areaUnit_optional& x)
    {
      this->areaUnit_ = x;
    }

    void AreaValueType::
    areaUnit (::std::auto_ptr< areaUnit_type > x)
    {
      this->areaUnit_.set (x);
    }


    // ActualAreaValueType
    // 

    const ActualAreaValueType::areaUnit_optional& ActualAreaValueType::
    areaUnit () const
    {
      return this->areaUnit_;
    }

    ActualAreaValueType::areaUnit_optional& ActualAreaValueType::
    areaUnit ()
    {
      return this->areaUnit_;
    }

    void ActualAreaValueType::
    areaUnit (const areaUnit_type& x)
    {
      this->areaUnit_.set (x);
    }

    void ActualAreaValueType::
    areaUnit (const areaUnit_optional& x)
    {
      this->areaUnit_ = x;
    }

    void ActualAreaValueType::
    areaUnit (::std::auto_ptr< areaUnit_type > x)
    {
      this->areaUnit_.set (x);
    }


    // ForceUnitType
    // 

    const ForceUnitType::SIUnitName_optional& ForceUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    ForceUnitType::SIUnitName_optional& ForceUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void ForceUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void ForceUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void ForceUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const ForceUnitType::SIUnitName_type& ForceUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const ForceUnitType::UnitName_type& ForceUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    ForceUnitType::UnitName_type& ForceUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void ForceUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void ForceUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const ForceUnitType::UnitConversion_optional& ForceUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    ForceUnitType::UnitConversion_optional& ForceUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void ForceUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void ForceUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void ForceUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // ForceValueType
    // 

    const ForceValueType::forceUnit_optional& ForceValueType::
    forceUnit () const
    {
      return this->forceUnit_;
    }

    ForceValueType::forceUnit_optional& ForceValueType::
    forceUnit ()
    {
      return this->forceUnit_;
    }

    void ForceValueType::
    forceUnit (const forceUnit_type& x)
    {
      this->forceUnit_.set (x);
    }

    void ForceValueType::
    forceUnit (const forceUnit_optional& x)
    {
      this->forceUnit_ = x;
    }

    void ForceValueType::
    forceUnit (::std::auto_ptr< forceUnit_type > x)
    {
      this->forceUnit_.set (x);
    }


    // ActualForceValueType
    // 

    const ActualForceValueType::forceUnit_optional& ActualForceValueType::
    forceUnit () const
    {
      return this->forceUnit_;
    }

    ActualForceValueType::forceUnit_optional& ActualForceValueType::
    forceUnit ()
    {
      return this->forceUnit_;
    }

    void ActualForceValueType::
    forceUnit (const forceUnit_type& x)
    {
      this->forceUnit_.set (x);
    }

    void ActualForceValueType::
    forceUnit (const forceUnit_optional& x)
    {
      this->forceUnit_ = x;
    }

    void ActualForceValueType::
    forceUnit (::std::auto_ptr< forceUnit_type > x)
    {
      this->forceUnit_.set (x);
    }


    // LinearUnitType
    // 

    const LinearUnitType::SIUnitName_optional& LinearUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    LinearUnitType::SIUnitName_optional& LinearUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void LinearUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void LinearUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void LinearUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const LinearUnitType::SIUnitName_type& LinearUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const LinearUnitType::UnitName_type& LinearUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    LinearUnitType::UnitName_type& LinearUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void LinearUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void LinearUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const LinearUnitType::UnitConversion_optional& LinearUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    LinearUnitType::UnitConversion_optional& LinearUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void LinearUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void LinearUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void LinearUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // LinearValueType
    // 

    const LinearValueType::linearUnit_optional& LinearValueType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    LinearValueType::linearUnit_optional& LinearValueType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void LinearValueType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void LinearValueType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void LinearValueType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }


    // ActualLinearValueType
    // 

    const ActualLinearValueType::linearUnit_optional& ActualLinearValueType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    ActualLinearValueType::linearUnit_optional& ActualLinearValueType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void ActualLinearValueType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void ActualLinearValueType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void ActualLinearValueType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }


    // MassUnitType
    // 

    const MassUnitType::SIUnitName_optional& MassUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    MassUnitType::SIUnitName_optional& MassUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void MassUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void MassUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void MassUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const MassUnitType::SIUnitName_type& MassUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const MassUnitType::UnitName_type& MassUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    MassUnitType::UnitName_type& MassUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void MassUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void MassUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const MassUnitType::UnitConversion_optional& MassUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    MassUnitType::UnitConversion_optional& MassUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void MassUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void MassUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void MassUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // MassValueType
    // 

    const MassValueType::massUnit_optional& MassValueType::
    massUnit () const
    {
      return this->massUnit_;
    }

    MassValueType::massUnit_optional& MassValueType::
    massUnit ()
    {
      return this->massUnit_;
    }

    void MassValueType::
    massUnit (const massUnit_type& x)
    {
      this->massUnit_.set (x);
    }

    void MassValueType::
    massUnit (const massUnit_optional& x)
    {
      this->massUnit_ = x;
    }

    void MassValueType::
    massUnit (::std::auto_ptr< massUnit_type > x)
    {
      this->massUnit_.set (x);
    }


    // ActualMassValueType
    // 

    const ActualMassValueType::massUnit_optional& ActualMassValueType::
    massUnit () const
    {
      return this->massUnit_;
    }

    ActualMassValueType::massUnit_optional& ActualMassValueType::
    massUnit ()
    {
      return this->massUnit_;
    }

    void ActualMassValueType::
    massUnit (const massUnit_type& x)
    {
      this->massUnit_.set (x);
    }

    void ActualMassValueType::
    massUnit (const massUnit_optional& x)
    {
      this->massUnit_ = x;
    }

    void ActualMassValueType::
    massUnit (::std::auto_ptr< massUnit_type > x)
    {
      this->massUnit_.set (x);
    }


    // PressureUnitType
    // 

    const PressureUnitType::SIUnitName_optional& PressureUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    PressureUnitType::SIUnitName_optional& PressureUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void PressureUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void PressureUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void PressureUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const PressureUnitType::SIUnitName_type& PressureUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const PressureUnitType::UnitName_type& PressureUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    PressureUnitType::UnitName_type& PressureUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void PressureUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void PressureUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const PressureUnitType::UnitConversion_optional& PressureUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    PressureUnitType::UnitConversion_optional& PressureUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void PressureUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void PressureUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void PressureUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // PressureValueType
    // 

    const PressureValueType::pressureUnit_optional& PressureValueType::
    pressureUnit () const
    {
      return this->pressureUnit_;
    }

    PressureValueType::pressureUnit_optional& PressureValueType::
    pressureUnit ()
    {
      return this->pressureUnit_;
    }

    void PressureValueType::
    pressureUnit (const pressureUnit_type& x)
    {
      this->pressureUnit_.set (x);
    }

    void PressureValueType::
    pressureUnit (const pressureUnit_optional& x)
    {
      this->pressureUnit_ = x;
    }

    void PressureValueType::
    pressureUnit (::std::auto_ptr< pressureUnit_type > x)
    {
      this->pressureUnit_.set (x);
    }


    // ActualPressureValueType
    // 

    const ActualPressureValueType::pressureUnit_optional& ActualPressureValueType::
    pressureUnit () const
    {
      return this->pressureUnit_;
    }

    ActualPressureValueType::pressureUnit_optional& ActualPressureValueType::
    pressureUnit ()
    {
      return this->pressureUnit_;
    }

    void ActualPressureValueType::
    pressureUnit (const pressureUnit_type& x)
    {
      this->pressureUnit_.set (x);
    }

    void ActualPressureValueType::
    pressureUnit (const pressureUnit_optional& x)
    {
      this->pressureUnit_ = x;
    }

    void ActualPressureValueType::
    pressureUnit (::std::auto_ptr< pressureUnit_type > x)
    {
      this->pressureUnit_.set (x);
    }


    // SpeedUnitType
    // 

    const SpeedUnitType::SIUnitName_optional& SpeedUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    SpeedUnitType::SIUnitName_optional& SpeedUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void SpeedUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void SpeedUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void SpeedUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const SpeedUnitType::SIUnitName_type& SpeedUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const SpeedUnitType::UnitName_type& SpeedUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    SpeedUnitType::UnitName_type& SpeedUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void SpeedUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void SpeedUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const SpeedUnitType::UnitConversion_optional& SpeedUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    SpeedUnitType::UnitConversion_optional& SpeedUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void SpeedUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void SpeedUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void SpeedUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // SpeedValueType
    // 

    const SpeedValueType::speedUnit_optional& SpeedValueType::
    speedUnit () const
    {
      return this->speedUnit_;
    }

    SpeedValueType::speedUnit_optional& SpeedValueType::
    speedUnit ()
    {
      return this->speedUnit_;
    }

    void SpeedValueType::
    speedUnit (const speedUnit_type& x)
    {
      this->speedUnit_.set (x);
    }

    void SpeedValueType::
    speedUnit (const speedUnit_optional& x)
    {
      this->speedUnit_ = x;
    }

    void SpeedValueType::
    speedUnit (::std::auto_ptr< speedUnit_type > x)
    {
      this->speedUnit_.set (x);
    }


    // ActualSpeedValueType
    // 

    const ActualSpeedValueType::speedUnit_optional& ActualSpeedValueType::
    speedUnit () const
    {
      return this->speedUnit_;
    }

    ActualSpeedValueType::speedUnit_optional& ActualSpeedValueType::
    speedUnit ()
    {
      return this->speedUnit_;
    }

    void ActualSpeedValueType::
    speedUnit (const speedUnit_type& x)
    {
      this->speedUnit_.set (x);
    }

    void ActualSpeedValueType::
    speedUnit (const speedUnit_optional& x)
    {
      this->speedUnit_ = x;
    }

    void ActualSpeedValueType::
    speedUnit (::std::auto_ptr< speedUnit_type > x)
    {
      this->speedUnit_.set (x);
    }


    // TemperatureUnitType
    // 

    const TemperatureUnitType::SIUnitName_optional& TemperatureUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    TemperatureUnitType::SIUnitName_optional& TemperatureUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void TemperatureUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void TemperatureUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void TemperatureUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const TemperatureUnitType::SIUnitName_type& TemperatureUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const TemperatureUnitType::UnitName_type& TemperatureUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    TemperatureUnitType::UnitName_type& TemperatureUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void TemperatureUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void TemperatureUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const TemperatureUnitType::UnitConversion_optional& TemperatureUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    TemperatureUnitType::UnitConversion_optional& TemperatureUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void TemperatureUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void TemperatureUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void TemperatureUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // TemperatureValueType
    // 

    const TemperatureValueType::temperatureUnit_optional& TemperatureValueType::
    temperatureUnit () const
    {
      return this->temperatureUnit_;
    }

    TemperatureValueType::temperatureUnit_optional& TemperatureValueType::
    temperatureUnit ()
    {
      return this->temperatureUnit_;
    }

    void TemperatureValueType::
    temperatureUnit (const temperatureUnit_type& x)
    {
      this->temperatureUnit_.set (x);
    }

    void TemperatureValueType::
    temperatureUnit (const temperatureUnit_optional& x)
    {
      this->temperatureUnit_ = x;
    }

    void TemperatureValueType::
    temperatureUnit (::std::auto_ptr< temperatureUnit_type > x)
    {
      this->temperatureUnit_.set (x);
    }


    // ActualTemperatureValueType
    // 

    const ActualTemperatureValueType::temperatureUnit_optional& ActualTemperatureValueType::
    temperatureUnit () const
    {
      return this->temperatureUnit_;
    }

    ActualTemperatureValueType::temperatureUnit_optional& ActualTemperatureValueType::
    temperatureUnit ()
    {
      return this->temperatureUnit_;
    }

    void ActualTemperatureValueType::
    temperatureUnit (const temperatureUnit_type& x)
    {
      this->temperatureUnit_.set (x);
    }

    void ActualTemperatureValueType::
    temperatureUnit (const temperatureUnit_optional& x)
    {
      this->temperatureUnit_ = x;
    }

    void ActualTemperatureValueType::
    temperatureUnit (::std::auto_ptr< temperatureUnit_type > x)
    {
      this->temperatureUnit_.set (x);
    }


    // TimeUnitType
    // 

    const TimeUnitType::SIUnitName_optional& TimeUnitType::
    SIUnitName () const
    {
      return this->SIUnitName_;
    }

    TimeUnitType::SIUnitName_optional& TimeUnitType::
    SIUnitName ()
    {
      return this->SIUnitName_;
    }

    void TimeUnitType::
    SIUnitName (const SIUnitName_type& x)
    {
      this->SIUnitName_.set (x);
    }

    void TimeUnitType::
    SIUnitName (const SIUnitName_optional& x)
    {
      this->SIUnitName_ = x;
    }

    void TimeUnitType::
    SIUnitName (::std::auto_ptr< SIUnitName_type > x)
    {
      this->SIUnitName_.set (x);
    }

    const TimeUnitType::SIUnitName_type& TimeUnitType::
    SIUnitName_default_value ()
    {
      return SIUnitName_default_value_;
    }

    const TimeUnitType::UnitName_type& TimeUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    TimeUnitType::UnitName_type& TimeUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void TimeUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void TimeUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const TimeUnitType::UnitConversion_optional& TimeUnitType::
    UnitConversion () const
    {
      return this->UnitConversion_;
    }

    TimeUnitType::UnitConversion_optional& TimeUnitType::
    UnitConversion ()
    {
      return this->UnitConversion_;
    }

    void TimeUnitType::
    UnitConversion (const UnitConversion_type& x)
    {
      this->UnitConversion_.set (x);
    }

    void TimeUnitType::
    UnitConversion (const UnitConversion_optional& x)
    {
      this->UnitConversion_ = x;
    }

    void TimeUnitType::
    UnitConversion (::std::auto_ptr< UnitConversion_type > x)
    {
      this->UnitConversion_.set (x);
    }


    // TimeValueType
    // 

    const TimeValueType::timeUnit_optional& TimeValueType::
    timeUnit () const
    {
      return this->timeUnit_;
    }

    TimeValueType::timeUnit_optional& TimeValueType::
    timeUnit ()
    {
      return this->timeUnit_;
    }

    void TimeValueType::
    timeUnit (const timeUnit_type& x)
    {
      this->timeUnit_.set (x);
    }

    void TimeValueType::
    timeUnit (const timeUnit_optional& x)
    {
      this->timeUnit_ = x;
    }

    void TimeValueType::
    timeUnit (::std::auto_ptr< timeUnit_type > x)
    {
      this->timeUnit_.set (x);
    }


    // ActualTimeValueType
    // 

    const ActualTimeValueType::timeUnit_optional& ActualTimeValueType::
    timeUnit () const
    {
      return this->timeUnit_;
    }

    ActualTimeValueType::timeUnit_optional& ActualTimeValueType::
    timeUnit ()
    {
      return this->timeUnit_;
    }

    void ActualTimeValueType::
    timeUnit (const timeUnit_type& x)
    {
      this->timeUnit_.set (x);
    }

    void ActualTimeValueType::
    timeUnit (const timeUnit_optional& x)
    {
      this->timeUnit_ = x;
    }

    void ActualTimeValueType::
    timeUnit (::std::auto_ptr< timeUnit_type > x)
    {
      this->timeUnit_.set (x);
    }


    // PrimaryUnitsType
    // 

    const PrimaryUnitsType::AreaUnit_optional& PrimaryUnitsType::
    AreaUnit () const
    {
      return this->AreaUnit_;
    }

    PrimaryUnitsType::AreaUnit_optional& PrimaryUnitsType::
    AreaUnit ()
    {
      return this->AreaUnit_;
    }

    void PrimaryUnitsType::
    AreaUnit (const AreaUnit_type& x)
    {
      this->AreaUnit_.set (x);
    }

    void PrimaryUnitsType::
    AreaUnit (const AreaUnit_optional& x)
    {
      this->AreaUnit_ = x;
    }

    void PrimaryUnitsType::
    AreaUnit (::std::auto_ptr< AreaUnit_type > x)
    {
      this->AreaUnit_.set (x);
    }

    const PrimaryUnitsType::AngularUnit_optional& PrimaryUnitsType::
    AngularUnit () const
    {
      return this->AngularUnit_;
    }

    PrimaryUnitsType::AngularUnit_optional& PrimaryUnitsType::
    AngularUnit ()
    {
      return this->AngularUnit_;
    }

    void PrimaryUnitsType::
    AngularUnit (const AngularUnit_type& x)
    {
      this->AngularUnit_.set (x);
    }

    void PrimaryUnitsType::
    AngularUnit (const AngularUnit_optional& x)
    {
      this->AngularUnit_ = x;
    }

    void PrimaryUnitsType::
    AngularUnit (::std::auto_ptr< AngularUnit_type > x)
    {
      this->AngularUnit_.set (x);
    }

    const PrimaryUnitsType::ForceUnit_optional& PrimaryUnitsType::
    ForceUnit () const
    {
      return this->ForceUnit_;
    }

    PrimaryUnitsType::ForceUnit_optional& PrimaryUnitsType::
    ForceUnit ()
    {
      return this->ForceUnit_;
    }

    void PrimaryUnitsType::
    ForceUnit (const ForceUnit_type& x)
    {
      this->ForceUnit_.set (x);
    }

    void PrimaryUnitsType::
    ForceUnit (const ForceUnit_optional& x)
    {
      this->ForceUnit_ = x;
    }

    void PrimaryUnitsType::
    ForceUnit (::std::auto_ptr< ForceUnit_type > x)
    {
      this->ForceUnit_.set (x);
    }

    const PrimaryUnitsType::LinearUnit_optional& PrimaryUnitsType::
    LinearUnit () const
    {
      return this->LinearUnit_;
    }

    PrimaryUnitsType::LinearUnit_optional& PrimaryUnitsType::
    LinearUnit ()
    {
      return this->LinearUnit_;
    }

    void PrimaryUnitsType::
    LinearUnit (const LinearUnit_type& x)
    {
      this->LinearUnit_.set (x);
    }

    void PrimaryUnitsType::
    LinearUnit (const LinearUnit_optional& x)
    {
      this->LinearUnit_ = x;
    }

    void PrimaryUnitsType::
    LinearUnit (::std::auto_ptr< LinearUnit_type > x)
    {
      this->LinearUnit_.set (x);
    }

    const PrimaryUnitsType::MassUnit_optional& PrimaryUnitsType::
    MassUnit () const
    {
      return this->MassUnit_;
    }

    PrimaryUnitsType::MassUnit_optional& PrimaryUnitsType::
    MassUnit ()
    {
      return this->MassUnit_;
    }

    void PrimaryUnitsType::
    MassUnit (const MassUnit_type& x)
    {
      this->MassUnit_.set (x);
    }

    void PrimaryUnitsType::
    MassUnit (const MassUnit_optional& x)
    {
      this->MassUnit_ = x;
    }

    void PrimaryUnitsType::
    MassUnit (::std::auto_ptr< MassUnit_type > x)
    {
      this->MassUnit_.set (x);
    }

    const PrimaryUnitsType::PressureUnit_optional& PrimaryUnitsType::
    PressureUnit () const
    {
      return this->PressureUnit_;
    }

    PrimaryUnitsType::PressureUnit_optional& PrimaryUnitsType::
    PressureUnit ()
    {
      return this->PressureUnit_;
    }

    void PrimaryUnitsType::
    PressureUnit (const PressureUnit_type& x)
    {
      this->PressureUnit_.set (x);
    }

    void PrimaryUnitsType::
    PressureUnit (const PressureUnit_optional& x)
    {
      this->PressureUnit_ = x;
    }

    void PrimaryUnitsType::
    PressureUnit (::std::auto_ptr< PressureUnit_type > x)
    {
      this->PressureUnit_.set (x);
    }

    const PrimaryUnitsType::SpeedUnit_optional& PrimaryUnitsType::
    SpeedUnit () const
    {
      return this->SpeedUnit_;
    }

    PrimaryUnitsType::SpeedUnit_optional& PrimaryUnitsType::
    SpeedUnit ()
    {
      return this->SpeedUnit_;
    }

    void PrimaryUnitsType::
    SpeedUnit (const SpeedUnit_type& x)
    {
      this->SpeedUnit_.set (x);
    }

    void PrimaryUnitsType::
    SpeedUnit (const SpeedUnit_optional& x)
    {
      this->SpeedUnit_ = x;
    }

    void PrimaryUnitsType::
    SpeedUnit (::std::auto_ptr< SpeedUnit_type > x)
    {
      this->SpeedUnit_.set (x);
    }

    const PrimaryUnitsType::TemperatureUnit_optional& PrimaryUnitsType::
    TemperatureUnit () const
    {
      return this->TemperatureUnit_;
    }

    PrimaryUnitsType::TemperatureUnit_optional& PrimaryUnitsType::
    TemperatureUnit ()
    {
      return this->TemperatureUnit_;
    }

    void PrimaryUnitsType::
    TemperatureUnit (const TemperatureUnit_type& x)
    {
      this->TemperatureUnit_.set (x);
    }

    void PrimaryUnitsType::
    TemperatureUnit (const TemperatureUnit_optional& x)
    {
      this->TemperatureUnit_ = x;
    }

    void PrimaryUnitsType::
    TemperatureUnit (::std::auto_ptr< TemperatureUnit_type > x)
    {
      this->TemperatureUnit_.set (x);
    }

    const PrimaryUnitsType::TimeUnit_optional& PrimaryUnitsType::
    TimeUnit () const
    {
      return this->TimeUnit_;
    }

    PrimaryUnitsType::TimeUnit_optional& PrimaryUnitsType::
    TimeUnit ()
    {
      return this->TimeUnit_;
    }

    void PrimaryUnitsType::
    TimeUnit (const TimeUnit_type& x)
    {
      this->TimeUnit_.set (x);
    }

    void PrimaryUnitsType::
    TimeUnit (const TimeUnit_optional& x)
    {
      this->TimeUnit_ = x;
    }

    void PrimaryUnitsType::
    TimeUnit (::std::auto_ptr< TimeUnit_type > x)
    {
      this->TimeUnit_.set (x);
    }


    // OtherUnitsType
    // 

    const OtherUnitsType::AreaUnit_sequence& OtherUnitsType::
    AreaUnit () const
    {
      return this->AreaUnit_;
    }

    OtherUnitsType::AreaUnit_sequence& OtherUnitsType::
    AreaUnit ()
    {
      return this->AreaUnit_;
    }

    void OtherUnitsType::
    AreaUnit (const AreaUnit_sequence& s)
    {
      this->AreaUnit_ = s;
    }

    const OtherUnitsType::AngularUnit_sequence& OtherUnitsType::
    AngularUnit () const
    {
      return this->AngularUnit_;
    }

    OtherUnitsType::AngularUnit_sequence& OtherUnitsType::
    AngularUnit ()
    {
      return this->AngularUnit_;
    }

    void OtherUnitsType::
    AngularUnit (const AngularUnit_sequence& s)
    {
      this->AngularUnit_ = s;
    }

    const OtherUnitsType::ForceUnit_sequence& OtherUnitsType::
    ForceUnit () const
    {
      return this->ForceUnit_;
    }

    OtherUnitsType::ForceUnit_sequence& OtherUnitsType::
    ForceUnit ()
    {
      return this->ForceUnit_;
    }

    void OtherUnitsType::
    ForceUnit (const ForceUnit_sequence& s)
    {
      this->ForceUnit_ = s;
    }

    const OtherUnitsType::LinearUnit_sequence& OtherUnitsType::
    LinearUnit () const
    {
      return this->LinearUnit_;
    }

    OtherUnitsType::LinearUnit_sequence& OtherUnitsType::
    LinearUnit ()
    {
      return this->LinearUnit_;
    }

    void OtherUnitsType::
    LinearUnit (const LinearUnit_sequence& s)
    {
      this->LinearUnit_ = s;
    }

    const OtherUnitsType::MassUnit_sequence& OtherUnitsType::
    MassUnit () const
    {
      return this->MassUnit_;
    }

    OtherUnitsType::MassUnit_sequence& OtherUnitsType::
    MassUnit ()
    {
      return this->MassUnit_;
    }

    void OtherUnitsType::
    MassUnit (const MassUnit_sequence& s)
    {
      this->MassUnit_ = s;
    }

    const OtherUnitsType::PressureUnit_sequence& OtherUnitsType::
    PressureUnit () const
    {
      return this->PressureUnit_;
    }

    OtherUnitsType::PressureUnit_sequence& OtherUnitsType::
    PressureUnit ()
    {
      return this->PressureUnit_;
    }

    void OtherUnitsType::
    PressureUnit (const PressureUnit_sequence& s)
    {
      this->PressureUnit_ = s;
    }

    const OtherUnitsType::SpeedUnit_sequence& OtherUnitsType::
    SpeedUnit () const
    {
      return this->SpeedUnit_;
    }

    OtherUnitsType::SpeedUnit_sequence& OtherUnitsType::
    SpeedUnit ()
    {
      return this->SpeedUnit_;
    }

    void OtherUnitsType::
    SpeedUnit (const SpeedUnit_sequence& s)
    {
      this->SpeedUnit_ = s;
    }

    const OtherUnitsType::TemperatureUnit_sequence& OtherUnitsType::
    TemperatureUnit () const
    {
      return this->TemperatureUnit_;
    }

    OtherUnitsType::TemperatureUnit_sequence& OtherUnitsType::
    TemperatureUnit ()
    {
      return this->TemperatureUnit_;
    }

    void OtherUnitsType::
    TemperatureUnit (const TemperatureUnit_sequence& s)
    {
      this->TemperatureUnit_ = s;
    }

    const OtherUnitsType::TimeUnit_sequence& OtherUnitsType::
    TimeUnit () const
    {
      return this->TimeUnit_;
    }

    OtherUnitsType::TimeUnit_sequence& OtherUnitsType::
    TimeUnit ()
    {
      return this->TimeUnit_;
    }

    void OtherUnitsType::
    TimeUnit (const TimeUnit_sequence& s)
    {
      this->TimeUnit_ = s;
    }


    // UserDefinedUnitType
    // 

    const UserDefinedUnitType::WhatIsMeasured_type& UserDefinedUnitType::
    WhatIsMeasured () const
    {
      return this->WhatIsMeasured_.get ();
    }

    UserDefinedUnitType::WhatIsMeasured_type& UserDefinedUnitType::
    WhatIsMeasured ()
    {
      return this->WhatIsMeasured_.get ();
    }

    void UserDefinedUnitType::
    WhatIsMeasured (const WhatIsMeasured_type& x)
    {
      this->WhatIsMeasured_.set (x);
    }

    void UserDefinedUnitType::
    WhatIsMeasured (::std::auto_ptr< WhatIsMeasured_type > x)
    {
      this->WhatIsMeasured_.set (x);
    }

    const UserDefinedUnitType::UnitName_type& UserDefinedUnitType::
    UnitName () const
    {
      return this->UnitName_.get ();
    }

    UserDefinedUnitType::UnitName_type& UserDefinedUnitType::
    UnitName ()
    {
      return this->UnitName_.get ();
    }

    void UserDefinedUnitType::
    UnitName (const UnitName_type& x)
    {
      this->UnitName_.set (x);
    }

    void UserDefinedUnitType::
    UnitName (::std::auto_ptr< UnitName_type > x)
    {
      this->UnitName_.set (x);
    }

    const UserDefinedUnitType::StandardName_optional& UserDefinedUnitType::
    StandardName () const
    {
      return this->StandardName_;
    }

    UserDefinedUnitType::StandardName_optional& UserDefinedUnitType::
    StandardName ()
    {
      return this->StandardName_;
    }

    void UserDefinedUnitType::
    StandardName (const StandardName_type& x)
    {
      this->StandardName_.set (x);
    }

    void UserDefinedUnitType::
    StandardName (const StandardName_optional& x)
    {
      this->StandardName_ = x;
    }

    void UserDefinedUnitType::
    StandardName (::std::auto_ptr< StandardName_type > x)
    {
      this->StandardName_.set (x);
    }


    // UserDefinedUnitValueType
    // 

    const UserDefinedUnitValueType::unitName_type& UserDefinedUnitValueType::
    unitName () const
    {
      return this->unitName_.get ();
    }

    UserDefinedUnitValueType::unitName_type& UserDefinedUnitValueType::
    unitName ()
    {
      return this->unitName_.get ();
    }

    void UserDefinedUnitValueType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void UserDefinedUnitValueType::
    unitName (::std::auto_ptr< unitName_type > x)
    {
      this->unitName_.set (x);
    }


    // ActualUserDefinedUnitValueType
    // 

    const ActualUserDefinedUnitValueType::unitName_type& ActualUserDefinedUnitValueType::
    unitName () const
    {
      return this->unitName_.get ();
    }

    ActualUserDefinedUnitValueType::unitName_type& ActualUserDefinedUnitValueType::
    unitName ()
    {
      return this->unitName_.get ();
    }

    void ActualUserDefinedUnitValueType::
    unitName (const unitName_type& x)
    {
      this->unitName_.set (x);
    }

    void ActualUserDefinedUnitValueType::
    unitName (::std::auto_ptr< unitName_type > x)
    {
      this->unitName_.set (x);
    }


    // UserDefinedUnitsType
    // 

    const UserDefinedUnitsType::UserDefinedUnit_sequence& UserDefinedUnitsType::
    UserDefinedUnit () const
    {
      return this->UserDefinedUnit_;
    }

    UserDefinedUnitsType::UserDefinedUnit_sequence& UserDefinedUnitsType::
    UserDefinedUnit ()
    {
      return this->UserDefinedUnit_;
    }

    void UserDefinedUnitsType::
    UserDefinedUnit (const UserDefinedUnit_sequence& s)
    {
      this->UserDefinedUnit_ = s;
    }


    // FileUnitsType
    // 

    const FileUnitsType::PrimaryUnits_type& FileUnitsType::
    PrimaryUnits () const
    {
      return this->PrimaryUnits_.get ();
    }

    FileUnitsType::PrimaryUnits_type& FileUnitsType::
    PrimaryUnits ()
    {
      return this->PrimaryUnits_.get ();
    }

    void FileUnitsType::
    PrimaryUnits (const PrimaryUnits_type& x)
    {
      this->PrimaryUnits_.set (x);
    }

    void FileUnitsType::
    PrimaryUnits (::std::auto_ptr< PrimaryUnits_type > x)
    {
      this->PrimaryUnits_.set (x);
    }

    const FileUnitsType::OtherUnits_optional& FileUnitsType::
    OtherUnits () const
    {
      return this->OtherUnits_;
    }

    FileUnitsType::OtherUnits_optional& FileUnitsType::
    OtherUnits ()
    {
      return this->OtherUnits_;
    }

    void FileUnitsType::
    OtherUnits (const OtherUnits_type& x)
    {
      this->OtherUnits_.set (x);
    }

    void FileUnitsType::
    OtherUnits (const OtherUnits_optional& x)
    {
      this->OtherUnits_ = x;
    }

    void FileUnitsType::
    OtherUnits (::std::auto_ptr< OtherUnits_type > x)
    {
      this->OtherUnits_.set (x);
    }

    const FileUnitsType::UserDefinedUnits_optional& FileUnitsType::
    UserDefinedUnits () const
    {
      return this->UserDefinedUnits_;
    }

    FileUnitsType::UserDefinedUnits_optional& FileUnitsType::
    UserDefinedUnits ()
    {
      return this->UserDefinedUnits_;
    }

    void FileUnitsType::
    UserDefinedUnits (const UserDefinedUnits_type& x)
    {
      this->UserDefinedUnits_.set (x);
    }

    void FileUnitsType::
    UserDefinedUnits (const UserDefinedUnits_optional& x)
    {
      this->UserDefinedUnits_ = x;
    }

    void FileUnitsType::
    UserDefinedUnits (::std::auto_ptr< UserDefinedUnits_type > x)
    {
      this->UserDefinedUnits_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace xsd
{
  namespace qif2
  {
    // PositiveDecimalType
    //

    PositiveDecimalType::
    PositiveDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const PositiveDecimalType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
    {
    }

    PositiveDecimalType::
    PositiveDecimalType (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
    {
    }

    PositiveDecimalType* PositiveDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PositiveDecimalType (*this, f, c);
    }

    PositiveDecimalType::
    ~PositiveDecimalType ()
    {
    }

    // NonNegativeDecimalType
    //

    NonNegativeDecimalType::
    NonNegativeDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const NonNegativeDecimalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f, c)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (a, f, c)
    {
    }

    NonNegativeDecimalType::
    NonNegativeDecimalType (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (s, e, f, c)
    {
    }

    NonNegativeDecimalType* NonNegativeDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NonNegativeDecimalType (*this, f, c);
    }

    NonNegativeDecimalType::
    ~NonNegativeDecimalType ()
    {
    }

    // UnitConversionType
    //

    UnitConversionType::
    UnitConversionType (const Factor_type& Factor)
    : ::xml_schema::type (),
      Factor_ (Factor, ::xml_schema::flags (), this),
      Offset_ (::xml_schema::flags (), this)
    {
    }

    UnitConversionType::
    UnitConversionType (const UnitConversionType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Factor_ (x.Factor_, f, this),
      Offset_ (x.Offset_, f, this)
    {
    }

    UnitConversionType::
    UnitConversionType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Factor_ (f, this),
      Offset_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void UnitConversionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Factor
        //
        if (n.name () == "Factor" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Factor_type > r (
            Factor_traits::create (i, f, this));

          if (!Factor_.present ())
          {
            this->Factor_.set (r);
            continue;
          }
        }

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->Offset_)
          {
            this->Offset_.set (Offset_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Factor_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Factor",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    UnitConversionType* UnitConversionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UnitConversionType (*this, f, c);
    }

    UnitConversionType::
    ~UnitConversionType ()
    {
    }

    // SpecifiedDecimalType
    //

    SpecifiedDecimalType::
    SpecifiedDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
      decimalPlaces_ (::xml_schema::flags (), this),
      significantFigures_ (::xml_schema::flags (), this)
    {
    }

    SpecifiedDecimalType::
    SpecifiedDecimalType (const SpecifiedDecimalType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this)
    {
    }

    SpecifiedDecimalType::
    SpecifiedDecimalType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
      decimalPlaces_ (f, this),
      significantFigures_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void SpecifiedDecimalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }
      }
    }

    SpecifiedDecimalType* SpecifiedDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpecifiedDecimalType (*this, f, c);
    }

    SpecifiedDecimalType::
    ~SpecifiedDecimalType ()
    {
    }

    // ActualDecimalType
    //

    ActualDecimalType::
    ActualDecimalType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      combinedUncertainty_ (::xml_schema::flags (), this),
      meanError_ (::xml_schema::flags (), this)
    {
    }

    ActualDecimalType::
    ActualDecimalType (const ActualDecimalType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this)
    {
    }

    ActualDecimalType::
    ActualDecimalType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      combinedUncertainty_ (f, this),
      meanError_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualDecimalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "combinedUncertainty" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< combinedUncertainty_type > r (
            combinedUncertainty_traits::create (i, f, this));

          this->combinedUncertainty_.set (r);
          continue;
        }

        if (n.name () == "meanError" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< meanError_type > r (
            meanError_traits::create (i, f, this));

          this->meanError_.set (r);
          continue;
        }
      }
    }

    ActualDecimalType* ActualDecimalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualDecimalType (*this, f, c);
    }

    ActualDecimalType::
    ~ActualDecimalType ()
    {
    }

    // AngularUnitType
    //

    const AngularUnitType::SIUnitName_type AngularUnitType::SIUnitName_default_value_ (
      "radian");

    AngularUnitType::
    AngularUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (::xml_schema::flags (), this),
      UnitName_ (UnitName, ::xml_schema::flags (), this),
      UnitConversion_ (::xml_schema::flags (), this)
    {
    }

    AngularUnitType::
    AngularUnitType (const AngularUnitType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    AngularUnitType::
    AngularUnitType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (f, this),
      UnitName_ (f, this),
      UnitConversion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void AngularUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AngularUnitType* AngularUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularUnitType (*this, f, c);
    }

    AngularUnitType::
    ~AngularUnitType ()
    {
    }

    // AngularValueType
    //

    AngularValueType::
    AngularValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      angularUnit_ (::xml_schema::flags (), this)
    {
    }

    AngularValueType::
    AngularValueType (const AngularValueType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    AngularValueType::
    AngularValueType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void AngularValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "angularUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< angularUnit_type > r (
            angularUnit_traits::create (i, f, this));

          this->angularUnit_.set (r);
          continue;
        }
      }
    }

    AngularValueType* AngularValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AngularValueType (*this, f, c);
    }

    AngularValueType::
    ~AngularValueType ()
    {
    }

    // ActualAngularValueType
    //

    ActualAngularValueType::
    ActualAngularValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      angularUnit_ (::xml_schema::flags (), this)
    {
    }

    ActualAngularValueType::
    ActualAngularValueType (const ActualAngularValueType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      angularUnit_ (x.angularUnit_, f, this)
    {
    }

    ActualAngularValueType::
    ActualAngularValueType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      angularUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualAngularValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "angularUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< angularUnit_type > r (
            angularUnit_traits::create (i, f, this));

          this->angularUnit_.set (r);
          continue;
        }
      }
    }

    ActualAngularValueType* ActualAngularValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualAngularValueType (*this, f, c);
    }

    ActualAngularValueType::
    ~ActualAngularValueType ()
    {
    }

    // AreaUnitType
    //

    const AreaUnitType::SIUnitName_type AreaUnitType::SIUnitName_default_value_ (
      "square meter");

    AreaUnitType::
    AreaUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (::xml_schema::flags (), this),
      UnitName_ (UnitName, ::xml_schema::flags (), this),
      UnitConversion_ (::xml_schema::flags (), this)
    {
    }

    AreaUnitType::
    AreaUnitType (const AreaUnitType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    AreaUnitType::
    AreaUnitType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (f, this),
      UnitName_ (f, this),
      UnitConversion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void AreaUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    AreaUnitType* AreaUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AreaUnitType (*this, f, c);
    }

    AreaUnitType::
    ~AreaUnitType ()
    {
    }

    // AreaValueType
    //

    AreaValueType::
    AreaValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      areaUnit_ (::xml_schema::flags (), this)
    {
    }

    AreaValueType::
    AreaValueType (const AreaValueType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      areaUnit_ (x.areaUnit_, f, this)
    {
    }

    AreaValueType::
    AreaValueType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      areaUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void AreaValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "areaUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< areaUnit_type > r (
            areaUnit_traits::create (i, f, this));

          this->areaUnit_.set (r);
          continue;
        }
      }
    }

    AreaValueType* AreaValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AreaValueType (*this, f, c);
    }

    AreaValueType::
    ~AreaValueType ()
    {
    }

    // ActualAreaValueType
    //

    ActualAreaValueType::
    ActualAreaValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      areaUnit_ (::xml_schema::flags (), this)
    {
    }

    ActualAreaValueType::
    ActualAreaValueType (const ActualAreaValueType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      areaUnit_ (x.areaUnit_, f, this)
    {
    }

    ActualAreaValueType::
    ActualAreaValueType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      areaUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualAreaValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "areaUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< areaUnit_type > r (
            areaUnit_traits::create (i, f, this));

          this->areaUnit_.set (r);
          continue;
        }
      }
    }

    ActualAreaValueType* ActualAreaValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualAreaValueType (*this, f, c);
    }

    ActualAreaValueType::
    ~ActualAreaValueType ()
    {
    }

    // ForceUnitType
    //

    const ForceUnitType::SIUnitName_type ForceUnitType::SIUnitName_default_value_ (
      "newton");

    ForceUnitType::
    ForceUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (::xml_schema::flags (), this),
      UnitName_ (UnitName, ::xml_schema::flags (), this),
      UnitConversion_ (::xml_schema::flags (), this)
    {
    }

    ForceUnitType::
    ForceUnitType (const ForceUnitType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    ForceUnitType::
    ForceUnitType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (f, this),
      UnitName_ (f, this),
      UnitConversion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ForceUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ForceUnitType* ForceUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ForceUnitType (*this, f, c);
    }

    ForceUnitType::
    ~ForceUnitType ()
    {
    }

    // ForceValueType
    //

    ForceValueType::
    ForceValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      forceUnit_ (::xml_schema::flags (), this)
    {
    }

    ForceValueType::
    ForceValueType (const ForceValueType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      forceUnit_ (x.forceUnit_, f, this)
    {
    }

    ForceValueType::
    ForceValueType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      forceUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ForceValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "forceUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< forceUnit_type > r (
            forceUnit_traits::create (i, f, this));

          this->forceUnit_.set (r);
          continue;
        }
      }
    }

    ForceValueType* ForceValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ForceValueType (*this, f, c);
    }

    ForceValueType::
    ~ForceValueType ()
    {
    }

    // ActualForceValueType
    //

    ActualForceValueType::
    ActualForceValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      forceUnit_ (::xml_schema::flags (), this)
    {
    }

    ActualForceValueType::
    ActualForceValueType (const ActualForceValueType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      forceUnit_ (x.forceUnit_, f, this)
    {
    }

    ActualForceValueType::
    ActualForceValueType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      forceUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualForceValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "forceUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< forceUnit_type > r (
            forceUnit_traits::create (i, f, this));

          this->forceUnit_.set (r);
          continue;
        }
      }
    }

    ActualForceValueType* ActualForceValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualForceValueType (*this, f, c);
    }

    ActualForceValueType::
    ~ActualForceValueType ()
    {
    }

    // LinearUnitType
    //

    const LinearUnitType::SIUnitName_type LinearUnitType::SIUnitName_default_value_ (
      "meter");

    LinearUnitType::
    LinearUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (::xml_schema::flags (), this),
      UnitName_ (UnitName, ::xml_schema::flags (), this),
      UnitConversion_ (::xml_schema::flags (), this)
    {
    }

    LinearUnitType::
    LinearUnitType (const LinearUnitType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    LinearUnitType::
    LinearUnitType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (f, this),
      UnitName_ (f, this),
      UnitConversion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void LinearUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LinearUnitType* LinearUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearUnitType (*this, f, c);
    }

    LinearUnitType::
    ~LinearUnitType ()
    {
    }

    // LinearValueType
    //

    LinearValueType::
    LinearValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      linearUnit_ (::xml_schema::flags (), this)
    {
    }

    LinearValueType::
    LinearValueType (const LinearValueType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this)
    {
    }

    LinearValueType::
    LinearValueType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void LinearValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }
      }
    }

    LinearValueType* LinearValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinearValueType (*this, f, c);
    }

    LinearValueType::
    ~LinearValueType ()
    {
    }

    // ActualLinearValueType
    //

    ActualLinearValueType::
    ActualLinearValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      linearUnit_ (::xml_schema::flags (), this)
    {
    }

    ActualLinearValueType::
    ActualLinearValueType (const ActualLinearValueType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      linearUnit_ (x.linearUnit_, f, this)
    {
    }

    ActualLinearValueType::
    ActualLinearValueType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      linearUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualLinearValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< linearUnit_type > r (
            linearUnit_traits::create (i, f, this));

          this->linearUnit_.set (r);
          continue;
        }
      }
    }

    ActualLinearValueType* ActualLinearValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualLinearValueType (*this, f, c);
    }

    ActualLinearValueType::
    ~ActualLinearValueType ()
    {
    }

    // MassUnitType
    //

    const MassUnitType::SIUnitName_type MassUnitType::SIUnitName_default_value_ (
      "kilogram");

    MassUnitType::
    MassUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (::xml_schema::flags (), this),
      UnitName_ (UnitName, ::xml_schema::flags (), this),
      UnitConversion_ (::xml_schema::flags (), this)
    {
    }

    MassUnitType::
    MassUnitType (const MassUnitType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    MassUnitType::
    MassUnitType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (f, this),
      UnitName_ (f, this),
      UnitConversion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void MassUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MassUnitType* MassUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MassUnitType (*this, f, c);
    }

    MassUnitType::
    ~MassUnitType ()
    {
    }

    // MassValueType
    //

    MassValueType::
    MassValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      massUnit_ (::xml_schema::flags (), this)
    {
    }

    MassValueType::
    MassValueType (const MassValueType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      massUnit_ (x.massUnit_, f, this)
    {
    }

    MassValueType::
    MassValueType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      massUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void MassValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "massUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< massUnit_type > r (
            massUnit_traits::create (i, f, this));

          this->massUnit_.set (r);
          continue;
        }
      }
    }

    MassValueType* MassValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MassValueType (*this, f, c);
    }

    MassValueType::
    ~MassValueType ()
    {
    }

    // ActualMassValueType
    //

    ActualMassValueType::
    ActualMassValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      massUnit_ (::xml_schema::flags (), this)
    {
    }

    ActualMassValueType::
    ActualMassValueType (const ActualMassValueType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      massUnit_ (x.massUnit_, f, this)
    {
    }

    ActualMassValueType::
    ActualMassValueType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      massUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualMassValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "massUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< massUnit_type > r (
            massUnit_traits::create (i, f, this));

          this->massUnit_.set (r);
          continue;
        }
      }
    }

    ActualMassValueType* ActualMassValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualMassValueType (*this, f, c);
    }

    ActualMassValueType::
    ~ActualMassValueType ()
    {
    }

    // PressureUnitType
    //

    const PressureUnitType::SIUnitName_type PressureUnitType::SIUnitName_default_value_ (
      "pascal");

    PressureUnitType::
    PressureUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (::xml_schema::flags (), this),
      UnitName_ (UnitName, ::xml_schema::flags (), this),
      UnitConversion_ (::xml_schema::flags (), this)
    {
    }

    PressureUnitType::
    PressureUnitType (const PressureUnitType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    PressureUnitType::
    PressureUnitType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (f, this),
      UnitName_ (f, this),
      UnitConversion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PressureUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PressureUnitType* PressureUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PressureUnitType (*this, f, c);
    }

    PressureUnitType::
    ~PressureUnitType ()
    {
    }

    // PressureValueType
    //

    PressureValueType::
    PressureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      pressureUnit_ (::xml_schema::flags (), this)
    {
    }

    PressureValueType::
    PressureValueType (const PressureValueType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      pressureUnit_ (x.pressureUnit_, f, this)
    {
    }

    PressureValueType::
    PressureValueType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      pressureUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void PressureValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "pressureUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< pressureUnit_type > r (
            pressureUnit_traits::create (i, f, this));

          this->pressureUnit_.set (r);
          continue;
        }
      }
    }

    PressureValueType* PressureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PressureValueType (*this, f, c);
    }

    PressureValueType::
    ~PressureValueType ()
    {
    }

    // ActualPressureValueType
    //

    ActualPressureValueType::
    ActualPressureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      pressureUnit_ (::xml_schema::flags (), this)
    {
    }

    ActualPressureValueType::
    ActualPressureValueType (const ActualPressureValueType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      pressureUnit_ (x.pressureUnit_, f, this)
    {
    }

    ActualPressureValueType::
    ActualPressureValueType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      pressureUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualPressureValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "pressureUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< pressureUnit_type > r (
            pressureUnit_traits::create (i, f, this));

          this->pressureUnit_.set (r);
          continue;
        }
      }
    }

    ActualPressureValueType* ActualPressureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualPressureValueType (*this, f, c);
    }

    ActualPressureValueType::
    ~ActualPressureValueType ()
    {
    }

    // SpeedUnitType
    //

    const SpeedUnitType::SIUnitName_type SpeedUnitType::SIUnitName_default_value_ (
      "meter per second");

    SpeedUnitType::
    SpeedUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (::xml_schema::flags (), this),
      UnitName_ (UnitName, ::xml_schema::flags (), this),
      UnitConversion_ (::xml_schema::flags (), this)
    {
    }

    SpeedUnitType::
    SpeedUnitType (const SpeedUnitType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    SpeedUnitType::
    SpeedUnitType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (f, this),
      UnitName_ (f, this),
      UnitConversion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void SpeedUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SpeedUnitType* SpeedUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpeedUnitType (*this, f, c);
    }

    SpeedUnitType::
    ~SpeedUnitType ()
    {
    }

    // SpeedValueType
    //

    SpeedValueType::
    SpeedValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      speedUnit_ (::xml_schema::flags (), this)
    {
    }

    SpeedValueType::
    SpeedValueType (const SpeedValueType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      speedUnit_ (x.speedUnit_, f, this)
    {
    }

    SpeedValueType::
    SpeedValueType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      speedUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void SpeedValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "speedUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< speedUnit_type > r (
            speedUnit_traits::create (i, f, this));

          this->speedUnit_.set (r);
          continue;
        }
      }
    }

    SpeedValueType* SpeedValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SpeedValueType (*this, f, c);
    }

    SpeedValueType::
    ~SpeedValueType ()
    {
    }

    // ActualSpeedValueType
    //

    ActualSpeedValueType::
    ActualSpeedValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      speedUnit_ (::xml_schema::flags (), this)
    {
    }

    ActualSpeedValueType::
    ActualSpeedValueType (const ActualSpeedValueType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      speedUnit_ (x.speedUnit_, f, this)
    {
    }

    ActualSpeedValueType::
    ActualSpeedValueType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      speedUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualSpeedValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "speedUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< speedUnit_type > r (
            speedUnit_traits::create (i, f, this));

          this->speedUnit_.set (r);
          continue;
        }
      }
    }

    ActualSpeedValueType* ActualSpeedValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualSpeedValueType (*this, f, c);
    }

    ActualSpeedValueType::
    ~ActualSpeedValueType ()
    {
    }

    // TemperatureUnitType
    //

    const TemperatureUnitType::SIUnitName_type TemperatureUnitType::SIUnitName_default_value_ (
      "kelvin");

    TemperatureUnitType::
    TemperatureUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (::xml_schema::flags (), this),
      UnitName_ (UnitName, ::xml_schema::flags (), this),
      UnitConversion_ (::xml_schema::flags (), this)
    {
    }

    TemperatureUnitType::
    TemperatureUnitType (const TemperatureUnitType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    TemperatureUnitType::
    TemperatureUnitType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (f, this),
      UnitName_ (f, this),
      UnitConversion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TemperatureUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TemperatureUnitType* TemperatureUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureUnitType (*this, f, c);
    }

    TemperatureUnitType::
    ~TemperatureUnitType ()
    {
    }

    // TemperatureValueType
    //

    TemperatureValueType::
    TemperatureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      temperatureUnit_ (::xml_schema::flags (), this)
    {
    }

    TemperatureValueType::
    TemperatureValueType (const TemperatureValueType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      temperatureUnit_ (x.temperatureUnit_, f, this)
    {
    }

    TemperatureValueType::
    TemperatureValueType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      temperatureUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void TemperatureValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "temperatureUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< temperatureUnit_type > r (
            temperatureUnit_traits::create (i, f, this));

          this->temperatureUnit_.set (r);
          continue;
        }
      }
    }

    TemperatureValueType* TemperatureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TemperatureValueType (*this, f, c);
    }

    TemperatureValueType::
    ~TemperatureValueType ()
    {
    }

    // ActualTemperatureValueType
    //

    ActualTemperatureValueType::
    ActualTemperatureValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      temperatureUnit_ (::xml_schema::flags (), this)
    {
    }

    ActualTemperatureValueType::
    ActualTemperatureValueType (const ActualTemperatureValueType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      temperatureUnit_ (x.temperatureUnit_, f, this)
    {
    }

    ActualTemperatureValueType::
    ActualTemperatureValueType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      temperatureUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualTemperatureValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "temperatureUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< temperatureUnit_type > r (
            temperatureUnit_traits::create (i, f, this));

          this->temperatureUnit_.set (r);
          continue;
        }
      }
    }

    ActualTemperatureValueType* ActualTemperatureValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualTemperatureValueType (*this, f, c);
    }

    ActualTemperatureValueType::
    ~ActualTemperatureValueType ()
    {
    }

    // TimeUnitType
    //

    const TimeUnitType::SIUnitName_type TimeUnitType::SIUnitName_default_value_ (
      "second");

    TimeUnitType::
    TimeUnitType (const UnitName_type& UnitName)
    : ::xml_schema::type (),
      SIUnitName_ (::xml_schema::flags (), this),
      UnitName_ (UnitName, ::xml_schema::flags (), this),
      UnitConversion_ (::xml_schema::flags (), this)
    {
    }

    TimeUnitType::
    TimeUnitType (const TimeUnitType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SIUnitName_ (x.SIUnitName_, f, this),
      UnitName_ (x.UnitName_, f, this),
      UnitConversion_ (x.UnitConversion_, f, this)
    {
    }

    TimeUnitType::
    TimeUnitType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SIUnitName_ (f, this),
      UnitName_ (f, this),
      UnitConversion_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TimeUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SIUnitName
        //
        if (n.name () == "SIUnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SIUnitName_type > r (
            SIUnitName_traits::create (i, f, this));

          if (!this->SIUnitName_)
          {
            this->SIUnitName_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // UnitConversion
        //
        if (n.name () == "UnitConversion" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitConversion_type > r (
            UnitConversion_traits::create (i, f, this));

          if (!this->UnitConversion_)
          {
            this->UnitConversion_.set (r);
            continue;
          }
        }

        break;
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TimeUnitType* TimeUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TimeUnitType (*this, f, c);
    }

    TimeUnitType::
    ~TimeUnitType ()
    {
    }

    // TimeValueType
    //

    TimeValueType::
    TimeValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      timeUnit_ (::xml_schema::flags (), this)
    {
    }

    TimeValueType::
    TimeValueType (const TimeValueType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      timeUnit_ (x.timeUnit_, f, this)
    {
    }

    TimeValueType::
    TimeValueType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      timeUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void TimeValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "timeUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< timeUnit_type > r (
            timeUnit_traits::create (i, f, this));

          this->timeUnit_.set (r);
          continue;
        }
      }
    }

    TimeValueType* TimeValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TimeValueType (*this, f, c);
    }

    TimeValueType::
    ~TimeValueType ()
    {
    }

    // ActualTimeValueType
    //

    ActualTimeValueType::
    ActualTimeValueType (const ::xml_schema::decimal& _xsd_decimal_base)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      timeUnit_ (::xml_schema::flags (), this)
    {
    }

    ActualTimeValueType::
    ActualTimeValueType (const ActualTimeValueType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      timeUnit_ (x.timeUnit_, f, this)
    {
    }

    ActualTimeValueType::
    ActualTimeValueType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      timeUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualTimeValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "timeUnit" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< timeUnit_type > r (
            timeUnit_traits::create (i, f, this));

          this->timeUnit_.set (r);
          continue;
        }
      }
    }

    ActualTimeValueType* ActualTimeValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualTimeValueType (*this, f, c);
    }

    ActualTimeValueType::
    ~ActualTimeValueType ()
    {
    }

    // PrimaryUnitsType
    //

    PrimaryUnitsType::
    PrimaryUnitsType ()
    : ::xml_schema::type (),
      AreaUnit_ (::xml_schema::flags (), this),
      AngularUnit_ (::xml_schema::flags (), this),
      ForceUnit_ (::xml_schema::flags (), this),
      LinearUnit_ (::xml_schema::flags (), this),
      MassUnit_ (::xml_schema::flags (), this),
      PressureUnit_ (::xml_schema::flags (), this),
      SpeedUnit_ (::xml_schema::flags (), this),
      TemperatureUnit_ (::xml_schema::flags (), this),
      TimeUnit_ (::xml_schema::flags (), this)
    {
    }

    PrimaryUnitsType::
    PrimaryUnitsType (const PrimaryUnitsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AreaUnit_ (x.AreaUnit_, f, this),
      AngularUnit_ (x.AngularUnit_, f, this),
      ForceUnit_ (x.ForceUnit_, f, this),
      LinearUnit_ (x.LinearUnit_, f, this),
      MassUnit_ (x.MassUnit_, f, this),
      PressureUnit_ (x.PressureUnit_, f, this),
      SpeedUnit_ (x.SpeedUnit_, f, this),
      TemperatureUnit_ (x.TemperatureUnit_, f, this),
      TimeUnit_ (x.TimeUnit_, f, this)
    {
    }

    PrimaryUnitsType::
    PrimaryUnitsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AreaUnit_ (f, this),
      AngularUnit_ (f, this),
      ForceUnit_ (f, this),
      LinearUnit_ (f, this),
      MassUnit_ (f, this),
      PressureUnit_ (f, this),
      SpeedUnit_ (f, this),
      TemperatureUnit_ (f, this),
      TimeUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void PrimaryUnitsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AreaUnit
        //
        if (n.name () == "AreaUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AreaUnit_type > r (
            AreaUnit_traits::create (i, f, this));

          if (!this->AreaUnit_)
          {
            this->AreaUnit_.set (r);
            continue;
          }
        }

        // AngularUnit
        //
        if (n.name () == "AngularUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AngularUnit_type > r (
            AngularUnit_traits::create (i, f, this));

          if (!this->AngularUnit_)
          {
            this->AngularUnit_.set (r);
            continue;
          }
        }

        // ForceUnit
        //
        if (n.name () == "ForceUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ForceUnit_type > r (
            ForceUnit_traits::create (i, f, this));

          if (!this->ForceUnit_)
          {
            this->ForceUnit_.set (r);
            continue;
          }
        }

        // LinearUnit
        //
        if (n.name () == "LinearUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LinearUnit_type > r (
            LinearUnit_traits::create (i, f, this));

          if (!this->LinearUnit_)
          {
            this->LinearUnit_.set (r);
            continue;
          }
        }

        // MassUnit
        //
        if (n.name () == "MassUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MassUnit_type > r (
            MassUnit_traits::create (i, f, this));

          if (!this->MassUnit_)
          {
            this->MassUnit_.set (r);
            continue;
          }
        }

        // PressureUnit
        //
        if (n.name () == "PressureUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PressureUnit_type > r (
            PressureUnit_traits::create (i, f, this));

          if (!this->PressureUnit_)
          {
            this->PressureUnit_.set (r);
            continue;
          }
        }

        // SpeedUnit
        //
        if (n.name () == "SpeedUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SpeedUnit_type > r (
            SpeedUnit_traits::create (i, f, this));

          if (!this->SpeedUnit_)
          {
            this->SpeedUnit_.set (r);
            continue;
          }
        }

        // TemperatureUnit
        //
        if (n.name () == "TemperatureUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TemperatureUnit_type > r (
            TemperatureUnit_traits::create (i, f, this));

          if (!this->TemperatureUnit_)
          {
            this->TemperatureUnit_.set (r);
            continue;
          }
        }

        // TimeUnit
        //
        if (n.name () == "TimeUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TimeUnit_type > r (
            TimeUnit_traits::create (i, f, this));

          if (!this->TimeUnit_)
          {
            this->TimeUnit_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PrimaryUnitsType* PrimaryUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PrimaryUnitsType (*this, f, c);
    }

    PrimaryUnitsType::
    ~PrimaryUnitsType ()
    {
    }

    // OtherUnitsType
    //

    OtherUnitsType::
    OtherUnitsType ()
    : ::xml_schema::type (),
      AreaUnit_ (::xml_schema::flags (), this),
      AngularUnit_ (::xml_schema::flags (), this),
      ForceUnit_ (::xml_schema::flags (), this),
      LinearUnit_ (::xml_schema::flags (), this),
      MassUnit_ (::xml_schema::flags (), this),
      PressureUnit_ (::xml_schema::flags (), this),
      SpeedUnit_ (::xml_schema::flags (), this),
      TemperatureUnit_ (::xml_schema::flags (), this),
      TimeUnit_ (::xml_schema::flags (), this)
    {
    }

    OtherUnitsType::
    OtherUnitsType (const OtherUnitsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      AreaUnit_ (x.AreaUnit_, f, this),
      AngularUnit_ (x.AngularUnit_, f, this),
      ForceUnit_ (x.ForceUnit_, f, this),
      LinearUnit_ (x.LinearUnit_, f, this),
      MassUnit_ (x.MassUnit_, f, this),
      PressureUnit_ (x.PressureUnit_, f, this),
      SpeedUnit_ (x.SpeedUnit_, f, this),
      TemperatureUnit_ (x.TemperatureUnit_, f, this),
      TimeUnit_ (x.TimeUnit_, f, this)
    {
    }

    OtherUnitsType::
    OtherUnitsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      AreaUnit_ (f, this),
      AngularUnit_ (f, this),
      ForceUnit_ (f, this),
      LinearUnit_ (f, this),
      MassUnit_ (f, this),
      PressureUnit_ (f, this),
      SpeedUnit_ (f, this),
      TemperatureUnit_ (f, this),
      TimeUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void OtherUnitsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // AreaUnit
        //
        if (n.name () == "AreaUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AreaUnit_type > r (
            AreaUnit_traits::create (i, f, this));

          this->AreaUnit_.push_back (r);
          continue;
        }

        // AngularUnit
        //
        if (n.name () == "AngularUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AngularUnit_type > r (
            AngularUnit_traits::create (i, f, this));

          this->AngularUnit_.push_back (r);
          continue;
        }

        // ForceUnit
        //
        if (n.name () == "ForceUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ForceUnit_type > r (
            ForceUnit_traits::create (i, f, this));

          this->ForceUnit_.push_back (r);
          continue;
        }

        // LinearUnit
        //
        if (n.name () == "LinearUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LinearUnit_type > r (
            LinearUnit_traits::create (i, f, this));

          this->LinearUnit_.push_back (r);
          continue;
        }

        // MassUnit
        //
        if (n.name () == "MassUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MassUnit_type > r (
            MassUnit_traits::create (i, f, this));

          this->MassUnit_.push_back (r);
          continue;
        }

        // PressureUnit
        //
        if (n.name () == "PressureUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PressureUnit_type > r (
            PressureUnit_traits::create (i, f, this));

          this->PressureUnit_.push_back (r);
          continue;
        }

        // SpeedUnit
        //
        if (n.name () == "SpeedUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SpeedUnit_type > r (
            SpeedUnit_traits::create (i, f, this));

          this->SpeedUnit_.push_back (r);
          continue;
        }

        // TemperatureUnit
        //
        if (n.name () == "TemperatureUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TemperatureUnit_type > r (
            TemperatureUnit_traits::create (i, f, this));

          this->TemperatureUnit_.push_back (r);
          continue;
        }

        // TimeUnit
        //
        if (n.name () == "TimeUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TimeUnit_type > r (
            TimeUnit_traits::create (i, f, this));

          this->TimeUnit_.push_back (r);
          continue;
        }

        break;
      }
    }

    OtherUnitsType* OtherUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OtherUnitsType (*this, f, c);
    }

    OtherUnitsType::
    ~OtherUnitsType ()
    {
    }

    // UserDefinedUnitType
    //

    UserDefinedUnitType::
    UserDefinedUnitType (const WhatIsMeasured_type& WhatIsMeasured,
                         const UnitName_type& UnitName)
    : ::xml_schema::type (),
      WhatIsMeasured_ (WhatIsMeasured, ::xml_schema::flags (), this),
      UnitName_ (UnitName, ::xml_schema::flags (), this),
      StandardName_ (::xml_schema::flags (), this)
    {
    }

    UserDefinedUnitType::
    UserDefinedUnitType (const UserDefinedUnitType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      WhatIsMeasured_ (x.WhatIsMeasured_, f, this),
      UnitName_ (x.UnitName_, f, this),
      StandardName_ (x.StandardName_, f, this)
    {
    }

    UserDefinedUnitType::
    UserDefinedUnitType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      WhatIsMeasured_ (f, this),
      UnitName_ (f, this),
      StandardName_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void UserDefinedUnitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // WhatIsMeasured
        //
        if (n.name () == "WhatIsMeasured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WhatIsMeasured_type > r (
            WhatIsMeasured_traits::create (i, f, this));

          if (!WhatIsMeasured_.present ())
          {
            this->WhatIsMeasured_.set (r);
            continue;
          }
        }

        // UnitName
        //
        if (n.name () == "UnitName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UnitName_type > r (
            UnitName_traits::create (i, f, this));

          if (!UnitName_.present ())
          {
            this->UnitName_.set (r);
            continue;
          }
        }

        // StandardName
        //
        if (n.name () == "StandardName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< StandardName_type > r (
            StandardName_traits::create (i, f, this));

          if (!this->StandardName_)
          {
            this->StandardName_.set (r);
            continue;
          }
        }

        break;
      }

      if (!WhatIsMeasured_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "WhatIsMeasured",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!UnitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "UnitName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    UserDefinedUnitType* UserDefinedUnitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedUnitType (*this, f, c);
    }

    UserDefinedUnitType::
    ~UserDefinedUnitType ()
    {
    }

    // UserDefinedUnitValueType
    //

    UserDefinedUnitValueType::
    UserDefinedUnitValueType (const ::xml_schema::decimal& _xsd_decimal_base,
                              const unitName_type& unitName)
    : ::xsd::qif2::SpecifiedDecimalType (_xsd_decimal_base),
      unitName_ (unitName, ::xml_schema::flags (), this)
    {
    }

    UserDefinedUnitValueType::
    UserDefinedUnitValueType (const UserDefinedUnitValueType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (x, f, c),
      unitName_ (x.unitName_, f, this)
    {
    }

    UserDefinedUnitValueType::
    UserDefinedUnitValueType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::SpecifiedDecimalType (e, f | ::xml_schema::flags::base, c),
      unitName_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void UserDefinedUnitValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::SpecifiedDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unitName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< unitName_type > r (
            unitName_traits::create (i, f, this));

          this->unitName_.set (r);
          continue;
        }
      }

      if (!unitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "unitName",
          "");
      }
    }

    UserDefinedUnitValueType* UserDefinedUnitValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedUnitValueType (*this, f, c);
    }

    UserDefinedUnitValueType::
    ~UserDefinedUnitValueType ()
    {
    }

    // ActualUserDefinedUnitValueType
    //

    ActualUserDefinedUnitValueType::
    ActualUserDefinedUnitValueType (const ::xml_schema::decimal& _xsd_decimal_base,
                                    const unitName_type& unitName)
    : ::xsd::qif2::ActualDecimalType (_xsd_decimal_base),
      unitName_ (unitName, ::xml_schema::flags (), this)
    {
    }

    ActualUserDefinedUnitValueType::
    ActualUserDefinedUnitValueType (const ActualUserDefinedUnitValueType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (x, f, c),
      unitName_ (x.unitName_, f, this)
    {
    }

    ActualUserDefinedUnitValueType::
    ActualUserDefinedUnitValueType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ActualDecimalType (e, f | ::xml_schema::flags::base, c),
      unitName_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
        this->parse (p, f);
      }
    }

    void ActualUserDefinedUnitValueType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ActualDecimalType::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "unitName" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< unitName_type > r (
            unitName_traits::create (i, f, this));

          this->unitName_.set (r);
          continue;
        }
      }

      if (!unitName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "unitName",
          "");
      }
    }

    ActualUserDefinedUnitValueType* ActualUserDefinedUnitValueType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ActualUserDefinedUnitValueType (*this, f, c);
    }

    ActualUserDefinedUnitValueType::
    ~ActualUserDefinedUnitValueType ()
    {
    }

    // UserDefinedUnitsType
    //

    UserDefinedUnitsType::
    UserDefinedUnitsType ()
    : ::xml_schema::type (),
      UserDefinedUnit_ (::xml_schema::flags (), this)
    {
    }

    UserDefinedUnitsType::
    UserDefinedUnitsType (const UserDefinedUnitsType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      UserDefinedUnit_ (x.UserDefinedUnit_, f, this)
    {
    }

    UserDefinedUnitsType::
    UserDefinedUnitsType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      UserDefinedUnit_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void UserDefinedUnitsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // UserDefinedUnit
        //
        if (n.name () == "UserDefinedUnit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedUnit_type > r (
            UserDefinedUnit_traits::create (i, f, this));

          this->UserDefinedUnit_.push_back (r);
          continue;
        }

        break;
      }
    }

    UserDefinedUnitsType* UserDefinedUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UserDefinedUnitsType (*this, f, c);
    }

    UserDefinedUnitsType::
    ~UserDefinedUnitsType ()
    {
    }

    // FileUnitsType
    //

    FileUnitsType::
    FileUnitsType (const PrimaryUnits_type& PrimaryUnits)
    : ::xml_schema::type (),
      PrimaryUnits_ (PrimaryUnits, ::xml_schema::flags (), this),
      OtherUnits_ (::xml_schema::flags (), this),
      UserDefinedUnits_ (::xml_schema::flags (), this)
    {
    }

    FileUnitsType::
    FileUnitsType (::std::auto_ptr< PrimaryUnits_type >& PrimaryUnits)
    : ::xml_schema::type (),
      PrimaryUnits_ (PrimaryUnits, ::xml_schema::flags (), this),
      OtherUnits_ (::xml_schema::flags (), this),
      UserDefinedUnits_ (::xml_schema::flags (), this)
    {
    }

    FileUnitsType::
    FileUnitsType (const FileUnitsType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PrimaryUnits_ (x.PrimaryUnits_, f, this),
      OtherUnits_ (x.OtherUnits_, f, this),
      UserDefinedUnits_ (x.UserDefinedUnits_, f, this)
    {
    }

    FileUnitsType::
    FileUnitsType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PrimaryUnits_ (f, this),
      OtherUnits_ (f, this),
      UserDefinedUnits_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
        this->parse (p, f);
      }
    }

    void FileUnitsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PrimaryUnits
        //
        if (n.name () == "PrimaryUnits" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PrimaryUnits_type > r (
            PrimaryUnits_traits::create (i, f, this));

          if (!PrimaryUnits_.present ())
          {
            this->PrimaryUnits_.set (r);
            continue;
          }
        }

        // OtherUnits
        //
        if (n.name () == "OtherUnits" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< OtherUnits_type > r (
            OtherUnits_traits::create (i, f, this));

          if (!this->OtherUnits_)
          {
            this->OtherUnits_.set (r);
            continue;
          }
        }

        // UserDefinedUnits
        //
        if (n.name () == "UserDefinedUnits" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< UserDefinedUnits_type > r (
            UserDefinedUnits_traits::create (i, f, this));

          if (!this->UserDefinedUnits_)
          {
            this->UserDefinedUnits_.set (r);
            continue;
          }
        }

        break;
      }

      if (!PrimaryUnits_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PrimaryUnits",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FileUnitsType* FileUnitsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FileUnitsType (*this, f, c);
    }

    FileUnitsType::
    ~FileUnitsType ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FileUnitsType > r (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FileUnitsType > r (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FileUnitsType > r (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FileUnits (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FileUnits (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::xsd::qif2::FileUnits (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FileUnits (isrc, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FileUnits (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::xsd::qif2::FileUnits (isrc, h, f, p);
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      ::std::auto_ptr< ::xsd::qif2::FileUnitsType > r (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FileUnitsType > r (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      ::std::auto_ptr< ::xsd::qif2::FileUnitsType > r (
        ::xsd::qif2::FileUnits (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::xsd::qif2::FileUnitsType > r (
          ::xsd::qif2::FileUnits (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "FileUnits" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FileUnitsType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FileUnitsType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FileUnits",
        "http://qifstandards.org/xsd/qif2");
    }

    ::std::auto_ptr< ::xsd::qif2::FileUnitsType >
    FileUnits (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "FileUnits" &&
          n.namespace_ () == "http://qifstandards.org/xsd/qif2")
      {
        ::std::auto_ptr< ::xsd::qif2::FileUnitsType > r (
          ::xsd::cxx::tree::traits< ::xsd::qif2::FileUnitsType, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "FileUnits",
        "http://qifstandards.org/xsd/qif2");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

