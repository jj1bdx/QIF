// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Features.hxx"

namespace xsd
{
  namespace qif2
  {
    // FeatureBaseType
    // 

    const FeatureBaseType::Attributes_optional& FeatureBaseType::
    Attributes () const
    {
      return this->Attributes_;
    }

    FeatureBaseType::Attributes_optional& FeatureBaseType::
    Attributes ()
    {
      return this->Attributes_;
    }

    void FeatureBaseType::
    Attributes (const Attributes_type& x)
    {
      this->Attributes_.set (x);
    }

    void FeatureBaseType::
    Attributes (const Attributes_optional& x)
    {
      this->Attributes_ = x;
    }

    void FeatureBaseType::
    Attributes (::std::auto_ptr< Attributes_type > x)
    {
      this->Attributes_.set (x);
    }

    const FeatureBaseType::id_type& FeatureBaseType::
    id () const
    {
      return this->id_.get ();
    }

    FeatureBaseType::id_type& FeatureBaseType::
    id ()
    {
      return this->id_.get ();
    }

    void FeatureBaseType::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void FeatureBaseType::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // FeatureItemBaseType
    // 

    const FeatureItemBaseType::FeatureNominalId_optional& FeatureItemBaseType::
    FeatureNominalId () const
    {
      return this->FeatureNominalId_;
    }

    FeatureItemBaseType::FeatureNominalId_optional& FeatureItemBaseType::
    FeatureNominalId ()
    {
      return this->FeatureNominalId_;
    }

    void FeatureItemBaseType::
    FeatureNominalId (const FeatureNominalId_type& x)
    {
      this->FeatureNominalId_.set (x);
    }

    void FeatureItemBaseType::
    FeatureNominalId (const FeatureNominalId_optional& x)
    {
      this->FeatureNominalId_ = x;
    }

    void FeatureItemBaseType::
    FeatureNominalId (::std::auto_ptr< FeatureNominalId_type > x)
    {
      this->FeatureNominalId_.set (x);
    }

    const FeatureItemBaseType::ParentFeatureItemId_optional& FeatureItemBaseType::
    ParentFeatureItemId () const
    {
      return this->ParentFeatureItemId_;
    }

    FeatureItemBaseType::ParentFeatureItemId_optional& FeatureItemBaseType::
    ParentFeatureItemId ()
    {
      return this->ParentFeatureItemId_;
    }

    void FeatureItemBaseType::
    ParentFeatureItemId (const ParentFeatureItemId_type& x)
    {
      this->ParentFeatureItemId_.set (x);
    }

    void FeatureItemBaseType::
    ParentFeatureItemId (const ParentFeatureItemId_optional& x)
    {
      this->ParentFeatureItemId_ = x;
    }

    void FeatureItemBaseType::
    ParentFeatureItemId (::std::auto_ptr< ParentFeatureItemId_type > x)
    {
      this->ParentFeatureItemId_.set (x);
    }

    const FeatureItemBaseType::FeatureName_type& FeatureItemBaseType::
    FeatureName () const
    {
      return this->FeatureName_.get ();
    }

    FeatureItemBaseType::FeatureName_type& FeatureItemBaseType::
    FeatureName ()
    {
      return this->FeatureName_.get ();
    }

    void FeatureItemBaseType::
    FeatureName (const FeatureName_type& x)
    {
      this->FeatureName_.set (x);
    }

    void FeatureItemBaseType::
    FeatureName (::std::auto_ptr< FeatureName_type > x)
    {
      this->FeatureName_.set (x);
    }

    const FeatureItemBaseType::QPId_optional& FeatureItemBaseType::
    QPId () const
    {
      return this->QPId_;
    }

    FeatureItemBaseType::QPId_optional& FeatureItemBaseType::
    QPId ()
    {
      return this->QPId_;
    }

    void FeatureItemBaseType::
    QPId (const QPId_type& x)
    {
      this->QPId_.set (x);
    }

    void FeatureItemBaseType::
    QPId (const QPId_optional& x)
    {
      this->QPId_ = x;
    }

    void FeatureItemBaseType::
    QPId (::std::auto_ptr< QPId_type > x)
    {
      this->QPId_.set (x);
    }

    const FeatureItemBaseType::NotableEventIds_optional& FeatureItemBaseType::
    NotableEventIds () const
    {
      return this->NotableEventIds_;
    }

    FeatureItemBaseType::NotableEventIds_optional& FeatureItemBaseType::
    NotableEventIds ()
    {
      return this->NotableEventIds_;
    }

    void FeatureItemBaseType::
    NotableEventIds (const NotableEventIds_type& x)
    {
      this->NotableEventIds_.set (x);
    }

    void FeatureItemBaseType::
    NotableEventIds (const NotableEventIds_optional& x)
    {
      this->NotableEventIds_ = x;
    }

    void FeatureItemBaseType::
    NotableEventIds (::std::auto_ptr< NotableEventIds_type > x)
    {
      this->NotableEventIds_.set (x);
    }

    const FeatureItemBaseType::CoordinateSystemId_optional& FeatureItemBaseType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_;
    }

    FeatureItemBaseType::CoordinateSystemId_optional& FeatureItemBaseType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_;
    }

    void FeatureItemBaseType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void FeatureItemBaseType::
    CoordinateSystemId (const CoordinateSystemId_optional& x)
    {
      this->CoordinateSystemId_ = x;
    }

    void FeatureItemBaseType::
    CoordinateSystemId (::std::auto_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (x);
    }


    // FeatureDefinitionBaseType
    // 


    // PointListNominalType
    // 

    const PointListNominalType::MeasurePoint_sequence& PointListNominalType::
    MeasurePoint () const
    {
      return this->MeasurePoint_;
    }

    PointListNominalType::MeasurePoint_sequence& PointListNominalType::
    MeasurePoint ()
    {
      return this->MeasurePoint_;
    }

    void PointListNominalType::
    MeasurePoint (const MeasurePoint_sequence& s)
    {
      this->MeasurePoint_ = s;
    }

    const PointListNominalType::linearUnit_optional& PointListNominalType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    PointListNominalType::linearUnit_optional& PointListNominalType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void PointListNominalType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void PointListNominalType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void PointListNominalType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const PointListNominalType::decimalPlaces_optional& PointListNominalType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    PointListNominalType::decimalPlaces_optional& PointListNominalType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void PointListNominalType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void PointListNominalType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const PointListNominalType::significantFigures_optional& PointListNominalType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    PointListNominalType::significantFigures_optional& PointListNominalType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void PointListNominalType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void PointListNominalType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const PointListNominalType::validity_optional& PointListNominalType::
    validity () const
    {
      return this->validity_;
    }

    PointListNominalType::validity_optional& PointListNominalType::
    validity ()
    {
      return this->validity_;
    }

    void PointListNominalType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void PointListNominalType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void PointListNominalType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const PointListNominalType::xDecimalPlaces_optional& PointListNominalType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    PointListNominalType::xDecimalPlaces_optional& PointListNominalType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void PointListNominalType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void PointListNominalType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const PointListNominalType::xSignificantFigures_optional& PointListNominalType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    PointListNominalType::xSignificantFigures_optional& PointListNominalType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void PointListNominalType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void PointListNominalType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const PointListNominalType::xValidity_optional& PointListNominalType::
    xValidity () const
    {
      return this->xValidity_;
    }

    PointListNominalType::xValidity_optional& PointListNominalType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void PointListNominalType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void PointListNominalType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void PointListNominalType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const PointListNominalType::yDecimalPlaces_optional& PointListNominalType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    PointListNominalType::yDecimalPlaces_optional& PointListNominalType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void PointListNominalType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void PointListNominalType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const PointListNominalType::ySignificantFigures_optional& PointListNominalType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    PointListNominalType::ySignificantFigures_optional& PointListNominalType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void PointListNominalType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void PointListNominalType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const PointListNominalType::yValidity_optional& PointListNominalType::
    yValidity () const
    {
      return this->yValidity_;
    }

    PointListNominalType::yValidity_optional& PointListNominalType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void PointListNominalType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void PointListNominalType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void PointListNominalType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const PointListNominalType::zDecimalPlaces_optional& PointListNominalType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    PointListNominalType::zDecimalPlaces_optional& PointListNominalType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void PointListNominalType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void PointListNominalType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const PointListNominalType::zSignificantFigures_optional& PointListNominalType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    PointListNominalType::zSignificantFigures_optional& PointListNominalType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void PointListNominalType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void PointListNominalType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const PointListNominalType::zValidity_optional& PointListNominalType::
    zValidity () const
    {
      return this->zValidity_;
    }

    PointListNominalType::zValidity_optional& PointListNominalType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void PointListNominalType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void PointListNominalType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void PointListNominalType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }


    // FeatureNominalBaseType
    // 

    const FeatureNominalBaseType::Name_optional& FeatureNominalBaseType::
    Name () const
    {
      return this->Name_;
    }

    FeatureNominalBaseType::Name_optional& FeatureNominalBaseType::
    Name ()
    {
      return this->Name_;
    }

    void FeatureNominalBaseType::
    Name (const Name_type& x)
    {
      this->Name_.set (x);
    }

    void FeatureNominalBaseType::
    Name (const Name_optional& x)
    {
      this->Name_ = x;
    }

    void FeatureNominalBaseType::
    Name (::std::auto_ptr< Name_type > x)
    {
      this->Name_.set (x);
    }

    const FeatureNominalBaseType::PointList_optional& FeatureNominalBaseType::
    PointList () const
    {
      return this->PointList_;
    }

    FeatureNominalBaseType::PointList_optional& FeatureNominalBaseType::
    PointList ()
    {
      return this->PointList_;
    }

    void FeatureNominalBaseType::
    PointList (const PointList_type& x)
    {
      this->PointList_.set (x);
    }

    void FeatureNominalBaseType::
    PointList (const PointList_optional& x)
    {
      this->PointList_ = x;
    }

    void FeatureNominalBaseType::
    PointList (::std::auto_ptr< PointList_type > x)
    {
      this->PointList_.set (x);
    }

    const FeatureNominalBaseType::FeatureDefinitionId_type& FeatureNominalBaseType::
    FeatureDefinitionId () const
    {
      return this->FeatureDefinitionId_.get ();
    }

    FeatureNominalBaseType::FeatureDefinitionId_type& FeatureNominalBaseType::
    FeatureDefinitionId ()
    {
      return this->FeatureDefinitionId_.get ();
    }

    void FeatureNominalBaseType::
    FeatureDefinitionId (const FeatureDefinitionId_type& x)
    {
      this->FeatureDefinitionId_.set (x);
    }

    void FeatureNominalBaseType::
    FeatureDefinitionId (::std::auto_ptr< FeatureDefinitionId_type > x)
    {
      this->FeatureDefinitionId_.set (x);
    }

    const FeatureNominalBaseType::EntityInternalIds_optional& FeatureNominalBaseType::
    EntityInternalIds () const
    {
      return this->EntityInternalIds_;
    }

    FeatureNominalBaseType::EntityInternalIds_optional& FeatureNominalBaseType::
    EntityInternalIds ()
    {
      return this->EntityInternalIds_;
    }

    void FeatureNominalBaseType::
    EntityInternalIds (const EntityInternalIds_type& x)
    {
      this->EntityInternalIds_.set (x);
    }

    void FeatureNominalBaseType::
    EntityInternalIds (const EntityInternalIds_optional& x)
    {
      this->EntityInternalIds_ = x;
    }

    void FeatureNominalBaseType::
    EntityInternalIds (::std::auto_ptr< EntityInternalIds_type > x)
    {
      this->EntityInternalIds_.set (x);
    }

    const FeatureNominalBaseType::EntityExternalIds_optional& FeatureNominalBaseType::
    EntityExternalIds () const
    {
      return this->EntityExternalIds_;
    }

    FeatureNominalBaseType::EntityExternalIds_optional& FeatureNominalBaseType::
    EntityExternalIds ()
    {
      return this->EntityExternalIds_;
    }

    void FeatureNominalBaseType::
    EntityExternalIds (const EntityExternalIds_type& x)
    {
      this->EntityExternalIds_.set (x);
    }

    void FeatureNominalBaseType::
    EntityExternalIds (const EntityExternalIds_optional& x)
    {
      this->EntityExternalIds_ = x;
    }

    void FeatureNominalBaseType::
    EntityExternalIds (::std::auto_ptr< EntityExternalIds_type > x)
    {
      this->EntityExternalIds_.set (x);
    }


    // PointListActualType
    // 

    const PointListActualType::MeasurePoint_sequence& PointListActualType::
    MeasurePoint () const
    {
      return this->MeasurePoint_;
    }

    PointListActualType::MeasurePoint_sequence& PointListActualType::
    MeasurePoint ()
    {
      return this->MeasurePoint_;
    }

    void PointListActualType::
    MeasurePoint (const MeasurePoint_sequence& s)
    {
      this->MeasurePoint_ = s;
    }

    const PointListActualType::linearUnit_optional& PointListActualType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    PointListActualType::linearUnit_optional& PointListActualType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void PointListActualType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void PointListActualType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void PointListActualType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const PointListActualType::decimalPlaces_optional& PointListActualType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    PointListActualType::decimalPlaces_optional& PointListActualType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void PointListActualType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void PointListActualType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const PointListActualType::significantFigures_optional& PointListActualType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    PointListActualType::significantFigures_optional& PointListActualType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void PointListActualType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void PointListActualType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const PointListActualType::validity_optional& PointListActualType::
    validity () const
    {
      return this->validity_;
    }

    PointListActualType::validity_optional& PointListActualType::
    validity ()
    {
      return this->validity_;
    }

    void PointListActualType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void PointListActualType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void PointListActualType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const PointListActualType::xDecimalPlaces_optional& PointListActualType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    PointListActualType::xDecimalPlaces_optional& PointListActualType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void PointListActualType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void PointListActualType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const PointListActualType::xSignificantFigures_optional& PointListActualType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    PointListActualType::xSignificantFigures_optional& PointListActualType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void PointListActualType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void PointListActualType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const PointListActualType::xValidity_optional& PointListActualType::
    xValidity () const
    {
      return this->xValidity_;
    }

    PointListActualType::xValidity_optional& PointListActualType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void PointListActualType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void PointListActualType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void PointListActualType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const PointListActualType::yDecimalPlaces_optional& PointListActualType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    PointListActualType::yDecimalPlaces_optional& PointListActualType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void PointListActualType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void PointListActualType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const PointListActualType::ySignificantFigures_optional& PointListActualType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    PointListActualType::ySignificantFigures_optional& PointListActualType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void PointListActualType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void PointListActualType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const PointListActualType::yValidity_optional& PointListActualType::
    yValidity () const
    {
      return this->yValidity_;
    }

    PointListActualType::yValidity_optional& PointListActualType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void PointListActualType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void PointListActualType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void PointListActualType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const PointListActualType::zDecimalPlaces_optional& PointListActualType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    PointListActualType::zDecimalPlaces_optional& PointListActualType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void PointListActualType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void PointListActualType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const PointListActualType::zSignificantFigures_optional& PointListActualType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    PointListActualType::zSignificantFigures_optional& PointListActualType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void PointListActualType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void PointListActualType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const PointListActualType::zValidity_optional& PointListActualType::
    zValidity () const
    {
      return this->zValidity_;
    }

    PointListActualType::zValidity_optional& PointListActualType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void PointListActualType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void PointListActualType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void PointListActualType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }

    const PointListActualType::combinedUncertainty_optional& PointListActualType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    PointListActualType::combinedUncertainty_optional& PointListActualType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void PointListActualType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void PointListActualType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    const PointListActualType::meanError_optional& PointListActualType::
    meanError () const
    {
      return this->meanError_;
    }

    PointListActualType::meanError_optional& PointListActualType::
    meanError ()
    {
      return this->meanError_;
    }

    void PointListActualType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void PointListActualType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    const PointListActualType::xCombinedUncertainty_optional& PointListActualType::
    xCombinedUncertainty () const
    {
      return this->xCombinedUncertainty_;
    }

    PointListActualType::xCombinedUncertainty_optional& PointListActualType::
    xCombinedUncertainty ()
    {
      return this->xCombinedUncertainty_;
    }

    void PointListActualType::
    xCombinedUncertainty (const xCombinedUncertainty_type& x)
    {
      this->xCombinedUncertainty_.set (x);
    }

    void PointListActualType::
    xCombinedUncertainty (const xCombinedUncertainty_optional& x)
    {
      this->xCombinedUncertainty_ = x;
    }

    const PointListActualType::xMeanError_optional& PointListActualType::
    xMeanError () const
    {
      return this->xMeanError_;
    }

    PointListActualType::xMeanError_optional& PointListActualType::
    xMeanError ()
    {
      return this->xMeanError_;
    }

    void PointListActualType::
    xMeanError (const xMeanError_type& x)
    {
      this->xMeanError_.set (x);
    }

    void PointListActualType::
    xMeanError (const xMeanError_optional& x)
    {
      this->xMeanError_ = x;
    }

    const PointListActualType::yCombinedUncertainty_optional& PointListActualType::
    yCombinedUncertainty () const
    {
      return this->yCombinedUncertainty_;
    }

    PointListActualType::yCombinedUncertainty_optional& PointListActualType::
    yCombinedUncertainty ()
    {
      return this->yCombinedUncertainty_;
    }

    void PointListActualType::
    yCombinedUncertainty (const yCombinedUncertainty_type& x)
    {
      this->yCombinedUncertainty_.set (x);
    }

    void PointListActualType::
    yCombinedUncertainty (const yCombinedUncertainty_optional& x)
    {
      this->yCombinedUncertainty_ = x;
    }

    const PointListActualType::yMeanError_optional& PointListActualType::
    yMeanError () const
    {
      return this->yMeanError_;
    }

    PointListActualType::yMeanError_optional& PointListActualType::
    yMeanError ()
    {
      return this->yMeanError_;
    }

    void PointListActualType::
    yMeanError (const yMeanError_type& x)
    {
      this->yMeanError_.set (x);
    }

    void PointListActualType::
    yMeanError (const yMeanError_optional& x)
    {
      this->yMeanError_ = x;
    }

    const PointListActualType::zCombinedUncertainty_optional& PointListActualType::
    zCombinedUncertainty () const
    {
      return this->zCombinedUncertainty_;
    }

    PointListActualType::zCombinedUncertainty_optional& PointListActualType::
    zCombinedUncertainty ()
    {
      return this->zCombinedUncertainty_;
    }

    void PointListActualType::
    zCombinedUncertainty (const zCombinedUncertainty_type& x)
    {
      this->zCombinedUncertainty_.set (x);
    }

    void PointListActualType::
    zCombinedUncertainty (const zCombinedUncertainty_optional& x)
    {
      this->zCombinedUncertainty_ = x;
    }

    const PointListActualType::zMeanError_optional& PointListActualType::
    zMeanError () const
    {
      return this->zMeanError_;
    }

    PointListActualType::zMeanError_optional& PointListActualType::
    zMeanError ()
    {
      return this->zMeanError_;
    }

    void PointListActualType::
    zMeanError (const zMeanError_type& x)
    {
      this->zMeanError_.set (x);
    }

    void PointListActualType::
    zMeanError (const zMeanError_optional& x)
    {
      this->zMeanError_ = x;
    }


    // FeatureActualBaseType
    // 

    const FeatureActualBaseType::PointList_optional& FeatureActualBaseType::
    PointList () const
    {
      return this->PointList_;
    }

    FeatureActualBaseType::PointList_optional& FeatureActualBaseType::
    PointList ()
    {
      return this->PointList_;
    }

    void FeatureActualBaseType::
    PointList (const PointList_type& x)
    {
      this->PointList_.set (x);
    }

    void FeatureActualBaseType::
    PointList (const PointList_optional& x)
    {
      this->PointList_ = x;
    }

    void FeatureActualBaseType::
    PointList (::std::auto_ptr< PointList_type > x)
    {
      this->PointList_.set (x);
    }

    const FeatureActualBaseType::FeatureItemId_type& FeatureActualBaseType::
    FeatureItemId () const
    {
      return this->FeatureItemId_.get ();
    }

    FeatureActualBaseType::FeatureItemId_type& FeatureActualBaseType::
    FeatureItemId ()
    {
      return this->FeatureItemId_.get ();
    }

    void FeatureActualBaseType::
    FeatureItemId (const FeatureItemId_type& x)
    {
      this->FeatureItemId_.set (x);
    }

    void FeatureActualBaseType::
    FeatureItemId (::std::auto_ptr< FeatureItemId_type > x)
    {
      this->FeatureItemId_.set (x);
    }

    const FeatureActualBaseType::ActualComponentId_optional& FeatureActualBaseType::
    ActualComponentId () const
    {
      return this->ActualComponentId_;
    }

    FeatureActualBaseType::ActualComponentId_optional& FeatureActualBaseType::
    ActualComponentId ()
    {
      return this->ActualComponentId_;
    }

    void FeatureActualBaseType::
    ActualComponentId (const ActualComponentId_type& x)
    {
      this->ActualComponentId_.set (x);
    }

    void FeatureActualBaseType::
    ActualComponentId (const ActualComponentId_optional& x)
    {
      this->ActualComponentId_ = x;
    }

    void FeatureActualBaseType::
    ActualComponentId (::std::auto_ptr< ActualComponentId_type > x)
    {
      this->ActualComponentId_.set (x);
    }

    const FeatureActualBaseType::ManufacturingProcessId_optional& FeatureActualBaseType::
    ManufacturingProcessId () const
    {
      return this->ManufacturingProcessId_;
    }

    FeatureActualBaseType::ManufacturingProcessId_optional& FeatureActualBaseType::
    ManufacturingProcessId ()
    {
      return this->ManufacturingProcessId_;
    }

    void FeatureActualBaseType::
    ManufacturingProcessId (const ManufacturingProcessId_type& x)
    {
      this->ManufacturingProcessId_.set (x);
    }

    void FeatureActualBaseType::
    ManufacturingProcessId (const ManufacturingProcessId_optional& x)
    {
      this->ManufacturingProcessId_ = x;
    }

    void FeatureActualBaseType::
    ManufacturingProcessId (::std::auto_ptr< ManufacturingProcessId_type > x)
    {
      this->ManufacturingProcessId_.set (x);
    }

    const FeatureActualBaseType::MeasurementDeviceIds_optional& FeatureActualBaseType::
    MeasurementDeviceIds () const
    {
      return this->MeasurementDeviceIds_;
    }

    FeatureActualBaseType::MeasurementDeviceIds_optional& FeatureActualBaseType::
    MeasurementDeviceIds ()
    {
      return this->MeasurementDeviceIds_;
    }

    void FeatureActualBaseType::
    MeasurementDeviceIds (const MeasurementDeviceIds_type& x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    void FeatureActualBaseType::
    MeasurementDeviceIds (const MeasurementDeviceIds_optional& x)
    {
      this->MeasurementDeviceIds_ = x;
    }

    void FeatureActualBaseType::
    MeasurementDeviceIds (::std::auto_ptr< MeasurementDeviceIds_type > x)
    {
      this->MeasurementDeviceIds_.set (x);
    }

    const FeatureActualBaseType::NotedEventIds_optional& FeatureActualBaseType::
    NotedEventIds () const
    {
      return this->NotedEventIds_;
    }

    FeatureActualBaseType::NotedEventIds_optional& FeatureActualBaseType::
    NotedEventIds ()
    {
      return this->NotedEventIds_;
    }

    void FeatureActualBaseType::
    NotedEventIds (const NotedEventIds_type& x)
    {
      this->NotedEventIds_.set (x);
    }

    void FeatureActualBaseType::
    NotedEventIds (const NotedEventIds_optional& x)
    {
      this->NotedEventIds_ = x;
    }

    void FeatureActualBaseType::
    NotedEventIds (::std::auto_ptr< NotedEventIds_type > x)
    {
      this->NotedEventIds_.set (x);
    }


    // SetFeatureType
    // 


    // MeasuredFeatureType
    // 

    const MeasuredFeatureType::PointList_optional& MeasuredFeatureType::
    PointList () const
    {
      return this->PointList_;
    }

    MeasuredFeatureType::PointList_optional& MeasuredFeatureType::
    PointList ()
    {
      return this->PointList_;
    }

    void MeasuredFeatureType::
    PointList (const PointList_type& x)
    {
      this->PointList_.set (x);
    }

    void MeasuredFeatureType::
    PointList (const PointList_optional& x)
    {
      this->PointList_ = x;
    }

    void MeasuredFeatureType::
    PointList (::std::auto_ptr< PointList_type > x)
    {
      this->PointList_.set (x);
    }


    // ConstructionMethodBaseType
    // 

    const ConstructionMethodBaseType::NominalsCalculated_optional& ConstructionMethodBaseType::
    NominalsCalculated () const
    {
      return this->NominalsCalculated_;
    }

    ConstructionMethodBaseType::NominalsCalculated_optional& ConstructionMethodBaseType::
    NominalsCalculated ()
    {
      return this->NominalsCalculated_;
    }

    void ConstructionMethodBaseType::
    NominalsCalculated (const NominalsCalculated_type& x)
    {
      this->NominalsCalculated_.set (x);
    }

    void ConstructionMethodBaseType::
    NominalsCalculated (const NominalsCalculated_optional& x)
    {
      this->NominalsCalculated_ = x;
    }


    // PointRangeType
    // 

    const PointRangeType::Start_type& PointRangeType::
    Start () const
    {
      return this->Start_.get ();
    }

    PointRangeType::Start_type& PointRangeType::
    Start ()
    {
      return this->Start_.get ();
    }

    void PointRangeType::
    Start (const Start_type& x)
    {
      this->Start_.set (x);
    }

    const PointRangeType::Stop_type& PointRangeType::
    Stop () const
    {
      return this->Stop_.get ();
    }

    PointRangeType::Stop_type& PointRangeType::
    Stop ()
    {
      return this->Stop_.get ();
    }

    void PointRangeType::
    Stop (const Stop_type& x)
    {
      this->Stop_.set (x);
    }


    // PointIndexType
    // 

    const PointIndexType::Single_optional& PointIndexType::
    Single () const
    {
      return this->Single_;
    }

    PointIndexType::Single_optional& PointIndexType::
    Single ()
    {
      return this->Single_;
    }

    void PointIndexType::
    Single (const Single_type& x)
    {
      this->Single_.set (x);
    }

    void PointIndexType::
    Single (const Single_optional& x)
    {
      this->Single_ = x;
    }

    const PointIndexType::Range_optional& PointIndexType::
    Range () const
    {
      return this->Range_;
    }

    PointIndexType::Range_optional& PointIndexType::
    Range ()
    {
      return this->Range_;
    }

    void PointIndexType::
    Range (const Range_type& x)
    {
      this->Range_.set (x);
    }

    void PointIndexType::
    Range (const Range_optional& x)
    {
      this->Range_ = x;
    }

    void PointIndexType::
    Range (::std::auto_ptr< Range_type > x)
    {
      this->Range_.set (x);
    }

    const PointIndexType::All_optional& PointIndexType::
    All () const
    {
      return this->All_;
    }

    PointIndexType::All_optional& PointIndexType::
    All ()
    {
      return this->All_;
    }

    void PointIndexType::
    All (const All_type& x)
    {
      this->All_.set (x);
    }

    void PointIndexType::
    All (const All_optional& x)
    {
      this->All_ = x;
    }

    void PointIndexType::
    All (::std::auto_ptr< All_type > x)
    {
      this->All_.set (x);
    }

    const PointIndexType::All_type& PointIndexType::
    All_default_value ()
    {
      return All_default_value_;
    }


    // BaseFeaturePointSetType
    // 

    const BaseFeaturePointSetType::FeatureItemId_type& BaseFeaturePointSetType::
    FeatureItemId () const
    {
      return this->FeatureItemId_.get ();
    }

    BaseFeaturePointSetType::FeatureItemId_type& BaseFeaturePointSetType::
    FeatureItemId ()
    {
      return this->FeatureItemId_.get ();
    }

    void BaseFeaturePointSetType::
    FeatureItemId (const FeatureItemId_type& x)
    {
      this->FeatureItemId_.set (x);
    }

    void BaseFeaturePointSetType::
    FeatureItemId (::std::auto_ptr< FeatureItemId_type > x)
    {
      this->FeatureItemId_.set (x);
    }

    const BaseFeaturePointSetType::PointIndex_type& BaseFeaturePointSetType::
    PointIndex () const
    {
      return this->PointIndex_.get ();
    }

    BaseFeaturePointSetType::PointIndex_type& BaseFeaturePointSetType::
    PointIndex ()
    {
      return this->PointIndex_.get ();
    }

    void BaseFeaturePointSetType::
    PointIndex (const PointIndex_type& x)
    {
      this->PointIndex_.set (x);
    }

    void BaseFeaturePointSetType::
    PointIndex (::std::auto_ptr< PointIndex_type > x)
    {
      this->PointIndex_.set (x);
    }

    const BaseFeaturePointSetType::ReferencedComponent_type& BaseFeaturePointSetType::
    ReferencedComponent () const
    {
      return this->ReferencedComponent_.get ();
    }

    BaseFeaturePointSetType::ReferencedComponent_type& BaseFeaturePointSetType::
    ReferencedComponent ()
    {
      return this->ReferencedComponent_.get ();
    }

    void BaseFeaturePointSetType::
    ReferencedComponent (const ReferencedComponent_type& x)
    {
      this->ReferencedComponent_.set (x);
    }

    void BaseFeaturePointSetType::
    ReferencedComponent (::std::auto_ptr< ReferencedComponent_type > x)
    {
      this->ReferencedComponent_.set (x);
    }

    const BaseFeaturePointSetType::SequenceNumber_type& BaseFeaturePointSetType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    BaseFeaturePointSetType::SequenceNumber_type& BaseFeaturePointSetType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void BaseFeaturePointSetType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }


    // BaseFeaturePointListType
    // 

    const BaseFeaturePointListType::BaseFeaturePointSet_sequence& BaseFeaturePointListType::
    BaseFeaturePointSet () const
    {
      return this->BaseFeaturePointSet_;
    }

    BaseFeaturePointListType::BaseFeaturePointSet_sequence& BaseFeaturePointListType::
    BaseFeaturePointSet ()
    {
      return this->BaseFeaturePointSet_;
    }

    void BaseFeaturePointListType::
    BaseFeaturePointSet (const BaseFeaturePointSet_sequence& s)
    {
      this->BaseFeaturePointSet_ = s;
    }


    // TransformationReferenceType
    // 

    const TransformationReferenceType::ReferencedComponent_type& TransformationReferenceType::
    ReferencedComponent () const
    {
      return this->ReferencedComponent_.get ();
    }

    TransformationReferenceType::ReferencedComponent_type& TransformationReferenceType::
    ReferencedComponent ()
    {
      return this->ReferencedComponent_.get ();
    }

    void TransformationReferenceType::
    ReferencedComponent (const ReferencedComponent_type& x)
    {
      this->ReferencedComponent_.set (x);
    }

    void TransformationReferenceType::
    ReferencedComponent (::std::auto_ptr< ReferencedComponent_type > x)
    {
      this->ReferencedComponent_.set (x);
    }

    const TransformationReferenceType::CoordinateSystemId_type& TransformationReferenceType::
    CoordinateSystemId () const
    {
      return this->CoordinateSystemId_.get ();
    }

    TransformationReferenceType::CoordinateSystemId_type& TransformationReferenceType::
    CoordinateSystemId ()
    {
      return this->CoordinateSystemId_.get ();
    }

    void TransformationReferenceType::
    CoordinateSystemId (const CoordinateSystemId_type& x)
    {
      this->CoordinateSystemId_.set (x);
    }

    void TransformationReferenceType::
    CoordinateSystemId (::std::auto_ptr< CoordinateSystemId_type > x)
    {
      this->CoordinateSystemId_.set (x);
    }

    const TransformationReferenceType::SequenceNumber_type& TransformationReferenceType::
    SequenceNumber () const
    {
      return this->SequenceNumber_.get ();
    }

    TransformationReferenceType::SequenceNumber_type& TransformationReferenceType::
    SequenceNumber ()
    {
      return this->SequenceNumber_.get ();
    }

    void TransformationReferenceType::
    SequenceNumber (const SequenceNumber_type& x)
    {
      this->SequenceNumber_.set (x);
    }


    // ArcConstructionMethodType
    // 

    const ArcConstructionMethodType::BestFit_optional& ArcConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ArcConstructionMethodType::BestFit_optional& ArcConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ArcConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ArcConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ArcConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ArcConstructionMethodType::Recompensated_optional& ArcConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ArcConstructionMethodType::Recompensated_optional& ArcConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ArcConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ArcConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ArcConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ArcConstructionMethodType::Projection_optional& ArcConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    ArcConstructionMethodType::Projection_optional& ArcConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void ArcConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void ArcConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void ArcConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const ArcConstructionMethodType::Copy_optional& ArcConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ArcConstructionMethodType::Copy_optional& ArcConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ArcConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ArcConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ArcConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ArcConstructionMethodType::Cast_optional& ArcConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ArcConstructionMethodType::Cast_optional& ArcConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ArcConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ArcConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ArcConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ArcConstructionMethodType::Transform_optional& ArcConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ArcConstructionMethodType::Transform_optional& ArcConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ArcConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ArcConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ArcConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const ArcConstructionMethodType::FromScan_optional& ArcConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    ArcConstructionMethodType::FromScan_optional& ArcConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void ArcConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void ArcConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void ArcConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }

    const ArcConstructionMethodType::Extract_optional& ArcConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    ArcConstructionMethodType::Extract_optional& ArcConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void ArcConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void ArcConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void ArcConstructionMethodType::
    Extract (::std::auto_ptr< Extract_type > x)
    {
      this->Extract_.set (x);
    }


    // ArcBestFitType
    // 

    const ArcBestFitType::BaseFeature_sequence& ArcBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ArcBestFitType::BaseFeature_sequence& ArcBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ArcBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ArcRecompType
    // 

    const ArcRecompType::BaseFeaturePointList_type& ArcRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ArcRecompType::BaseFeaturePointList_type& ArcRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ArcRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ArcRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ArcProjectionType
    // 

    const ArcProjectionType::ProjectionArc_type& ArcProjectionType::
    ProjectionArc () const
    {
      return this->ProjectionArc_.get ();
    }

    ArcProjectionType::ProjectionArc_type& ArcProjectionType::
    ProjectionArc ()
    {
      return this->ProjectionArc_.get ();
    }

    void ArcProjectionType::
    ProjectionArc (const ProjectionArc_type& x)
    {
      this->ProjectionArc_.set (x);
    }

    void ArcProjectionType::
    ProjectionArc (::std::auto_ptr< ProjectionArc_type > x)
    {
      this->ProjectionArc_.set (x);
    }

    const ArcProjectionType::ProjectionPlane_type& ArcProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    ArcProjectionType::ProjectionPlane_type& ArcProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void ArcProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void ArcProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }


    // ArcCopyType
    // 

    const ArcCopyType::BaseArc_type& ArcCopyType::
    BaseArc () const
    {
      return this->BaseArc_.get ();
    }

    ArcCopyType::BaseArc_type& ArcCopyType::
    BaseArc ()
    {
      return this->BaseArc_.get ();
    }

    void ArcCopyType::
    BaseArc (const BaseArc_type& x)
    {
      this->BaseArc_.set (x);
    }

    void ArcCopyType::
    BaseArc (::std::auto_ptr< BaseArc_type > x)
    {
      this->BaseArc_.set (x);
    }


    // ArcCastType
    // 

    const ArcCastType::BaseFeature_type& ArcCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ArcCastType::BaseFeature_type& ArcCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ArcCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ArcCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ArcTransformType
    // 

    const ArcTransformType::BaseArc_type& ArcTransformType::
    BaseArc () const
    {
      return this->BaseArc_.get ();
    }

    ArcTransformType::BaseArc_type& ArcTransformType::
    BaseArc ()
    {
      return this->BaseArc_.get ();
    }

    void ArcTransformType::
    BaseArc (const BaseArc_type& x)
    {
      this->BaseArc_.set (x);
    }

    void ArcTransformType::
    BaseArc (::std::auto_ptr< BaseArc_type > x)
    {
      this->BaseArc_.set (x);
    }

    const ArcTransformType::Transformation_type& ArcTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ArcTransformType::Transformation_type& ArcTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ArcTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ArcTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ArcFromScanType
    // 

    const ArcFromScanType::SurfaceFeature_type& ArcFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    ArcFromScanType::SurfaceFeature_type& ArcFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void ArcFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void ArcFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const ArcFromScanType::SearchRadius_type& ArcFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    ArcFromScanType::SearchRadius_type& ArcFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void ArcFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void ArcFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const ArcFromScanType::Depth_type& ArcFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    ArcFromScanType::Depth_type& ArcFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void ArcFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void ArcFromScanType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }


    // ArcExtractType
    // 

    const ArcExtractType::CurveFeature_type& ArcExtractType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    ArcExtractType::CurveFeature_type& ArcExtractType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void ArcExtractType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void ArcExtractType::
    CurveFeature (::std::auto_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (x);
    }


    // ArcCheckedType
    // 

    const ArcCheckedType::Measured_optional& ArcCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ArcCheckedType::Measured_optional& ArcCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ArcCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ArcCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ArcCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ArcCheckedType::Constructed_optional& ArcCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ArcCheckedType::Constructed_optional& ArcCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ArcCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ArcCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ArcCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ArcCheckedFeatureType
    // 

    const ArcCheckedFeatureType::CheckDetails_optional& ArcCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ArcCheckedFeatureType::CheckDetails_optional& ArcCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ArcCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ArcCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ArcCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ArcActualDeterminationType
    // 

    const ArcActualDeterminationType::Checked_optional& ArcActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ArcActualDeterminationType::Checked_optional& ArcActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ArcActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ArcActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ArcActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ArcActualDeterminationType::Set_optional& ArcActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ArcActualDeterminationType::Set_optional& ArcActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ArcActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ArcActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ArcActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ArcFeatureItemType
    // 

    const ArcFeatureItemType::DeterminationMode_type& ArcFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ArcFeatureItemType::DeterminationMode_type& ArcFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ArcFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ArcFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ArcFeatureItemType::SubstituteFeatureAlgorithm_optional& ArcFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ArcFeatureItemType::SubstituteFeatureAlgorithm_optional& ArcFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ArcFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ArcFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ArcFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ArcFeatureDefinitionType
    // 

    const ArcFeatureDefinitionType::InternalExternal_type& ArcFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ArcFeatureDefinitionType::InternalExternal_type& ArcFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ArcFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ArcFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ArcFeatureDefinitionType::Radius_type& ArcFeatureDefinitionType::
    Radius () const
    {
      return this->Radius_.get ();
    }

    ArcFeatureDefinitionType::Radius_type& ArcFeatureDefinitionType::
    Radius ()
    {
      return this->Radius_.get ();
    }

    void ArcFeatureDefinitionType::
    Radius (const Radius_type& x)
    {
      this->Radius_.set (x);
    }

    void ArcFeatureDefinitionType::
    Radius (::std::auto_ptr< Radius_type > x)
    {
      this->Radius_.set (x);
    }


    // ArcFeatureNominalType
    // 

    const ArcFeatureNominalType::Location_type& ArcFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    ArcFeatureNominalType::Location_type& ArcFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void ArcFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void ArcFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const ArcFeatureNominalType::Sweep_type& ArcFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    ArcFeatureNominalType::Sweep_type& ArcFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void ArcFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ArcFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const ArcFeatureNominalType::Normal_type& ArcFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    ArcFeatureNominalType::Normal_type& ArcFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void ArcFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void ArcFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // ArcFeatureActualType
    // 

    const ArcFeatureActualType::Location_optional& ArcFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    ArcFeatureActualType::Location_optional& ArcFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void ArcFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void ArcFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void ArcFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const ArcFeatureActualType::Normal_optional& ArcFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    ArcFeatureActualType::Normal_optional& ArcFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void ArcFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void ArcFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void ArcFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const ArcFeatureActualType::Radius_optional& ArcFeatureActualType::
    Radius () const
    {
      return this->Radius_;
    }

    ArcFeatureActualType::Radius_optional& ArcFeatureActualType::
    Radius ()
    {
      return this->Radius_;
    }

    void ArcFeatureActualType::
    Radius (const Radius_type& x)
    {
      this->Radius_.set (x);
    }

    void ArcFeatureActualType::
    Radius (const Radius_optional& x)
    {
      this->Radius_ = x;
    }

    void ArcFeatureActualType::
    Radius (::std::auto_ptr< Radius_type > x)
    {
      this->Radius_.set (x);
    }

    const ArcFeatureActualType::RadiusMin_optional& ArcFeatureActualType::
    RadiusMin () const
    {
      return this->RadiusMin_;
    }

    ArcFeatureActualType::RadiusMin_optional& ArcFeatureActualType::
    RadiusMin ()
    {
      return this->RadiusMin_;
    }

    void ArcFeatureActualType::
    RadiusMin (const RadiusMin_type& x)
    {
      this->RadiusMin_.set (x);
    }

    void ArcFeatureActualType::
    RadiusMin (const RadiusMin_optional& x)
    {
      this->RadiusMin_ = x;
    }

    void ArcFeatureActualType::
    RadiusMin (::std::auto_ptr< RadiusMin_type > x)
    {
      this->RadiusMin_.set (x);
    }

    const ArcFeatureActualType::RadiusMax_optional& ArcFeatureActualType::
    RadiusMax () const
    {
      return this->RadiusMax_;
    }

    ArcFeatureActualType::RadiusMax_optional& ArcFeatureActualType::
    RadiusMax ()
    {
      return this->RadiusMax_;
    }

    void ArcFeatureActualType::
    RadiusMax (const RadiusMax_type& x)
    {
      this->RadiusMax_.set (x);
    }

    void ArcFeatureActualType::
    RadiusMax (const RadiusMax_optional& x)
    {
      this->RadiusMax_ = x;
    }

    void ArcFeatureActualType::
    RadiusMax (::std::auto_ptr< RadiusMax_type > x)
    {
      this->RadiusMax_.set (x);
    }

    const ArcFeatureActualType::Sweep_optional& ArcFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    ArcFeatureActualType::Sweep_optional& ArcFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void ArcFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ArcFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void ArcFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const ArcFeatureActualType::Form_optional& ArcFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ArcFeatureActualType::Form_optional& ArcFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ArcFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ArcFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ArcFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // CircleConstructionMethodType
    // 

    const CircleConstructionMethodType::BestFit_optional& CircleConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CircleConstructionMethodType::BestFit_optional& CircleConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CircleConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CircleConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CircleConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const CircleConstructionMethodType::Recompensated_optional& CircleConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CircleConstructionMethodType::Recompensated_optional& CircleConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CircleConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CircleConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CircleConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const CircleConstructionMethodType::Intersection_optional& CircleConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    CircleConstructionMethodType::Intersection_optional& CircleConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void CircleConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void CircleConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void CircleConstructionMethodType::
    Intersection (::std::auto_ptr< Intersection_type > x)
    {
      this->Intersection_.set (x);
    }

    const CircleConstructionMethodType::Projection_optional& CircleConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    CircleConstructionMethodType::Projection_optional& CircleConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void CircleConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void CircleConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void CircleConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const CircleConstructionMethodType::Copy_optional& CircleConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CircleConstructionMethodType::Copy_optional& CircleConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CircleConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CircleConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CircleConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const CircleConstructionMethodType::Cast_optional& CircleConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CircleConstructionMethodType::Cast_optional& CircleConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CircleConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CircleConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CircleConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const CircleConstructionMethodType::Tangent_optional& CircleConstructionMethodType::
    Tangent () const
    {
      return this->Tangent_;
    }

    CircleConstructionMethodType::Tangent_optional& CircleConstructionMethodType::
    Tangent ()
    {
      return this->Tangent_;
    }

    void CircleConstructionMethodType::
    Tangent (const Tangent_type& x)
    {
      this->Tangent_.set (x);
    }

    void CircleConstructionMethodType::
    Tangent (const Tangent_optional& x)
    {
      this->Tangent_ = x;
    }

    void CircleConstructionMethodType::
    Tangent (::std::auto_ptr< Tangent_type > x)
    {
      this->Tangent_.set (x);
    }

    const CircleConstructionMethodType::TangentThrough_optional& CircleConstructionMethodType::
    TangentThrough () const
    {
      return this->TangentThrough_;
    }

    CircleConstructionMethodType::TangentThrough_optional& CircleConstructionMethodType::
    TangentThrough ()
    {
      return this->TangentThrough_;
    }

    void CircleConstructionMethodType::
    TangentThrough (const TangentThrough_type& x)
    {
      this->TangentThrough_.set (x);
    }

    void CircleConstructionMethodType::
    TangentThrough (const TangentThrough_optional& x)
    {
      this->TangentThrough_ = x;
    }

    void CircleConstructionMethodType::
    TangentThrough (::std::auto_ptr< TangentThrough_type > x)
    {
      this->TangentThrough_.set (x);
    }

    const CircleConstructionMethodType::Transform_optional& CircleConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CircleConstructionMethodType::Transform_optional& CircleConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CircleConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CircleConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CircleConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const CircleConstructionMethodType::FromCone_optional& CircleConstructionMethodType::
    FromCone () const
    {
      return this->FromCone_;
    }

    CircleConstructionMethodType::FromCone_optional& CircleConstructionMethodType::
    FromCone ()
    {
      return this->FromCone_;
    }

    void CircleConstructionMethodType::
    FromCone (const FromCone_type& x)
    {
      this->FromCone_.set (x);
    }

    void CircleConstructionMethodType::
    FromCone (const FromCone_optional& x)
    {
      this->FromCone_ = x;
    }

    void CircleConstructionMethodType::
    FromCone (::std::auto_ptr< FromCone_type > x)
    {
      this->FromCone_.set (x);
    }

    const CircleConstructionMethodType::FromScan_optional& CircleConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    CircleConstructionMethodType::FromScan_optional& CircleConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void CircleConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void CircleConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void CircleConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // CircleBestFitType
    // 

    const CircleBestFitType::BaseFeature_sequence& CircleBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CircleBestFitType::BaseFeature_sequence& CircleBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CircleBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // CircleRecompType
    // 

    const CircleRecompType::BaseFeaturePointList_type& CircleRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CircleRecompType::BaseFeaturePointList_type& CircleRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CircleRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CircleRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // CircleIntersectionType
    // 

    const CircleIntersectionType::IntersectionPlane_type& CircleIntersectionType::
    IntersectionPlane () const
    {
      return this->IntersectionPlane_.get ();
    }

    CircleIntersectionType::IntersectionPlane_type& CircleIntersectionType::
    IntersectionPlane ()
    {
      return this->IntersectionPlane_.get ();
    }

    void CircleIntersectionType::
    IntersectionPlane (const IntersectionPlane_type& x)
    {
      this->IntersectionPlane_.set (x);
    }

    void CircleIntersectionType::
    IntersectionPlane (::std::auto_ptr< IntersectionPlane_type > x)
    {
      this->IntersectionPlane_.set (x);
    }

    const CircleIntersectionType::IntersectionFeature_type& CircleIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_.get ();
    }

    CircleIntersectionType::IntersectionFeature_type& CircleIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_.get ();
    }

    void CircleIntersectionType::
    IntersectionFeature (const IntersectionFeature_type& x)
    {
      this->IntersectionFeature_.set (x);
    }

    void CircleIntersectionType::
    IntersectionFeature (::std::auto_ptr< IntersectionFeature_type > x)
    {
      this->IntersectionFeature_.set (x);
    }


    // CircleProjectionType
    // 

    const CircleProjectionType::ProjectionCircle_type& CircleProjectionType::
    ProjectionCircle () const
    {
      return this->ProjectionCircle_.get ();
    }

    CircleProjectionType::ProjectionCircle_type& CircleProjectionType::
    ProjectionCircle ()
    {
      return this->ProjectionCircle_.get ();
    }

    void CircleProjectionType::
    ProjectionCircle (const ProjectionCircle_type& x)
    {
      this->ProjectionCircle_.set (x);
    }

    void CircleProjectionType::
    ProjectionCircle (::std::auto_ptr< ProjectionCircle_type > x)
    {
      this->ProjectionCircle_.set (x);
    }

    const CircleProjectionType::ProjectionPlane_type& CircleProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    CircleProjectionType::ProjectionPlane_type& CircleProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void CircleProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void CircleProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }


    // CircleCopyType
    // 

    const CircleCopyType::BaseCircle_type& CircleCopyType::
    BaseCircle () const
    {
      return this->BaseCircle_.get ();
    }

    CircleCopyType::BaseCircle_type& CircleCopyType::
    BaseCircle ()
    {
      return this->BaseCircle_.get ();
    }

    void CircleCopyType::
    BaseCircle (const BaseCircle_type& x)
    {
      this->BaseCircle_.set (x);
    }

    void CircleCopyType::
    BaseCircle (::std::auto_ptr< BaseCircle_type > x)
    {
      this->BaseCircle_.set (x);
    }


    // CircleCastType
    // 

    const CircleCastType::BaseFeature_type& CircleCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CircleCastType::BaseFeature_type& CircleCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CircleCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CircleCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // CircleTangentType
    // 

    const CircleTangentType::TangentFeature_sequence& CircleTangentType::
    TangentFeature () const
    {
      return this->TangentFeature_;
    }

    CircleTangentType::TangentFeature_sequence& CircleTangentType::
    TangentFeature ()
    {
      return this->TangentFeature_;
    }

    void CircleTangentType::
    TangentFeature (const TangentFeature_sequence& s)
    {
      this->TangentFeature_ = s;
    }


    // CircleTangentThroughType
    // 

    const CircleTangentThroughType::TangentFeature_type& CircleTangentThroughType::
    TangentFeature () const
    {
      return this->TangentFeature_.get ();
    }

    CircleTangentThroughType::TangentFeature_type& CircleTangentThroughType::
    TangentFeature ()
    {
      return this->TangentFeature_.get ();
    }

    void CircleTangentThroughType::
    TangentFeature (const TangentFeature_type& x)
    {
      this->TangentFeature_.set (x);
    }

    void CircleTangentThroughType::
    TangentFeature (::std::auto_ptr< TangentFeature_type > x)
    {
      this->TangentFeature_.set (x);
    }

    const CircleTangentThroughType::PointFeature_type& CircleTangentThroughType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    CircleTangentThroughType::PointFeature_type& CircleTangentThroughType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void CircleTangentThroughType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void CircleTangentThroughType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // CircleTransformType
    // 

    const CircleTransformType::BaseCircle_type& CircleTransformType::
    BaseCircle () const
    {
      return this->BaseCircle_.get ();
    }

    CircleTransformType::BaseCircle_type& CircleTransformType::
    BaseCircle ()
    {
      return this->BaseCircle_.get ();
    }

    void CircleTransformType::
    BaseCircle (const BaseCircle_type& x)
    {
      this->BaseCircle_.set (x);
    }

    void CircleTransformType::
    BaseCircle (::std::auto_ptr< BaseCircle_type > x)
    {
      this->BaseCircle_.set (x);
    }

    const CircleTransformType::Transformation_type& CircleTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CircleTransformType::Transformation_type& CircleTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CircleTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CircleTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // CircleFromConeType
    // 

    const CircleFromConeType::Diameter_optional& CircleFromConeType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CircleFromConeType::Diameter_optional& CircleFromConeType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CircleFromConeType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CircleFromConeType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CircleFromConeType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CircleFromConeType::Distance_optional& CircleFromConeType::
    Distance () const
    {
      return this->Distance_;
    }

    CircleFromConeType::Distance_optional& CircleFromConeType::
    Distance ()
    {
      return this->Distance_;
    }

    void CircleFromConeType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void CircleFromConeType::
    Distance (const Distance_optional& x)
    {
      this->Distance_ = x;
    }

    void CircleFromConeType::
    Distance (::std::auto_ptr< Distance_type > x)
    {
      this->Distance_.set (x);
    }


    // CircleFromScanType
    // 

    const CircleFromScanType::SurfaceFeature_type& CircleFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    CircleFromScanType::SurfaceFeature_type& CircleFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void CircleFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void CircleFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const CircleFromScanType::SearchRadius_type& CircleFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    CircleFromScanType::SearchRadius_type& CircleFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void CircleFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void CircleFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const CircleFromScanType::Depth_type& CircleFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    CircleFromScanType::Depth_type& CircleFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void CircleFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void CircleFromScanType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }


    // CircleCheckedType
    // 

    const CircleCheckedType::Measured_optional& CircleCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CircleCheckedType::Measured_optional& CircleCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CircleCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CircleCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CircleCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const CircleCheckedType::Constructed_optional& CircleCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CircleCheckedType::Constructed_optional& CircleCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CircleCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CircleCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CircleCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // CircleCheckedFeatureType
    // 

    const CircleCheckedFeatureType::CheckDetails_optional& CircleCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CircleCheckedFeatureType::CheckDetails_optional& CircleCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CircleCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CircleCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CircleCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // CircleActualDeterminationType
    // 

    const CircleActualDeterminationType::Checked_optional& CircleActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CircleActualDeterminationType::Checked_optional& CircleActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CircleActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CircleActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CircleActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const CircleActualDeterminationType::Set_optional& CircleActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CircleActualDeterminationType::Set_optional& CircleActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CircleActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CircleActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CircleActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // CircleFeatureItemType
    // 

    const CircleFeatureItemType::DeterminationMode_type& CircleFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CircleFeatureItemType::DeterminationMode_type& CircleFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CircleFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CircleFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const CircleFeatureItemType::SubstituteFeatureAlgorithm_optional& CircleFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    CircleFeatureItemType::SubstituteFeatureAlgorithm_optional& CircleFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void CircleFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void CircleFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void CircleFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // CircleFeatureDefinitionType
    // 

    const CircleFeatureDefinitionType::InternalExternal_type& CircleFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CircleFeatureDefinitionType::InternalExternal_type& CircleFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CircleFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CircleFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const CircleFeatureDefinitionType::Diameter_type& CircleFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CircleFeatureDefinitionType::Diameter_type& CircleFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CircleFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CircleFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }


    // CircleFeatureNominalType
    // 

    const CircleFeatureNominalType::Location_type& CircleFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    CircleFeatureNominalType::Location_type& CircleFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void CircleFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CircleFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CircleFeatureNominalType::Normal_type& CircleFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    CircleFeatureNominalType::Normal_type& CircleFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void CircleFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void CircleFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // CircleFeatureActualType
    // 

    const CircleFeatureActualType::Location_optional& CircleFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    CircleFeatureActualType::Location_optional& CircleFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void CircleFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CircleFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void CircleFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CircleFeatureActualType::Normal_optional& CircleFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    CircleFeatureActualType::Normal_optional& CircleFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void CircleFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void CircleFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void CircleFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const CircleFeatureActualType::Diameter_optional& CircleFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CircleFeatureActualType::Diameter_optional& CircleFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CircleFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CircleFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CircleFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CircleFeatureActualType::DiameterMin_optional& CircleFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    CircleFeatureActualType::DiameterMin_optional& CircleFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void CircleFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void CircleFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void CircleFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const CircleFeatureActualType::DiameterMax_optional& CircleFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    CircleFeatureActualType::DiameterMax_optional& CircleFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void CircleFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void CircleFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void CircleFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const CircleFeatureActualType::Form_optional& CircleFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    CircleFeatureActualType::Form_optional& CircleFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void CircleFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CircleFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CircleFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // ConeConstructionMethodType
    // 

    const ConeConstructionMethodType::BestFit_optional& ConeConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ConeConstructionMethodType::BestFit_optional& ConeConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ConeConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ConeConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ConeConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ConeConstructionMethodType::Recompensated_optional& ConeConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ConeConstructionMethodType::Recompensated_optional& ConeConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ConeConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ConeConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ConeConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ConeConstructionMethodType::Copy_optional& ConeConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ConeConstructionMethodType::Copy_optional& ConeConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ConeConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ConeConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ConeConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ConeConstructionMethodType::Cast_optional& ConeConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ConeConstructionMethodType::Cast_optional& ConeConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ConeConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ConeConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ConeConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ConeConstructionMethodType::Transform_optional& ConeConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ConeConstructionMethodType::Transform_optional& ConeConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ConeConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ConeConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ConeConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const ConeConstructionMethodType::FromScan_optional& ConeConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    ConeConstructionMethodType::FromScan_optional& ConeConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void ConeConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void ConeConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void ConeConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // ConeBestFitType
    // 

    const ConeBestFitType::BaseFeature_sequence& ConeBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ConeBestFitType::BaseFeature_sequence& ConeBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ConeBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ConeRecompType
    // 

    const ConeRecompType::BaseFeaturePointList_type& ConeRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ConeRecompType::BaseFeaturePointList_type& ConeRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ConeRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ConeRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ConeCopyType
    // 

    const ConeCopyType::BaseCone_type& ConeCopyType::
    BaseCone () const
    {
      return this->BaseCone_.get ();
    }

    ConeCopyType::BaseCone_type& ConeCopyType::
    BaseCone ()
    {
      return this->BaseCone_.get ();
    }

    void ConeCopyType::
    BaseCone (const BaseCone_type& x)
    {
      this->BaseCone_.set (x);
    }

    void ConeCopyType::
    BaseCone (::std::auto_ptr< BaseCone_type > x)
    {
      this->BaseCone_.set (x);
    }


    // ConeCastType
    // 

    const ConeCastType::BaseFeature_type& ConeCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ConeCastType::BaseFeature_type& ConeCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ConeCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ConeCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ConeTransformType
    // 

    const ConeTransformType::BaseCone_type& ConeTransformType::
    BaseCone () const
    {
      return this->BaseCone_.get ();
    }

    ConeTransformType::BaseCone_type& ConeTransformType::
    BaseCone ()
    {
      return this->BaseCone_.get ();
    }

    void ConeTransformType::
    BaseCone (const BaseCone_type& x)
    {
      this->BaseCone_.set (x);
    }

    void ConeTransformType::
    BaseCone (::std::auto_ptr< BaseCone_type > x)
    {
      this->BaseCone_.set (x);
    }

    const ConeTransformType::Transformation_type& ConeTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ConeTransformType::Transformation_type& ConeTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ConeTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ConeTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ConeFromScanType
    // 

    const ConeFromScanType::SurfaceFeature_type& ConeFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    ConeFromScanType::SurfaceFeature_type& ConeFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void ConeFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void ConeFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const ConeFromScanType::SearchRadius_type& ConeFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    ConeFromScanType::SearchRadius_type& ConeFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void ConeFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void ConeFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // ConeCheckedType
    // 

    const ConeCheckedType::Measured_optional& ConeCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ConeCheckedType::Measured_optional& ConeCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ConeCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ConeCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ConeCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ConeCheckedType::Constructed_optional& ConeCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ConeCheckedType::Constructed_optional& ConeCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ConeCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ConeCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ConeCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ConeCheckedFeatureType
    // 

    const ConeCheckedFeatureType::CheckDetails_optional& ConeCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ConeCheckedFeatureType::CheckDetails_optional& ConeCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ConeCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ConeCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ConeCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ConeActualDeterminationType
    // 

    const ConeActualDeterminationType::Checked_optional& ConeActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ConeActualDeterminationType::Checked_optional& ConeActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ConeActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ConeActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ConeActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ConeActualDeterminationType::Set_optional& ConeActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ConeActualDeterminationType::Set_optional& ConeActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ConeActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ConeActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ConeActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ConeFeatureItemType
    // 

    const ConeFeatureItemType::DeterminationMode_type& ConeFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ConeFeatureItemType::DeterminationMode_type& ConeFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ConeFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ConeFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ConeFeatureItemType::SubstituteFeatureAlgorithm_optional& ConeFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ConeFeatureItemType::SubstituteFeatureAlgorithm_optional& ConeFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ConeFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ConeFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ConeFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ConeFeatureDefinitionType
    // 

    const ConeFeatureDefinitionType::InternalExternal_type& ConeFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ConeFeatureDefinitionType::InternalExternal_type& ConeFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ConeFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ConeFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ConeFeatureDefinitionType::Diameter_type& ConeFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ConeFeatureDefinitionType::Diameter_type& ConeFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ConeFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConeFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ConeFeatureDefinitionType::HalfAngle_optional& ConeFeatureDefinitionType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConeFeatureDefinitionType::HalfAngle_optional& ConeFeatureDefinitionType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConeFeatureDefinitionType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConeFeatureDefinitionType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConeFeatureDefinitionType::
    HalfAngle (::std::auto_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (x);
    }

    const ConeFeatureDefinitionType::FullAngle_optional& ConeFeatureDefinitionType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConeFeatureDefinitionType::FullAngle_optional& ConeFeatureDefinitionType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConeFeatureDefinitionType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConeFeatureDefinitionType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConeFeatureDefinitionType::
    FullAngle (::std::auto_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (x);
    }

    const ConeFeatureDefinitionType::LargeEndDistance_optional& ConeFeatureDefinitionType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConeFeatureDefinitionType::LargeEndDistance_optional& ConeFeatureDefinitionType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConeFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConeFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConeFeatureDefinitionType::
    LargeEndDistance (::std::auto_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (x);
    }

    const ConeFeatureDefinitionType::SmallEndDistance_optional& ConeFeatureDefinitionType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConeFeatureDefinitionType::SmallEndDistance_optional& ConeFeatureDefinitionType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConeFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConeFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConeFeatureDefinitionType::
    SmallEndDistance (::std::auto_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (x);
    }


    // ConeFeatureNominalType
    // 

    const ConeFeatureNominalType::Axis_type& ConeFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    ConeFeatureNominalType::Axis_type& ConeFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void ConeFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConeFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const ConeFeatureNominalType::Sweep_optional& ConeFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_;
    }

    ConeFeatureNominalType::Sweep_optional& ConeFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void ConeFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ConeFeatureNominalType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void ConeFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }


    // ConeFeatureActualType
    // 

    const ConeFeatureActualType::Axis_optional& ConeFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    ConeFeatureActualType::Axis_optional& ConeFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void ConeFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConeFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void ConeFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const ConeFeatureActualType::Diameter_optional& ConeFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    ConeFeatureActualType::Diameter_optional& ConeFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void ConeFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConeFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void ConeFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ConeFeatureActualType::DiameterMin_optional& ConeFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    ConeFeatureActualType::DiameterMin_optional& ConeFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void ConeFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void ConeFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void ConeFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const ConeFeatureActualType::DiameterMax_optional& ConeFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    ConeFeatureActualType::DiameterMax_optional& ConeFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void ConeFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void ConeFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void ConeFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const ConeFeatureActualType::HalfAngle_optional& ConeFeatureActualType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConeFeatureActualType::HalfAngle_optional& ConeFeatureActualType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConeFeatureActualType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConeFeatureActualType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConeFeatureActualType::
    HalfAngle (::std::auto_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (x);
    }

    const ConeFeatureActualType::FullAngle_optional& ConeFeatureActualType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConeFeatureActualType::FullAngle_optional& ConeFeatureActualType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConeFeatureActualType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConeFeatureActualType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConeFeatureActualType::
    FullAngle (::std::auto_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (x);
    }

    const ConeFeatureActualType::SmallEndDistance_optional& ConeFeatureActualType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConeFeatureActualType::SmallEndDistance_optional& ConeFeatureActualType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConeFeatureActualType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConeFeatureActualType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConeFeatureActualType::
    SmallEndDistance (::std::auto_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (x);
    }

    const ConeFeatureActualType::LargeEndDistance_optional& ConeFeatureActualType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConeFeatureActualType::LargeEndDistance_optional& ConeFeatureActualType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConeFeatureActualType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConeFeatureActualType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConeFeatureActualType::
    LargeEndDistance (::std::auto_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (x);
    }

    const ConeFeatureActualType::Sweep_optional& ConeFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    ConeFeatureActualType::Sweep_optional& ConeFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void ConeFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ConeFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void ConeFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const ConeFeatureActualType::Form_optional& ConeFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ConeFeatureActualType::Form_optional& ConeFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ConeFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ConeFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ConeFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // ConicalSegmentConstructionMethodType
    // 

    const ConicalSegmentConstructionMethodType::BestFit_optional& ConicalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ConicalSegmentConstructionMethodType::BestFit_optional& ConicalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ConicalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ConicalSegmentConstructionMethodType::Recompensated_optional& ConicalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ConicalSegmentConstructionMethodType::Recompensated_optional& ConicalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ConicalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ConicalSegmentConstructionMethodType::Copy_optional& ConicalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ConicalSegmentConstructionMethodType::Copy_optional& ConicalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ConicalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ConicalSegmentConstructionMethodType::Cast_optional& ConicalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ConicalSegmentConstructionMethodType::Cast_optional& ConicalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ConicalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ConicalSegmentConstructionMethodType::Transform_optional& ConicalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ConicalSegmentConstructionMethodType::Transform_optional& ConicalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ConicalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ConicalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ConicalSegmentConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // ConicalSegmentBestFitType
    // 

    const ConicalSegmentBestFitType::BaseFeature_sequence& ConicalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ConicalSegmentBestFitType::BaseFeature_sequence& ConicalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ConicalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ConicalSegmentRecompType
    // 

    const ConicalSegmentRecompType::BaseFeaturePointList_type& ConicalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ConicalSegmentRecompType::BaseFeaturePointList_type& ConicalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ConicalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ConicalSegmentRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ConicalSegmentCopyType
    // 

    const ConicalSegmentCopyType::BaseConicalSegment_type& ConicalSegmentCopyType::
    BaseConicalSegment () const
    {
      return this->BaseConicalSegment_.get ();
    }

    ConicalSegmentCopyType::BaseConicalSegment_type& ConicalSegmentCopyType::
    BaseConicalSegment ()
    {
      return this->BaseConicalSegment_.get ();
    }

    void ConicalSegmentCopyType::
    BaseConicalSegment (const BaseConicalSegment_type& x)
    {
      this->BaseConicalSegment_.set (x);
    }

    void ConicalSegmentCopyType::
    BaseConicalSegment (::std::auto_ptr< BaseConicalSegment_type > x)
    {
      this->BaseConicalSegment_.set (x);
    }


    // ConicalSegmentCastType
    // 

    const ConicalSegmentCastType::BaseFeature_type& ConicalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ConicalSegmentCastType::BaseFeature_type& ConicalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ConicalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ConicalSegmentCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ConicalSegmentTransformType
    // 

    const ConicalSegmentTransformType::BaseConicalSegment_type& ConicalSegmentTransformType::
    BaseConicalSegment () const
    {
      return this->BaseConicalSegment_.get ();
    }

    ConicalSegmentTransformType::BaseConicalSegment_type& ConicalSegmentTransformType::
    BaseConicalSegment ()
    {
      return this->BaseConicalSegment_.get ();
    }

    void ConicalSegmentTransformType::
    BaseConicalSegment (const BaseConicalSegment_type& x)
    {
      this->BaseConicalSegment_.set (x);
    }

    void ConicalSegmentTransformType::
    BaseConicalSegment (::std::auto_ptr< BaseConicalSegment_type > x)
    {
      this->BaseConicalSegment_.set (x);
    }

    const ConicalSegmentTransformType::Transformation_type& ConicalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ConicalSegmentTransformType::Transformation_type& ConicalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ConicalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ConicalSegmentTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ConicalSegmentCheckedType
    // 

    const ConicalSegmentCheckedType::Measured_optional& ConicalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ConicalSegmentCheckedType::Measured_optional& ConicalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ConicalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ConicalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ConicalSegmentCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ConicalSegmentCheckedType::Constructed_optional& ConicalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ConicalSegmentCheckedType::Constructed_optional& ConicalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ConicalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ConicalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ConicalSegmentCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ConicalSegmentCheckedFeatureType
    // 

    const ConicalSegmentCheckedFeatureType::CheckDetails_optional& ConicalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ConicalSegmentCheckedFeatureType::CheckDetails_optional& ConicalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ConicalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ConicalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ConicalSegmentCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ConicalSegmentActualDeterminationType
    // 

    const ConicalSegmentActualDeterminationType::Checked_optional& ConicalSegmentActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ConicalSegmentActualDeterminationType::Checked_optional& ConicalSegmentActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ConicalSegmentActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ConicalSegmentActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ConicalSegmentActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ConicalSegmentActualDeterminationType::Set_optional& ConicalSegmentActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ConicalSegmentActualDeterminationType::Set_optional& ConicalSegmentActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ConicalSegmentActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ConicalSegmentActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ConicalSegmentActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ConicalSegmentFeatureItemType
    // 

    const ConicalSegmentFeatureItemType::DeterminationMode_type& ConicalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ConicalSegmentFeatureItemType::DeterminationMode_type& ConicalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ConicalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ConicalSegmentFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ConicalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& ConicalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ConicalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& ConicalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ConicalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ConicalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ConicalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ConicalSegmentFeatureDefinitionType
    // 

    const ConicalSegmentFeatureDefinitionType::InternalExternal_type& ConicalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ConicalSegmentFeatureDefinitionType::InternalExternal_type& ConicalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ConicalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ConicalSegmentFeatureDefinitionType::Diameter_type& ConicalSegmentFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ConicalSegmentFeatureDefinitionType::Diameter_type& ConicalSegmentFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ConicalSegmentFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ConicalSegmentFeatureDefinitionType::HalfAngle_optional& ConicalSegmentFeatureDefinitionType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConicalSegmentFeatureDefinitionType::HalfAngle_optional& ConicalSegmentFeatureDefinitionType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConicalSegmentFeatureDefinitionType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    HalfAngle (::std::auto_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (x);
    }

    const ConicalSegmentFeatureDefinitionType::FullAngle_optional& ConicalSegmentFeatureDefinitionType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConicalSegmentFeatureDefinitionType::FullAngle_optional& ConicalSegmentFeatureDefinitionType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConicalSegmentFeatureDefinitionType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    FullAngle (::std::auto_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (x);
    }

    const ConicalSegmentFeatureDefinitionType::LargeEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConicalSegmentFeatureDefinitionType::LargeEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConicalSegmentFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    LargeEndDistance (::std::auto_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (x);
    }

    const ConicalSegmentFeatureDefinitionType::SmallEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConicalSegmentFeatureDefinitionType::SmallEndDistance_optional& ConicalSegmentFeatureDefinitionType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConicalSegmentFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConicalSegmentFeatureDefinitionType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConicalSegmentFeatureDefinitionType::
    SmallEndDistance (::std::auto_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (x);
    }


    // ConicalSegmentFeatureNominalType
    // 

    const ConicalSegmentFeatureNominalType::Axis_type& ConicalSegmentFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    ConicalSegmentFeatureNominalType::Axis_type& ConicalSegmentFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void ConicalSegmentFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConicalSegmentFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const ConicalSegmentFeatureNominalType::Sweep_type& ConicalSegmentFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    ConicalSegmentFeatureNominalType::Sweep_type& ConicalSegmentFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void ConicalSegmentFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ConicalSegmentFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }


    // ConicalSegmentFeatureActualType
    // 

    const ConicalSegmentFeatureActualType::Axis_optional& ConicalSegmentFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    ConicalSegmentFeatureActualType::Axis_optional& ConicalSegmentFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void ConicalSegmentFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void ConicalSegmentFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const ConicalSegmentFeatureActualType::Diameter_optional& ConicalSegmentFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    ConicalSegmentFeatureActualType::Diameter_optional& ConicalSegmentFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void ConicalSegmentFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void ConicalSegmentFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ConicalSegmentFeatureActualType::DiameterMin_optional& ConicalSegmentFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    ConicalSegmentFeatureActualType::DiameterMin_optional& ConicalSegmentFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void ConicalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void ConicalSegmentFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const ConicalSegmentFeatureActualType::DiameterMax_optional& ConicalSegmentFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    ConicalSegmentFeatureActualType::DiameterMax_optional& ConicalSegmentFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void ConicalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void ConicalSegmentFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const ConicalSegmentFeatureActualType::HalfAngle_optional& ConicalSegmentFeatureActualType::
    HalfAngle () const
    {
      return this->HalfAngle_;
    }

    ConicalSegmentFeatureActualType::HalfAngle_optional& ConicalSegmentFeatureActualType::
    HalfAngle ()
    {
      return this->HalfAngle_;
    }

    void ConicalSegmentFeatureActualType::
    HalfAngle (const HalfAngle_type& x)
    {
      this->HalfAngle_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    HalfAngle (const HalfAngle_optional& x)
    {
      this->HalfAngle_ = x;
    }

    void ConicalSegmentFeatureActualType::
    HalfAngle (::std::auto_ptr< HalfAngle_type > x)
    {
      this->HalfAngle_.set (x);
    }

    const ConicalSegmentFeatureActualType::FullAngle_optional& ConicalSegmentFeatureActualType::
    FullAngle () const
    {
      return this->FullAngle_;
    }

    ConicalSegmentFeatureActualType::FullAngle_optional& ConicalSegmentFeatureActualType::
    FullAngle ()
    {
      return this->FullAngle_;
    }

    void ConicalSegmentFeatureActualType::
    FullAngle (const FullAngle_type& x)
    {
      this->FullAngle_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    FullAngle (const FullAngle_optional& x)
    {
      this->FullAngle_ = x;
    }

    void ConicalSegmentFeatureActualType::
    FullAngle (::std::auto_ptr< FullAngle_type > x)
    {
      this->FullAngle_.set (x);
    }

    const ConicalSegmentFeatureActualType::SmallEndDistance_optional& ConicalSegmentFeatureActualType::
    SmallEndDistance () const
    {
      return this->SmallEndDistance_;
    }

    ConicalSegmentFeatureActualType::SmallEndDistance_optional& ConicalSegmentFeatureActualType::
    SmallEndDistance ()
    {
      return this->SmallEndDistance_;
    }

    void ConicalSegmentFeatureActualType::
    SmallEndDistance (const SmallEndDistance_type& x)
    {
      this->SmallEndDistance_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    SmallEndDistance (const SmallEndDistance_optional& x)
    {
      this->SmallEndDistance_ = x;
    }

    void ConicalSegmentFeatureActualType::
    SmallEndDistance (::std::auto_ptr< SmallEndDistance_type > x)
    {
      this->SmallEndDistance_.set (x);
    }

    const ConicalSegmentFeatureActualType::LargeEndDistance_optional& ConicalSegmentFeatureActualType::
    LargeEndDistance () const
    {
      return this->LargeEndDistance_;
    }

    ConicalSegmentFeatureActualType::LargeEndDistance_optional& ConicalSegmentFeatureActualType::
    LargeEndDistance ()
    {
      return this->LargeEndDistance_;
    }

    void ConicalSegmentFeatureActualType::
    LargeEndDistance (const LargeEndDistance_type& x)
    {
      this->LargeEndDistance_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    LargeEndDistance (const LargeEndDistance_optional& x)
    {
      this->LargeEndDistance_ = x;
    }

    void ConicalSegmentFeatureActualType::
    LargeEndDistance (::std::auto_ptr< LargeEndDistance_type > x)
    {
      this->LargeEndDistance_.set (x);
    }

    const ConicalSegmentFeatureActualType::Sweep_optional& ConicalSegmentFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    ConicalSegmentFeatureActualType::Sweep_optional& ConicalSegmentFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void ConicalSegmentFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void ConicalSegmentFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const ConicalSegmentFeatureActualType::Form_optional& ConicalSegmentFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ConicalSegmentFeatureActualType::Form_optional& ConicalSegmentFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ConicalSegmentFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ConicalSegmentFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ConicalSegmentFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // CuboidConstructionMethodType
    // 

    const CuboidConstructionMethodType::BestFit_optional& CuboidConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CuboidConstructionMethodType::BestFit_optional& CuboidConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CuboidConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CuboidConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CuboidConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const CuboidConstructionMethodType::Recompensated_optional& CuboidConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CuboidConstructionMethodType::Recompensated_optional& CuboidConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CuboidConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CuboidConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CuboidConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const CuboidConstructionMethodType::Copy_optional& CuboidConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CuboidConstructionMethodType::Copy_optional& CuboidConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CuboidConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CuboidConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CuboidConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const CuboidConstructionMethodType::Cast_optional& CuboidConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CuboidConstructionMethodType::Cast_optional& CuboidConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CuboidConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CuboidConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CuboidConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const CuboidConstructionMethodType::Transform_optional& CuboidConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CuboidConstructionMethodType::Transform_optional& CuboidConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CuboidConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CuboidConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CuboidConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // CuboidBestFitType
    // 

    const CuboidBestFitType::BaseFeature_sequence& CuboidBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CuboidBestFitType::BaseFeature_sequence& CuboidBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CuboidBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // CuboidRecompType
    // 

    const CuboidRecompType::BaseFeaturePointList_type& CuboidRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CuboidRecompType::BaseFeaturePointList_type& CuboidRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CuboidRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CuboidRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // CuboidCopyType
    // 

    const CuboidCopyType::BaseCuboid_type& CuboidCopyType::
    BaseCuboid () const
    {
      return this->BaseCuboid_.get ();
    }

    CuboidCopyType::BaseCuboid_type& CuboidCopyType::
    BaseCuboid ()
    {
      return this->BaseCuboid_.get ();
    }

    void CuboidCopyType::
    BaseCuboid (const BaseCuboid_type& x)
    {
      this->BaseCuboid_.set (x);
    }

    void CuboidCopyType::
    BaseCuboid (::std::auto_ptr< BaseCuboid_type > x)
    {
      this->BaseCuboid_.set (x);
    }


    // CuboidCastType
    // 

    const CuboidCastType::BaseFeature_type& CuboidCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CuboidCastType::BaseFeature_type& CuboidCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CuboidCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CuboidCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // CuboidTransformType
    // 

    const CuboidTransformType::BaseCuboid_type& CuboidTransformType::
    BaseCuboid () const
    {
      return this->BaseCuboid_.get ();
    }

    CuboidTransformType::BaseCuboid_type& CuboidTransformType::
    BaseCuboid ()
    {
      return this->BaseCuboid_.get ();
    }

    void CuboidTransformType::
    BaseCuboid (const BaseCuboid_type& x)
    {
      this->BaseCuboid_.set (x);
    }

    void CuboidTransformType::
    BaseCuboid (::std::auto_ptr< BaseCuboid_type > x)
    {
      this->BaseCuboid_.set (x);
    }

    const CuboidTransformType::Transformation_type& CuboidTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CuboidTransformType::Transformation_type& CuboidTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CuboidTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CuboidTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // CuboidCheckedType
    // 

    const CuboidCheckedType::Measured_optional& CuboidCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CuboidCheckedType::Measured_optional& CuboidCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CuboidCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CuboidCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CuboidCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const CuboidCheckedType::Constructed_optional& CuboidCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CuboidCheckedType::Constructed_optional& CuboidCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CuboidCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CuboidCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CuboidCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // CuboidCheckedFeatureType
    // 

    const CuboidCheckedFeatureType::CheckDetails_optional& CuboidCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CuboidCheckedFeatureType::CheckDetails_optional& CuboidCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CuboidCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CuboidCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CuboidCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // CuboidActualDeterminationType
    // 

    const CuboidActualDeterminationType::Checked_optional& CuboidActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CuboidActualDeterminationType::Checked_optional& CuboidActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CuboidActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CuboidActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CuboidActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const CuboidActualDeterminationType::Set_optional& CuboidActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CuboidActualDeterminationType::Set_optional& CuboidActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CuboidActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CuboidActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CuboidActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // CuboidFeatureItemType
    // 

    const CuboidFeatureItemType::DeterminationMode_type& CuboidFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CuboidFeatureItemType::DeterminationMode_type& CuboidFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CuboidFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CuboidFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const CuboidFeatureItemType::SubstituteFeatureAlgorithm_optional& CuboidFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    CuboidFeatureItemType::SubstituteFeatureAlgorithm_optional& CuboidFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void CuboidFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void CuboidFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void CuboidFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // CuboidFeatureDefinitionType
    // 

    const CuboidFeatureDefinitionType::InternalExternal_type& CuboidFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CuboidFeatureDefinitionType::InternalExternal_type& CuboidFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CuboidFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CuboidFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const CuboidFeatureDefinitionType::Length_type& CuboidFeatureDefinitionType::
    Length () const
    {
      return this->Length_.get ();
    }

    CuboidFeatureDefinitionType::Length_type& CuboidFeatureDefinitionType::
    Length ()
    {
      return this->Length_.get ();
    }

    void CuboidFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CuboidFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CuboidFeatureDefinitionType::Width_type& CuboidFeatureDefinitionType::
    Width () const
    {
      return this->Width_.get ();
    }

    CuboidFeatureDefinitionType::Width_type& CuboidFeatureDefinitionType::
    Width ()
    {
      return this->Width_.get ();
    }

    void CuboidFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void CuboidFeatureDefinitionType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const CuboidFeatureDefinitionType::Height_type& CuboidFeatureDefinitionType::
    Height () const
    {
      return this->Height_.get ();
    }

    CuboidFeatureDefinitionType::Height_type& CuboidFeatureDefinitionType::
    Height ()
    {
      return this->Height_.get ();
    }

    void CuboidFeatureDefinitionType::
    Height (const Height_type& x)
    {
      this->Height_.set (x);
    }

    void CuboidFeatureDefinitionType::
    Height (::std::auto_ptr< Height_type > x)
    {
      this->Height_.set (x);
    }


    // CuboidFeatureNominalType
    // 

    const CuboidFeatureNominalType::Location_type& CuboidFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    CuboidFeatureNominalType::Location_type& CuboidFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void CuboidFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CuboidFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CuboidFeatureNominalType::LengthVector_type& CuboidFeatureNominalType::
    LengthVector () const
    {
      return this->LengthVector_.get ();
    }

    CuboidFeatureNominalType::LengthVector_type& CuboidFeatureNominalType::
    LengthVector ()
    {
      return this->LengthVector_.get ();
    }

    void CuboidFeatureNominalType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void CuboidFeatureNominalType::
    LengthVector (::std::auto_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (x);
    }

    const CuboidFeatureNominalType::HeightVector_type& CuboidFeatureNominalType::
    HeightVector () const
    {
      return this->HeightVector_.get ();
    }

    CuboidFeatureNominalType::HeightVector_type& CuboidFeatureNominalType::
    HeightVector ()
    {
      return this->HeightVector_.get ();
    }

    void CuboidFeatureNominalType::
    HeightVector (const HeightVector_type& x)
    {
      this->HeightVector_.set (x);
    }

    void CuboidFeatureNominalType::
    HeightVector (::std::auto_ptr< HeightVector_type > x)
    {
      this->HeightVector_.set (x);
    }


    // CuboidFeatureActualType
    // 

    const CuboidFeatureActualType::Location_optional& CuboidFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    CuboidFeatureActualType::Location_optional& CuboidFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void CuboidFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CuboidFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void CuboidFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CuboidFeatureActualType::Length_optional& CuboidFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    CuboidFeatureActualType::Length_optional& CuboidFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void CuboidFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CuboidFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CuboidFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CuboidFeatureActualType::LengthMax_optional& CuboidFeatureActualType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    CuboidFeatureActualType::LengthMax_optional& CuboidFeatureActualType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void CuboidFeatureActualType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void CuboidFeatureActualType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void CuboidFeatureActualType::
    LengthMax (::std::auto_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (x);
    }

    const CuboidFeatureActualType::LengthMin_optional& CuboidFeatureActualType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    CuboidFeatureActualType::LengthMin_optional& CuboidFeatureActualType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void CuboidFeatureActualType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void CuboidFeatureActualType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void CuboidFeatureActualType::
    LengthMin (::std::auto_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (x);
    }

    const CuboidFeatureActualType::LengthVector_optional& CuboidFeatureActualType::
    LengthVector () const
    {
      return this->LengthVector_;
    }

    CuboidFeatureActualType::LengthVector_optional& CuboidFeatureActualType::
    LengthVector ()
    {
      return this->LengthVector_;
    }

    void CuboidFeatureActualType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void CuboidFeatureActualType::
    LengthVector (const LengthVector_optional& x)
    {
      this->LengthVector_ = x;
    }

    void CuboidFeatureActualType::
    LengthVector (::std::auto_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (x);
    }

    const CuboidFeatureActualType::Width_optional& CuboidFeatureActualType::
    Width () const
    {
      return this->Width_;
    }

    CuboidFeatureActualType::Width_optional& CuboidFeatureActualType::
    Width ()
    {
      return this->Width_;
    }

    void CuboidFeatureActualType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void CuboidFeatureActualType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void CuboidFeatureActualType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const CuboidFeatureActualType::WidthMax_optional& CuboidFeatureActualType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    CuboidFeatureActualType::WidthMax_optional& CuboidFeatureActualType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void CuboidFeatureActualType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void CuboidFeatureActualType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void CuboidFeatureActualType::
    WidthMax (::std::auto_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (x);
    }

    const CuboidFeatureActualType::WidthMin_optional& CuboidFeatureActualType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    CuboidFeatureActualType::WidthMin_optional& CuboidFeatureActualType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void CuboidFeatureActualType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void CuboidFeatureActualType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void CuboidFeatureActualType::
    WidthMin (::std::auto_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (x);
    }

    const CuboidFeatureActualType::Height_optional& CuboidFeatureActualType::
    Height () const
    {
      return this->Height_;
    }

    CuboidFeatureActualType::Height_optional& CuboidFeatureActualType::
    Height ()
    {
      return this->Height_;
    }

    void CuboidFeatureActualType::
    Height (const Height_type& x)
    {
      this->Height_.set (x);
    }

    void CuboidFeatureActualType::
    Height (const Height_optional& x)
    {
      this->Height_ = x;
    }

    void CuboidFeatureActualType::
    Height (::std::auto_ptr< Height_type > x)
    {
      this->Height_.set (x);
    }

    const CuboidFeatureActualType::HeightMax_optional& CuboidFeatureActualType::
    HeightMax () const
    {
      return this->HeightMax_;
    }

    CuboidFeatureActualType::HeightMax_optional& CuboidFeatureActualType::
    HeightMax ()
    {
      return this->HeightMax_;
    }

    void CuboidFeatureActualType::
    HeightMax (const HeightMax_type& x)
    {
      this->HeightMax_.set (x);
    }

    void CuboidFeatureActualType::
    HeightMax (const HeightMax_optional& x)
    {
      this->HeightMax_ = x;
    }

    void CuboidFeatureActualType::
    HeightMax (::std::auto_ptr< HeightMax_type > x)
    {
      this->HeightMax_.set (x);
    }

    const CuboidFeatureActualType::HeightMin_optional& CuboidFeatureActualType::
    HeightMin () const
    {
      return this->HeightMin_;
    }

    CuboidFeatureActualType::HeightMin_optional& CuboidFeatureActualType::
    HeightMin ()
    {
      return this->HeightMin_;
    }

    void CuboidFeatureActualType::
    HeightMin (const HeightMin_type& x)
    {
      this->HeightMin_.set (x);
    }

    void CuboidFeatureActualType::
    HeightMin (const HeightMin_optional& x)
    {
      this->HeightMin_ = x;
    }

    void CuboidFeatureActualType::
    HeightMin (::std::auto_ptr< HeightMin_type > x)
    {
      this->HeightMin_.set (x);
    }

    const CuboidFeatureActualType::HeightVector_optional& CuboidFeatureActualType::
    HeightVector () const
    {
      return this->HeightVector_;
    }

    CuboidFeatureActualType::HeightVector_optional& CuboidFeatureActualType::
    HeightVector ()
    {
      return this->HeightVector_;
    }

    void CuboidFeatureActualType::
    HeightVector (const HeightVector_type& x)
    {
      this->HeightVector_.set (x);
    }

    void CuboidFeatureActualType::
    HeightVector (const HeightVector_optional& x)
    {
      this->HeightVector_ = x;
    }

    void CuboidFeatureActualType::
    HeightVector (::std::auto_ptr< HeightVector_type > x)
    {
      this->HeightVector_.set (x);
    }

    const CuboidFeatureActualType::Form_optional& CuboidFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    CuboidFeatureActualType::Form_optional& CuboidFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void CuboidFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CuboidFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CuboidFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // CylinderConstructionMethodType
    // 

    const CylinderConstructionMethodType::BestFit_optional& CylinderConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CylinderConstructionMethodType::BestFit_optional& CylinderConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CylinderConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CylinderConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CylinderConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const CylinderConstructionMethodType::Recompensated_optional& CylinderConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CylinderConstructionMethodType::Recompensated_optional& CylinderConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CylinderConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CylinderConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CylinderConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const CylinderConstructionMethodType::Copy_optional& CylinderConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CylinderConstructionMethodType::Copy_optional& CylinderConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CylinderConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CylinderConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CylinderConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const CylinderConstructionMethodType::Cast_optional& CylinderConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CylinderConstructionMethodType::Cast_optional& CylinderConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CylinderConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CylinderConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CylinderConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const CylinderConstructionMethodType::Transform_optional& CylinderConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CylinderConstructionMethodType::Transform_optional& CylinderConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CylinderConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CylinderConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CylinderConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const CylinderConstructionMethodType::FromScan_optional& CylinderConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    CylinderConstructionMethodType::FromScan_optional& CylinderConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void CylinderConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void CylinderConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void CylinderConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // CylinderBestFitType
    // 

    const CylinderBestFitType::BaseFeature_sequence& CylinderBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CylinderBestFitType::BaseFeature_sequence& CylinderBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CylinderBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // CylinderRecompType
    // 

    const CylinderRecompType::BaseFeaturePointList_type& CylinderRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CylinderRecompType::BaseFeaturePointList_type& CylinderRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CylinderRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CylinderRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // CylinderCopyType
    // 

    const CylinderCopyType::BaseCylinder_type& CylinderCopyType::
    BaseCylinder () const
    {
      return this->BaseCylinder_.get ();
    }

    CylinderCopyType::BaseCylinder_type& CylinderCopyType::
    BaseCylinder ()
    {
      return this->BaseCylinder_.get ();
    }

    void CylinderCopyType::
    BaseCylinder (const BaseCylinder_type& x)
    {
      this->BaseCylinder_.set (x);
    }

    void CylinderCopyType::
    BaseCylinder (::std::auto_ptr< BaseCylinder_type > x)
    {
      this->BaseCylinder_.set (x);
    }


    // CylinderCastType
    // 

    const CylinderCastType::BaseFeature_type& CylinderCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CylinderCastType::BaseFeature_type& CylinderCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CylinderCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CylinderCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // CylinderTransformType
    // 

    const CylinderTransformType::BaseCylinder_type& CylinderTransformType::
    BaseCylinder () const
    {
      return this->BaseCylinder_.get ();
    }

    CylinderTransformType::BaseCylinder_type& CylinderTransformType::
    BaseCylinder ()
    {
      return this->BaseCylinder_.get ();
    }

    void CylinderTransformType::
    BaseCylinder (const BaseCylinder_type& x)
    {
      this->BaseCylinder_.set (x);
    }

    void CylinderTransformType::
    BaseCylinder (::std::auto_ptr< BaseCylinder_type > x)
    {
      this->BaseCylinder_.set (x);
    }

    const CylinderTransformType::Transformation_type& CylinderTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CylinderTransformType::Transformation_type& CylinderTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CylinderTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CylinderTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // CylinderFromScanType
    // 

    const CylinderFromScanType::SurfaceFeature_type& CylinderFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    CylinderFromScanType::SurfaceFeature_type& CylinderFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void CylinderFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void CylinderFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const CylinderFromScanType::SearchRadius_type& CylinderFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    CylinderFromScanType::SearchRadius_type& CylinderFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void CylinderFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void CylinderFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // CylinderCheckedType
    // 

    const CylinderCheckedType::Measured_optional& CylinderCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CylinderCheckedType::Measured_optional& CylinderCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CylinderCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CylinderCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CylinderCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const CylinderCheckedType::Constructed_optional& CylinderCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CylinderCheckedType::Constructed_optional& CylinderCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CylinderCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CylinderCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CylinderCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // CylinderCheckedFeatureType
    // 

    const CylinderCheckedFeatureType::CheckDetails_optional& CylinderCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CylinderCheckedFeatureType::CheckDetails_optional& CylinderCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CylinderCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // CylinderActualDeterminationType
    // 

    const CylinderActualDeterminationType::Checked_optional& CylinderActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CylinderActualDeterminationType::Checked_optional& CylinderActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CylinderActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CylinderActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CylinderActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const CylinderActualDeterminationType::Set_optional& CylinderActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CylinderActualDeterminationType::Set_optional& CylinderActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CylinderActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CylinderActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CylinderActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // CylinderFeatureItemType
    // 

    const CylinderFeatureItemType::DeterminationMode_type& CylinderFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CylinderFeatureItemType::DeterminationMode_type& CylinderFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CylinderFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CylinderFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const CylinderFeatureItemType::SubstituteFeatureAlgorithm_optional& CylinderFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    CylinderFeatureItemType::SubstituteFeatureAlgorithm_optional& CylinderFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void CylinderFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void CylinderFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void CylinderFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // CylinderFeatureDefinitionType
    // 

    const CylinderFeatureDefinitionType::InternalExternal_type& CylinderFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CylinderFeatureDefinitionType::InternalExternal_type& CylinderFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CylinderFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CylinderFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const CylinderFeatureDefinitionType::Diameter_type& CylinderFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CylinderFeatureDefinitionType::Diameter_type& CylinderFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CylinderFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylinderFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CylinderFeatureDefinitionType::Length_optional& CylinderFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    CylinderFeatureDefinitionType::Length_optional& CylinderFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void CylinderFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylinderFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylinderFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CylinderFeatureDefinitionType::Bottom_optional& CylinderFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    CylinderFeatureDefinitionType::Bottom_optional& CylinderFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void CylinderFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void CylinderFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void CylinderFeatureDefinitionType::
    Bottom (::std::auto_ptr< Bottom_type > x)
    {
      this->Bottom_.set (x);
    }


    // CylinderFeatureNominalType
    // 

    const CylinderFeatureNominalType::Axis_type& CylinderFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    CylinderFeatureNominalType::Axis_type& CylinderFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void CylinderFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylinderFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const CylinderFeatureNominalType::Sweep_optional& CylinderFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_;
    }

    CylinderFeatureNominalType::Sweep_optional& CylinderFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void CylinderFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CylinderFeatureNominalType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void CylinderFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }


    // CylinderFeatureActualType
    // 

    const CylinderFeatureActualType::Axis_optional& CylinderFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    CylinderFeatureActualType::Axis_optional& CylinderFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void CylinderFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylinderFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void CylinderFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const CylinderFeatureActualType::Diameter_optional& CylinderFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CylinderFeatureActualType::Diameter_optional& CylinderFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CylinderFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylinderFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CylinderFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CylinderFeatureActualType::Length_optional& CylinderFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    CylinderFeatureActualType::Length_optional& CylinderFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void CylinderFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylinderFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylinderFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CylinderFeatureActualType::DiameterMin_optional& CylinderFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    CylinderFeatureActualType::DiameterMin_optional& CylinderFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void CylinderFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void CylinderFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void CylinderFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const CylinderFeatureActualType::DiameterMax_optional& CylinderFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    CylinderFeatureActualType::DiameterMax_optional& CylinderFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void CylinderFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void CylinderFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void CylinderFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const CylinderFeatureActualType::Sweep_optional& CylinderFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    CylinderFeatureActualType::Sweep_optional& CylinderFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void CylinderFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CylinderFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void CylinderFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const CylinderFeatureActualType::Form_optional& CylinderFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    CylinderFeatureActualType::Form_optional& CylinderFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void CylinderFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CylinderFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CylinderFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // CylindricalSegmentConstructionMethodType
    // 

    const CylindricalSegmentConstructionMethodType::BestFit_optional& CylindricalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    CylindricalSegmentConstructionMethodType::BestFit_optional& CylindricalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void CylindricalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const CylindricalSegmentConstructionMethodType::Recompensated_optional& CylindricalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    CylindricalSegmentConstructionMethodType::Recompensated_optional& CylindricalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void CylindricalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const CylindricalSegmentConstructionMethodType::Copy_optional& CylindricalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    CylindricalSegmentConstructionMethodType::Copy_optional& CylindricalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void CylindricalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const CylindricalSegmentConstructionMethodType::Cast_optional& CylindricalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    CylindricalSegmentConstructionMethodType::Cast_optional& CylindricalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void CylindricalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const CylindricalSegmentConstructionMethodType::Transform_optional& CylindricalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    CylindricalSegmentConstructionMethodType::Transform_optional& CylindricalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void CylindricalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void CylindricalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void CylindricalSegmentConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // CylindricalSegmentBestFitType
    // 

    const CylindricalSegmentBestFitType::BaseFeature_sequence& CylindricalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    CylindricalSegmentBestFitType::BaseFeature_sequence& CylindricalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void CylindricalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // CylindricalSegmentRecompType
    // 

    const CylindricalSegmentRecompType::BaseFeaturePointList_type& CylindricalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    CylindricalSegmentRecompType::BaseFeaturePointList_type& CylindricalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void CylindricalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void CylindricalSegmentRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // CylindricalSegmentCopyType
    // 

    const CylindricalSegmentCopyType::BaseCylindricalSegment_type& CylindricalSegmentCopyType::
    BaseCylindricalSegment () const
    {
      return this->BaseCylindricalSegment_.get ();
    }

    CylindricalSegmentCopyType::BaseCylindricalSegment_type& CylindricalSegmentCopyType::
    BaseCylindricalSegment ()
    {
      return this->BaseCylindricalSegment_.get ();
    }

    void CylindricalSegmentCopyType::
    BaseCylindricalSegment (const BaseCylindricalSegment_type& x)
    {
      this->BaseCylindricalSegment_.set (x);
    }

    void CylindricalSegmentCopyType::
    BaseCylindricalSegment (::std::auto_ptr< BaseCylindricalSegment_type > x)
    {
      this->BaseCylindricalSegment_.set (x);
    }


    // CylindricalSegmentCastType
    // 

    const CylindricalSegmentCastType::BaseFeature_type& CylindricalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    CylindricalSegmentCastType::BaseFeature_type& CylindricalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void CylindricalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void CylindricalSegmentCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // CylindricalSegmentTransformType
    // 

    const CylindricalSegmentTransformType::BaseCylindricalSegment_type& CylindricalSegmentTransformType::
    BaseCylindricalSegment () const
    {
      return this->BaseCylindricalSegment_.get ();
    }

    CylindricalSegmentTransformType::BaseCylindricalSegment_type& CylindricalSegmentTransformType::
    BaseCylindricalSegment ()
    {
      return this->BaseCylindricalSegment_.get ();
    }

    void CylindricalSegmentTransformType::
    BaseCylindricalSegment (const BaseCylindricalSegment_type& x)
    {
      this->BaseCylindricalSegment_.set (x);
    }

    void CylindricalSegmentTransformType::
    BaseCylindricalSegment (::std::auto_ptr< BaseCylindricalSegment_type > x)
    {
      this->BaseCylindricalSegment_.set (x);
    }

    const CylindricalSegmentTransformType::Transformation_type& CylindricalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    CylindricalSegmentTransformType::Transformation_type& CylindricalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void CylindricalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void CylindricalSegmentTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // CylindricalSegmentCheckedType
    // 

    const CylindricalSegmentCheckedType::Measured_optional& CylindricalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    CylindricalSegmentCheckedType::Measured_optional& CylindricalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void CylindricalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void CylindricalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void CylindricalSegmentCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const CylindricalSegmentCheckedType::Constructed_optional& CylindricalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    CylindricalSegmentCheckedType::Constructed_optional& CylindricalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void CylindricalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void CylindricalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void CylindricalSegmentCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // CylindricalSegmentCheckedFeatureType
    // 

    const CylindricalSegmentCheckedFeatureType::CheckDetails_optional& CylindricalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    CylindricalSegmentCheckedFeatureType::CheckDetails_optional& CylindricalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void CylindricalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void CylindricalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void CylindricalSegmentCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // CylindricalSegmentActualDeterminationType
    // 

    const CylindricalSegmentActualDeterminationType::Checked_optional& CylindricalSegmentActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    CylindricalSegmentActualDeterminationType::Checked_optional& CylindricalSegmentActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void CylindricalSegmentActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void CylindricalSegmentActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void CylindricalSegmentActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const CylindricalSegmentActualDeterminationType::Set_optional& CylindricalSegmentActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    CylindricalSegmentActualDeterminationType::Set_optional& CylindricalSegmentActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void CylindricalSegmentActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void CylindricalSegmentActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void CylindricalSegmentActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // CylindricalSegmentFeatureItemType
    // 

    const CylindricalSegmentFeatureItemType::DeterminationMode_type& CylindricalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    CylindricalSegmentFeatureItemType::DeterminationMode_type& CylindricalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void CylindricalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void CylindricalSegmentFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const CylindricalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& CylindricalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    CylindricalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& CylindricalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void CylindricalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void CylindricalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void CylindricalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // CylindricalSegmentFeatureDefinitionType
    // 

    const CylindricalSegmentFeatureDefinitionType::InternalExternal_type& CylindricalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    CylindricalSegmentFeatureDefinitionType::InternalExternal_type& CylindricalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void CylindricalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const CylindricalSegmentFeatureDefinitionType::Diameter_type& CylindricalSegmentFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    CylindricalSegmentFeatureDefinitionType::Diameter_type& CylindricalSegmentFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void CylindricalSegmentFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CylindricalSegmentFeatureDefinitionType::Length_optional& CylindricalSegmentFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    CylindricalSegmentFeatureDefinitionType::Length_optional& CylindricalSegmentFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CylindricalSegmentFeatureDefinitionType::Bottom_optional& CylindricalSegmentFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    CylindricalSegmentFeatureDefinitionType::Bottom_optional& CylindricalSegmentFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void CylindricalSegmentFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void CylindricalSegmentFeatureDefinitionType::
    Bottom (::std::auto_ptr< Bottom_type > x)
    {
      this->Bottom_.set (x);
    }


    // CylindricalSegmentFeatureNominalType
    // 

    const CylindricalSegmentFeatureNominalType::Axis_type& CylindricalSegmentFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    CylindricalSegmentFeatureNominalType::Axis_type& CylindricalSegmentFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void CylindricalSegmentFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylindricalSegmentFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const CylindricalSegmentFeatureNominalType::Sweep_type& CylindricalSegmentFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_.get ();
    }

    CylindricalSegmentFeatureNominalType::Sweep_type& CylindricalSegmentFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_.get ();
    }

    void CylindricalSegmentFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CylindricalSegmentFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }


    // CylindricalSegmentFeatureActualType
    // 

    const CylindricalSegmentFeatureActualType::Axis_optional& CylindricalSegmentFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    CylindricalSegmentFeatureActualType::Axis_optional& CylindricalSegmentFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void CylindricalSegmentFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const CylindricalSegmentFeatureActualType::Diameter_optional& CylindricalSegmentFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    CylindricalSegmentFeatureActualType::Diameter_optional& CylindricalSegmentFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void CylindricalSegmentFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const CylindricalSegmentFeatureActualType::Length_optional& CylindricalSegmentFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    CylindricalSegmentFeatureActualType::Length_optional& CylindricalSegmentFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void CylindricalSegmentFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const CylindricalSegmentFeatureActualType::DiameterMin_optional& CylindricalSegmentFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    CylindricalSegmentFeatureActualType::DiameterMin_optional& CylindricalSegmentFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const CylindricalSegmentFeatureActualType::DiameterMax_optional& CylindricalSegmentFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    CylindricalSegmentFeatureActualType::DiameterMax_optional& CylindricalSegmentFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const CylindricalSegmentFeatureActualType::Sweep_optional& CylindricalSegmentFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    CylindricalSegmentFeatureActualType::Sweep_optional& CylindricalSegmentFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void CylindricalSegmentFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const CylindricalSegmentFeatureActualType::Form_optional& CylindricalSegmentFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    CylindricalSegmentFeatureActualType::Form_optional& CylindricalSegmentFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void CylindricalSegmentFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void CylindricalSegmentFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void CylindricalSegmentFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // EdgePointConstructionMethodType
    // 

    const EdgePointConstructionMethodType::Copy_optional& EdgePointConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    EdgePointConstructionMethodType::Copy_optional& EdgePointConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void EdgePointConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void EdgePointConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void EdgePointConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const EdgePointConstructionMethodType::Cast_optional& EdgePointConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    EdgePointConstructionMethodType::Cast_optional& EdgePointConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void EdgePointConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void EdgePointConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void EdgePointConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const EdgePointConstructionMethodType::Transform_optional& EdgePointConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    EdgePointConstructionMethodType::Transform_optional& EdgePointConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void EdgePointConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void EdgePointConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void EdgePointConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const EdgePointConstructionMethodType::FromScan_optional& EdgePointConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    EdgePointConstructionMethodType::FromScan_optional& EdgePointConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void EdgePointConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void EdgePointConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void EdgePointConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // EdgePointCopyType
    // 

    const EdgePointCopyType::BaseEdgePoint_type& EdgePointCopyType::
    BaseEdgePoint () const
    {
      return this->BaseEdgePoint_.get ();
    }

    EdgePointCopyType::BaseEdgePoint_type& EdgePointCopyType::
    BaseEdgePoint ()
    {
      return this->BaseEdgePoint_.get ();
    }

    void EdgePointCopyType::
    BaseEdgePoint (const BaseEdgePoint_type& x)
    {
      this->BaseEdgePoint_.set (x);
    }

    void EdgePointCopyType::
    BaseEdgePoint (::std::auto_ptr< BaseEdgePoint_type > x)
    {
      this->BaseEdgePoint_.set (x);
    }


    // EdgePointCastType
    // 

    const EdgePointCastType::BaseFeature_type& EdgePointCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    EdgePointCastType::BaseFeature_type& EdgePointCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void EdgePointCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void EdgePointCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // EdgePointTransformType
    // 

    const EdgePointTransformType::BaseEdgePoint_type& EdgePointTransformType::
    BaseEdgePoint () const
    {
      return this->BaseEdgePoint_.get ();
    }

    EdgePointTransformType::BaseEdgePoint_type& EdgePointTransformType::
    BaseEdgePoint ()
    {
      return this->BaseEdgePoint_.get ();
    }

    void EdgePointTransformType::
    BaseEdgePoint (const BaseEdgePoint_type& x)
    {
      this->BaseEdgePoint_.set (x);
    }

    void EdgePointTransformType::
    BaseEdgePoint (::std::auto_ptr< BaseEdgePoint_type > x)
    {
      this->BaseEdgePoint_.set (x);
    }

    const EdgePointTransformType::Transformation_type& EdgePointTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    EdgePointTransformType::Transformation_type& EdgePointTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void EdgePointTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void EdgePointTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // EdgePointFromScanType
    // 

    const EdgePointFromScanType::SurfaceFeature_type& EdgePointFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    EdgePointFromScanType::SurfaceFeature_type& EdgePointFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void EdgePointFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void EdgePointFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const EdgePointFromScanType::SearchRadius_type& EdgePointFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    EdgePointFromScanType::SearchRadius_type& EdgePointFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void EdgePointFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void EdgePointFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const EdgePointFromScanType::PatchRadius_type& EdgePointFromScanType::
    PatchRadius () const
    {
      return this->PatchRadius_.get ();
    }

    EdgePointFromScanType::PatchRadius_type& EdgePointFromScanType::
    PatchRadius ()
    {
      return this->PatchRadius_.get ();
    }

    void EdgePointFromScanType::
    PatchRadius (const PatchRadius_type& x)
    {
      this->PatchRadius_.set (x);
    }

    void EdgePointFromScanType::
    PatchRadius (::std::auto_ptr< PatchRadius_type > x)
    {
      this->PatchRadius_.set (x);
    }

    const EdgePointFromScanType::Distance_type& EdgePointFromScanType::
    Distance () const
    {
      return this->Distance_.get ();
    }

    EdgePointFromScanType::Distance_type& EdgePointFromScanType::
    Distance ()
    {
      return this->Distance_.get ();
    }

    void EdgePointFromScanType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void EdgePointFromScanType::
    Distance (::std::auto_ptr< Distance_type > x)
    {
      this->Distance_.set (x);
    }

    const EdgePointFromScanType::Depth_type& EdgePointFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    EdgePointFromScanType::Depth_type& EdgePointFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void EdgePointFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void EdgePointFromScanType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }

    const EdgePointFromScanType::RetrievalMethod_type& EdgePointFromScanType::
    RetrievalMethod () const
    {
      return this->RetrievalMethod_.get ();
    }

    EdgePointFromScanType::RetrievalMethod_type& EdgePointFromScanType::
    RetrievalMethod ()
    {
      return this->RetrievalMethod_.get ();
    }

    void EdgePointFromScanType::
    RetrievalMethod (const RetrievalMethod_type& x)
    {
      this->RetrievalMethod_.set (x);
    }

    void EdgePointFromScanType::
    RetrievalMethod (::std::auto_ptr< RetrievalMethod_type > x)
    {
      this->RetrievalMethod_.set (x);
    }


    // EdgePointCheckedType
    // 

    const EdgePointCheckedType::Measured_optional& EdgePointCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    EdgePointCheckedType::Measured_optional& EdgePointCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void EdgePointCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void EdgePointCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void EdgePointCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const EdgePointCheckedType::Constructed_optional& EdgePointCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    EdgePointCheckedType::Constructed_optional& EdgePointCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void EdgePointCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void EdgePointCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void EdgePointCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // EdgePointCheckedFeatureType
    // 

    const EdgePointCheckedFeatureType::CheckDetails_optional& EdgePointCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    EdgePointCheckedFeatureType::CheckDetails_optional& EdgePointCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void EdgePointCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void EdgePointCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void EdgePointCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // EdgePointActualDeterminationType
    // 

    const EdgePointActualDeterminationType::Checked_optional& EdgePointActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    EdgePointActualDeterminationType::Checked_optional& EdgePointActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void EdgePointActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void EdgePointActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void EdgePointActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const EdgePointActualDeterminationType::Set_optional& EdgePointActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    EdgePointActualDeterminationType::Set_optional& EdgePointActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void EdgePointActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void EdgePointActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void EdgePointActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // EdgePointFeatureItemType
    // 

    const EdgePointFeatureItemType::DeterminationMode_type& EdgePointFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    EdgePointFeatureItemType::DeterminationMode_type& EdgePointFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void EdgePointFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void EdgePointFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }


    // EdgePointFeatureDefinitionType
    // 

    const EdgePointFeatureDefinitionType::InternalExternal_type& EdgePointFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    EdgePointFeatureDefinitionType::InternalExternal_type& EdgePointFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void EdgePointFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void EdgePointFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }


    // EdgePointFeatureNominalType
    // 

    const EdgePointFeatureNominalType::Location_type& EdgePointFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    EdgePointFeatureNominalType::Location_type& EdgePointFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void EdgePointFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void EdgePointFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const EdgePointFeatureNominalType::Normal_type& EdgePointFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    EdgePointFeatureNominalType::Normal_type& EdgePointFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void EdgePointFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EdgePointFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const EdgePointFeatureNominalType::AdjacentNormal_optional& EdgePointFeatureNominalType::
    AdjacentNormal () const
    {
      return this->AdjacentNormal_;
    }

    EdgePointFeatureNominalType::AdjacentNormal_optional& EdgePointFeatureNominalType::
    AdjacentNormal ()
    {
      return this->AdjacentNormal_;
    }

    void EdgePointFeatureNominalType::
    AdjacentNormal (const AdjacentNormal_type& x)
    {
      this->AdjacentNormal_.set (x);
    }

    void EdgePointFeatureNominalType::
    AdjacentNormal (const AdjacentNormal_optional& x)
    {
      this->AdjacentNormal_ = x;
    }

    void EdgePointFeatureNominalType::
    AdjacentNormal (::std::auto_ptr< AdjacentNormal_type > x)
    {
      this->AdjacentNormal_.set (x);
    }


    // EdgePointFeatureActualType
    // 

    const EdgePointFeatureActualType::Location_optional& EdgePointFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    EdgePointFeatureActualType::Location_optional& EdgePointFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void EdgePointFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void EdgePointFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void EdgePointFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const EdgePointFeatureActualType::Normal_optional& EdgePointFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    EdgePointFeatureActualType::Normal_optional& EdgePointFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void EdgePointFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EdgePointFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void EdgePointFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const EdgePointFeatureActualType::AdjacentNormal_optional& EdgePointFeatureActualType::
    AdjacentNormal () const
    {
      return this->AdjacentNormal_;
    }

    EdgePointFeatureActualType::AdjacentNormal_optional& EdgePointFeatureActualType::
    AdjacentNormal ()
    {
      return this->AdjacentNormal_;
    }

    void EdgePointFeatureActualType::
    AdjacentNormal (const AdjacentNormal_type& x)
    {
      this->AdjacentNormal_.set (x);
    }

    void EdgePointFeatureActualType::
    AdjacentNormal (const AdjacentNormal_optional& x)
    {
      this->AdjacentNormal_ = x;
    }

    void EdgePointFeatureActualType::
    AdjacentNormal (::std::auto_ptr< AdjacentNormal_type > x)
    {
      this->AdjacentNormal_.set (x);
    }


    // EllipseConstructionMethodType
    // 

    const EllipseConstructionMethodType::BestFit_optional& EllipseConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    EllipseConstructionMethodType::BestFit_optional& EllipseConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void EllipseConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void EllipseConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void EllipseConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const EllipseConstructionMethodType::Recompensated_optional& EllipseConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    EllipseConstructionMethodType::Recompensated_optional& EllipseConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void EllipseConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void EllipseConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void EllipseConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const EllipseConstructionMethodType::Intersection_optional& EllipseConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    EllipseConstructionMethodType::Intersection_optional& EllipseConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void EllipseConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void EllipseConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void EllipseConstructionMethodType::
    Intersection (::std::auto_ptr< Intersection_type > x)
    {
      this->Intersection_.set (x);
    }

    const EllipseConstructionMethodType::Projection_optional& EllipseConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    EllipseConstructionMethodType::Projection_optional& EllipseConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void EllipseConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void EllipseConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void EllipseConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const EllipseConstructionMethodType::Copy_optional& EllipseConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    EllipseConstructionMethodType::Copy_optional& EllipseConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void EllipseConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void EllipseConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void EllipseConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const EllipseConstructionMethodType::Cast_optional& EllipseConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    EllipseConstructionMethodType::Cast_optional& EllipseConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void EllipseConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void EllipseConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void EllipseConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const EllipseConstructionMethodType::Transform_optional& EllipseConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    EllipseConstructionMethodType::Transform_optional& EllipseConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void EllipseConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void EllipseConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void EllipseConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const EllipseConstructionMethodType::FromScan_optional& EllipseConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    EllipseConstructionMethodType::FromScan_optional& EllipseConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void EllipseConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void EllipseConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void EllipseConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // EllipseBestFitType
    // 

    const EllipseBestFitType::BaseFeature_sequence& EllipseBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    EllipseBestFitType::BaseFeature_sequence& EllipseBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void EllipseBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // EllipseRecompType
    // 

    const EllipseRecompType::BaseFeaturePointList_type& EllipseRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    EllipseRecompType::BaseFeaturePointList_type& EllipseRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void EllipseRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void EllipseRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // EllipseProjectionType
    // 

    const EllipseProjectionType::ProjectionFeature_type& EllipseProjectionType::
    ProjectionFeature () const
    {
      return this->ProjectionFeature_.get ();
    }

    EllipseProjectionType::ProjectionFeature_type& EllipseProjectionType::
    ProjectionFeature ()
    {
      return this->ProjectionFeature_.get ();
    }

    void EllipseProjectionType::
    ProjectionFeature (const ProjectionFeature_type& x)
    {
      this->ProjectionFeature_.set (x);
    }

    void EllipseProjectionType::
    ProjectionFeature (::std::auto_ptr< ProjectionFeature_type > x)
    {
      this->ProjectionFeature_.set (x);
    }

    const EllipseProjectionType::ProjectionPlane_type& EllipseProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    EllipseProjectionType::ProjectionPlane_type& EllipseProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void EllipseProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void EllipseProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }


    // EllipseIntersectionType
    // 

    const EllipseIntersectionType::IntersectionPlane_type& EllipseIntersectionType::
    IntersectionPlane () const
    {
      return this->IntersectionPlane_.get ();
    }

    EllipseIntersectionType::IntersectionPlane_type& EllipseIntersectionType::
    IntersectionPlane ()
    {
      return this->IntersectionPlane_.get ();
    }

    void EllipseIntersectionType::
    IntersectionPlane (const IntersectionPlane_type& x)
    {
      this->IntersectionPlane_.set (x);
    }

    void EllipseIntersectionType::
    IntersectionPlane (::std::auto_ptr< IntersectionPlane_type > x)
    {
      this->IntersectionPlane_.set (x);
    }

    const EllipseIntersectionType::IntersectionFeature_type& EllipseIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_.get ();
    }

    EllipseIntersectionType::IntersectionFeature_type& EllipseIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_.get ();
    }

    void EllipseIntersectionType::
    IntersectionFeature (const IntersectionFeature_type& x)
    {
      this->IntersectionFeature_.set (x);
    }

    void EllipseIntersectionType::
    IntersectionFeature (::std::auto_ptr< IntersectionFeature_type > x)
    {
      this->IntersectionFeature_.set (x);
    }


    // EllipseCopyType
    // 

    const EllipseCopyType::BaseEllipse_type& EllipseCopyType::
    BaseEllipse () const
    {
      return this->BaseEllipse_.get ();
    }

    EllipseCopyType::BaseEllipse_type& EllipseCopyType::
    BaseEllipse ()
    {
      return this->BaseEllipse_.get ();
    }

    void EllipseCopyType::
    BaseEllipse (const BaseEllipse_type& x)
    {
      this->BaseEllipse_.set (x);
    }

    void EllipseCopyType::
    BaseEllipse (::std::auto_ptr< BaseEllipse_type > x)
    {
      this->BaseEllipse_.set (x);
    }


    // EllipseCastType
    // 

    const EllipseCastType::BaseFeature_type& EllipseCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    EllipseCastType::BaseFeature_type& EllipseCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void EllipseCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void EllipseCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // EllipseTransformType
    // 

    const EllipseTransformType::BaseEllipse_type& EllipseTransformType::
    BaseEllipse () const
    {
      return this->BaseEllipse_.get ();
    }

    EllipseTransformType::BaseEllipse_type& EllipseTransformType::
    BaseEllipse ()
    {
      return this->BaseEllipse_.get ();
    }

    void EllipseTransformType::
    BaseEllipse (const BaseEllipse_type& x)
    {
      this->BaseEllipse_.set (x);
    }

    void EllipseTransformType::
    BaseEllipse (::std::auto_ptr< BaseEllipse_type > x)
    {
      this->BaseEllipse_.set (x);
    }

    const EllipseTransformType::Transformation_type& EllipseTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    EllipseTransformType::Transformation_type& EllipseTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void EllipseTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void EllipseTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // EllipseFromScanType
    // 

    const EllipseFromScanType::SurfaceFeature_type& EllipseFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    EllipseFromScanType::SurfaceFeature_type& EllipseFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void EllipseFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void EllipseFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const EllipseFromScanType::SearchRadius_type& EllipseFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    EllipseFromScanType::SearchRadius_type& EllipseFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void EllipseFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void EllipseFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const EllipseFromScanType::Depth_type& EllipseFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    EllipseFromScanType::Depth_type& EllipseFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void EllipseFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void EllipseFromScanType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }


    // EllipseCheckedType
    // 

    const EllipseCheckedType::Measured_optional& EllipseCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    EllipseCheckedType::Measured_optional& EllipseCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void EllipseCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void EllipseCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void EllipseCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const EllipseCheckedType::Constructed_optional& EllipseCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    EllipseCheckedType::Constructed_optional& EllipseCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void EllipseCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void EllipseCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void EllipseCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // EllipseCheckedFeatureType
    // 

    const EllipseCheckedFeatureType::CheckDetails_optional& EllipseCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    EllipseCheckedFeatureType::CheckDetails_optional& EllipseCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void EllipseCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void EllipseCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void EllipseCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // EllipseActualDeterminationType
    // 

    const EllipseActualDeterminationType::Checked_optional& EllipseActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    EllipseActualDeterminationType::Checked_optional& EllipseActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void EllipseActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void EllipseActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void EllipseActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const EllipseActualDeterminationType::Set_optional& EllipseActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    EllipseActualDeterminationType::Set_optional& EllipseActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void EllipseActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void EllipseActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void EllipseActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // EllipseFeatureItemType
    // 

    const EllipseFeatureItemType::DeterminationMode_type& EllipseFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    EllipseFeatureItemType::DeterminationMode_type& EllipseFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void EllipseFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void EllipseFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const EllipseFeatureItemType::SubstituteFeatureAlgorithm_optional& EllipseFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    EllipseFeatureItemType::SubstituteFeatureAlgorithm_optional& EllipseFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void EllipseFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void EllipseFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void EllipseFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // EllipseFeatureDefinitionType
    // 

    const EllipseFeatureDefinitionType::InternalExternal_type& EllipseFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    EllipseFeatureDefinitionType::InternalExternal_type& EllipseFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void EllipseFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void EllipseFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const EllipseFeatureDefinitionType::MajorDiameter_type& EllipseFeatureDefinitionType::
    MajorDiameter () const
    {
      return this->MajorDiameter_.get ();
    }

    EllipseFeatureDefinitionType::MajorDiameter_type& EllipseFeatureDefinitionType::
    MajorDiameter ()
    {
      return this->MajorDiameter_.get ();
    }

    void EllipseFeatureDefinitionType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void EllipseFeatureDefinitionType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }

    const EllipseFeatureDefinitionType::MinorDiameter_type& EllipseFeatureDefinitionType::
    MinorDiameter () const
    {
      return this->MinorDiameter_.get ();
    }

    EllipseFeatureDefinitionType::MinorDiameter_type& EllipseFeatureDefinitionType::
    MinorDiameter ()
    {
      return this->MinorDiameter_.get ();
    }

    void EllipseFeatureDefinitionType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void EllipseFeatureDefinitionType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }


    // EllipseFeatureNominalType
    // 

    const EllipseFeatureNominalType::Axis_type& EllipseFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    EllipseFeatureNominalType::Axis_type& EllipseFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void EllipseFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void EllipseFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const EllipseFeatureNominalType::Normal_type& EllipseFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    EllipseFeatureNominalType::Normal_type& EllipseFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void EllipseFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EllipseFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // EllipseFeatureActualType
    // 

    const EllipseFeatureActualType::Axis_optional& EllipseFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    EllipseFeatureActualType::Axis_optional& EllipseFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void EllipseFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void EllipseFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void EllipseFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const EllipseFeatureActualType::Normal_optional& EllipseFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    EllipseFeatureActualType::Normal_optional& EllipseFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void EllipseFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void EllipseFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void EllipseFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const EllipseFeatureActualType::MajorDiameter_optional& EllipseFeatureActualType::
    MajorDiameter () const
    {
      return this->MajorDiameter_;
    }

    EllipseFeatureActualType::MajorDiameter_optional& EllipseFeatureActualType::
    MajorDiameter ()
    {
      return this->MajorDiameter_;
    }

    void EllipseFeatureActualType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void EllipseFeatureActualType::
    MajorDiameter (const MajorDiameter_optional& x)
    {
      this->MajorDiameter_ = x;
    }

    void EllipseFeatureActualType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }

    const EllipseFeatureActualType::MinorDiameter_optional& EllipseFeatureActualType::
    MinorDiameter () const
    {
      return this->MinorDiameter_;
    }

    EllipseFeatureActualType::MinorDiameter_optional& EllipseFeatureActualType::
    MinorDiameter ()
    {
      return this->MinorDiameter_;
    }

    void EllipseFeatureActualType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void EllipseFeatureActualType::
    MinorDiameter (const MinorDiameter_optional& x)
    {
      this->MinorDiameter_ = x;
    }

    void EllipseFeatureActualType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }

    const EllipseFeatureActualType::Form_optional& EllipseFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    EllipseFeatureActualType::Form_optional& EllipseFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void EllipseFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void EllipseFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void EllipseFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // ElongatedCylinderConstructionMethodType
    // 

    const ElongatedCylinderConstructionMethodType::BestFit_optional& ElongatedCylinderConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ElongatedCylinderConstructionMethodType::BestFit_optional& ElongatedCylinderConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ElongatedCylinderConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ElongatedCylinderConstructionMethodType::Recompensated_optional& ElongatedCylinderConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ElongatedCylinderConstructionMethodType::Recompensated_optional& ElongatedCylinderConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ElongatedCylinderConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ElongatedCylinderConstructionMethodType::Copy_optional& ElongatedCylinderConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ElongatedCylinderConstructionMethodType::Copy_optional& ElongatedCylinderConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ElongatedCylinderConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ElongatedCylinderConstructionMethodType::Cast_optional& ElongatedCylinderConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ElongatedCylinderConstructionMethodType::Cast_optional& ElongatedCylinderConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ElongatedCylinderConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ElongatedCylinderConstructionMethodType::Transform_optional& ElongatedCylinderConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ElongatedCylinderConstructionMethodType::Transform_optional& ElongatedCylinderConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ElongatedCylinderConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ElongatedCylinderConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ElongatedCylinderConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // ElongatedCylinderBestFitType
    // 

    const ElongatedCylinderBestFitType::BaseFeature_sequence& ElongatedCylinderBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ElongatedCylinderBestFitType::BaseFeature_sequence& ElongatedCylinderBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ElongatedCylinderBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ElongatedCylinderRecompType
    // 

    const ElongatedCylinderRecompType::BaseFeaturePointList_type& ElongatedCylinderRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ElongatedCylinderRecompType::BaseFeaturePointList_type& ElongatedCylinderRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ElongatedCylinderRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ElongatedCylinderRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ElongatedCylinderCopyType
    // 

    const ElongatedCylinderCopyType::BaseElongatedCylinder_type& ElongatedCylinderCopyType::
    BaseElongatedCylinder () const
    {
      return this->BaseElongatedCylinder_.get ();
    }

    ElongatedCylinderCopyType::BaseElongatedCylinder_type& ElongatedCylinderCopyType::
    BaseElongatedCylinder ()
    {
      return this->BaseElongatedCylinder_.get ();
    }

    void ElongatedCylinderCopyType::
    BaseElongatedCylinder (const BaseElongatedCylinder_type& x)
    {
      this->BaseElongatedCylinder_.set (x);
    }

    void ElongatedCylinderCopyType::
    BaseElongatedCylinder (::std::auto_ptr< BaseElongatedCylinder_type > x)
    {
      this->BaseElongatedCylinder_.set (x);
    }


    // ElongatedCylinderCastType
    // 

    const ElongatedCylinderCastType::BaseFeature_type& ElongatedCylinderCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ElongatedCylinderCastType::BaseFeature_type& ElongatedCylinderCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ElongatedCylinderCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ElongatedCylinderCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ElongatedCylinderTransformType
    // 

    const ElongatedCylinderTransformType::BaseElongatedCylinder_type& ElongatedCylinderTransformType::
    BaseElongatedCylinder () const
    {
      return this->BaseElongatedCylinder_.get ();
    }

    ElongatedCylinderTransformType::BaseElongatedCylinder_type& ElongatedCylinderTransformType::
    BaseElongatedCylinder ()
    {
      return this->BaseElongatedCylinder_.get ();
    }

    void ElongatedCylinderTransformType::
    BaseElongatedCylinder (const BaseElongatedCylinder_type& x)
    {
      this->BaseElongatedCylinder_.set (x);
    }

    void ElongatedCylinderTransformType::
    BaseElongatedCylinder (::std::auto_ptr< BaseElongatedCylinder_type > x)
    {
      this->BaseElongatedCylinder_.set (x);
    }

    const ElongatedCylinderTransformType::Transformation_type& ElongatedCylinderTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ElongatedCylinderTransformType::Transformation_type& ElongatedCylinderTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ElongatedCylinderTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ElongatedCylinderTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ElongatedCylinderCheckedType
    // 

    const ElongatedCylinderCheckedType::Measured_optional& ElongatedCylinderCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ElongatedCylinderCheckedType::Measured_optional& ElongatedCylinderCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ElongatedCylinderCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ElongatedCylinderCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ElongatedCylinderCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ElongatedCylinderCheckedType::Constructed_optional& ElongatedCylinderCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ElongatedCylinderCheckedType::Constructed_optional& ElongatedCylinderCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ElongatedCylinderCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ElongatedCylinderCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ElongatedCylinderCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ElongatedCylinderCheckedFeatureType
    // 

    const ElongatedCylinderCheckedFeatureType::CheckDetails_optional& ElongatedCylinderCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ElongatedCylinderCheckedFeatureType::CheckDetails_optional& ElongatedCylinderCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ElongatedCylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ElongatedCylinderCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ElongatedCylinderCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ElongatedCylinderActualDeterminationType
    // 

    const ElongatedCylinderActualDeterminationType::Checked_optional& ElongatedCylinderActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ElongatedCylinderActualDeterminationType::Checked_optional& ElongatedCylinderActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ElongatedCylinderActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ElongatedCylinderActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ElongatedCylinderActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ElongatedCylinderActualDeterminationType::Set_optional& ElongatedCylinderActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ElongatedCylinderActualDeterminationType::Set_optional& ElongatedCylinderActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ElongatedCylinderActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ElongatedCylinderActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ElongatedCylinderActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ElongatedCylinderFeatureItemType
    // 

    const ElongatedCylinderFeatureItemType::DeterminationMode_type& ElongatedCylinderFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ElongatedCylinderFeatureItemType::DeterminationMode_type& ElongatedCylinderFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ElongatedCylinderFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ElongatedCylinderFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ElongatedCylinderFeatureItemType::SubstituteFeatureAlgorithm_optional& ElongatedCylinderFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ElongatedCylinderFeatureItemType::SubstituteFeatureAlgorithm_optional& ElongatedCylinderFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ElongatedCylinderFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ElongatedCylinderFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ElongatedCylinderFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ElongatedCylinderFeatureDefinitionType
    // 

    const ElongatedCylinderFeatureDefinitionType::InternalExternal_type& ElongatedCylinderFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ElongatedCylinderFeatureDefinitionType::InternalExternal_type& ElongatedCylinderFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ElongatedCylinderFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ElongatedCylinderFeatureDefinitionType::Diameter_type& ElongatedCylinderFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    ElongatedCylinderFeatureDefinitionType::Diameter_type& ElongatedCylinderFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void ElongatedCylinderFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ElongatedCylinderFeatureDefinitionType::Length_type& ElongatedCylinderFeatureDefinitionType::
    Length () const
    {
      return this->Length_.get ();
    }

    ElongatedCylinderFeatureDefinitionType::Length_type& ElongatedCylinderFeatureDefinitionType::
    Length ()
    {
      return this->Length_.get ();
    }

    void ElongatedCylinderFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const ElongatedCylinderFeatureDefinitionType::Width_optional& ElongatedCylinderFeatureDefinitionType::
    Width () const
    {
      return this->Width_;
    }

    ElongatedCylinderFeatureDefinitionType::Width_optional& ElongatedCylinderFeatureDefinitionType::
    Width ()
    {
      return this->Width_;
    }

    void ElongatedCylinderFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void ElongatedCylinderFeatureDefinitionType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const ElongatedCylinderFeatureDefinitionType::Depth_optional& ElongatedCylinderFeatureDefinitionType::
    Depth () const
    {
      return this->Depth_;
    }

    ElongatedCylinderFeatureDefinitionType::Depth_optional& ElongatedCylinderFeatureDefinitionType::
    Depth ()
    {
      return this->Depth_;
    }

    void ElongatedCylinderFeatureDefinitionType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void ElongatedCylinderFeatureDefinitionType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void ElongatedCylinderFeatureDefinitionType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }


    // ElongatedCylinderFeatureNominalType
    // 

    const ElongatedCylinderFeatureNominalType::CenterPlane_type& ElongatedCylinderFeatureNominalType::
    CenterPlane () const
    {
      return this->CenterPlane_.get ();
    }

    ElongatedCylinderFeatureNominalType::CenterPlane_type& ElongatedCylinderFeatureNominalType::
    CenterPlane ()
    {
      return this->CenterPlane_.get ();
    }

    void ElongatedCylinderFeatureNominalType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void ElongatedCylinderFeatureNominalType::
    CenterPlane (::std::auto_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (x);
    }

    const ElongatedCylinderFeatureNominalType::DepthVector_type& ElongatedCylinderFeatureNominalType::
    DepthVector () const
    {
      return this->DepthVector_.get ();
    }

    ElongatedCylinderFeatureNominalType::DepthVector_type& ElongatedCylinderFeatureNominalType::
    DepthVector ()
    {
      return this->DepthVector_.get ();
    }

    void ElongatedCylinderFeatureNominalType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void ElongatedCylinderFeatureNominalType::
    DepthVector (::std::auto_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (x);
    }


    // ElongatedCylinderFeatureActualType
    // 

    const ElongatedCylinderFeatureActualType::Diameter_optional& ElongatedCylinderFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    ElongatedCylinderFeatureActualType::Diameter_optional& ElongatedCylinderFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void ElongatedCylinderFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const ElongatedCylinderFeatureActualType::DiameterMin_optional& ElongatedCylinderFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    ElongatedCylinderFeatureActualType::DiameterMin_optional& ElongatedCylinderFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const ElongatedCylinderFeatureActualType::DiameterMax_optional& ElongatedCylinderFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    ElongatedCylinderFeatureActualType::DiameterMax_optional& ElongatedCylinderFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const ElongatedCylinderFeatureActualType::CenterPlane_optional& ElongatedCylinderFeatureActualType::
    CenterPlane () const
    {
      return this->CenterPlane_;
    }

    ElongatedCylinderFeatureActualType::CenterPlane_optional& ElongatedCylinderFeatureActualType::
    CenterPlane ()
    {
      return this->CenterPlane_;
    }

    void ElongatedCylinderFeatureActualType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    CenterPlane (const CenterPlane_optional& x)
    {
      this->CenterPlane_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    CenterPlane (::std::auto_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (x);
    }

    const ElongatedCylinderFeatureActualType::Length_optional& ElongatedCylinderFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    ElongatedCylinderFeatureActualType::Length_optional& ElongatedCylinderFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void ElongatedCylinderFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const ElongatedCylinderFeatureActualType::LengthMax_optional& ElongatedCylinderFeatureActualType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    ElongatedCylinderFeatureActualType::LengthMax_optional& ElongatedCylinderFeatureActualType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void ElongatedCylinderFeatureActualType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    LengthMax (::std::auto_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (x);
    }

    const ElongatedCylinderFeatureActualType::LengthMin_optional& ElongatedCylinderFeatureActualType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    ElongatedCylinderFeatureActualType::LengthMin_optional& ElongatedCylinderFeatureActualType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void ElongatedCylinderFeatureActualType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    LengthMin (::std::auto_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (x);
    }

    const ElongatedCylinderFeatureActualType::Width_optional& ElongatedCylinderFeatureActualType::
    Width () const
    {
      return this->Width_;
    }

    ElongatedCylinderFeatureActualType::Width_optional& ElongatedCylinderFeatureActualType::
    Width ()
    {
      return this->Width_;
    }

    void ElongatedCylinderFeatureActualType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const ElongatedCylinderFeatureActualType::WidthMax_optional& ElongatedCylinderFeatureActualType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    ElongatedCylinderFeatureActualType::WidthMax_optional& ElongatedCylinderFeatureActualType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void ElongatedCylinderFeatureActualType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    WidthMax (::std::auto_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (x);
    }

    const ElongatedCylinderFeatureActualType::WidthMin_optional& ElongatedCylinderFeatureActualType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    ElongatedCylinderFeatureActualType::WidthMin_optional& ElongatedCylinderFeatureActualType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void ElongatedCylinderFeatureActualType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    WidthMin (::std::auto_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (x);
    }

    const ElongatedCylinderFeatureActualType::Depth_optional& ElongatedCylinderFeatureActualType::
    Depth () const
    {
      return this->Depth_;
    }

    ElongatedCylinderFeatureActualType::Depth_optional& ElongatedCylinderFeatureActualType::
    Depth ()
    {
      return this->Depth_;
    }

    void ElongatedCylinderFeatureActualType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }

    const ElongatedCylinderFeatureActualType::DepthMax_optional& ElongatedCylinderFeatureActualType::
    DepthMax () const
    {
      return this->DepthMax_;
    }

    ElongatedCylinderFeatureActualType::DepthMax_optional& ElongatedCylinderFeatureActualType::
    DepthMax ()
    {
      return this->DepthMax_;
    }

    void ElongatedCylinderFeatureActualType::
    DepthMax (const DepthMax_type& x)
    {
      this->DepthMax_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    DepthMax (const DepthMax_optional& x)
    {
      this->DepthMax_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    DepthMax (::std::auto_ptr< DepthMax_type > x)
    {
      this->DepthMax_.set (x);
    }

    const ElongatedCylinderFeatureActualType::DepthMin_optional& ElongatedCylinderFeatureActualType::
    DepthMin () const
    {
      return this->DepthMin_;
    }

    ElongatedCylinderFeatureActualType::DepthMin_optional& ElongatedCylinderFeatureActualType::
    DepthMin ()
    {
      return this->DepthMin_;
    }

    void ElongatedCylinderFeatureActualType::
    DepthMin (const DepthMin_type& x)
    {
      this->DepthMin_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    DepthMin (const DepthMin_optional& x)
    {
      this->DepthMin_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    DepthMin (::std::auto_ptr< DepthMin_type > x)
    {
      this->DepthMin_.set (x);
    }

    const ElongatedCylinderFeatureActualType::DepthVector_optional& ElongatedCylinderFeatureActualType::
    DepthVector () const
    {
      return this->DepthVector_;
    }

    ElongatedCylinderFeatureActualType::DepthVector_optional& ElongatedCylinderFeatureActualType::
    DepthVector ()
    {
      return this->DepthVector_;
    }

    void ElongatedCylinderFeatureActualType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    DepthVector (const DepthVector_optional& x)
    {
      this->DepthVector_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    DepthVector (::std::auto_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (x);
    }

    const ElongatedCylinderFeatureActualType::Form_optional& ElongatedCylinderFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ElongatedCylinderFeatureActualType::Form_optional& ElongatedCylinderFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ElongatedCylinderFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ElongatedCylinderFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ElongatedCylinderFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // ExtrudedCrossSectionConstructionMethodType
    // 

    const ExtrudedCrossSectionConstructionMethodType::BestFit_optional& ExtrudedCrossSectionConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ExtrudedCrossSectionConstructionMethodType::BestFit_optional& ExtrudedCrossSectionConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ExtrudedCrossSectionConstructionMethodType::Recompensated_optional& ExtrudedCrossSectionConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ExtrudedCrossSectionConstructionMethodType::Recompensated_optional& ExtrudedCrossSectionConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ExtrudedCrossSectionConstructionMethodType::Copy_optional& ExtrudedCrossSectionConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ExtrudedCrossSectionConstructionMethodType::Copy_optional& ExtrudedCrossSectionConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ExtrudedCrossSectionConstructionMethodType::Cast_optional& ExtrudedCrossSectionConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ExtrudedCrossSectionConstructionMethodType::Cast_optional& ExtrudedCrossSectionConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ExtrudedCrossSectionConstructionMethodType::Transform_optional& ExtrudedCrossSectionConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ExtrudedCrossSectionConstructionMethodType::Transform_optional& ExtrudedCrossSectionConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ExtrudedCrossSectionConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // ExtrudedCrossSectionBestFitType
    // 

    const ExtrudedCrossSectionBestFitType::BaseFeature_sequence& ExtrudedCrossSectionBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ExtrudedCrossSectionBestFitType::BaseFeature_sequence& ExtrudedCrossSectionBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ExtrudedCrossSectionBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ExtrudedCrossSectionRecompType
    // 

    const ExtrudedCrossSectionRecompType::BaseFeaturePointList_type& ExtrudedCrossSectionRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ExtrudedCrossSectionRecompType::BaseFeaturePointList_type& ExtrudedCrossSectionRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ExtrudedCrossSectionRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ExtrudedCrossSectionRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ExtrudedCrossSectionCopyType
    // 

    const ExtrudedCrossSectionCopyType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection () const
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    ExtrudedCrossSectionCopyType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection ()
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    void ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection (const BaseExtrudedCrossSection_type& x)
    {
      this->BaseExtrudedCrossSection_.set (x);
    }

    void ExtrudedCrossSectionCopyType::
    BaseExtrudedCrossSection (::std::auto_ptr< BaseExtrudedCrossSection_type > x)
    {
      this->BaseExtrudedCrossSection_.set (x);
    }


    // ExtrudedCrossSectionCastType
    // 

    const ExtrudedCrossSectionCastType::BaseFeature_type& ExtrudedCrossSectionCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ExtrudedCrossSectionCastType::BaseFeature_type& ExtrudedCrossSectionCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ExtrudedCrossSectionCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ExtrudedCrossSectionCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ExtrudedCrossSectionTransformType
    // 

    const ExtrudedCrossSectionTransformType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection () const
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    ExtrudedCrossSectionTransformType::BaseExtrudedCrossSection_type& ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection ()
    {
      return this->BaseExtrudedCrossSection_.get ();
    }

    void ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection (const BaseExtrudedCrossSection_type& x)
    {
      this->BaseExtrudedCrossSection_.set (x);
    }

    void ExtrudedCrossSectionTransformType::
    BaseExtrudedCrossSection (::std::auto_ptr< BaseExtrudedCrossSection_type > x)
    {
      this->BaseExtrudedCrossSection_.set (x);
    }

    const ExtrudedCrossSectionTransformType::Transformation_type& ExtrudedCrossSectionTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ExtrudedCrossSectionTransformType::Transformation_type& ExtrudedCrossSectionTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ExtrudedCrossSectionTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ExtrudedCrossSectionTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ExtrudedCrossSectionCheckedType
    // 

    const ExtrudedCrossSectionCheckedType::Measured_optional& ExtrudedCrossSectionCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ExtrudedCrossSectionCheckedType::Measured_optional& ExtrudedCrossSectionCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ExtrudedCrossSectionCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ExtrudedCrossSectionCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ExtrudedCrossSectionCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ExtrudedCrossSectionCheckedType::Constructed_optional& ExtrudedCrossSectionCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ExtrudedCrossSectionCheckedType::Constructed_optional& ExtrudedCrossSectionCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ExtrudedCrossSectionCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ExtrudedCrossSectionCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ExtrudedCrossSectionCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ExtrudedCrossSectionCheckedFeatureType
    // 

    const ExtrudedCrossSectionCheckedFeatureType::CheckDetails_optional& ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ExtrudedCrossSectionCheckedFeatureType::CheckDetails_optional& ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ExtrudedCrossSectionActualDeterminationType
    // 

    const ExtrudedCrossSectionActualDeterminationType::Checked_optional& ExtrudedCrossSectionActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ExtrudedCrossSectionActualDeterminationType::Checked_optional& ExtrudedCrossSectionActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ExtrudedCrossSectionActualDeterminationType::Set_optional& ExtrudedCrossSectionActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ExtrudedCrossSectionActualDeterminationType::Set_optional& ExtrudedCrossSectionActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ExtrudedCrossSectionActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ExtrudedCrossSectionFeatureItemType
    // 

    const ExtrudedCrossSectionFeatureItemType::DeterminationMode_type& ExtrudedCrossSectionFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ExtrudedCrossSectionFeatureItemType::DeterminationMode_type& ExtrudedCrossSectionFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ExtrudedCrossSectionFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ExtrudedCrossSectionFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ExtrudedCrossSectionFeatureItemType::SubstituteFeatureAlgorithm_optional& ExtrudedCrossSectionFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ExtrudedCrossSectionFeatureItemType::SubstituteFeatureAlgorithm_optional& ExtrudedCrossSectionFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ExtrudedCrossSectionFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ExtrudedCrossSectionFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ExtrudedCrossSectionFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ExtrudedCrossSectionFeatureDefinitionType
    // 

    const ExtrudedCrossSectionFeatureDefinitionType::InternalExternal_type& ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ExtrudedCrossSectionFeatureDefinitionType::InternalExternal_type& ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ExtrudedCrossSectionFeatureDefinitionType::Length_type& ExtrudedCrossSectionFeatureDefinitionType::
    Length () const
    {
      return this->Length_.get ();
    }

    ExtrudedCrossSectionFeatureDefinitionType::Length_type& ExtrudedCrossSectionFeatureDefinitionType::
    Length ()
    {
      return this->Length_.get ();
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }


    // ExtrudedCrossSectionFeatureNominalType
    // 

    const ExtrudedCrossSectionFeatureNominalType::Direction_type& ExtrudedCrossSectionFeatureNominalType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    ExtrudedCrossSectionFeatureNominalType::Direction_type& ExtrudedCrossSectionFeatureNominalType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void ExtrudedCrossSectionFeatureNominalType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void ExtrudedCrossSectionFeatureNominalType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }

    const ExtrudedCrossSectionFeatureNominalType::CrossSectionReferenceFeatureId_type& ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId () const
    {
      return this->CrossSectionReferenceFeatureId_.get ();
    }

    ExtrudedCrossSectionFeatureNominalType::CrossSectionReferenceFeatureId_type& ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId ()
    {
      return this->CrossSectionReferenceFeatureId_.get ();
    }

    void ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId (const CrossSectionReferenceFeatureId_type& x)
    {
      this->CrossSectionReferenceFeatureId_.set (x);
    }

    void ExtrudedCrossSectionFeatureNominalType::
    CrossSectionReferenceFeatureId (::std::auto_ptr< CrossSectionReferenceFeatureId_type > x)
    {
      this->CrossSectionReferenceFeatureId_.set (x);
    }


    // ExtrudedCrossSectionFeatureActualType
    // 

    const ExtrudedCrossSectionFeatureActualType::Direction_optional& ExtrudedCrossSectionFeatureActualType::
    Direction () const
    {
      return this->Direction_;
    }

    ExtrudedCrossSectionFeatureActualType::Direction_optional& ExtrudedCrossSectionFeatureActualType::
    Direction ()
    {
      return this->Direction_;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void ExtrudedCrossSectionFeatureActualType::
    Direction (const Direction_optional& x)
    {
      this->Direction_ = x;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }

    const ExtrudedCrossSectionFeatureActualType::Length_optional& ExtrudedCrossSectionFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    ExtrudedCrossSectionFeatureActualType::Length_optional& ExtrudedCrossSectionFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ExtrudedCrossSectionFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const ExtrudedCrossSectionFeatureActualType::Form_optional& ExtrudedCrossSectionFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ExtrudedCrossSectionFeatureActualType::Form_optional& ExtrudedCrossSectionFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ExtrudedCrossSectionFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ExtrudedCrossSectionFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // GenericFeatureItemType
    // 


    // GenericFeatureDefinitionType
    // 


    // GenericFeatureNominalType
    // 

    const GenericFeatureNominalType::Location_optional& GenericFeatureNominalType::
    Location () const
    {
      return this->Location_;
    }

    GenericFeatureNominalType::Location_optional& GenericFeatureNominalType::
    Location ()
    {
      return this->Location_;
    }

    void GenericFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void GenericFeatureNominalType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void GenericFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const GenericFeatureNominalType::ReferenceFeatureNominalId_sequence& GenericFeatureNominalType::
    ReferenceFeatureNominalId () const
    {
      return this->ReferenceFeatureNominalId_;
    }

    GenericFeatureNominalType::ReferenceFeatureNominalId_sequence& GenericFeatureNominalType::
    ReferenceFeatureNominalId ()
    {
      return this->ReferenceFeatureNominalId_;
    }

    void GenericFeatureNominalType::
    ReferenceFeatureNominalId (const ReferenceFeatureNominalId_sequence& s)
    {
      this->ReferenceFeatureNominalId_ = s;
    }


    // GenericFeatureActualType
    // 


    // LineConstructionMethodType
    // 

    const LineConstructionMethodType::BestFit_optional& LineConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    LineConstructionMethodType::BestFit_optional& LineConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void LineConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void LineConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void LineConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const LineConstructionMethodType::Recompensated_optional& LineConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    LineConstructionMethodType::Recompensated_optional& LineConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void LineConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void LineConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void LineConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const LineConstructionMethodType::Midline_optional& LineConstructionMethodType::
    Midline () const
    {
      return this->Midline_;
    }

    LineConstructionMethodType::Midline_optional& LineConstructionMethodType::
    Midline ()
    {
      return this->Midline_;
    }

    void LineConstructionMethodType::
    Midline (const Midline_type& x)
    {
      this->Midline_.set (x);
    }

    void LineConstructionMethodType::
    Midline (const Midline_optional& x)
    {
      this->Midline_ = x;
    }

    void LineConstructionMethodType::
    Midline (::std::auto_ptr< Midline_type > x)
    {
      this->Midline_.set (x);
    }

    const LineConstructionMethodType::Intersection_optional& LineConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    LineConstructionMethodType::Intersection_optional& LineConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void LineConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void LineConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void LineConstructionMethodType::
    Intersection (::std::auto_ptr< Intersection_type > x)
    {
      this->Intersection_.set (x);
    }

    const LineConstructionMethodType::Projection_optional& LineConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    LineConstructionMethodType::Projection_optional& LineConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void LineConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void LineConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void LineConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const LineConstructionMethodType::Perpendicular_optional& LineConstructionMethodType::
    Perpendicular () const
    {
      return this->Perpendicular_;
    }

    LineConstructionMethodType::Perpendicular_optional& LineConstructionMethodType::
    Perpendicular ()
    {
      return this->Perpendicular_;
    }

    void LineConstructionMethodType::
    Perpendicular (const Perpendicular_type& x)
    {
      this->Perpendicular_.set (x);
    }

    void LineConstructionMethodType::
    Perpendicular (const Perpendicular_optional& x)
    {
      this->Perpendicular_ = x;
    }

    void LineConstructionMethodType::
    Perpendicular (::std::auto_ptr< Perpendicular_type > x)
    {
      this->Perpendicular_.set (x);
    }

    const LineConstructionMethodType::Parallel_optional& LineConstructionMethodType::
    Parallel () const
    {
      return this->Parallel_;
    }

    LineConstructionMethodType::Parallel_optional& LineConstructionMethodType::
    Parallel ()
    {
      return this->Parallel_;
    }

    void LineConstructionMethodType::
    Parallel (const Parallel_type& x)
    {
      this->Parallel_.set (x);
    }

    void LineConstructionMethodType::
    Parallel (const Parallel_optional& x)
    {
      this->Parallel_ = x;
    }

    void LineConstructionMethodType::
    Parallel (::std::auto_ptr< Parallel_type > x)
    {
      this->Parallel_.set (x);
    }

    const LineConstructionMethodType::Copy_optional& LineConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    LineConstructionMethodType::Copy_optional& LineConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void LineConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void LineConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void LineConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const LineConstructionMethodType::Cast_optional& LineConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    LineConstructionMethodType::Cast_optional& LineConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void LineConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void LineConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void LineConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const LineConstructionMethodType::TangentThrough_optional& LineConstructionMethodType::
    TangentThrough () const
    {
      return this->TangentThrough_;
    }

    LineConstructionMethodType::TangentThrough_optional& LineConstructionMethodType::
    TangentThrough ()
    {
      return this->TangentThrough_;
    }

    void LineConstructionMethodType::
    TangentThrough (const TangentThrough_type& x)
    {
      this->TangentThrough_.set (x);
    }

    void LineConstructionMethodType::
    TangentThrough (const TangentThrough_optional& x)
    {
      this->TangentThrough_ = x;
    }

    void LineConstructionMethodType::
    TangentThrough (::std::auto_ptr< TangentThrough_type > x)
    {
      this->TangentThrough_.set (x);
    }

    const LineConstructionMethodType::Transform_optional& LineConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    LineConstructionMethodType::Transform_optional& LineConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void LineConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void LineConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void LineConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const LineConstructionMethodType::Extract_optional& LineConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    LineConstructionMethodType::Extract_optional& LineConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void LineConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void LineConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void LineConstructionMethodType::
    Extract (::std::auto_ptr< Extract_type > x)
    {
      this->Extract_.set (x);
    }

    const LineConstructionMethodType::FromScan_optional& LineConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    LineConstructionMethodType::FromScan_optional& LineConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void LineConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void LineConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void LineConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // LineBestFitType
    // 

    const LineBestFitType::BaseFeature_sequence& LineBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    LineBestFitType::BaseFeature_sequence& LineBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void LineBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // LineRecompType
    // 

    const LineRecompType::BaseFeaturePointList_type& LineRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    LineRecompType::BaseFeaturePointList_type& LineRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void LineRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void LineRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // LineMidlineType
    // 

    const LineMidlineType::BaseLine_sequence& LineMidlineType::
    BaseLine () const
    {
      return this->BaseLine_;
    }

    LineMidlineType::BaseLine_sequence& LineMidlineType::
    BaseLine ()
    {
      return this->BaseLine_;
    }

    void LineMidlineType::
    BaseLine (const BaseLine_sequence& s)
    {
      this->BaseLine_ = s;
    }


    // LineIntersectionType
    // 

    const LineIntersectionType::BasePlane_sequence& LineIntersectionType::
    BasePlane () const
    {
      return this->BasePlane_;
    }

    LineIntersectionType::BasePlane_sequence& LineIntersectionType::
    BasePlane ()
    {
      return this->BasePlane_;
    }

    void LineIntersectionType::
    BasePlane (const BasePlane_sequence& s)
    {
      this->BasePlane_ = s;
    }


    // LineProjectionType
    // 

    const LineProjectionType::ProjectionPlane_type& LineProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    LineProjectionType::ProjectionPlane_type& LineProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void LineProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void LineProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }

    const LineProjectionType::ProjectionLine_type& LineProjectionType::
    ProjectionLine () const
    {
      return this->ProjectionLine_.get ();
    }

    LineProjectionType::ProjectionLine_type& LineProjectionType::
    ProjectionLine ()
    {
      return this->ProjectionLine_.get ();
    }

    void LineProjectionType::
    ProjectionLine (const ProjectionLine_type& x)
    {
      this->ProjectionLine_.set (x);
    }

    void LineProjectionType::
    ProjectionLine (::std::auto_ptr< ProjectionLine_type > x)
    {
      this->ProjectionLine_.set (x);
    }


    // LinePerpendicularType
    // 

    const LinePerpendicularType::PerpendicularFeature_type& LinePerpendicularType::
    PerpendicularFeature () const
    {
      return this->PerpendicularFeature_.get ();
    }

    LinePerpendicularType::PerpendicularFeature_type& LinePerpendicularType::
    PerpendicularFeature ()
    {
      return this->PerpendicularFeature_.get ();
    }

    void LinePerpendicularType::
    PerpendicularFeature (const PerpendicularFeature_type& x)
    {
      this->PerpendicularFeature_.set (x);
    }

    void LinePerpendicularType::
    PerpendicularFeature (::std::auto_ptr< PerpendicularFeature_type > x)
    {
      this->PerpendicularFeature_.set (x);
    }

    const LinePerpendicularType::PointFeature_type& LinePerpendicularType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    LinePerpendicularType::PointFeature_type& LinePerpendicularType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void LinePerpendicularType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void LinePerpendicularType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // LineParallelType
    // 

    const LineParallelType::ParallelFeature_type& LineParallelType::
    ParallelFeature () const
    {
      return this->ParallelFeature_.get ();
    }

    LineParallelType::ParallelFeature_type& LineParallelType::
    ParallelFeature ()
    {
      return this->ParallelFeature_.get ();
    }

    void LineParallelType::
    ParallelFeature (const ParallelFeature_type& x)
    {
      this->ParallelFeature_.set (x);
    }

    void LineParallelType::
    ParallelFeature (::std::auto_ptr< ParallelFeature_type > x)
    {
      this->ParallelFeature_.set (x);
    }

    const LineParallelType::PointFeature_type& LineParallelType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    LineParallelType::PointFeature_type& LineParallelType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void LineParallelType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void LineParallelType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // LineCopyType
    // 

    const LineCopyType::BaseLine_type& LineCopyType::
    BaseLine () const
    {
      return this->BaseLine_.get ();
    }

    LineCopyType::BaseLine_type& LineCopyType::
    BaseLine ()
    {
      return this->BaseLine_.get ();
    }

    void LineCopyType::
    BaseLine (const BaseLine_type& x)
    {
      this->BaseLine_.set (x);
    }

    void LineCopyType::
    BaseLine (::std::auto_ptr< BaseLine_type > x)
    {
      this->BaseLine_.set (x);
    }


    // LineCastType
    // 

    const LineCastType::BaseFeature_type& LineCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    LineCastType::BaseFeature_type& LineCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void LineCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void LineCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // LineTangentThroughType
    // 

    const LineTangentThroughType::TangentFeature_type& LineTangentThroughType::
    TangentFeature () const
    {
      return this->TangentFeature_.get ();
    }

    LineTangentThroughType::TangentFeature_type& LineTangentThroughType::
    TangentFeature ()
    {
      return this->TangentFeature_.get ();
    }

    void LineTangentThroughType::
    TangentFeature (const TangentFeature_type& x)
    {
      this->TangentFeature_.set (x);
    }

    void LineTangentThroughType::
    TangentFeature (::std::auto_ptr< TangentFeature_type > x)
    {
      this->TangentFeature_.set (x);
    }

    const LineTangentThroughType::PointFeature_type& LineTangentThroughType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    LineTangentThroughType::PointFeature_type& LineTangentThroughType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void LineTangentThroughType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void LineTangentThroughType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // LineTransformType
    // 

    const LineTransformType::BaseLine_type& LineTransformType::
    BaseLine () const
    {
      return this->BaseLine_.get ();
    }

    LineTransformType::BaseLine_type& LineTransformType::
    BaseLine ()
    {
      return this->BaseLine_.get ();
    }

    void LineTransformType::
    BaseLine (const BaseLine_type& x)
    {
      this->BaseLine_.set (x);
    }

    void LineTransformType::
    BaseLine (::std::auto_ptr< BaseLine_type > x)
    {
      this->BaseLine_.set (x);
    }

    const LineTransformType::Transformation_type& LineTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    LineTransformType::Transformation_type& LineTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void LineTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void LineTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // LineFromScanType
    // 

    const LineFromScanType::SurfaceFeature_type& LineFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    LineFromScanType::SurfaceFeature_type& LineFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void LineFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void LineFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const LineFromScanType::SearchRadius_type& LineFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    LineFromScanType::SearchRadius_type& LineFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void LineFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void LineFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // LineExtractType
    // 

    const LineExtractType::CurveFeature_type& LineExtractType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    LineExtractType::CurveFeature_type& LineExtractType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void LineExtractType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void LineExtractType::
    CurveFeature (::std::auto_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (x);
    }


    // LineCheckedType
    // 

    const LineCheckedType::Measured_optional& LineCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    LineCheckedType::Measured_optional& LineCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void LineCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void LineCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void LineCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const LineCheckedType::Constructed_optional& LineCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    LineCheckedType::Constructed_optional& LineCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void LineCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void LineCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void LineCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // LineCheckedFeatureType
    // 

    const LineCheckedFeatureType::CheckDetails_optional& LineCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    LineCheckedFeatureType::CheckDetails_optional& LineCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void LineCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void LineCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void LineCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // LineActualDeterminationType
    // 

    const LineActualDeterminationType::Checked_optional& LineActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    LineActualDeterminationType::Checked_optional& LineActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void LineActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void LineActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void LineActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const LineActualDeterminationType::Set_optional& LineActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    LineActualDeterminationType::Set_optional& LineActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void LineActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void LineActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void LineActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // LineFeatureItemType
    // 

    const LineFeatureItemType::DeterminationMode_type& LineFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    LineFeatureItemType::DeterminationMode_type& LineFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void LineFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void LineFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const LineFeatureItemType::SubstituteFeatureAlgorithm_optional& LineFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    LineFeatureItemType::SubstituteFeatureAlgorithm_optional& LineFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void LineFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void LineFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void LineFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // LineFeatureDefinitionType
    // 


    // LineFeatureNominalType
    // 

    const LineFeatureNominalType::Location_type& LineFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    LineFeatureNominalType::Location_type& LineFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void LineFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void LineFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const LineFeatureNominalType::Direction_type& LineFeatureNominalType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    LineFeatureNominalType::Direction_type& LineFeatureNominalType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void LineFeatureNominalType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void LineFeatureNominalType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }

    const LineFeatureNominalType::Length_optional& LineFeatureNominalType::
    Length () const
    {
      return this->Length_;
    }

    LineFeatureNominalType::Length_optional& LineFeatureNominalType::
    Length ()
    {
      return this->Length_;
    }

    void LineFeatureNominalType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void LineFeatureNominalType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void LineFeatureNominalType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const LineFeatureNominalType::Normal_optional& LineFeatureNominalType::
    Normal () const
    {
      return this->Normal_;
    }

    LineFeatureNominalType::Normal_optional& LineFeatureNominalType::
    Normal ()
    {
      return this->Normal_;
    }

    void LineFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void LineFeatureNominalType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void LineFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // LineFeatureActualType
    // 

    const LineFeatureActualType::Location_optional& LineFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    LineFeatureActualType::Location_optional& LineFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void LineFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void LineFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void LineFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const LineFeatureActualType::Direction_optional& LineFeatureActualType::
    Direction () const
    {
      return this->Direction_;
    }

    LineFeatureActualType::Direction_optional& LineFeatureActualType::
    Direction ()
    {
      return this->Direction_;
    }

    void LineFeatureActualType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void LineFeatureActualType::
    Direction (const Direction_optional& x)
    {
      this->Direction_ = x;
    }

    void LineFeatureActualType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }

    const LineFeatureActualType::Length_optional& LineFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    LineFeatureActualType::Length_optional& LineFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void LineFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void LineFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void LineFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const LineFeatureActualType::Normal_optional& LineFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    LineFeatureActualType::Normal_optional& LineFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void LineFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void LineFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void LineFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const LineFeatureActualType::Form_optional& LineFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    LineFeatureActualType::Form_optional& LineFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void LineFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void LineFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void LineFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // OppositeLinesConstructionMethodType
    // 

    const OppositeLinesConstructionMethodType::BestFit_optional& OppositeLinesConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    OppositeLinesConstructionMethodType::BestFit_optional& OppositeLinesConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void OppositeLinesConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void OppositeLinesConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const OppositeLinesConstructionMethodType::Recompensated_optional& OppositeLinesConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    OppositeLinesConstructionMethodType::Recompensated_optional& OppositeLinesConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void OppositeLinesConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void OppositeLinesConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const OppositeLinesConstructionMethodType::Projection_optional& OppositeLinesConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    OppositeLinesConstructionMethodType::Projection_optional& OppositeLinesConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void OppositeLinesConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void OppositeLinesConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const OppositeLinesConstructionMethodType::Copy_optional& OppositeLinesConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    OppositeLinesConstructionMethodType::Copy_optional& OppositeLinesConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void OppositeLinesConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void OppositeLinesConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const OppositeLinesConstructionMethodType::Cast_optional& OppositeLinesConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    OppositeLinesConstructionMethodType::Cast_optional& OppositeLinesConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void OppositeLinesConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void OppositeLinesConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const OppositeLinesConstructionMethodType::Transform_optional& OppositeLinesConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    OppositeLinesConstructionMethodType::Transform_optional& OppositeLinesConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void OppositeLinesConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void OppositeLinesConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const OppositeLinesConstructionMethodType::FromScan_optional& OppositeLinesConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    OppositeLinesConstructionMethodType::FromScan_optional& OppositeLinesConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void OppositeLinesConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void OppositeLinesConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void OppositeLinesConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // OppositeLinesBestFitType
    // 

    const OppositeLinesBestFitType::BaseFeature_sequence& OppositeLinesBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    OppositeLinesBestFitType::BaseFeature_sequence& OppositeLinesBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void OppositeLinesBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // OppositeLinesRecompType
    // 

    const OppositeLinesRecompType::BaseFeaturePointList_type& OppositeLinesRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    OppositeLinesRecompType::BaseFeaturePointList_type& OppositeLinesRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void OppositeLinesRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void OppositeLinesRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // OppositeLinesProjectionType
    // 

    const OppositeLinesProjectionType::ProjectionPlane_type& OppositeLinesProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    OppositeLinesProjectionType::ProjectionPlane_type& OppositeLinesProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void OppositeLinesProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void OppositeLinesProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }

    const OppositeLinesProjectionType::ProjectionOppositeLines_type& OppositeLinesProjectionType::
    ProjectionOppositeLines () const
    {
      return this->ProjectionOppositeLines_.get ();
    }

    OppositeLinesProjectionType::ProjectionOppositeLines_type& OppositeLinesProjectionType::
    ProjectionOppositeLines ()
    {
      return this->ProjectionOppositeLines_.get ();
    }

    void OppositeLinesProjectionType::
    ProjectionOppositeLines (const ProjectionOppositeLines_type& x)
    {
      this->ProjectionOppositeLines_.set (x);
    }

    void OppositeLinesProjectionType::
    ProjectionOppositeLines (::std::auto_ptr< ProjectionOppositeLines_type > x)
    {
      this->ProjectionOppositeLines_.set (x);
    }


    // OppositeLinesCopyType
    // 

    const OppositeLinesCopyType::BaseOppositeLines_type& OppositeLinesCopyType::
    BaseOppositeLines () const
    {
      return this->BaseOppositeLines_.get ();
    }

    OppositeLinesCopyType::BaseOppositeLines_type& OppositeLinesCopyType::
    BaseOppositeLines ()
    {
      return this->BaseOppositeLines_.get ();
    }

    void OppositeLinesCopyType::
    BaseOppositeLines (const BaseOppositeLines_type& x)
    {
      this->BaseOppositeLines_.set (x);
    }

    void OppositeLinesCopyType::
    BaseOppositeLines (::std::auto_ptr< BaseOppositeLines_type > x)
    {
      this->BaseOppositeLines_.set (x);
    }


    // OppositeLinesCastType
    // 

    const OppositeLinesCastType::BaseFeature_type& OppositeLinesCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    OppositeLinesCastType::BaseFeature_type& OppositeLinesCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void OppositeLinesCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void OppositeLinesCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // OppositeLinesTransformType
    // 

    const OppositeLinesTransformType::BaseOppositeLines_type& OppositeLinesTransformType::
    BaseOppositeLines () const
    {
      return this->BaseOppositeLines_.get ();
    }

    OppositeLinesTransformType::BaseOppositeLines_type& OppositeLinesTransformType::
    BaseOppositeLines ()
    {
      return this->BaseOppositeLines_.get ();
    }

    void OppositeLinesTransformType::
    BaseOppositeLines (const BaseOppositeLines_type& x)
    {
      this->BaseOppositeLines_.set (x);
    }

    void OppositeLinesTransformType::
    BaseOppositeLines (::std::auto_ptr< BaseOppositeLines_type > x)
    {
      this->BaseOppositeLines_.set (x);
    }

    const OppositeLinesTransformType::Transformation_type& OppositeLinesTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    OppositeLinesTransformType::Transformation_type& OppositeLinesTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void OppositeLinesTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void OppositeLinesTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // OppositeLinesFromScanType
    // 

    const OppositeLinesFromScanType::SurfaceFeature_type& OppositeLinesFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    OppositeLinesFromScanType::SurfaceFeature_type& OppositeLinesFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void OppositeLinesFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void OppositeLinesFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const OppositeLinesFromScanType::SearchRadius_type& OppositeLinesFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    OppositeLinesFromScanType::SearchRadius_type& OppositeLinesFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void OppositeLinesFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void OppositeLinesFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const OppositeLinesFromScanType::Depth_type& OppositeLinesFromScanType::
    Depth () const
    {
      return this->Depth_.get ();
    }

    OppositeLinesFromScanType::Depth_type& OppositeLinesFromScanType::
    Depth ()
    {
      return this->Depth_.get ();
    }

    void OppositeLinesFromScanType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositeLinesFromScanType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }


    // OppositeLinesCheckedType
    // 

    const OppositeLinesCheckedType::Measured_optional& OppositeLinesCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    OppositeLinesCheckedType::Measured_optional& OppositeLinesCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void OppositeLinesCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void OppositeLinesCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void OppositeLinesCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const OppositeLinesCheckedType::Constructed_optional& OppositeLinesCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositeLinesCheckedType::Constructed_optional& OppositeLinesCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositeLinesCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositeLinesCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositeLinesCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // OppositeLinesCheckedFeatureType
    // 

    const OppositeLinesCheckedFeatureType::CheckDetails_optional& OppositeLinesCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    OppositeLinesCheckedFeatureType::CheckDetails_optional& OppositeLinesCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void OppositeLinesCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void OppositeLinesCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void OppositeLinesCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // OppositeLinesActualDeterminationType
    // 

    const OppositeLinesActualDeterminationType::Checked_optional& OppositeLinesActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    OppositeLinesActualDeterminationType::Checked_optional& OppositeLinesActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void OppositeLinesActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void OppositeLinesActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void OppositeLinesActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const OppositeLinesActualDeterminationType::Set_optional& OppositeLinesActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    OppositeLinesActualDeterminationType::Set_optional& OppositeLinesActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void OppositeLinesActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void OppositeLinesActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void OppositeLinesActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // OppositeLinesFeatureItemType
    // 

    const OppositeLinesFeatureItemType::DeterminationMode_type& OppositeLinesFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    OppositeLinesFeatureItemType::DeterminationMode_type& OppositeLinesFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void OppositeLinesFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void OppositeLinesFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const OppositeLinesFeatureItemType::SubstituteFeatureAlgorithm_optional& OppositeLinesFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    OppositeLinesFeatureItemType::SubstituteFeatureAlgorithm_optional& OppositeLinesFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void OppositeLinesFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void OppositeLinesFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void OppositeLinesFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // OppositeLinesFeatureDefinitionType
    // 

    const OppositeLinesFeatureDefinitionType::InternalExternal_type& OppositeLinesFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    OppositeLinesFeatureDefinitionType::InternalExternal_type& OppositeLinesFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void OppositeLinesFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::Width_type& OppositeLinesFeatureDefinitionType::
    Width () const
    {
      return this->Width_.get ();
    }

    OppositeLinesFeatureDefinitionType::Width_type& OppositeLinesFeatureDefinitionType::
    Width ()
    {
      return this->Width_.get ();
    }

    void OppositeLinesFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::Length_optional& OppositeLinesFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    OppositeLinesFeatureDefinitionType::Length_optional& OppositeLinesFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeLinesFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeLinesFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::EndType_type& OppositeLinesFeatureDefinitionType::
    EndType () const
    {
      return this->EndType_.get ();
    }

    OppositeLinesFeatureDefinitionType::EndType_type& OppositeLinesFeatureDefinitionType::
    EndType ()
    {
      return this->EndType_.get ();
    }

    void OppositeLinesFeatureDefinitionType::
    EndType (const EndType_type& x)
    {
      this->EndType_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    EndType (::std::auto_ptr< EndType_type > x)
    {
      this->EndType_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::TaperAngle_optional& OppositeLinesFeatureDefinitionType::
    TaperAngle () const
    {
      return this->TaperAngle_;
    }

    OppositeLinesFeatureDefinitionType::TaperAngle_optional& OppositeLinesFeatureDefinitionType::
    TaperAngle ()
    {
      return this->TaperAngle_;
    }

    void OppositeLinesFeatureDefinitionType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    TaperAngle (const TaperAngle_optional& x)
    {
      this->TaperAngle_ = x;
    }

    void OppositeLinesFeatureDefinitionType::
    TaperAngle (::std::auto_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::SingleOpenEnd_optional& OppositeLinesFeatureDefinitionType::
    SingleOpenEnd () const
    {
      return this->SingleOpenEnd_;
    }

    OppositeLinesFeatureDefinitionType::SingleOpenEnd_optional& OppositeLinesFeatureDefinitionType::
    SingleOpenEnd ()
    {
      return this->SingleOpenEnd_;
    }

    void OppositeLinesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_type& x)
    {
      this->SingleOpenEnd_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_optional& x)
    {
      this->SingleOpenEnd_ = x;
    }

    const OppositeLinesFeatureDefinitionType::EndRadius1_optional& OppositeLinesFeatureDefinitionType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeLinesFeatureDefinitionType::EndRadius1_optional& OppositeLinesFeatureDefinitionType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius1 (::std::auto_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (x);
    }

    const OppositeLinesFeatureDefinitionType::EndRadius2_optional& OppositeLinesFeatureDefinitionType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeLinesFeatureDefinitionType::EndRadius2_optional& OppositeLinesFeatureDefinitionType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeLinesFeatureDefinitionType::
    EndRadius2 (::std::auto_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (x);
    }


    // OppositeLinesFeatureNominalType
    // 

    const OppositeLinesFeatureNominalType::CenterLine_type& OppositeLinesFeatureNominalType::
    CenterLine () const
    {
      return this->CenterLine_.get ();
    }

    OppositeLinesFeatureNominalType::CenterLine_type& OppositeLinesFeatureNominalType::
    CenterLine ()
    {
      return this->CenterLine_.get ();
    }

    void OppositeLinesFeatureNominalType::
    CenterLine (const CenterLine_type& x)
    {
      this->CenterLine_.set (x);
    }

    void OppositeLinesFeatureNominalType::
    CenterLine (::std::auto_ptr< CenterLine_type > x)
    {
      this->CenterLine_.set (x);
    }

    const OppositeLinesFeatureNominalType::Normal_type& OppositeLinesFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    OppositeLinesFeatureNominalType::Normal_type& OppositeLinesFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void OppositeLinesFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void OppositeLinesFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // OppositeLinesFeatureActualType
    // 

    const OppositeLinesFeatureActualType::CenterLine_optional& OppositeLinesFeatureActualType::
    CenterLine () const
    {
      return this->CenterLine_;
    }

    OppositeLinesFeatureActualType::CenterLine_optional& OppositeLinesFeatureActualType::
    CenterLine ()
    {
      return this->CenterLine_;
    }

    void OppositeLinesFeatureActualType::
    CenterLine (const CenterLine_type& x)
    {
      this->CenterLine_.set (x);
    }

    void OppositeLinesFeatureActualType::
    CenterLine (const CenterLine_optional& x)
    {
      this->CenterLine_ = x;
    }

    void OppositeLinesFeatureActualType::
    CenterLine (::std::auto_ptr< CenterLine_type > x)
    {
      this->CenterLine_.set (x);
    }

    const OppositeLinesFeatureActualType::Normal_optional& OppositeLinesFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    OppositeLinesFeatureActualType::Normal_optional& OppositeLinesFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void OppositeLinesFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void OppositeLinesFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void OppositeLinesFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const OppositeLinesFeatureActualType::Width_optional& OppositeLinesFeatureActualType::
    Width () const
    {
      return this->Width_;
    }

    OppositeLinesFeatureActualType::Width_optional& OppositeLinesFeatureActualType::
    Width ()
    {
      return this->Width_;
    }

    void OppositeLinesFeatureActualType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositeLinesFeatureActualType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void OppositeLinesFeatureActualType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const OppositeLinesFeatureActualType::WidthMin_optional& OppositeLinesFeatureActualType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    OppositeLinesFeatureActualType::WidthMin_optional& OppositeLinesFeatureActualType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void OppositeLinesFeatureActualType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void OppositeLinesFeatureActualType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void OppositeLinesFeatureActualType::
    WidthMin (::std::auto_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (x);
    }

    const OppositeLinesFeatureActualType::WidthMax_optional& OppositeLinesFeatureActualType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    OppositeLinesFeatureActualType::WidthMax_optional& OppositeLinesFeatureActualType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void OppositeLinesFeatureActualType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void OppositeLinesFeatureActualType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void OppositeLinesFeatureActualType::
    WidthMax (::std::auto_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (x);
    }

    const OppositeLinesFeatureActualType::Length_optional& OppositeLinesFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    OppositeLinesFeatureActualType::Length_optional& OppositeLinesFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void OppositeLinesFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositeLinesFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositeLinesFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const OppositeLinesFeatureActualType::LengthMin_optional& OppositeLinesFeatureActualType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    OppositeLinesFeatureActualType::LengthMin_optional& OppositeLinesFeatureActualType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void OppositeLinesFeatureActualType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void OppositeLinesFeatureActualType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void OppositeLinesFeatureActualType::
    LengthMin (::std::auto_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (x);
    }

    const OppositeLinesFeatureActualType::LengthMax_optional& OppositeLinesFeatureActualType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    OppositeLinesFeatureActualType::LengthMax_optional& OppositeLinesFeatureActualType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void OppositeLinesFeatureActualType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void OppositeLinesFeatureActualType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void OppositeLinesFeatureActualType::
    LengthMax (::std::auto_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (x);
    }

    const OppositeLinesFeatureActualType::TaperAngle_optional& OppositeLinesFeatureActualType::
    TaperAngle () const
    {
      return this->TaperAngle_;
    }

    OppositeLinesFeatureActualType::TaperAngle_optional& OppositeLinesFeatureActualType::
    TaperAngle ()
    {
      return this->TaperAngle_;
    }

    void OppositeLinesFeatureActualType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositeLinesFeatureActualType::
    TaperAngle (const TaperAngle_optional& x)
    {
      this->TaperAngle_ = x;
    }

    void OppositeLinesFeatureActualType::
    TaperAngle (::std::auto_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (x);
    }

    const OppositeLinesFeatureActualType::EndRadius1_optional& OppositeLinesFeatureActualType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositeLinesFeatureActualType::EndRadius1_optional& OppositeLinesFeatureActualType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositeLinesFeatureActualType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositeLinesFeatureActualType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositeLinesFeatureActualType::
    EndRadius1 (::std::auto_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (x);
    }

    const OppositeLinesFeatureActualType::EndRadius2_optional& OppositeLinesFeatureActualType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositeLinesFeatureActualType::EndRadius2_optional& OppositeLinesFeatureActualType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositeLinesFeatureActualType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositeLinesFeatureActualType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositeLinesFeatureActualType::
    EndRadius2 (::std::auto_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (x);
    }

    const OppositeLinesFeatureActualType::Form_optional& OppositeLinesFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    OppositeLinesFeatureActualType::Form_optional& OppositeLinesFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void OppositeLinesFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void OppositeLinesFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void OppositeLinesFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // OppositePlanesConstructionMethodType
    // 

    const OppositePlanesConstructionMethodType::BestFit_optional& OppositePlanesConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    OppositePlanesConstructionMethodType::BestFit_optional& OppositePlanesConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void OppositePlanesConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void OppositePlanesConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const OppositePlanesConstructionMethodType::Recompensated_optional& OppositePlanesConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    OppositePlanesConstructionMethodType::Recompensated_optional& OppositePlanesConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void OppositePlanesConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void OppositePlanesConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const OppositePlanesConstructionMethodType::Copy_optional& OppositePlanesConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    OppositePlanesConstructionMethodType::Copy_optional& OppositePlanesConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void OppositePlanesConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void OppositePlanesConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const OppositePlanesConstructionMethodType::Cast_optional& OppositePlanesConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    OppositePlanesConstructionMethodType::Cast_optional& OppositePlanesConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void OppositePlanesConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void OppositePlanesConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const OppositePlanesConstructionMethodType::Transform_optional& OppositePlanesConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    OppositePlanesConstructionMethodType::Transform_optional& OppositePlanesConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void OppositePlanesConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void OppositePlanesConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const OppositePlanesConstructionMethodType::FromScan_optional& OppositePlanesConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    OppositePlanesConstructionMethodType::FromScan_optional& OppositePlanesConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void OppositePlanesConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void OppositePlanesConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void OppositePlanesConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // OppositePlanesBestFitType
    // 

    const OppositePlanesBestFitType::BaseFeature_sequence& OppositePlanesBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    OppositePlanesBestFitType::BaseFeature_sequence& OppositePlanesBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void OppositePlanesBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // OppositePlanesRecompType
    // 

    const OppositePlanesRecompType::BaseFeaturePointList_type& OppositePlanesRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    OppositePlanesRecompType::BaseFeaturePointList_type& OppositePlanesRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void OppositePlanesRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void OppositePlanesRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // OppositePlanesCopyType
    // 

    const OppositePlanesCopyType::BaseOppositePlanes_type& OppositePlanesCopyType::
    BaseOppositePlanes () const
    {
      return this->BaseOppositePlanes_.get ();
    }

    OppositePlanesCopyType::BaseOppositePlanes_type& OppositePlanesCopyType::
    BaseOppositePlanes ()
    {
      return this->BaseOppositePlanes_.get ();
    }

    void OppositePlanesCopyType::
    BaseOppositePlanes (const BaseOppositePlanes_type& x)
    {
      this->BaseOppositePlanes_.set (x);
    }

    void OppositePlanesCopyType::
    BaseOppositePlanes (::std::auto_ptr< BaseOppositePlanes_type > x)
    {
      this->BaseOppositePlanes_.set (x);
    }


    // OppositePlanesCastType
    // 

    const OppositePlanesCastType::BaseFeature_type& OppositePlanesCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    OppositePlanesCastType::BaseFeature_type& OppositePlanesCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void OppositePlanesCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void OppositePlanesCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // OppositePlanesTransformType
    // 

    const OppositePlanesTransformType::BaseOppositePlanes_type& OppositePlanesTransformType::
    BaseOppositePlanes () const
    {
      return this->BaseOppositePlanes_.get ();
    }

    OppositePlanesTransformType::BaseOppositePlanes_type& OppositePlanesTransformType::
    BaseOppositePlanes ()
    {
      return this->BaseOppositePlanes_.get ();
    }

    void OppositePlanesTransformType::
    BaseOppositePlanes (const BaseOppositePlanes_type& x)
    {
      this->BaseOppositePlanes_.set (x);
    }

    void OppositePlanesTransformType::
    BaseOppositePlanes (::std::auto_ptr< BaseOppositePlanes_type > x)
    {
      this->BaseOppositePlanes_.set (x);
    }

    const OppositePlanesTransformType::Transformation_type& OppositePlanesTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    OppositePlanesTransformType::Transformation_type& OppositePlanesTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void OppositePlanesTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void OppositePlanesTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // OppositePlanesFromScanType
    // 

    const OppositePlanesFromScanType::SurfaceFeature_type& OppositePlanesFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    OppositePlanesFromScanType::SurfaceFeature_type& OppositePlanesFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void OppositePlanesFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void OppositePlanesFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const OppositePlanesFromScanType::SearchRadius_type& OppositePlanesFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    OppositePlanesFromScanType::SearchRadius_type& OppositePlanesFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void OppositePlanesFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void OppositePlanesFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // OppositePlanesCheckedType
    // 

    const OppositePlanesCheckedType::Measured_optional& OppositePlanesCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    OppositePlanesCheckedType::Measured_optional& OppositePlanesCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void OppositePlanesCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void OppositePlanesCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void OppositePlanesCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const OppositePlanesCheckedType::Constructed_optional& OppositePlanesCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    OppositePlanesCheckedType::Constructed_optional& OppositePlanesCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void OppositePlanesCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void OppositePlanesCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void OppositePlanesCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // OppositePlanesCheckedFeatureType
    // 

    const OppositePlanesCheckedFeatureType::CheckDetails_optional& OppositePlanesCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    OppositePlanesCheckedFeatureType::CheckDetails_optional& OppositePlanesCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void OppositePlanesCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void OppositePlanesCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void OppositePlanesCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // OppositePlanesActualDeterminationType
    // 

    const OppositePlanesActualDeterminationType::Checked_optional& OppositePlanesActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    OppositePlanesActualDeterminationType::Checked_optional& OppositePlanesActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void OppositePlanesActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void OppositePlanesActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void OppositePlanesActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const OppositePlanesActualDeterminationType::Set_optional& OppositePlanesActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    OppositePlanesActualDeterminationType::Set_optional& OppositePlanesActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void OppositePlanesActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void OppositePlanesActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void OppositePlanesActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // OppositePlanesFeatureItemType
    // 

    const OppositePlanesFeatureItemType::DeterminationMode_type& OppositePlanesFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    OppositePlanesFeatureItemType::DeterminationMode_type& OppositePlanesFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void OppositePlanesFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void OppositePlanesFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const OppositePlanesFeatureItemType::SubstituteFeatureAlgorithm_optional& OppositePlanesFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    OppositePlanesFeatureItemType::SubstituteFeatureAlgorithm_optional& OppositePlanesFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void OppositePlanesFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void OppositePlanesFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void OppositePlanesFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // OppositePlanesFeatureDefinitionType
    // 

    const OppositePlanesFeatureDefinitionType::InternalExternal_type& OppositePlanesFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    OppositePlanesFeatureDefinitionType::InternalExternal_type& OppositePlanesFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void OppositePlanesFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::Width_type& OppositePlanesFeatureDefinitionType::
    Width () const
    {
      return this->Width_.get ();
    }

    OppositePlanesFeatureDefinitionType::Width_type& OppositePlanesFeatureDefinitionType::
    Width ()
    {
      return this->Width_.get ();
    }

    void OppositePlanesFeatureDefinitionType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::Length_optional& OppositePlanesFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    OppositePlanesFeatureDefinitionType::Length_optional& OppositePlanesFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void OppositePlanesFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::EndType_type& OppositePlanesFeatureDefinitionType::
    EndType () const
    {
      return this->EndType_.get ();
    }

    OppositePlanesFeatureDefinitionType::EndType_type& OppositePlanesFeatureDefinitionType::
    EndType ()
    {
      return this->EndType_.get ();
    }

    void OppositePlanesFeatureDefinitionType::
    EndType (const EndType_type& x)
    {
      this->EndType_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    EndType (::std::auto_ptr< EndType_type > x)
    {
      this->EndType_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::Depth_optional& OppositePlanesFeatureDefinitionType::
    Depth () const
    {
      return this->Depth_;
    }

    OppositePlanesFeatureDefinitionType::Depth_optional& OppositePlanesFeatureDefinitionType::
    Depth ()
    {
      return this->Depth_;
    }

    void OppositePlanesFeatureDefinitionType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::Bottom_optional& OppositePlanesFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    OppositePlanesFeatureDefinitionType::Bottom_optional& OppositePlanesFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void OppositePlanesFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    Bottom (::std::auto_ptr< Bottom_type > x)
    {
      this->Bottom_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::SingleOpenEnd_optional& OppositePlanesFeatureDefinitionType::
    SingleOpenEnd () const
    {
      return this->SingleOpenEnd_;
    }

    OppositePlanesFeatureDefinitionType::SingleOpenEnd_optional& OppositePlanesFeatureDefinitionType::
    SingleOpenEnd ()
    {
      return this->SingleOpenEnd_;
    }

    void OppositePlanesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_type& x)
    {
      this->SingleOpenEnd_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    SingleOpenEnd (const SingleOpenEnd_optional& x)
    {
      this->SingleOpenEnd_ = x;
    }

    const OppositePlanesFeatureDefinitionType::EndRadius1_optional& OppositePlanesFeatureDefinitionType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositePlanesFeatureDefinitionType::EndRadius1_optional& OppositePlanesFeatureDefinitionType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius1 (::std::auto_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::EndRadius2_optional& OppositePlanesFeatureDefinitionType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositePlanesFeatureDefinitionType::EndRadius2_optional& OppositePlanesFeatureDefinitionType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    EndRadius2 (::std::auto_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::TaperAngle_optional& OppositePlanesFeatureDefinitionType::
    TaperAngle () const
    {
      return this->TaperAngle_;
    }

    OppositePlanesFeatureDefinitionType::TaperAngle_optional& OppositePlanesFeatureDefinitionType::
    TaperAngle ()
    {
      return this->TaperAngle_;
    }

    void OppositePlanesFeatureDefinitionType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    TaperAngle (const TaperAngle_optional& x)
    {
      this->TaperAngle_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    TaperAngle (::std::auto_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (x);
    }

    const OppositePlanesFeatureDefinitionType::DraftAngle_optional& OppositePlanesFeatureDefinitionType::
    DraftAngle () const
    {
      return this->DraftAngle_;
    }

    OppositePlanesFeatureDefinitionType::DraftAngle_optional& OppositePlanesFeatureDefinitionType::
    DraftAngle ()
    {
      return this->DraftAngle_;
    }

    void OppositePlanesFeatureDefinitionType::
    DraftAngle (const DraftAngle_type& x)
    {
      this->DraftAngle_.set (x);
    }

    void OppositePlanesFeatureDefinitionType::
    DraftAngle (const DraftAngle_optional& x)
    {
      this->DraftAngle_ = x;
    }

    void OppositePlanesFeatureDefinitionType::
    DraftAngle (::std::auto_ptr< DraftAngle_type > x)
    {
      this->DraftAngle_.set (x);
    }


    // OppositePlanesFeatureNominalType
    // 

    const OppositePlanesFeatureNominalType::CenterPlane_type& OppositePlanesFeatureNominalType::
    CenterPlane () const
    {
      return this->CenterPlane_.get ();
    }

    OppositePlanesFeatureNominalType::CenterPlane_type& OppositePlanesFeatureNominalType::
    CenterPlane ()
    {
      return this->CenterPlane_.get ();
    }

    void OppositePlanesFeatureNominalType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void OppositePlanesFeatureNominalType::
    CenterPlane (::std::auto_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (x);
    }

    const OppositePlanesFeatureNominalType::LengthVector_optional& OppositePlanesFeatureNominalType::
    LengthVector () const
    {
      return this->LengthVector_;
    }

    OppositePlanesFeatureNominalType::LengthVector_optional& OppositePlanesFeatureNominalType::
    LengthVector ()
    {
      return this->LengthVector_;
    }

    void OppositePlanesFeatureNominalType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void OppositePlanesFeatureNominalType::
    LengthVector (const LengthVector_optional& x)
    {
      this->LengthVector_ = x;
    }

    void OppositePlanesFeatureNominalType::
    LengthVector (::std::auto_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (x);
    }

    const OppositePlanesFeatureNominalType::DepthVector_optional& OppositePlanesFeatureNominalType::
    DepthVector () const
    {
      return this->DepthVector_;
    }

    OppositePlanesFeatureNominalType::DepthVector_optional& OppositePlanesFeatureNominalType::
    DepthVector ()
    {
      return this->DepthVector_;
    }

    void OppositePlanesFeatureNominalType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void OppositePlanesFeatureNominalType::
    DepthVector (const DepthVector_optional& x)
    {
      this->DepthVector_ = x;
    }

    void OppositePlanesFeatureNominalType::
    DepthVector (::std::auto_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (x);
    }

    const OppositePlanesFeatureNominalType::DraftVector_optional& OppositePlanesFeatureNominalType::
    DraftVector () const
    {
      return this->DraftVector_;
    }

    OppositePlanesFeatureNominalType::DraftVector_optional& OppositePlanesFeatureNominalType::
    DraftVector ()
    {
      return this->DraftVector_;
    }

    void OppositePlanesFeatureNominalType::
    DraftVector (const DraftVector_type& x)
    {
      this->DraftVector_.set (x);
    }

    void OppositePlanesFeatureNominalType::
    DraftVector (const DraftVector_optional& x)
    {
      this->DraftVector_ = x;
    }

    void OppositePlanesFeatureNominalType::
    DraftVector (::std::auto_ptr< DraftVector_type > x)
    {
      this->DraftVector_.set (x);
    }


    // OppositePlanesFeatureActualType
    // 

    const OppositePlanesFeatureActualType::CenterPlane_optional& OppositePlanesFeatureActualType::
    CenterPlane () const
    {
      return this->CenterPlane_;
    }

    OppositePlanesFeatureActualType::CenterPlane_optional& OppositePlanesFeatureActualType::
    CenterPlane ()
    {
      return this->CenterPlane_;
    }

    void OppositePlanesFeatureActualType::
    CenterPlane (const CenterPlane_type& x)
    {
      this->CenterPlane_.set (x);
    }

    void OppositePlanesFeatureActualType::
    CenterPlane (const CenterPlane_optional& x)
    {
      this->CenterPlane_ = x;
    }

    void OppositePlanesFeatureActualType::
    CenterPlane (::std::auto_ptr< CenterPlane_type > x)
    {
      this->CenterPlane_.set (x);
    }

    const OppositePlanesFeatureActualType::LengthVector_optional& OppositePlanesFeatureActualType::
    LengthVector () const
    {
      return this->LengthVector_;
    }

    OppositePlanesFeatureActualType::LengthVector_optional& OppositePlanesFeatureActualType::
    LengthVector ()
    {
      return this->LengthVector_;
    }

    void OppositePlanesFeatureActualType::
    LengthVector (const LengthVector_type& x)
    {
      this->LengthVector_.set (x);
    }

    void OppositePlanesFeatureActualType::
    LengthVector (const LengthVector_optional& x)
    {
      this->LengthVector_ = x;
    }

    void OppositePlanesFeatureActualType::
    LengthVector (::std::auto_ptr< LengthVector_type > x)
    {
      this->LengthVector_.set (x);
    }

    const OppositePlanesFeatureActualType::DepthVector_optional& OppositePlanesFeatureActualType::
    DepthVector () const
    {
      return this->DepthVector_;
    }

    OppositePlanesFeatureActualType::DepthVector_optional& OppositePlanesFeatureActualType::
    DepthVector ()
    {
      return this->DepthVector_;
    }

    void OppositePlanesFeatureActualType::
    DepthVector (const DepthVector_type& x)
    {
      this->DepthVector_.set (x);
    }

    void OppositePlanesFeatureActualType::
    DepthVector (const DepthVector_optional& x)
    {
      this->DepthVector_ = x;
    }

    void OppositePlanesFeatureActualType::
    DepthVector (::std::auto_ptr< DepthVector_type > x)
    {
      this->DepthVector_.set (x);
    }

    const OppositePlanesFeatureActualType::Width_optional& OppositePlanesFeatureActualType::
    Width () const
    {
      return this->Width_;
    }

    OppositePlanesFeatureActualType::Width_optional& OppositePlanesFeatureActualType::
    Width ()
    {
      return this->Width_;
    }

    void OppositePlanesFeatureActualType::
    Width (const Width_type& x)
    {
      this->Width_.set (x);
    }

    void OppositePlanesFeatureActualType::
    Width (const Width_optional& x)
    {
      this->Width_ = x;
    }

    void OppositePlanesFeatureActualType::
    Width (::std::auto_ptr< Width_type > x)
    {
      this->Width_.set (x);
    }

    const OppositePlanesFeatureActualType::WidthMin_optional& OppositePlanesFeatureActualType::
    WidthMin () const
    {
      return this->WidthMin_;
    }

    OppositePlanesFeatureActualType::WidthMin_optional& OppositePlanesFeatureActualType::
    WidthMin ()
    {
      return this->WidthMin_;
    }

    void OppositePlanesFeatureActualType::
    WidthMin (const WidthMin_type& x)
    {
      this->WidthMin_.set (x);
    }

    void OppositePlanesFeatureActualType::
    WidthMin (const WidthMin_optional& x)
    {
      this->WidthMin_ = x;
    }

    void OppositePlanesFeatureActualType::
    WidthMin (::std::auto_ptr< WidthMin_type > x)
    {
      this->WidthMin_.set (x);
    }

    const OppositePlanesFeatureActualType::WidthMax_optional& OppositePlanesFeatureActualType::
    WidthMax () const
    {
      return this->WidthMax_;
    }

    OppositePlanesFeatureActualType::WidthMax_optional& OppositePlanesFeatureActualType::
    WidthMax ()
    {
      return this->WidthMax_;
    }

    void OppositePlanesFeatureActualType::
    WidthMax (const WidthMax_type& x)
    {
      this->WidthMax_.set (x);
    }

    void OppositePlanesFeatureActualType::
    WidthMax (const WidthMax_optional& x)
    {
      this->WidthMax_ = x;
    }

    void OppositePlanesFeatureActualType::
    WidthMax (::std::auto_ptr< WidthMax_type > x)
    {
      this->WidthMax_.set (x);
    }

    const OppositePlanesFeatureActualType::Length_optional& OppositePlanesFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    OppositePlanesFeatureActualType::Length_optional& OppositePlanesFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void OppositePlanesFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void OppositePlanesFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void OppositePlanesFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const OppositePlanesFeatureActualType::LengthMin_optional& OppositePlanesFeatureActualType::
    LengthMin () const
    {
      return this->LengthMin_;
    }

    OppositePlanesFeatureActualType::LengthMin_optional& OppositePlanesFeatureActualType::
    LengthMin ()
    {
      return this->LengthMin_;
    }

    void OppositePlanesFeatureActualType::
    LengthMin (const LengthMin_type& x)
    {
      this->LengthMin_.set (x);
    }

    void OppositePlanesFeatureActualType::
    LengthMin (const LengthMin_optional& x)
    {
      this->LengthMin_ = x;
    }

    void OppositePlanesFeatureActualType::
    LengthMin (::std::auto_ptr< LengthMin_type > x)
    {
      this->LengthMin_.set (x);
    }

    const OppositePlanesFeatureActualType::LengthMax_optional& OppositePlanesFeatureActualType::
    LengthMax () const
    {
      return this->LengthMax_;
    }

    OppositePlanesFeatureActualType::LengthMax_optional& OppositePlanesFeatureActualType::
    LengthMax ()
    {
      return this->LengthMax_;
    }

    void OppositePlanesFeatureActualType::
    LengthMax (const LengthMax_type& x)
    {
      this->LengthMax_.set (x);
    }

    void OppositePlanesFeatureActualType::
    LengthMax (const LengthMax_optional& x)
    {
      this->LengthMax_ = x;
    }

    void OppositePlanesFeatureActualType::
    LengthMax (::std::auto_ptr< LengthMax_type > x)
    {
      this->LengthMax_.set (x);
    }

    const OppositePlanesFeatureActualType::Depth_optional& OppositePlanesFeatureActualType::
    Depth () const
    {
      return this->Depth_;
    }

    OppositePlanesFeatureActualType::Depth_optional& OppositePlanesFeatureActualType::
    Depth ()
    {
      return this->Depth_;
    }

    void OppositePlanesFeatureActualType::
    Depth (const Depth_type& x)
    {
      this->Depth_.set (x);
    }

    void OppositePlanesFeatureActualType::
    Depth (const Depth_optional& x)
    {
      this->Depth_ = x;
    }

    void OppositePlanesFeatureActualType::
    Depth (::std::auto_ptr< Depth_type > x)
    {
      this->Depth_.set (x);
    }

    const OppositePlanesFeatureActualType::TaperAngle_optional& OppositePlanesFeatureActualType::
    TaperAngle () const
    {
      return this->TaperAngle_;
    }

    OppositePlanesFeatureActualType::TaperAngle_optional& OppositePlanesFeatureActualType::
    TaperAngle ()
    {
      return this->TaperAngle_;
    }

    void OppositePlanesFeatureActualType::
    TaperAngle (const TaperAngle_type& x)
    {
      this->TaperAngle_.set (x);
    }

    void OppositePlanesFeatureActualType::
    TaperAngle (const TaperAngle_optional& x)
    {
      this->TaperAngle_ = x;
    }

    void OppositePlanesFeatureActualType::
    TaperAngle (::std::auto_ptr< TaperAngle_type > x)
    {
      this->TaperAngle_.set (x);
    }

    const OppositePlanesFeatureActualType::DraftAngle_optional& OppositePlanesFeatureActualType::
    DraftAngle () const
    {
      return this->DraftAngle_;
    }

    OppositePlanesFeatureActualType::DraftAngle_optional& OppositePlanesFeatureActualType::
    DraftAngle ()
    {
      return this->DraftAngle_;
    }

    void OppositePlanesFeatureActualType::
    DraftAngle (const DraftAngle_type& x)
    {
      this->DraftAngle_.set (x);
    }

    void OppositePlanesFeatureActualType::
    DraftAngle (const DraftAngle_optional& x)
    {
      this->DraftAngle_ = x;
    }

    void OppositePlanesFeatureActualType::
    DraftAngle (::std::auto_ptr< DraftAngle_type > x)
    {
      this->DraftAngle_.set (x);
    }

    const OppositePlanesFeatureActualType::EndRadius1_optional& OppositePlanesFeatureActualType::
    EndRadius1 () const
    {
      return this->EndRadius1_;
    }

    OppositePlanesFeatureActualType::EndRadius1_optional& OppositePlanesFeatureActualType::
    EndRadius1 ()
    {
      return this->EndRadius1_;
    }

    void OppositePlanesFeatureActualType::
    EndRadius1 (const EndRadius1_type& x)
    {
      this->EndRadius1_.set (x);
    }

    void OppositePlanesFeatureActualType::
    EndRadius1 (const EndRadius1_optional& x)
    {
      this->EndRadius1_ = x;
    }

    void OppositePlanesFeatureActualType::
    EndRadius1 (::std::auto_ptr< EndRadius1_type > x)
    {
      this->EndRadius1_.set (x);
    }

    const OppositePlanesFeatureActualType::EndRadius2_optional& OppositePlanesFeatureActualType::
    EndRadius2 () const
    {
      return this->EndRadius2_;
    }

    OppositePlanesFeatureActualType::EndRadius2_optional& OppositePlanesFeatureActualType::
    EndRadius2 ()
    {
      return this->EndRadius2_;
    }

    void OppositePlanesFeatureActualType::
    EndRadius2 (const EndRadius2_type& x)
    {
      this->EndRadius2_.set (x);
    }

    void OppositePlanesFeatureActualType::
    EndRadius2 (const EndRadius2_optional& x)
    {
      this->EndRadius2_ = x;
    }

    void OppositePlanesFeatureActualType::
    EndRadius2 (::std::auto_ptr< EndRadius2_type > x)
    {
      this->EndRadius2_.set (x);
    }

    const OppositePlanesFeatureActualType::Form_optional& OppositePlanesFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    OppositePlanesFeatureActualType::Form_optional& OppositePlanesFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void OppositePlanesFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void OppositePlanesFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void OppositePlanesFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // PlaneConstructionMethodType
    // 

    const PlaneConstructionMethodType::BestFit_optional& PlaneConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    PlaneConstructionMethodType::BestFit_optional& PlaneConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void PlaneConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void PlaneConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void PlaneConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const PlaneConstructionMethodType::Recompensated_optional& PlaneConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    PlaneConstructionMethodType::Recompensated_optional& PlaneConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void PlaneConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void PlaneConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void PlaneConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const PlaneConstructionMethodType::Midplane_optional& PlaneConstructionMethodType::
    Midplane () const
    {
      return this->Midplane_;
    }

    PlaneConstructionMethodType::Midplane_optional& PlaneConstructionMethodType::
    Midplane ()
    {
      return this->Midplane_;
    }

    void PlaneConstructionMethodType::
    Midplane (const Midplane_type& x)
    {
      this->Midplane_.set (x);
    }

    void PlaneConstructionMethodType::
    Midplane (const Midplane_optional& x)
    {
      this->Midplane_ = x;
    }

    void PlaneConstructionMethodType::
    Midplane (::std::auto_ptr< Midplane_type > x)
    {
      this->Midplane_.set (x);
    }

    const PlaneConstructionMethodType::Offset_optional& PlaneConstructionMethodType::
    Offset () const
    {
      return this->Offset_;
    }

    PlaneConstructionMethodType::Offset_optional& PlaneConstructionMethodType::
    Offset ()
    {
      return this->Offset_;
    }

    void PlaneConstructionMethodType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void PlaneConstructionMethodType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    void PlaneConstructionMethodType::
    Offset (::std::auto_ptr< Offset_type > x)
    {
      this->Offset_.set (x);
    }

    const PlaneConstructionMethodType::Perpendicular_optional& PlaneConstructionMethodType::
    Perpendicular () const
    {
      return this->Perpendicular_;
    }

    PlaneConstructionMethodType::Perpendicular_optional& PlaneConstructionMethodType::
    Perpendicular ()
    {
      return this->Perpendicular_;
    }

    void PlaneConstructionMethodType::
    Perpendicular (const Perpendicular_type& x)
    {
      this->Perpendicular_.set (x);
    }

    void PlaneConstructionMethodType::
    Perpendicular (const Perpendicular_optional& x)
    {
      this->Perpendicular_ = x;
    }

    void PlaneConstructionMethodType::
    Perpendicular (::std::auto_ptr< Perpendicular_type > x)
    {
      this->Perpendicular_.set (x);
    }

    const PlaneConstructionMethodType::Parallel_optional& PlaneConstructionMethodType::
    Parallel () const
    {
      return this->Parallel_;
    }

    PlaneConstructionMethodType::Parallel_optional& PlaneConstructionMethodType::
    Parallel ()
    {
      return this->Parallel_;
    }

    void PlaneConstructionMethodType::
    Parallel (const Parallel_type& x)
    {
      this->Parallel_.set (x);
    }

    void PlaneConstructionMethodType::
    Parallel (const Parallel_optional& x)
    {
      this->Parallel_ = x;
    }

    void PlaneConstructionMethodType::
    Parallel (::std::auto_ptr< Parallel_type > x)
    {
      this->Parallel_.set (x);
    }

    const PlaneConstructionMethodType::Copy_optional& PlaneConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PlaneConstructionMethodType::Copy_optional& PlaneConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PlaneConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PlaneConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PlaneConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const PlaneConstructionMethodType::Cast_optional& PlaneConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    PlaneConstructionMethodType::Cast_optional& PlaneConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void PlaneConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void PlaneConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void PlaneConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const PlaneConstructionMethodType::TangentThrough_optional& PlaneConstructionMethodType::
    TangentThrough () const
    {
      return this->TangentThrough_;
    }

    PlaneConstructionMethodType::TangentThrough_optional& PlaneConstructionMethodType::
    TangentThrough ()
    {
      return this->TangentThrough_;
    }

    void PlaneConstructionMethodType::
    TangentThrough (const TangentThrough_type& x)
    {
      this->TangentThrough_.set (x);
    }

    void PlaneConstructionMethodType::
    TangentThrough (const TangentThrough_optional& x)
    {
      this->TangentThrough_ = x;
    }

    void PlaneConstructionMethodType::
    TangentThrough (::std::auto_ptr< TangentThrough_type > x)
    {
      this->TangentThrough_.set (x);
    }

    const PlaneConstructionMethodType::Transform_optional& PlaneConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PlaneConstructionMethodType::Transform_optional& PlaneConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PlaneConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PlaneConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PlaneConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const PlaneConstructionMethodType::Extract_optional& PlaneConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    PlaneConstructionMethodType::Extract_optional& PlaneConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void PlaneConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void PlaneConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void PlaneConstructionMethodType::
    Extract (::std::auto_ptr< Extract_type > x)
    {
      this->Extract_.set (x);
    }


    // PlaneBestFitType
    // 

    const PlaneBestFitType::BaseFeature_sequence& PlaneBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PlaneBestFitType::BaseFeature_sequence& PlaneBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PlaneBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PlaneRecompType
    // 

    const PlaneRecompType::BaseFeaturePointList_type& PlaneRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    PlaneRecompType::BaseFeaturePointList_type& PlaneRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void PlaneRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void PlaneRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // PlaneMidplaneType
    // 

    const PlaneMidplaneType::BasePlane_sequence& PlaneMidplaneType::
    BasePlane () const
    {
      return this->BasePlane_;
    }

    PlaneMidplaneType::BasePlane_sequence& PlaneMidplaneType::
    BasePlane ()
    {
      return this->BasePlane_;
    }

    void PlaneMidplaneType::
    BasePlane (const BasePlane_sequence& s)
    {
      this->BasePlane_ = s;
    }


    // PlaneOffsetType
    // 

    const PlaneOffsetType::BasePlane_type& PlaneOffsetType::
    BasePlane () const
    {
      return this->BasePlane_.get ();
    }

    PlaneOffsetType::BasePlane_type& PlaneOffsetType::
    BasePlane ()
    {
      return this->BasePlane_.get ();
    }

    void PlaneOffsetType::
    BasePlane (const BasePlane_type& x)
    {
      this->BasePlane_.set (x);
    }

    void PlaneOffsetType::
    BasePlane (::std::auto_ptr< BasePlane_type > x)
    {
      this->BasePlane_.set (x);
    }

    const PlaneOffsetType::Offset_type& PlaneOffsetType::
    Offset () const
    {
      return this->Offset_.get ();
    }

    PlaneOffsetType::Offset_type& PlaneOffsetType::
    Offset ()
    {
      return this->Offset_.get ();
    }

    void PlaneOffsetType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void PlaneOffsetType::
    Offset (::std::auto_ptr< Offset_type > x)
    {
      this->Offset_.set (x);
    }


    // PlanePerpendicularType
    // 

    const PlanePerpendicularType::PerpendicularFeature_type& PlanePerpendicularType::
    PerpendicularFeature () const
    {
      return this->PerpendicularFeature_.get ();
    }

    PlanePerpendicularType::PerpendicularFeature_type& PlanePerpendicularType::
    PerpendicularFeature ()
    {
      return this->PerpendicularFeature_.get ();
    }

    void PlanePerpendicularType::
    PerpendicularFeature (const PerpendicularFeature_type& x)
    {
      this->PerpendicularFeature_.set (x);
    }

    void PlanePerpendicularType::
    PerpendicularFeature (::std::auto_ptr< PerpendicularFeature_type > x)
    {
      this->PerpendicularFeature_.set (x);
    }

    const PlanePerpendicularType::PointFeature_type& PlanePerpendicularType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    PlanePerpendicularType::PointFeature_type& PlanePerpendicularType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void PlanePerpendicularType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void PlanePerpendicularType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // PlaneParallelType
    // 

    const PlaneParallelType::ParallelFeature_type& PlaneParallelType::
    ParallelFeature () const
    {
      return this->ParallelFeature_.get ();
    }

    PlaneParallelType::ParallelFeature_type& PlaneParallelType::
    ParallelFeature ()
    {
      return this->ParallelFeature_.get ();
    }

    void PlaneParallelType::
    ParallelFeature (const ParallelFeature_type& x)
    {
      this->ParallelFeature_.set (x);
    }

    void PlaneParallelType::
    ParallelFeature (::std::auto_ptr< ParallelFeature_type > x)
    {
      this->ParallelFeature_.set (x);
    }

    const PlaneParallelType::PointFeature_type& PlaneParallelType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    PlaneParallelType::PointFeature_type& PlaneParallelType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void PlaneParallelType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void PlaneParallelType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // PlaneCopyType
    // 

    const PlaneCopyType::BasePlane_type& PlaneCopyType::
    BasePlane () const
    {
      return this->BasePlane_.get ();
    }

    PlaneCopyType::BasePlane_type& PlaneCopyType::
    BasePlane ()
    {
      return this->BasePlane_.get ();
    }

    void PlaneCopyType::
    BasePlane (const BasePlane_type& x)
    {
      this->BasePlane_.set (x);
    }

    void PlaneCopyType::
    BasePlane (::std::auto_ptr< BasePlane_type > x)
    {
      this->BasePlane_.set (x);
    }


    // PlaneCastType
    // 

    const PlaneCastType::BaseFeature_type& PlaneCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PlaneCastType::BaseFeature_type& PlaneCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PlaneCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PlaneCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // PlaneTangentThroughType
    // 

    const PlaneTangentThroughType::TangentFeature_type& PlaneTangentThroughType::
    TangentFeature () const
    {
      return this->TangentFeature_.get ();
    }

    PlaneTangentThroughType::TangentFeature_type& PlaneTangentThroughType::
    TangentFeature ()
    {
      return this->TangentFeature_.get ();
    }

    void PlaneTangentThroughType::
    TangentFeature (const TangentFeature_type& x)
    {
      this->TangentFeature_.set (x);
    }

    void PlaneTangentThroughType::
    TangentFeature (::std::auto_ptr< TangentFeature_type > x)
    {
      this->TangentFeature_.set (x);
    }

    const PlaneTangentThroughType::PointFeature_type& PlaneTangentThroughType::
    PointFeature () const
    {
      return this->PointFeature_.get ();
    }

    PlaneTangentThroughType::PointFeature_type& PlaneTangentThroughType::
    PointFeature ()
    {
      return this->PointFeature_.get ();
    }

    void PlaneTangentThroughType::
    PointFeature (const PointFeature_type& x)
    {
      this->PointFeature_.set (x);
    }

    void PlaneTangentThroughType::
    PointFeature (::std::auto_ptr< PointFeature_type > x)
    {
      this->PointFeature_.set (x);
    }


    // PlaneTransformType
    // 

    const PlaneTransformType::BasePlane_type& PlaneTransformType::
    BasePlane () const
    {
      return this->BasePlane_.get ();
    }

    PlaneTransformType::BasePlane_type& PlaneTransformType::
    BasePlane ()
    {
      return this->BasePlane_.get ();
    }

    void PlaneTransformType::
    BasePlane (const BasePlane_type& x)
    {
      this->BasePlane_.set (x);
    }

    void PlaneTransformType::
    BasePlane (::std::auto_ptr< BasePlane_type > x)
    {
      this->BasePlane_.set (x);
    }

    const PlaneTransformType::Transformation_type& PlaneTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PlaneTransformType::Transformation_type& PlaneTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PlaneTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PlaneTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // PlaneExtractType
    // 

    const PlaneExtractType::SurfaceFeature_type& PlaneExtractType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PlaneExtractType::SurfaceFeature_type& PlaneExtractType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PlaneExtractType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PlaneExtractType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }


    // PlaneCheckedType
    // 

    const PlaneCheckedType::Measured_optional& PlaneCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PlaneCheckedType::Measured_optional& PlaneCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PlaneCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PlaneCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PlaneCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const PlaneCheckedType::Constructed_optional& PlaneCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PlaneCheckedType::Constructed_optional& PlaneCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PlaneCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PlaneCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PlaneCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // PlaneCheckedFeatureType
    // 

    const PlaneCheckedFeatureType::CheckDetails_optional& PlaneCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PlaneCheckedFeatureType::CheckDetails_optional& PlaneCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PlaneCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PlaneCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PlaneCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // PlaneActualDeterminationType
    // 

    const PlaneActualDeterminationType::Checked_optional& PlaneActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PlaneActualDeterminationType::Checked_optional& PlaneActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PlaneActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PlaneActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PlaneActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const PlaneActualDeterminationType::Set_optional& PlaneActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PlaneActualDeterminationType::Set_optional& PlaneActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PlaneActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PlaneActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PlaneActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // PlaneFeatureItemType
    // 

    const PlaneFeatureItemType::DeterminationMode_type& PlaneFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PlaneFeatureItemType::DeterminationMode_type& PlaneFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PlaneFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PlaneFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const PlaneFeatureItemType::SubstituteFeatureAlgorithm_optional& PlaneFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    PlaneFeatureItemType::SubstituteFeatureAlgorithm_optional& PlaneFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void PlaneFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void PlaneFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void PlaneFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // PlaneFeatureDefinitionType
    // 


    // PlaneFeatureNominalType
    // 

    const PlaneFeatureNominalType::Location_type& PlaneFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    PlaneFeatureNominalType::Location_type& PlaneFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void PlaneFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PlaneFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const PlaneFeatureNominalType::Normal_type& PlaneFeatureNominalType::
    Normal () const
    {
      return this->Normal_.get ();
    }

    PlaneFeatureNominalType::Normal_type& PlaneFeatureNominalType::
    Normal ()
    {
      return this->Normal_.get ();
    }

    void PlaneFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PlaneFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const PlaneFeatureNominalType::PolyLine_optional& PlaneFeatureNominalType::
    PolyLine () const
    {
      return this->PolyLine_;
    }

    PlaneFeatureNominalType::PolyLine_optional& PlaneFeatureNominalType::
    PolyLine ()
    {
      return this->PolyLine_;
    }

    void PlaneFeatureNominalType::
    PolyLine (const PolyLine_type& x)
    {
      this->PolyLine_.set (x);
    }

    void PlaneFeatureNominalType::
    PolyLine (const PolyLine_optional& x)
    {
      this->PolyLine_ = x;
    }

    void PlaneFeatureNominalType::
    PolyLine (::std::auto_ptr< PolyLine_type > x)
    {
      this->PolyLine_.set (x);
    }


    // PlaneFeatureActualType
    // 

    const PlaneFeatureActualType::Location_optional& PlaneFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    PlaneFeatureActualType::Location_optional& PlaneFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void PlaneFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PlaneFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void PlaneFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const PlaneFeatureActualType::Normal_optional& PlaneFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    PlaneFeatureActualType::Normal_optional& PlaneFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void PlaneFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PlaneFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void PlaneFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }

    const PlaneFeatureActualType::PolyLine_optional& PlaneFeatureActualType::
    PolyLine () const
    {
      return this->PolyLine_;
    }

    PlaneFeatureActualType::PolyLine_optional& PlaneFeatureActualType::
    PolyLine ()
    {
      return this->PolyLine_;
    }

    void PlaneFeatureActualType::
    PolyLine (const PolyLine_type& x)
    {
      this->PolyLine_.set (x);
    }

    void PlaneFeatureActualType::
    PolyLine (const PolyLine_optional& x)
    {
      this->PolyLine_ = x;
    }

    void PlaneFeatureActualType::
    PolyLine (::std::auto_ptr< PolyLine_type > x)
    {
      this->PolyLine_.set (x);
    }

    const PlaneFeatureActualType::Form_optional& PlaneFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    PlaneFeatureActualType::Form_optional& PlaneFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void PlaneFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void PlaneFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void PlaneFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // PointDefinedCurveConstructionMethodType
    // 

    const PointDefinedCurveConstructionMethodType::BestFit_optional& PointDefinedCurveConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    PointDefinedCurveConstructionMethodType::BestFit_optional& PointDefinedCurveConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void PointDefinedCurveConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const PointDefinedCurveConstructionMethodType::Recompensated_optional& PointDefinedCurveConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    PointDefinedCurveConstructionMethodType::Recompensated_optional& PointDefinedCurveConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void PointDefinedCurveConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const PointDefinedCurveConstructionMethodType::Copy_optional& PointDefinedCurveConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PointDefinedCurveConstructionMethodType::Copy_optional& PointDefinedCurveConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PointDefinedCurveConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const PointDefinedCurveConstructionMethodType::Transform_optional& PointDefinedCurveConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PointDefinedCurveConstructionMethodType::Transform_optional& PointDefinedCurveConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PointDefinedCurveConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const PointDefinedCurveConstructionMethodType::FromScan_optional& PointDefinedCurveConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    PointDefinedCurveConstructionMethodType::FromScan_optional& PointDefinedCurveConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void PointDefinedCurveConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }

    const PointDefinedCurveConstructionMethodType::Extract_optional& PointDefinedCurveConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    PointDefinedCurveConstructionMethodType::Extract_optional& PointDefinedCurveConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void PointDefinedCurveConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void PointDefinedCurveConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void PointDefinedCurveConstructionMethodType::
    Extract (::std::auto_ptr< Extract_type > x)
    {
      this->Extract_.set (x);
    }


    // PointDefinedCurveBestFitType
    // 

    const PointDefinedCurveBestFitType::BaseFeature_sequence& PointDefinedCurveBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointDefinedCurveBestFitType::BaseFeature_sequence& PointDefinedCurveBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointDefinedCurveBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PointDefinedCurveRecompType
    // 

    const PointDefinedCurveRecompType::BaseFeaturePointList_type& PointDefinedCurveRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    PointDefinedCurveRecompType::BaseFeaturePointList_type& PointDefinedCurveRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void PointDefinedCurveRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void PointDefinedCurveRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // PointDefinedCurveCopyType
    // 

    const PointDefinedCurveCopyType::BasePointDefinedCurve_type& PointDefinedCurveCopyType::
    BasePointDefinedCurve () const
    {
      return this->BasePointDefinedCurve_.get ();
    }

    PointDefinedCurveCopyType::BasePointDefinedCurve_type& PointDefinedCurveCopyType::
    BasePointDefinedCurve ()
    {
      return this->BasePointDefinedCurve_.get ();
    }

    void PointDefinedCurveCopyType::
    BasePointDefinedCurve (const BasePointDefinedCurve_type& x)
    {
      this->BasePointDefinedCurve_.set (x);
    }

    void PointDefinedCurveCopyType::
    BasePointDefinedCurve (::std::auto_ptr< BasePointDefinedCurve_type > x)
    {
      this->BasePointDefinedCurve_.set (x);
    }


    // PointDefinedCurveTransformType
    // 

    const PointDefinedCurveTransformType::BasePointDefinedCurve_type& PointDefinedCurveTransformType::
    BasePointDefinedCurve () const
    {
      return this->BasePointDefinedCurve_.get ();
    }

    PointDefinedCurveTransformType::BasePointDefinedCurve_type& PointDefinedCurveTransformType::
    BasePointDefinedCurve ()
    {
      return this->BasePointDefinedCurve_.get ();
    }

    void PointDefinedCurveTransformType::
    BasePointDefinedCurve (const BasePointDefinedCurve_type& x)
    {
      this->BasePointDefinedCurve_.set (x);
    }

    void PointDefinedCurveTransformType::
    BasePointDefinedCurve (::std::auto_ptr< BasePointDefinedCurve_type > x)
    {
      this->BasePointDefinedCurve_.set (x);
    }

    const PointDefinedCurveTransformType::Transformation_type& PointDefinedCurveTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PointDefinedCurveTransformType::Transformation_type& PointDefinedCurveTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PointDefinedCurveTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PointDefinedCurveTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // PointDefinedCurveFromScanType
    // 

    const PointDefinedCurveFromScanType::SurfaceFeature_type& PointDefinedCurveFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointDefinedCurveFromScanType::SurfaceFeature_type& PointDefinedCurveFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointDefinedCurveFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointDefinedCurveFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const PointDefinedCurveFromScanType::SearchRadius_type& PointDefinedCurveFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    PointDefinedCurveFromScanType::SearchRadius_type& PointDefinedCurveFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void PointDefinedCurveFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void PointDefinedCurveFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // PointDefinedCurveExtractType
    // 

    const PointDefinedCurveExtractType::CurveFeature_type& PointDefinedCurveExtractType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    PointDefinedCurveExtractType::CurveFeature_type& PointDefinedCurveExtractType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void PointDefinedCurveExtractType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void PointDefinedCurveExtractType::
    CurveFeature (::std::auto_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (x);
    }


    // PointDefinedCurveCheckedType
    // 

    const PointDefinedCurveCheckedType::Measured_optional& PointDefinedCurveCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PointDefinedCurveCheckedType::Measured_optional& PointDefinedCurveCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PointDefinedCurveCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PointDefinedCurveCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PointDefinedCurveCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const PointDefinedCurveCheckedType::Constructed_optional& PointDefinedCurveCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointDefinedCurveCheckedType::Constructed_optional& PointDefinedCurveCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointDefinedCurveCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointDefinedCurveCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointDefinedCurveCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // PointDefinedCurveCheckedFeatureType
    // 

    const PointDefinedCurveCheckedFeatureType::CheckDetails_optional& PointDefinedCurveCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PointDefinedCurveCheckedFeatureType::CheckDetails_optional& PointDefinedCurveCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PointDefinedCurveCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PointDefinedCurveCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PointDefinedCurveCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // PointDefinedCurveActualDeterminationType
    // 

    const PointDefinedCurveActualDeterminationType::Checked_optional& PointDefinedCurveActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PointDefinedCurveActualDeterminationType::Checked_optional& PointDefinedCurveActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PointDefinedCurveActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PointDefinedCurveActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PointDefinedCurveActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const PointDefinedCurveActualDeterminationType::Set_optional& PointDefinedCurveActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PointDefinedCurveActualDeterminationType::Set_optional& PointDefinedCurveActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PointDefinedCurveActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PointDefinedCurveActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PointDefinedCurveActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // PointDefinedCurveFeatureItemType
    // 

    const PointDefinedCurveFeatureItemType::DeterminationMode_type& PointDefinedCurveFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PointDefinedCurveFeatureItemType::DeterminationMode_type& PointDefinedCurveFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PointDefinedCurveFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PointDefinedCurveFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const PointDefinedCurveFeatureItemType::SubstituteFeatureAlgorithm_optional& PointDefinedCurveFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    PointDefinedCurveFeatureItemType::SubstituteFeatureAlgorithm_optional& PointDefinedCurveFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void PointDefinedCurveFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void PointDefinedCurveFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void PointDefinedCurveFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // PointDefinedCurveFeatureDefinitionType
    // 


    // PointDefinedCurveFeatureNominalType
    // 

    const PointDefinedCurveFeatureNominalType::DefiningPoints_type& PointDefinedCurveFeatureNominalType::
    DefiningPoints () const
    {
      return this->DefiningPoints_.get ();
    }

    PointDefinedCurveFeatureNominalType::DefiningPoints_type& PointDefinedCurveFeatureNominalType::
    DefiningPoints ()
    {
      return this->DefiningPoints_.get ();
    }

    void PointDefinedCurveFeatureNominalType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedCurveFeatureNominalType::
    DefiningPoints (::std::auto_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (x);
    }

    const PointDefinedCurveFeatureNominalType::Plane_optional& PointDefinedCurveFeatureNominalType::
    Plane () const
    {
      return this->Plane_;
    }

    PointDefinedCurveFeatureNominalType::Plane_optional& PointDefinedCurveFeatureNominalType::
    Plane ()
    {
      return this->Plane_;
    }

    void PointDefinedCurveFeatureNominalType::
    Plane (const Plane_type& x)
    {
      this->Plane_.set (x);
    }

    void PointDefinedCurveFeatureNominalType::
    Plane (const Plane_optional& x)
    {
      this->Plane_ = x;
    }

    void PointDefinedCurveFeatureNominalType::
    Plane (::std::auto_ptr< Plane_type > x)
    {
      this->Plane_.set (x);
    }


    // TargetPointsActualType
    // 

    const TargetPointsActualType::TargetPoint_sequence& TargetPointsActualType::
    TargetPoint () const
    {
      return this->TargetPoint_;
    }

    TargetPointsActualType::TargetPoint_sequence& TargetPointsActualType::
    TargetPoint ()
    {
      return this->TargetPoint_;
    }

    void TargetPointsActualType::
    TargetPoint (const TargetPoint_sequence& s)
    {
      this->TargetPoint_ = s;
    }

    const TargetPointsActualType::linearUnit_optional& TargetPointsActualType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    TargetPointsActualType::linearUnit_optional& TargetPointsActualType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void TargetPointsActualType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void TargetPointsActualType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void TargetPointsActualType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const TargetPointsActualType::decimalPlaces_optional& TargetPointsActualType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    TargetPointsActualType::decimalPlaces_optional& TargetPointsActualType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void TargetPointsActualType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void TargetPointsActualType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const TargetPointsActualType::significantFigures_optional& TargetPointsActualType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    TargetPointsActualType::significantFigures_optional& TargetPointsActualType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void TargetPointsActualType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void TargetPointsActualType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const TargetPointsActualType::validity_optional& TargetPointsActualType::
    validity () const
    {
      return this->validity_;
    }

    TargetPointsActualType::validity_optional& TargetPointsActualType::
    validity ()
    {
      return this->validity_;
    }

    void TargetPointsActualType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void TargetPointsActualType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void TargetPointsActualType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const TargetPointsActualType::xDecimalPlaces_optional& TargetPointsActualType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    TargetPointsActualType::xDecimalPlaces_optional& TargetPointsActualType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void TargetPointsActualType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void TargetPointsActualType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const TargetPointsActualType::xSignificantFigures_optional& TargetPointsActualType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    TargetPointsActualType::xSignificantFigures_optional& TargetPointsActualType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void TargetPointsActualType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void TargetPointsActualType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const TargetPointsActualType::xValidity_optional& TargetPointsActualType::
    xValidity () const
    {
      return this->xValidity_;
    }

    TargetPointsActualType::xValidity_optional& TargetPointsActualType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void TargetPointsActualType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void TargetPointsActualType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void TargetPointsActualType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const TargetPointsActualType::yDecimalPlaces_optional& TargetPointsActualType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    TargetPointsActualType::yDecimalPlaces_optional& TargetPointsActualType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void TargetPointsActualType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void TargetPointsActualType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const TargetPointsActualType::ySignificantFigures_optional& TargetPointsActualType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    TargetPointsActualType::ySignificantFigures_optional& TargetPointsActualType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void TargetPointsActualType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void TargetPointsActualType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const TargetPointsActualType::yValidity_optional& TargetPointsActualType::
    yValidity () const
    {
      return this->yValidity_;
    }

    TargetPointsActualType::yValidity_optional& TargetPointsActualType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void TargetPointsActualType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void TargetPointsActualType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void TargetPointsActualType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const TargetPointsActualType::zDecimalPlaces_optional& TargetPointsActualType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    TargetPointsActualType::zDecimalPlaces_optional& TargetPointsActualType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void TargetPointsActualType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void TargetPointsActualType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const TargetPointsActualType::zSignificantFigures_optional& TargetPointsActualType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    TargetPointsActualType::zSignificantFigures_optional& TargetPointsActualType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void TargetPointsActualType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void TargetPointsActualType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const TargetPointsActualType::zValidity_optional& TargetPointsActualType::
    zValidity () const
    {
      return this->zValidity_;
    }

    TargetPointsActualType::zValidity_optional& TargetPointsActualType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void TargetPointsActualType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void TargetPointsActualType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void TargetPointsActualType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }

    const TargetPointsActualType::combinedUncertainty_optional& TargetPointsActualType::
    combinedUncertainty () const
    {
      return this->combinedUncertainty_;
    }

    TargetPointsActualType::combinedUncertainty_optional& TargetPointsActualType::
    combinedUncertainty ()
    {
      return this->combinedUncertainty_;
    }

    void TargetPointsActualType::
    combinedUncertainty (const combinedUncertainty_type& x)
    {
      this->combinedUncertainty_.set (x);
    }

    void TargetPointsActualType::
    combinedUncertainty (const combinedUncertainty_optional& x)
    {
      this->combinedUncertainty_ = x;
    }

    const TargetPointsActualType::meanError_optional& TargetPointsActualType::
    meanError () const
    {
      return this->meanError_;
    }

    TargetPointsActualType::meanError_optional& TargetPointsActualType::
    meanError ()
    {
      return this->meanError_;
    }

    void TargetPointsActualType::
    meanError (const meanError_type& x)
    {
      this->meanError_.set (x);
    }

    void TargetPointsActualType::
    meanError (const meanError_optional& x)
    {
      this->meanError_ = x;
    }

    const TargetPointsActualType::xCombinedUncertainty_optional& TargetPointsActualType::
    xCombinedUncertainty () const
    {
      return this->xCombinedUncertainty_;
    }

    TargetPointsActualType::xCombinedUncertainty_optional& TargetPointsActualType::
    xCombinedUncertainty ()
    {
      return this->xCombinedUncertainty_;
    }

    void TargetPointsActualType::
    xCombinedUncertainty (const xCombinedUncertainty_type& x)
    {
      this->xCombinedUncertainty_.set (x);
    }

    void TargetPointsActualType::
    xCombinedUncertainty (const xCombinedUncertainty_optional& x)
    {
      this->xCombinedUncertainty_ = x;
    }

    const TargetPointsActualType::xMeanError_optional& TargetPointsActualType::
    xMeanError () const
    {
      return this->xMeanError_;
    }

    TargetPointsActualType::xMeanError_optional& TargetPointsActualType::
    xMeanError ()
    {
      return this->xMeanError_;
    }

    void TargetPointsActualType::
    xMeanError (const xMeanError_type& x)
    {
      this->xMeanError_.set (x);
    }

    void TargetPointsActualType::
    xMeanError (const xMeanError_optional& x)
    {
      this->xMeanError_ = x;
    }

    const TargetPointsActualType::yCombinedUncertainty_optional& TargetPointsActualType::
    yCombinedUncertainty () const
    {
      return this->yCombinedUncertainty_;
    }

    TargetPointsActualType::yCombinedUncertainty_optional& TargetPointsActualType::
    yCombinedUncertainty ()
    {
      return this->yCombinedUncertainty_;
    }

    void TargetPointsActualType::
    yCombinedUncertainty (const yCombinedUncertainty_type& x)
    {
      this->yCombinedUncertainty_.set (x);
    }

    void TargetPointsActualType::
    yCombinedUncertainty (const yCombinedUncertainty_optional& x)
    {
      this->yCombinedUncertainty_ = x;
    }

    const TargetPointsActualType::yMeanError_optional& TargetPointsActualType::
    yMeanError () const
    {
      return this->yMeanError_;
    }

    TargetPointsActualType::yMeanError_optional& TargetPointsActualType::
    yMeanError ()
    {
      return this->yMeanError_;
    }

    void TargetPointsActualType::
    yMeanError (const yMeanError_type& x)
    {
      this->yMeanError_.set (x);
    }

    void TargetPointsActualType::
    yMeanError (const yMeanError_optional& x)
    {
      this->yMeanError_ = x;
    }

    const TargetPointsActualType::zCombinedUncertainty_optional& TargetPointsActualType::
    zCombinedUncertainty () const
    {
      return this->zCombinedUncertainty_;
    }

    TargetPointsActualType::zCombinedUncertainty_optional& TargetPointsActualType::
    zCombinedUncertainty ()
    {
      return this->zCombinedUncertainty_;
    }

    void TargetPointsActualType::
    zCombinedUncertainty (const zCombinedUncertainty_type& x)
    {
      this->zCombinedUncertainty_.set (x);
    }

    void TargetPointsActualType::
    zCombinedUncertainty (const zCombinedUncertainty_optional& x)
    {
      this->zCombinedUncertainty_ = x;
    }

    const TargetPointsActualType::zMeanError_optional& TargetPointsActualType::
    zMeanError () const
    {
      return this->zMeanError_;
    }

    TargetPointsActualType::zMeanError_optional& TargetPointsActualType::
    zMeanError ()
    {
      return this->zMeanError_;
    }

    void TargetPointsActualType::
    zMeanError (const zMeanError_type& x)
    {
      this->zMeanError_.set (x);
    }

    void TargetPointsActualType::
    zMeanError (const zMeanError_optional& x)
    {
      this->zMeanError_ = x;
    }


    // PointDefinedCurveFeatureActualType
    // 

    const PointDefinedCurveFeatureActualType::DefiningPoints_optional& PointDefinedCurveFeatureActualType::
    DefiningPoints () const
    {
      return this->DefiningPoints_;
    }

    PointDefinedCurveFeatureActualType::DefiningPoints_optional& PointDefinedCurveFeatureActualType::
    DefiningPoints ()
    {
      return this->DefiningPoints_;
    }

    void PointDefinedCurveFeatureActualType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedCurveFeatureActualType::
    DefiningPoints (const DefiningPoints_optional& x)
    {
      this->DefiningPoints_ = x;
    }

    void PointDefinedCurveFeatureActualType::
    DefiningPoints (::std::auto_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (x);
    }

    const PointDefinedCurveFeatureActualType::Plane_optional& PointDefinedCurveFeatureActualType::
    Plane () const
    {
      return this->Plane_;
    }

    PointDefinedCurveFeatureActualType::Plane_optional& PointDefinedCurveFeatureActualType::
    Plane ()
    {
      return this->Plane_;
    }

    void PointDefinedCurveFeatureActualType::
    Plane (const Plane_type& x)
    {
      this->Plane_.set (x);
    }

    void PointDefinedCurveFeatureActualType::
    Plane (const Plane_optional& x)
    {
      this->Plane_ = x;
    }

    void PointDefinedCurveFeatureActualType::
    Plane (::std::auto_ptr< Plane_type > x)
    {
      this->Plane_.set (x);
    }

    const PointDefinedCurveFeatureActualType::Form_optional& PointDefinedCurveFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    PointDefinedCurveFeatureActualType::Form_optional& PointDefinedCurveFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void PointDefinedCurveFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void PointDefinedCurveFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void PointDefinedCurveFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // PointDefinedSurfaceConstructionMethodType
    // 

    const PointDefinedSurfaceConstructionMethodType::BestFit_optional& PointDefinedSurfaceConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    PointDefinedSurfaceConstructionMethodType::BestFit_optional& PointDefinedSurfaceConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const PointDefinedSurfaceConstructionMethodType::Recompensated_optional& PointDefinedSurfaceConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    PointDefinedSurfaceConstructionMethodType::Recompensated_optional& PointDefinedSurfaceConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const PointDefinedSurfaceConstructionMethodType::Copy_optional& PointDefinedSurfaceConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PointDefinedSurfaceConstructionMethodType::Copy_optional& PointDefinedSurfaceConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const PointDefinedSurfaceConstructionMethodType::Transform_optional& PointDefinedSurfaceConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PointDefinedSurfaceConstructionMethodType::Transform_optional& PointDefinedSurfaceConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const PointDefinedSurfaceConstructionMethodType::Extract_optional& PointDefinedSurfaceConstructionMethodType::
    Extract () const
    {
      return this->Extract_;
    }

    PointDefinedSurfaceConstructionMethodType::Extract_optional& PointDefinedSurfaceConstructionMethodType::
    Extract ()
    {
      return this->Extract_;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Extract (const Extract_type& x)
    {
      this->Extract_.set (x);
    }

    void PointDefinedSurfaceConstructionMethodType::
    Extract (const Extract_optional& x)
    {
      this->Extract_ = x;
    }

    void PointDefinedSurfaceConstructionMethodType::
    Extract (::std::auto_ptr< Extract_type > x)
    {
      this->Extract_.set (x);
    }


    // PointDefinedSurfaceBestFitType
    // 

    const PointDefinedSurfaceBestFitType::BaseFeature_sequence& PointDefinedSurfaceBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointDefinedSurfaceBestFitType::BaseFeature_sequence& PointDefinedSurfaceBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointDefinedSurfaceBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PointDefinedSurfaceRecompType
    // 

    const PointDefinedSurfaceRecompType::BaseFeaturePointList_type& PointDefinedSurfaceRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    PointDefinedSurfaceRecompType::BaseFeaturePointList_type& PointDefinedSurfaceRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void PointDefinedSurfaceRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void PointDefinedSurfaceRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // PointDefinedSurfaceCopyType
    // 

    const PointDefinedSurfaceCopyType::BasePointDefinedSurface_type& PointDefinedSurfaceCopyType::
    BasePointDefinedSurface () const
    {
      return this->BasePointDefinedSurface_.get ();
    }

    PointDefinedSurfaceCopyType::BasePointDefinedSurface_type& PointDefinedSurfaceCopyType::
    BasePointDefinedSurface ()
    {
      return this->BasePointDefinedSurface_.get ();
    }

    void PointDefinedSurfaceCopyType::
    BasePointDefinedSurface (const BasePointDefinedSurface_type& x)
    {
      this->BasePointDefinedSurface_.set (x);
    }

    void PointDefinedSurfaceCopyType::
    BasePointDefinedSurface (::std::auto_ptr< BasePointDefinedSurface_type > x)
    {
      this->BasePointDefinedSurface_.set (x);
    }


    // PointDefinedSurfaceTransformType
    // 

    const PointDefinedSurfaceTransformType::BasePointDefinedSurface_type& PointDefinedSurfaceTransformType::
    BasePointDefinedSurface () const
    {
      return this->BasePointDefinedSurface_.get ();
    }

    PointDefinedSurfaceTransformType::BasePointDefinedSurface_type& PointDefinedSurfaceTransformType::
    BasePointDefinedSurface ()
    {
      return this->BasePointDefinedSurface_.get ();
    }

    void PointDefinedSurfaceTransformType::
    BasePointDefinedSurface (const BasePointDefinedSurface_type& x)
    {
      this->BasePointDefinedSurface_.set (x);
    }

    void PointDefinedSurfaceTransformType::
    BasePointDefinedSurface (::std::auto_ptr< BasePointDefinedSurface_type > x)
    {
      this->BasePointDefinedSurface_.set (x);
    }

    const PointDefinedSurfaceTransformType::Transformation_type& PointDefinedSurfaceTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PointDefinedSurfaceTransformType::Transformation_type& PointDefinedSurfaceTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PointDefinedSurfaceTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PointDefinedSurfaceTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // PointDefinedSurfaceExtractType
    // 

    const PointDefinedSurfaceExtractType::SurfaceFeature_type& PointDefinedSurfaceExtractType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointDefinedSurfaceExtractType::SurfaceFeature_type& PointDefinedSurfaceExtractType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointDefinedSurfaceExtractType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointDefinedSurfaceExtractType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }


    // PointDefinedSurfaceCheckedType
    // 

    const PointDefinedSurfaceCheckedType::Measured_optional& PointDefinedSurfaceCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PointDefinedSurfaceCheckedType::Measured_optional& PointDefinedSurfaceCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PointDefinedSurfaceCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PointDefinedSurfaceCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PointDefinedSurfaceCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const PointDefinedSurfaceCheckedType::Constructed_optional& PointDefinedSurfaceCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointDefinedSurfaceCheckedType::Constructed_optional& PointDefinedSurfaceCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointDefinedSurfaceCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointDefinedSurfaceCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointDefinedSurfaceCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // PointDefinedSurfaceCheckedFeatureType
    // 

    const PointDefinedSurfaceCheckedFeatureType::CheckDetails_optional& PointDefinedSurfaceCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PointDefinedSurfaceCheckedFeatureType::CheckDetails_optional& PointDefinedSurfaceCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PointDefinedSurfaceCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PointDefinedSurfaceCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PointDefinedSurfaceCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // PointDefinedSurfaceActualDeterminationType
    // 

    const PointDefinedSurfaceActualDeterminationType::Checked_optional& PointDefinedSurfaceActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PointDefinedSurfaceActualDeterminationType::Checked_optional& PointDefinedSurfaceActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PointDefinedSurfaceActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PointDefinedSurfaceActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PointDefinedSurfaceActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const PointDefinedSurfaceActualDeterminationType::Set_optional& PointDefinedSurfaceActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PointDefinedSurfaceActualDeterminationType::Set_optional& PointDefinedSurfaceActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PointDefinedSurfaceActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PointDefinedSurfaceActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PointDefinedSurfaceActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // PointDefinedSurfaceFeatureItemType
    // 

    const PointDefinedSurfaceFeatureItemType::DeterminationMode_type& PointDefinedSurfaceFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PointDefinedSurfaceFeatureItemType::DeterminationMode_type& PointDefinedSurfaceFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PointDefinedSurfaceFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PointDefinedSurfaceFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const PointDefinedSurfaceFeatureItemType::SubstituteFeatureAlgorithm_optional& PointDefinedSurfaceFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    PointDefinedSurfaceFeatureItemType::SubstituteFeatureAlgorithm_optional& PointDefinedSurfaceFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void PointDefinedSurfaceFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void PointDefinedSurfaceFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void PointDefinedSurfaceFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // PointDefinedSurfaceFeatureDefinitionType
    // 


    // TargetPointsNominalType
    // 

    const TargetPointsNominalType::TargetPoint_sequence& TargetPointsNominalType::
    TargetPoint () const
    {
      return this->TargetPoint_;
    }

    TargetPointsNominalType::TargetPoint_sequence& TargetPointsNominalType::
    TargetPoint ()
    {
      return this->TargetPoint_;
    }

    void TargetPointsNominalType::
    TargetPoint (const TargetPoint_sequence& s)
    {
      this->TargetPoint_ = s;
    }

    const TargetPointsNominalType::linearUnit_optional& TargetPointsNominalType::
    linearUnit () const
    {
      return this->linearUnit_;
    }

    TargetPointsNominalType::linearUnit_optional& TargetPointsNominalType::
    linearUnit ()
    {
      return this->linearUnit_;
    }

    void TargetPointsNominalType::
    linearUnit (const linearUnit_type& x)
    {
      this->linearUnit_.set (x);
    }

    void TargetPointsNominalType::
    linearUnit (const linearUnit_optional& x)
    {
      this->linearUnit_ = x;
    }

    void TargetPointsNominalType::
    linearUnit (::std::auto_ptr< linearUnit_type > x)
    {
      this->linearUnit_.set (x);
    }

    const TargetPointsNominalType::decimalPlaces_optional& TargetPointsNominalType::
    decimalPlaces () const
    {
      return this->decimalPlaces_;
    }

    TargetPointsNominalType::decimalPlaces_optional& TargetPointsNominalType::
    decimalPlaces ()
    {
      return this->decimalPlaces_;
    }

    void TargetPointsNominalType::
    decimalPlaces (const decimalPlaces_type& x)
    {
      this->decimalPlaces_.set (x);
    }

    void TargetPointsNominalType::
    decimalPlaces (const decimalPlaces_optional& x)
    {
      this->decimalPlaces_ = x;
    }

    const TargetPointsNominalType::significantFigures_optional& TargetPointsNominalType::
    significantFigures () const
    {
      return this->significantFigures_;
    }

    TargetPointsNominalType::significantFigures_optional& TargetPointsNominalType::
    significantFigures ()
    {
      return this->significantFigures_;
    }

    void TargetPointsNominalType::
    significantFigures (const significantFigures_type& x)
    {
      this->significantFigures_.set (x);
    }

    void TargetPointsNominalType::
    significantFigures (const significantFigures_optional& x)
    {
      this->significantFigures_ = x;
    }

    const TargetPointsNominalType::validity_optional& TargetPointsNominalType::
    validity () const
    {
      return this->validity_;
    }

    TargetPointsNominalType::validity_optional& TargetPointsNominalType::
    validity ()
    {
      return this->validity_;
    }

    void TargetPointsNominalType::
    validity (const validity_type& x)
    {
      this->validity_.set (x);
    }

    void TargetPointsNominalType::
    validity (const validity_optional& x)
    {
      this->validity_ = x;
    }

    void TargetPointsNominalType::
    validity (::std::auto_ptr< validity_type > x)
    {
      this->validity_.set (x);
    }

    const TargetPointsNominalType::xDecimalPlaces_optional& TargetPointsNominalType::
    xDecimalPlaces () const
    {
      return this->xDecimalPlaces_;
    }

    TargetPointsNominalType::xDecimalPlaces_optional& TargetPointsNominalType::
    xDecimalPlaces ()
    {
      return this->xDecimalPlaces_;
    }

    void TargetPointsNominalType::
    xDecimalPlaces (const xDecimalPlaces_type& x)
    {
      this->xDecimalPlaces_.set (x);
    }

    void TargetPointsNominalType::
    xDecimalPlaces (const xDecimalPlaces_optional& x)
    {
      this->xDecimalPlaces_ = x;
    }

    const TargetPointsNominalType::xSignificantFigures_optional& TargetPointsNominalType::
    xSignificantFigures () const
    {
      return this->xSignificantFigures_;
    }

    TargetPointsNominalType::xSignificantFigures_optional& TargetPointsNominalType::
    xSignificantFigures ()
    {
      return this->xSignificantFigures_;
    }

    void TargetPointsNominalType::
    xSignificantFigures (const xSignificantFigures_type& x)
    {
      this->xSignificantFigures_.set (x);
    }

    void TargetPointsNominalType::
    xSignificantFigures (const xSignificantFigures_optional& x)
    {
      this->xSignificantFigures_ = x;
    }

    const TargetPointsNominalType::xValidity_optional& TargetPointsNominalType::
    xValidity () const
    {
      return this->xValidity_;
    }

    TargetPointsNominalType::xValidity_optional& TargetPointsNominalType::
    xValidity ()
    {
      return this->xValidity_;
    }

    void TargetPointsNominalType::
    xValidity (const xValidity_type& x)
    {
      this->xValidity_.set (x);
    }

    void TargetPointsNominalType::
    xValidity (const xValidity_optional& x)
    {
      this->xValidity_ = x;
    }

    void TargetPointsNominalType::
    xValidity (::std::auto_ptr< xValidity_type > x)
    {
      this->xValidity_.set (x);
    }

    const TargetPointsNominalType::yDecimalPlaces_optional& TargetPointsNominalType::
    yDecimalPlaces () const
    {
      return this->yDecimalPlaces_;
    }

    TargetPointsNominalType::yDecimalPlaces_optional& TargetPointsNominalType::
    yDecimalPlaces ()
    {
      return this->yDecimalPlaces_;
    }

    void TargetPointsNominalType::
    yDecimalPlaces (const yDecimalPlaces_type& x)
    {
      this->yDecimalPlaces_.set (x);
    }

    void TargetPointsNominalType::
    yDecimalPlaces (const yDecimalPlaces_optional& x)
    {
      this->yDecimalPlaces_ = x;
    }

    const TargetPointsNominalType::ySignificantFigures_optional& TargetPointsNominalType::
    ySignificantFigures () const
    {
      return this->ySignificantFigures_;
    }

    TargetPointsNominalType::ySignificantFigures_optional& TargetPointsNominalType::
    ySignificantFigures ()
    {
      return this->ySignificantFigures_;
    }

    void TargetPointsNominalType::
    ySignificantFigures (const ySignificantFigures_type& x)
    {
      this->ySignificantFigures_.set (x);
    }

    void TargetPointsNominalType::
    ySignificantFigures (const ySignificantFigures_optional& x)
    {
      this->ySignificantFigures_ = x;
    }

    const TargetPointsNominalType::yValidity_optional& TargetPointsNominalType::
    yValidity () const
    {
      return this->yValidity_;
    }

    TargetPointsNominalType::yValidity_optional& TargetPointsNominalType::
    yValidity ()
    {
      return this->yValidity_;
    }

    void TargetPointsNominalType::
    yValidity (const yValidity_type& x)
    {
      this->yValidity_.set (x);
    }

    void TargetPointsNominalType::
    yValidity (const yValidity_optional& x)
    {
      this->yValidity_ = x;
    }

    void TargetPointsNominalType::
    yValidity (::std::auto_ptr< yValidity_type > x)
    {
      this->yValidity_.set (x);
    }

    const TargetPointsNominalType::zDecimalPlaces_optional& TargetPointsNominalType::
    zDecimalPlaces () const
    {
      return this->zDecimalPlaces_;
    }

    TargetPointsNominalType::zDecimalPlaces_optional& TargetPointsNominalType::
    zDecimalPlaces ()
    {
      return this->zDecimalPlaces_;
    }

    void TargetPointsNominalType::
    zDecimalPlaces (const zDecimalPlaces_type& x)
    {
      this->zDecimalPlaces_.set (x);
    }

    void TargetPointsNominalType::
    zDecimalPlaces (const zDecimalPlaces_optional& x)
    {
      this->zDecimalPlaces_ = x;
    }

    const TargetPointsNominalType::zSignificantFigures_optional& TargetPointsNominalType::
    zSignificantFigures () const
    {
      return this->zSignificantFigures_;
    }

    TargetPointsNominalType::zSignificantFigures_optional& TargetPointsNominalType::
    zSignificantFigures ()
    {
      return this->zSignificantFigures_;
    }

    void TargetPointsNominalType::
    zSignificantFigures (const zSignificantFigures_type& x)
    {
      this->zSignificantFigures_.set (x);
    }

    void TargetPointsNominalType::
    zSignificantFigures (const zSignificantFigures_optional& x)
    {
      this->zSignificantFigures_ = x;
    }

    const TargetPointsNominalType::zValidity_optional& TargetPointsNominalType::
    zValidity () const
    {
      return this->zValidity_;
    }

    TargetPointsNominalType::zValidity_optional& TargetPointsNominalType::
    zValidity ()
    {
      return this->zValidity_;
    }

    void TargetPointsNominalType::
    zValidity (const zValidity_type& x)
    {
      this->zValidity_.set (x);
    }

    void TargetPointsNominalType::
    zValidity (const zValidity_optional& x)
    {
      this->zValidity_ = x;
    }

    void TargetPointsNominalType::
    zValidity (::std::auto_ptr< zValidity_type > x)
    {
      this->zValidity_.set (x);
    }


    // PointDefinedSurfaceFeatureNominalType
    // 

    const PointDefinedSurfaceFeatureNominalType::DefiningPoints_type& PointDefinedSurfaceFeatureNominalType::
    DefiningPoints () const
    {
      return this->DefiningPoints_.get ();
    }

    PointDefinedSurfaceFeatureNominalType::DefiningPoints_type& PointDefinedSurfaceFeatureNominalType::
    DefiningPoints ()
    {
      return this->DefiningPoints_.get ();
    }

    void PointDefinedSurfaceFeatureNominalType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedSurfaceFeatureNominalType::
    DefiningPoints (::std::auto_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (x);
    }


    // PointDefinedSurfaceFeatureActualType
    // 

    const PointDefinedSurfaceFeatureActualType::DefiningPoints_optional& PointDefinedSurfaceFeatureActualType::
    DefiningPoints () const
    {
      return this->DefiningPoints_;
    }

    PointDefinedSurfaceFeatureActualType::DefiningPoints_optional& PointDefinedSurfaceFeatureActualType::
    DefiningPoints ()
    {
      return this->DefiningPoints_;
    }

    void PointDefinedSurfaceFeatureActualType::
    DefiningPoints (const DefiningPoints_type& x)
    {
      this->DefiningPoints_.set (x);
    }

    void PointDefinedSurfaceFeatureActualType::
    DefiningPoints (const DefiningPoints_optional& x)
    {
      this->DefiningPoints_ = x;
    }

    void PointDefinedSurfaceFeatureActualType::
    DefiningPoints (::std::auto_ptr< DefiningPoints_type > x)
    {
      this->DefiningPoints_.set (x);
    }

    const PointDefinedSurfaceFeatureActualType::Form_optional& PointDefinedSurfaceFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    PointDefinedSurfaceFeatureActualType::Form_optional& PointDefinedSurfaceFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void PointDefinedSurfaceFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void PointDefinedSurfaceFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void PointDefinedSurfaceFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // PointConstructionMethodType
    // 

    const PointConstructionMethodType::Intersection_optional& PointConstructionMethodType::
    Intersection () const
    {
      return this->Intersection_;
    }

    PointConstructionMethodType::Intersection_optional& PointConstructionMethodType::
    Intersection ()
    {
      return this->Intersection_;
    }

    void PointConstructionMethodType::
    Intersection (const Intersection_type& x)
    {
      this->Intersection_.set (x);
    }

    void PointConstructionMethodType::
    Intersection (const Intersection_optional& x)
    {
      this->Intersection_ = x;
    }

    void PointConstructionMethodType::
    Intersection (::std::auto_ptr< Intersection_type > x)
    {
      this->Intersection_.set (x);
    }

    const PointConstructionMethodType::Projection_optional& PointConstructionMethodType::
    Projection () const
    {
      return this->Projection_;
    }

    PointConstructionMethodType::Projection_optional& PointConstructionMethodType::
    Projection ()
    {
      return this->Projection_;
    }

    void PointConstructionMethodType::
    Projection (const Projection_type& x)
    {
      this->Projection_.set (x);
    }

    void PointConstructionMethodType::
    Projection (const Projection_optional& x)
    {
      this->Projection_ = x;
    }

    void PointConstructionMethodType::
    Projection (::std::auto_ptr< Projection_type > x)
    {
      this->Projection_.set (x);
    }

    const PointConstructionMethodType::Copy_optional& PointConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    PointConstructionMethodType::Copy_optional& PointConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void PointConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void PointConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void PointConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const PointConstructionMethodType::Cast_optional& PointConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    PointConstructionMethodType::Cast_optional& PointConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void PointConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void PointConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void PointConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const PointConstructionMethodType::Transform_optional& PointConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    PointConstructionMethodType::Transform_optional& PointConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void PointConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void PointConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void PointConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const PointConstructionMethodType::FromCone_optional& PointConstructionMethodType::
    FromCone () const
    {
      return this->FromCone_;
    }

    PointConstructionMethodType::FromCone_optional& PointConstructionMethodType::
    FromCone ()
    {
      return this->FromCone_;
    }

    void PointConstructionMethodType::
    FromCone (const FromCone_type& x)
    {
      this->FromCone_.set (x);
    }

    void PointConstructionMethodType::
    FromCone (const FromCone_optional& x)
    {
      this->FromCone_ = x;
    }

    void PointConstructionMethodType::
    FromCone (::std::auto_ptr< FromCone_type > x)
    {
      this->FromCone_.set (x);
    }

    const PointConstructionMethodType::FromScan_optional& PointConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    PointConstructionMethodType::FromScan_optional& PointConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void PointConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void PointConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void PointConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }

    const PointConstructionMethodType::CenterOfGravity_optional& PointConstructionMethodType::
    CenterOfGravity () const
    {
      return this->CenterOfGravity_;
    }

    PointConstructionMethodType::CenterOfGravity_optional& PointConstructionMethodType::
    CenterOfGravity ()
    {
      return this->CenterOfGravity_;
    }

    void PointConstructionMethodType::
    CenterOfGravity (const CenterOfGravity_type& x)
    {
      this->CenterOfGravity_.set (x);
    }

    void PointConstructionMethodType::
    CenterOfGravity (const CenterOfGravity_optional& x)
    {
      this->CenterOfGravity_ = x;
    }

    void PointConstructionMethodType::
    CenterOfGravity (::std::auto_ptr< CenterOfGravity_type > x)
    {
      this->CenterOfGravity_.set (x);
    }

    const PointConstructionMethodType::Pierce_optional& PointConstructionMethodType::
    Pierce () const
    {
      return this->Pierce_;
    }

    PointConstructionMethodType::Pierce_optional& PointConstructionMethodType::
    Pierce ()
    {
      return this->Pierce_;
    }

    void PointConstructionMethodType::
    Pierce (const Pierce_type& x)
    {
      this->Pierce_.set (x);
    }

    void PointConstructionMethodType::
    Pierce (const Pierce_optional& x)
    {
      this->Pierce_ = x;
    }

    void PointConstructionMethodType::
    Pierce (::std::auto_ptr< Pierce_type > x)
    {
      this->Pierce_.set (x);
    }

    const PointConstructionMethodType::MidPoint_optional& PointConstructionMethodType::
    MidPoint () const
    {
      return this->MidPoint_;
    }

    PointConstructionMethodType::MidPoint_optional& PointConstructionMethodType::
    MidPoint ()
    {
      return this->MidPoint_;
    }

    void PointConstructionMethodType::
    MidPoint (const MidPoint_type& x)
    {
      this->MidPoint_.set (x);
    }

    void PointConstructionMethodType::
    MidPoint (const MidPoint_optional& x)
    {
      this->MidPoint_ = x;
    }

    void PointConstructionMethodType::
    MidPoint (::std::auto_ptr< MidPoint_type > x)
    {
      this->MidPoint_.set (x);
    }

    const PointConstructionMethodType::MovePoint_optional& PointConstructionMethodType::
    MovePoint () const
    {
      return this->MovePoint_;
    }

    PointConstructionMethodType::MovePoint_optional& PointConstructionMethodType::
    MovePoint ()
    {
      return this->MovePoint_;
    }

    void PointConstructionMethodType::
    MovePoint (const MovePoint_type& x)
    {
      this->MovePoint_.set (x);
    }

    void PointConstructionMethodType::
    MovePoint (const MovePoint_optional& x)
    {
      this->MovePoint_ = x;
    }

    void PointConstructionMethodType::
    MovePoint (::std::auto_ptr< MovePoint_type > x)
    {
      this->MovePoint_.set (x);
    }

    const PointConstructionMethodType::MovePointVector_optional& PointConstructionMethodType::
    MovePointVector () const
    {
      return this->MovePointVector_;
    }

    PointConstructionMethodType::MovePointVector_optional& PointConstructionMethodType::
    MovePointVector ()
    {
      return this->MovePointVector_;
    }

    void PointConstructionMethodType::
    MovePointVector (const MovePointVector_type& x)
    {
      this->MovePointVector_.set (x);
    }

    void PointConstructionMethodType::
    MovePointVector (const MovePointVector_optional& x)
    {
      this->MovePointVector_ = x;
    }

    void PointConstructionMethodType::
    MovePointVector (::std::auto_ptr< MovePointVector_type > x)
    {
      this->MovePointVector_.set (x);
    }

    const PointConstructionMethodType::MovePointAxis_optional& PointConstructionMethodType::
    MovePointAxis () const
    {
      return this->MovePointAxis_;
    }

    PointConstructionMethodType::MovePointAxis_optional& PointConstructionMethodType::
    MovePointAxis ()
    {
      return this->MovePointAxis_;
    }

    void PointConstructionMethodType::
    MovePointAxis (const MovePointAxis_type& x)
    {
      this->MovePointAxis_.set (x);
    }

    void PointConstructionMethodType::
    MovePointAxis (const MovePointAxis_optional& x)
    {
      this->MovePointAxis_ = x;
    }

    void PointConstructionMethodType::
    MovePointAxis (::std::auto_ptr< MovePointAxis_type > x)
    {
      this->MovePointAxis_.set (x);
    }

    const PointConstructionMethodType::Extreme_optional& PointConstructionMethodType::
    Extreme () const
    {
      return this->Extreme_;
    }

    PointConstructionMethodType::Extreme_optional& PointConstructionMethodType::
    Extreme ()
    {
      return this->Extreme_;
    }

    void PointConstructionMethodType::
    Extreme (const Extreme_type& x)
    {
      this->Extreme_.set (x);
    }

    void PointConstructionMethodType::
    Extreme (const Extreme_optional& x)
    {
      this->Extreme_ = x;
    }

    void PointConstructionMethodType::
    Extreme (::std::auto_ptr< Extreme_type > x)
    {
      this->Extreme_.set (x);
    }


    // PointFeatureIntersectionType
    // 

    const PointFeatureIntersectionType::IntersectionFeature_sequence& PointFeatureIntersectionType::
    IntersectionFeature () const
    {
      return this->IntersectionFeature_;
    }

    PointFeatureIntersectionType::IntersectionFeature_sequence& PointFeatureIntersectionType::
    IntersectionFeature ()
    {
      return this->IntersectionFeature_;
    }

    void PointFeatureIntersectionType::
    IntersectionFeature (const IntersectionFeature_sequence& s)
    {
      this->IntersectionFeature_ = s;
    }


    // PointFeaturePierceType
    // 

    const PointFeaturePierceType::SurfaceFeature_type& PointFeaturePierceType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointFeaturePierceType::SurfaceFeature_type& PointFeaturePierceType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointFeaturePierceType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointFeaturePierceType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const PointFeaturePierceType::CurveFeature_type& PointFeaturePierceType::
    CurveFeature () const
    {
      return this->CurveFeature_.get ();
    }

    PointFeaturePierceType::CurveFeature_type& PointFeaturePierceType::
    CurveFeature ()
    {
      return this->CurveFeature_.get ();
    }

    void PointFeaturePierceType::
    CurveFeature (const CurveFeature_type& x)
    {
      this->CurveFeature_.set (x);
    }

    void PointFeaturePierceType::
    CurveFeature (::std::auto_ptr< CurveFeature_type > x)
    {
      this->CurveFeature_.set (x);
    }


    // PointFeatureProjectionType
    // 

    const PointFeatureProjectionType::ProjectionPlane_type& PointFeatureProjectionType::
    ProjectionPlane () const
    {
      return this->ProjectionPlane_.get ();
    }

    PointFeatureProjectionType::ProjectionPlane_type& PointFeatureProjectionType::
    ProjectionPlane ()
    {
      return this->ProjectionPlane_.get ();
    }

    void PointFeatureProjectionType::
    ProjectionPlane (const ProjectionPlane_type& x)
    {
      this->ProjectionPlane_.set (x);
    }

    void PointFeatureProjectionType::
    ProjectionPlane (::std::auto_ptr< ProjectionPlane_type > x)
    {
      this->ProjectionPlane_.set (x);
    }

    const PointFeatureProjectionType::ProjectionFeature_type& PointFeatureProjectionType::
    ProjectionFeature () const
    {
      return this->ProjectionFeature_.get ();
    }

    PointFeatureProjectionType::ProjectionFeature_type& PointFeatureProjectionType::
    ProjectionFeature ()
    {
      return this->ProjectionFeature_.get ();
    }

    void PointFeatureProjectionType::
    ProjectionFeature (const ProjectionFeature_type& x)
    {
      this->ProjectionFeature_.set (x);
    }

    void PointFeatureProjectionType::
    ProjectionFeature (::std::auto_ptr< ProjectionFeature_type > x)
    {
      this->ProjectionFeature_.set (x);
    }


    // PointFeatureFromConeType
    // 

    const PointFeatureFromConeType::BaseCone_type& PointFeatureFromConeType::
    BaseCone () const
    {
      return this->BaseCone_.get ();
    }

    PointFeatureFromConeType::BaseCone_type& PointFeatureFromConeType::
    BaseCone ()
    {
      return this->BaseCone_.get ();
    }

    void PointFeatureFromConeType::
    BaseCone (const BaseCone_type& x)
    {
      this->BaseCone_.set (x);
    }

    void PointFeatureFromConeType::
    BaseCone (::std::auto_ptr< BaseCone_type > x)
    {
      this->BaseCone_.set (x);
    }


    // PointFeatureCopyType
    // 

    const PointFeatureCopyType::BasePointFeature_type& PointFeatureCopyType::
    BasePointFeature () const
    {
      return this->BasePointFeature_.get ();
    }

    PointFeatureCopyType::BasePointFeature_type& PointFeatureCopyType::
    BasePointFeature ()
    {
      return this->BasePointFeature_.get ();
    }

    void PointFeatureCopyType::
    BasePointFeature (const BasePointFeature_type& x)
    {
      this->BasePointFeature_.set (x);
    }

    void PointFeatureCopyType::
    BasePointFeature (::std::auto_ptr< BasePointFeature_type > x)
    {
      this->BasePointFeature_.set (x);
    }


    // PointFeatureTransformType
    // 

    const PointFeatureTransformType::BasePointFeature_type& PointFeatureTransformType::
    BasePointFeature () const
    {
      return this->BasePointFeature_.get ();
    }

    PointFeatureTransformType::BasePointFeature_type& PointFeatureTransformType::
    BasePointFeature ()
    {
      return this->BasePointFeature_.get ();
    }

    void PointFeatureTransformType::
    BasePointFeature (const BasePointFeature_type& x)
    {
      this->BasePointFeature_.set (x);
    }

    void PointFeatureTransformType::
    BasePointFeature (::std::auto_ptr< BasePointFeature_type > x)
    {
      this->BasePointFeature_.set (x);
    }

    const PointFeatureTransformType::Transformation_type& PointFeatureTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    PointFeatureTransformType::Transformation_type& PointFeatureTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void PointFeatureTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void PointFeatureTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // PointFeatureFromScanType
    // 

    const PointFeatureFromScanType::SurfaceFeature_type& PointFeatureFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    PointFeatureFromScanType::SurfaceFeature_type& PointFeatureFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void PointFeatureFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void PointFeatureFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const PointFeatureFromScanType::SearchRadius_type& PointFeatureFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    PointFeatureFromScanType::SearchRadius_type& PointFeatureFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void PointFeatureFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void PointFeatureFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const PointFeatureFromScanType::RetrievalMethod_type& PointFeatureFromScanType::
    RetrievalMethod () const
    {
      return this->RetrievalMethod_.get ();
    }

    PointFeatureFromScanType::RetrievalMethod_type& PointFeatureFromScanType::
    RetrievalMethod ()
    {
      return this->RetrievalMethod_.get ();
    }

    void PointFeatureFromScanType::
    RetrievalMethod (const RetrievalMethod_type& x)
    {
      this->RetrievalMethod_.set (x);
    }

    void PointFeatureFromScanType::
    RetrievalMethod (::std::auto_ptr< RetrievalMethod_type > x)
    {
      this->RetrievalMethod_.set (x);
    }


    // PointFeatureCenterOfGravityType
    // 

    const PointFeatureCenterOfGravityType::BaseFeature_sequence& PointFeatureCenterOfGravityType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointFeatureCenterOfGravityType::BaseFeature_sequence& PointFeatureCenterOfGravityType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointFeatureCenterOfGravityType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PointFeatureMidPointType
    // 

    const PointFeatureMidPointType::BaseFeature_sequence& PointFeatureMidPointType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    PointFeatureMidPointType::BaseFeature_sequence& PointFeatureMidPointType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void PointFeatureMidPointType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // PointFeatureCastType
    // 

    const PointFeatureCastType::BaseFeature_type& PointFeatureCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureCastType::BaseFeature_type& PointFeatureCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // PointFeatureMovePointType
    // 

    const PointFeatureMovePointType::BaseFeature_type& PointFeatureMovePointType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureMovePointType::BaseFeature_type& PointFeatureMovePointType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureMovePointType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureMovePointType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }

    const PointFeatureMovePointType::Offset_optional& PointFeatureMovePointType::
    Offset () const
    {
      return this->Offset_;
    }

    PointFeatureMovePointType::Offset_optional& PointFeatureMovePointType::
    Offset ()
    {
      return this->Offset_;
    }

    void PointFeatureMovePointType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void PointFeatureMovePointType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    void PointFeatureMovePointType::
    Offset (::std::auto_ptr< Offset_type > x)
    {
      this->Offset_.set (x);
    }

    const PointFeatureMovePointType::DirectionalOffset_optional& PointFeatureMovePointType::
    DirectionalOffset () const
    {
      return this->DirectionalOffset_;
    }

    PointFeatureMovePointType::DirectionalOffset_optional& PointFeatureMovePointType::
    DirectionalOffset ()
    {
      return this->DirectionalOffset_;
    }

    void PointFeatureMovePointType::
    DirectionalOffset (const DirectionalOffset_type& x)
    {
      this->DirectionalOffset_.set (x);
    }

    void PointFeatureMovePointType::
    DirectionalOffset (const DirectionalOffset_optional& x)
    {
      this->DirectionalOffset_ = x;
    }

    void PointFeatureMovePointType::
    DirectionalOffset (::std::auto_ptr< DirectionalOffset_type > x)
    {
      this->DirectionalOffset_.set (x);
    }


    // PointFeatureMovePointVectorType
    // 

    const PointFeatureMovePointVectorType::BaseFeature_type& PointFeatureMovePointVectorType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureMovePointVectorType::BaseFeature_type& PointFeatureMovePointVectorType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureMovePointVectorType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureMovePointVectorType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }

    const PointFeatureMovePointVectorType::Distance_type& PointFeatureMovePointVectorType::
    Distance () const
    {
      return this->Distance_.get ();
    }

    PointFeatureMovePointVectorType::Distance_type& PointFeatureMovePointVectorType::
    Distance ()
    {
      return this->Distance_.get ();
    }

    void PointFeatureMovePointVectorType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void PointFeatureMovePointVectorType::
    Distance (::std::auto_ptr< Distance_type > x)
    {
      this->Distance_.set (x);
    }

    const PointFeatureMovePointVectorType::Vector_type& PointFeatureMovePointVectorType::
    Vector () const
    {
      return this->Vector_.get ();
    }

    PointFeatureMovePointVectorType::Vector_type& PointFeatureMovePointVectorType::
    Vector ()
    {
      return this->Vector_.get ();
    }

    void PointFeatureMovePointVectorType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void PointFeatureMovePointVectorType::
    Vector (::std::auto_ptr< Vector_type > x)
    {
      this->Vector_.set (x);
    }


    // PointFeatureMovePointAxisType
    // 

    const PointFeatureMovePointAxisType::BaseLocationFeature_type& PointFeatureMovePointAxisType::
    BaseLocationFeature () const
    {
      return this->BaseLocationFeature_.get ();
    }

    PointFeatureMovePointAxisType::BaseLocationFeature_type& PointFeatureMovePointAxisType::
    BaseLocationFeature ()
    {
      return this->BaseLocationFeature_.get ();
    }

    void PointFeatureMovePointAxisType::
    BaseLocationFeature (const BaseLocationFeature_type& x)
    {
      this->BaseLocationFeature_.set (x);
    }

    void PointFeatureMovePointAxisType::
    BaseLocationFeature (::std::auto_ptr< BaseLocationFeature_type > x)
    {
      this->BaseLocationFeature_.set (x);
    }

    const PointFeatureMovePointAxisType::Distance_type& PointFeatureMovePointAxisType::
    Distance () const
    {
      return this->Distance_.get ();
    }

    PointFeatureMovePointAxisType::Distance_type& PointFeatureMovePointAxisType::
    Distance ()
    {
      return this->Distance_.get ();
    }

    void PointFeatureMovePointAxisType::
    Distance (const Distance_type& x)
    {
      this->Distance_.set (x);
    }

    void PointFeatureMovePointAxisType::
    Distance (::std::auto_ptr< Distance_type > x)
    {
      this->Distance_.set (x);
    }

    const PointFeatureMovePointAxisType::BaseAxisFeature_type& PointFeatureMovePointAxisType::
    BaseAxisFeature () const
    {
      return this->BaseAxisFeature_.get ();
    }

    PointFeatureMovePointAxisType::BaseAxisFeature_type& PointFeatureMovePointAxisType::
    BaseAxisFeature ()
    {
      return this->BaseAxisFeature_.get ();
    }

    void PointFeatureMovePointAxisType::
    BaseAxisFeature (const BaseAxisFeature_type& x)
    {
      this->BaseAxisFeature_.set (x);
    }

    void PointFeatureMovePointAxisType::
    BaseAxisFeature (::std::auto_ptr< BaseAxisFeature_type > x)
    {
      this->BaseAxisFeature_.set (x);
    }


    // PointFeatureExtremeType
    // 

    const PointFeatureExtremeType::BaseFeature_type& PointFeatureExtremeType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    PointFeatureExtremeType::BaseFeature_type& PointFeatureExtremeType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void PointFeatureExtremeType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void PointFeatureExtremeType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }

    const PointFeatureExtremeType::Minimum_type& PointFeatureExtremeType::
    Minimum () const
    {
      return this->Minimum_.get ();
    }

    PointFeatureExtremeType::Minimum_type& PointFeatureExtremeType::
    Minimum ()
    {
      return this->Minimum_.get ();
    }

    void PointFeatureExtremeType::
    Minimum (const Minimum_type& x)
    {
      this->Minimum_.set (x);
    }

    PointFeatureExtremeType::Minimum_type PointFeatureExtremeType::
    Minimum_default_value ()
    {
      return Minimum_type (false);
    }

    const PointFeatureExtremeType::BaseAxisFeature_optional& PointFeatureExtremeType::
    BaseAxisFeature () const
    {
      return this->BaseAxisFeature_;
    }

    PointFeatureExtremeType::BaseAxisFeature_optional& PointFeatureExtremeType::
    BaseAxisFeature ()
    {
      return this->BaseAxisFeature_;
    }

    void PointFeatureExtremeType::
    BaseAxisFeature (const BaseAxisFeature_type& x)
    {
      this->BaseAxisFeature_.set (x);
    }

    void PointFeatureExtremeType::
    BaseAxisFeature (const BaseAxisFeature_optional& x)
    {
      this->BaseAxisFeature_ = x;
    }

    void PointFeatureExtremeType::
    BaseAxisFeature (::std::auto_ptr< BaseAxisFeature_type > x)
    {
      this->BaseAxisFeature_.set (x);
    }

    const PointFeatureExtremeType::Vector_optional& PointFeatureExtremeType::
    Vector () const
    {
      return this->Vector_;
    }

    PointFeatureExtremeType::Vector_optional& PointFeatureExtremeType::
    Vector ()
    {
      return this->Vector_;
    }

    void PointFeatureExtremeType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void PointFeatureExtremeType::
    Vector (const Vector_optional& x)
    {
      this->Vector_ = x;
    }

    void PointFeatureExtremeType::
    Vector (::std::auto_ptr< Vector_type > x)
    {
      this->Vector_.set (x);
    }

    const PointFeatureExtremeType::Radial_optional& PointFeatureExtremeType::
    Radial () const
    {
      return this->Radial_;
    }

    PointFeatureExtremeType::Radial_optional& PointFeatureExtremeType::
    Radial ()
    {
      return this->Radial_;
    }

    void PointFeatureExtremeType::
    Radial (const Radial_type& x)
    {
      this->Radial_.set (x);
    }

    void PointFeatureExtremeType::
    Radial (const Radial_optional& x)
    {
      this->Radial_ = x;
    }

    void PointFeatureExtremeType::
    Radial (::std::auto_ptr< Radial_type > x)
    {
      this->Radial_.set (x);
    }

    const PointFeatureExtremeType::Radial_type& PointFeatureExtremeType::
    Radial_default_value ()
    {
      return Radial_default_value_;
    }

    const PointFeatureExtremeType::Xaxis_optional& PointFeatureExtremeType::
    Xaxis () const
    {
      return this->Xaxis_;
    }

    PointFeatureExtremeType::Xaxis_optional& PointFeatureExtremeType::
    Xaxis ()
    {
      return this->Xaxis_;
    }

    void PointFeatureExtremeType::
    Xaxis (const Xaxis_type& x)
    {
      this->Xaxis_.set (x);
    }

    void PointFeatureExtremeType::
    Xaxis (const Xaxis_optional& x)
    {
      this->Xaxis_ = x;
    }

    void PointFeatureExtremeType::
    Xaxis (::std::auto_ptr< Xaxis_type > x)
    {
      this->Xaxis_.set (x);
    }

    const PointFeatureExtremeType::Xaxis_type& PointFeatureExtremeType::
    Xaxis_default_value ()
    {
      return Xaxis_default_value_;
    }

    const PointFeatureExtremeType::Yaxis_optional& PointFeatureExtremeType::
    Yaxis () const
    {
      return this->Yaxis_;
    }

    PointFeatureExtremeType::Yaxis_optional& PointFeatureExtremeType::
    Yaxis ()
    {
      return this->Yaxis_;
    }

    void PointFeatureExtremeType::
    Yaxis (const Yaxis_type& x)
    {
      this->Yaxis_.set (x);
    }

    void PointFeatureExtremeType::
    Yaxis (const Yaxis_optional& x)
    {
      this->Yaxis_ = x;
    }

    void PointFeatureExtremeType::
    Yaxis (::std::auto_ptr< Yaxis_type > x)
    {
      this->Yaxis_.set (x);
    }

    const PointFeatureExtremeType::Yaxis_type& PointFeatureExtremeType::
    Yaxis_default_value ()
    {
      return Yaxis_default_value_;
    }

    const PointFeatureExtremeType::Zaxis_optional& PointFeatureExtremeType::
    Zaxis () const
    {
      return this->Zaxis_;
    }

    PointFeatureExtremeType::Zaxis_optional& PointFeatureExtremeType::
    Zaxis ()
    {
      return this->Zaxis_;
    }

    void PointFeatureExtremeType::
    Zaxis (const Zaxis_type& x)
    {
      this->Zaxis_.set (x);
    }

    void PointFeatureExtremeType::
    Zaxis (const Zaxis_optional& x)
    {
      this->Zaxis_ = x;
    }

    void PointFeatureExtremeType::
    Zaxis (::std::auto_ptr< Zaxis_type > x)
    {
      this->Zaxis_.set (x);
    }

    const PointFeatureExtremeType::Zaxis_type& PointFeatureExtremeType::
    Zaxis_default_value ()
    {
      return Zaxis_default_value_;
    }


    // PointCheckedType
    // 

    const PointCheckedType::Measured_optional& PointCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    PointCheckedType::Measured_optional& PointCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void PointCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void PointCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void PointCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const PointCheckedType::Constructed_optional& PointCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    PointCheckedType::Constructed_optional& PointCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void PointCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void PointCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void PointCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // PointCheckedFeatureType
    // 

    const PointCheckedFeatureType::CheckDetails_optional& PointCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    PointCheckedFeatureType::CheckDetails_optional& PointCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void PointCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void PointCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void PointCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // PointActualDeterminationType
    // 

    const PointActualDeterminationType::Checked_optional& PointActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    PointActualDeterminationType::Checked_optional& PointActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void PointActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void PointActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void PointActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const PointActualDeterminationType::Set_optional& PointActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    PointActualDeterminationType::Set_optional& PointActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void PointActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void PointActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void PointActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // PointFeatureItemType
    // 

    const PointFeatureItemType::DeterminationMode_type& PointFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    PointFeatureItemType::DeterminationMode_type& PointFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void PointFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void PointFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }


    // PointFeatureDefinitionType
    // 


    // PointFeatureNominalType
    // 

    const PointFeatureNominalType::Location_type& PointFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    PointFeatureNominalType::Location_type& PointFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void PointFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PointFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const PointFeatureNominalType::Normal_optional& PointFeatureNominalType::
    Normal () const
    {
      return this->Normal_;
    }

    PointFeatureNominalType::Normal_optional& PointFeatureNominalType::
    Normal ()
    {
      return this->Normal_;
    }

    void PointFeatureNominalType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PointFeatureNominalType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void PointFeatureNominalType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // PointFeatureActualType
    // 

    const PointFeatureActualType::Location_optional& PointFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    PointFeatureActualType::Location_optional& PointFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void PointFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void PointFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void PointFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const PointFeatureActualType::Normal_optional& PointFeatureActualType::
    Normal () const
    {
      return this->Normal_;
    }

    PointFeatureActualType::Normal_optional& PointFeatureActualType::
    Normal ()
    {
      return this->Normal_;
    }

    void PointFeatureActualType::
    Normal (const Normal_type& x)
    {
      this->Normal_.set (x);
    }

    void PointFeatureActualType::
    Normal (const Normal_optional& x)
    {
      this->Normal_ = x;
    }

    void PointFeatureActualType::
    Normal (::std::auto_ptr< Normal_type > x)
    {
      this->Normal_.set (x);
    }


    // SphereConstructionMethodType
    // 

    const SphereConstructionMethodType::BestFit_optional& SphereConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    SphereConstructionMethodType::BestFit_optional& SphereConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void SphereConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void SphereConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void SphereConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const SphereConstructionMethodType::Recompensated_optional& SphereConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    SphereConstructionMethodType::Recompensated_optional& SphereConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void SphereConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void SphereConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void SphereConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const SphereConstructionMethodType::Copy_optional& SphereConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    SphereConstructionMethodType::Copy_optional& SphereConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void SphereConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void SphereConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void SphereConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const SphereConstructionMethodType::Cast_optional& SphereConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    SphereConstructionMethodType::Cast_optional& SphereConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void SphereConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void SphereConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void SphereConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const SphereConstructionMethodType::Transform_optional& SphereConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    SphereConstructionMethodType::Transform_optional& SphereConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void SphereConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void SphereConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void SphereConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const SphereConstructionMethodType::FromScan_optional& SphereConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    SphereConstructionMethodType::FromScan_optional& SphereConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void SphereConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void SphereConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void SphereConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // SphereBestFitType
    // 

    const SphereBestFitType::BaseFeature_sequence& SphereBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    SphereBestFitType::BaseFeature_sequence& SphereBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void SphereBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // SphereRecompType
    // 

    const SphereRecompType::BaseFeaturePointList_type& SphereRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    SphereRecompType::BaseFeaturePointList_type& SphereRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void SphereRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void SphereRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // SphereCopyType
    // 

    const SphereCopyType::BaseSphere_type& SphereCopyType::
    BaseSphere () const
    {
      return this->BaseSphere_.get ();
    }

    SphereCopyType::BaseSphere_type& SphereCopyType::
    BaseSphere ()
    {
      return this->BaseSphere_.get ();
    }

    void SphereCopyType::
    BaseSphere (const BaseSphere_type& x)
    {
      this->BaseSphere_.set (x);
    }

    void SphereCopyType::
    BaseSphere (::std::auto_ptr< BaseSphere_type > x)
    {
      this->BaseSphere_.set (x);
    }


    // SphereCastType
    // 

    const SphereCastType::BaseFeature_type& SphereCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    SphereCastType::BaseFeature_type& SphereCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void SphereCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void SphereCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // SphereTransformType
    // 

    const SphereTransformType::BaseSphere_type& SphereTransformType::
    BaseSphere () const
    {
      return this->BaseSphere_.get ();
    }

    SphereTransformType::BaseSphere_type& SphereTransformType::
    BaseSphere ()
    {
      return this->BaseSphere_.get ();
    }

    void SphereTransformType::
    BaseSphere (const BaseSphere_type& x)
    {
      this->BaseSphere_.set (x);
    }

    void SphereTransformType::
    BaseSphere (::std::auto_ptr< BaseSphere_type > x)
    {
      this->BaseSphere_.set (x);
    }

    const SphereTransformType::Transformation_type& SphereTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    SphereTransformType::Transformation_type& SphereTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void SphereTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void SphereTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // SphereFromScanType
    // 

    const SphereFromScanType::SurfaceFeature_type& SphereFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    SphereFromScanType::SurfaceFeature_type& SphereFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void SphereFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void SphereFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const SphereFromScanType::SearchRadius_type& SphereFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    SphereFromScanType::SearchRadius_type& SphereFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void SphereFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void SphereFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }

    const SphereFromScanType::Vector_optional& SphereFromScanType::
    Vector () const
    {
      return this->Vector_;
    }

    SphereFromScanType::Vector_optional& SphereFromScanType::
    Vector ()
    {
      return this->Vector_;
    }

    void SphereFromScanType::
    Vector (const Vector_type& x)
    {
      this->Vector_.set (x);
    }

    void SphereFromScanType::
    Vector (const Vector_optional& x)
    {
      this->Vector_ = x;
    }

    void SphereFromScanType::
    Vector (::std::auto_ptr< Vector_type > x)
    {
      this->Vector_.set (x);
    }


    // SphereCheckedType
    // 

    const SphereCheckedType::Measured_optional& SphereCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    SphereCheckedType::Measured_optional& SphereCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void SphereCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void SphereCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void SphereCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const SphereCheckedType::Constructed_optional& SphereCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SphereCheckedType::Constructed_optional& SphereCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SphereCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SphereCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SphereCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // SphereCheckedFeatureType
    // 

    const SphereCheckedFeatureType::CheckDetails_optional& SphereCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    SphereCheckedFeatureType::CheckDetails_optional& SphereCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void SphereCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void SphereCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void SphereCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // SphereActualDeterminationType
    // 

    const SphereActualDeterminationType::Checked_optional& SphereActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    SphereActualDeterminationType::Checked_optional& SphereActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void SphereActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void SphereActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void SphereActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const SphereActualDeterminationType::Set_optional& SphereActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    SphereActualDeterminationType::Set_optional& SphereActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void SphereActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void SphereActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void SphereActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // SphereFeatureItemType
    // 

    const SphereFeatureItemType::DeterminationMode_type& SphereFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    SphereFeatureItemType::DeterminationMode_type& SphereFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void SphereFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void SphereFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const SphereFeatureItemType::SubstituteFeatureAlgorithm_optional& SphereFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    SphereFeatureItemType::SubstituteFeatureAlgorithm_optional& SphereFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void SphereFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void SphereFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void SphereFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // SphereFeatureDefinitionType
    // 

    const SphereFeatureDefinitionType::InternalExternal_type& SphereFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    SphereFeatureDefinitionType::InternalExternal_type& SphereFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void SphereFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void SphereFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const SphereFeatureDefinitionType::Diameter_type& SphereFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    SphereFeatureDefinitionType::Diameter_type& SphereFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void SphereFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphereFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }


    // SphereFeatureNominalType
    // 

    const SphereFeatureNominalType::Location_type& SphereFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    SphereFeatureNominalType::Location_type& SphereFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void SphereFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphereFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const SphereFeatureNominalType::LatitudeLongitudeSweep_optional& SphereFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    SphereFeatureNominalType::LatitudeLongitudeSweep_optional& SphereFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void SphereFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void SphereFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void SphereFeatureNominalType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }


    // SphereFeatureActualType
    // 

    const SphereFeatureActualType::Location_optional& SphereFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    SphereFeatureActualType::Location_optional& SphereFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void SphereFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphereFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void SphereFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const SphereFeatureActualType::Diameter_optional& SphereFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    SphereFeatureActualType::Diameter_optional& SphereFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void SphereFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphereFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void SphereFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const SphereFeatureActualType::DiameterMin_optional& SphereFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    SphereFeatureActualType::DiameterMin_optional& SphereFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void SphereFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void SphereFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void SphereFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const SphereFeatureActualType::DiameterMax_optional& SphereFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    SphereFeatureActualType::DiameterMax_optional& SphereFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void SphereFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void SphereFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void SphereFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const SphereFeatureActualType::LatitudeLongitudeSweep_optional& SphereFeatureActualType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    SphereFeatureActualType::LatitudeLongitudeSweep_optional& SphereFeatureActualType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void SphereFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void SphereFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void SphereFeatureActualType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    const SphereFeatureActualType::Form_optional& SphereFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    SphereFeatureActualType::Form_optional& SphereFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void SphereFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void SphereFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void SphereFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // SphericalSegmentConstructionMethodType
    // 

    const SphericalSegmentConstructionMethodType::BestFit_optional& SphericalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    SphericalSegmentConstructionMethodType::BestFit_optional& SphericalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void SphericalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const SphericalSegmentConstructionMethodType::Recompensated_optional& SphericalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    SphericalSegmentConstructionMethodType::Recompensated_optional& SphericalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void SphericalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const SphericalSegmentConstructionMethodType::Copy_optional& SphericalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    SphericalSegmentConstructionMethodType::Copy_optional& SphericalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void SphericalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const SphericalSegmentConstructionMethodType::Cast_optional& SphericalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    SphericalSegmentConstructionMethodType::Cast_optional& SphericalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void SphericalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const SphericalSegmentConstructionMethodType::Transform_optional& SphericalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    SphericalSegmentConstructionMethodType::Transform_optional& SphericalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void SphericalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void SphericalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void SphericalSegmentConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // SphericalSegmentBestFitType
    // 

    const SphericalSegmentBestFitType::BaseFeature_sequence& SphericalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    SphericalSegmentBestFitType::BaseFeature_sequence& SphericalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void SphericalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // SphericalSegmentRecompType
    // 

    const SphericalSegmentRecompType::BaseFeaturePointList_type& SphericalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    SphericalSegmentRecompType::BaseFeaturePointList_type& SphericalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void SphericalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void SphericalSegmentRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // SphericalSegmentCopyType
    // 

    const SphericalSegmentCopyType::BaseSphericalSegment_type& SphericalSegmentCopyType::
    BaseSphericalSegment () const
    {
      return this->BaseSphericalSegment_.get ();
    }

    SphericalSegmentCopyType::BaseSphericalSegment_type& SphericalSegmentCopyType::
    BaseSphericalSegment ()
    {
      return this->BaseSphericalSegment_.get ();
    }

    void SphericalSegmentCopyType::
    BaseSphericalSegment (const BaseSphericalSegment_type& x)
    {
      this->BaseSphericalSegment_.set (x);
    }

    void SphericalSegmentCopyType::
    BaseSphericalSegment (::std::auto_ptr< BaseSphericalSegment_type > x)
    {
      this->BaseSphericalSegment_.set (x);
    }


    // SphericalSegmentCastType
    // 

    const SphericalSegmentCastType::BaseFeature_type& SphericalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    SphericalSegmentCastType::BaseFeature_type& SphericalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void SphericalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void SphericalSegmentCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // SphericalSegmentTransformType
    // 

    const SphericalSegmentTransformType::BaseSphericalSegment_type& SphericalSegmentTransformType::
    BaseSphericalSegment () const
    {
      return this->BaseSphericalSegment_.get ();
    }

    SphericalSegmentTransformType::BaseSphericalSegment_type& SphericalSegmentTransformType::
    BaseSphericalSegment ()
    {
      return this->BaseSphericalSegment_.get ();
    }

    void SphericalSegmentTransformType::
    BaseSphericalSegment (const BaseSphericalSegment_type& x)
    {
      this->BaseSphericalSegment_.set (x);
    }

    void SphericalSegmentTransformType::
    BaseSphericalSegment (::std::auto_ptr< BaseSphericalSegment_type > x)
    {
      this->BaseSphericalSegment_.set (x);
    }

    const SphericalSegmentTransformType::Transformation_type& SphericalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    SphericalSegmentTransformType::Transformation_type& SphericalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void SphericalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void SphericalSegmentTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // SphericalSegmentCheckedType
    // 

    const SphericalSegmentCheckedType::Measured_optional& SphericalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    SphericalSegmentCheckedType::Measured_optional& SphericalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void SphericalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void SphericalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void SphericalSegmentCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const SphericalSegmentCheckedType::Constructed_optional& SphericalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SphericalSegmentCheckedType::Constructed_optional& SphericalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SphericalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SphericalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SphericalSegmentCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // SphericalSegmentCheckedFeatureType
    // 

    const SphericalSegmentCheckedFeatureType::CheckDetails_optional& SphericalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    SphericalSegmentCheckedFeatureType::CheckDetails_optional& SphericalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void SphericalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void SphericalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void SphericalSegmentCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // SphericalSegmentActualDeterminationType
    // 

    const SphericalSegmentActualDeterminationType::Checked_optional& SphericalSegmentActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    SphericalSegmentActualDeterminationType::Checked_optional& SphericalSegmentActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void SphericalSegmentActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void SphericalSegmentActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void SphericalSegmentActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const SphericalSegmentActualDeterminationType::Set_optional& SphericalSegmentActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    SphericalSegmentActualDeterminationType::Set_optional& SphericalSegmentActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void SphericalSegmentActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void SphericalSegmentActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void SphericalSegmentActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // SphericalSegmentFeatureItemType
    // 

    const SphericalSegmentFeatureItemType::DeterminationMode_type& SphericalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    SphericalSegmentFeatureItemType::DeterminationMode_type& SphericalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void SphericalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void SphericalSegmentFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const SphericalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& SphericalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    SphericalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& SphericalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void SphericalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void SphericalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void SphericalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // SphericalSegmentFeatureDefinitionType
    // 

    const SphericalSegmentFeatureDefinitionType::InternalExternal_type& SphericalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    SphericalSegmentFeatureDefinitionType::InternalExternal_type& SphericalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void SphericalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void SphericalSegmentFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const SphericalSegmentFeatureDefinitionType::Diameter_type& SphericalSegmentFeatureDefinitionType::
    Diameter () const
    {
      return this->Diameter_.get ();
    }

    SphericalSegmentFeatureDefinitionType::Diameter_type& SphericalSegmentFeatureDefinitionType::
    Diameter ()
    {
      return this->Diameter_.get ();
    }

    void SphericalSegmentFeatureDefinitionType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphericalSegmentFeatureDefinitionType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }


    // SphericalSegmentFeatureNominalType
    // 

    const SphericalSegmentFeatureNominalType::Location_type& SphericalSegmentFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    SphericalSegmentFeatureNominalType::Location_type& SphericalSegmentFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void SphericalSegmentFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphericalSegmentFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const SphericalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    SphericalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    void SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void SphericalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }


    // SphericalSegmentFeatureActualType
    // 

    const SphericalSegmentFeatureActualType::Location_optional& SphericalSegmentFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    SphericalSegmentFeatureActualType::Location_optional& SphericalSegmentFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void SphericalSegmentFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void SphericalSegmentFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const SphericalSegmentFeatureActualType::Diameter_optional& SphericalSegmentFeatureActualType::
    Diameter () const
    {
      return this->Diameter_;
    }

    SphericalSegmentFeatureActualType::Diameter_optional& SphericalSegmentFeatureActualType::
    Diameter ()
    {
      return this->Diameter_;
    }

    void SphericalSegmentFeatureActualType::
    Diameter (const Diameter_type& x)
    {
      this->Diameter_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    Diameter (const Diameter_optional& x)
    {
      this->Diameter_ = x;
    }

    void SphericalSegmentFeatureActualType::
    Diameter (::std::auto_ptr< Diameter_type > x)
    {
      this->Diameter_.set (x);
    }

    const SphericalSegmentFeatureActualType::DiameterMin_optional& SphericalSegmentFeatureActualType::
    DiameterMin () const
    {
      return this->DiameterMin_;
    }

    SphericalSegmentFeatureActualType::DiameterMin_optional& SphericalSegmentFeatureActualType::
    DiameterMin ()
    {
      return this->DiameterMin_;
    }

    void SphericalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_type& x)
    {
      this->DiameterMin_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    DiameterMin (const DiameterMin_optional& x)
    {
      this->DiameterMin_ = x;
    }

    void SphericalSegmentFeatureActualType::
    DiameterMin (::std::auto_ptr< DiameterMin_type > x)
    {
      this->DiameterMin_.set (x);
    }

    const SphericalSegmentFeatureActualType::DiameterMax_optional& SphericalSegmentFeatureActualType::
    DiameterMax () const
    {
      return this->DiameterMax_;
    }

    SphericalSegmentFeatureActualType::DiameterMax_optional& SphericalSegmentFeatureActualType::
    DiameterMax ()
    {
      return this->DiameterMax_;
    }

    void SphericalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_type& x)
    {
      this->DiameterMax_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    DiameterMax (const DiameterMax_optional& x)
    {
      this->DiameterMax_ = x;
    }

    void SphericalSegmentFeatureActualType::
    DiameterMax (::std::auto_ptr< DiameterMax_type > x)
    {
      this->DiameterMax_.set (x);
    }

    const SphericalSegmentFeatureActualType::LatitudeLongitudeSweep_optional& SphericalSegmentFeatureActualType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    SphericalSegmentFeatureActualType::LatitudeLongitudeSweep_optional& SphericalSegmentFeatureActualType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void SphericalSegmentFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void SphericalSegmentFeatureActualType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    const SphericalSegmentFeatureActualType::Form_optional& SphericalSegmentFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    SphericalSegmentFeatureActualType::Form_optional& SphericalSegmentFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void SphericalSegmentFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void SphericalSegmentFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void SphericalSegmentFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // SurfaceOfRevolutionConstructionMethodType
    // 

    const SurfaceOfRevolutionConstructionMethodType::BestFit_optional& SurfaceOfRevolutionConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    SurfaceOfRevolutionConstructionMethodType::BestFit_optional& SurfaceOfRevolutionConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const SurfaceOfRevolutionConstructionMethodType::Recompensated_optional& SurfaceOfRevolutionConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    SurfaceOfRevolutionConstructionMethodType::Recompensated_optional& SurfaceOfRevolutionConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const SurfaceOfRevolutionConstructionMethodType::Copy_optional& SurfaceOfRevolutionConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    SurfaceOfRevolutionConstructionMethodType::Copy_optional& SurfaceOfRevolutionConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const SurfaceOfRevolutionConstructionMethodType::Cast_optional& SurfaceOfRevolutionConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    SurfaceOfRevolutionConstructionMethodType::Cast_optional& SurfaceOfRevolutionConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const SurfaceOfRevolutionConstructionMethodType::Transform_optional& SurfaceOfRevolutionConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    SurfaceOfRevolutionConstructionMethodType::Transform_optional& SurfaceOfRevolutionConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void SurfaceOfRevolutionConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // SurfaceOfRevolutionBestFitType
    // 

    const SurfaceOfRevolutionBestFitType::BaseFeature_sequence& SurfaceOfRevolutionBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    SurfaceOfRevolutionBestFitType::BaseFeature_sequence& SurfaceOfRevolutionBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void SurfaceOfRevolutionBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // SurfaceOfRevolutionRecompType
    // 

    const SurfaceOfRevolutionRecompType::BaseFeaturePointList_type& SurfaceOfRevolutionRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    SurfaceOfRevolutionRecompType::BaseFeaturePointList_type& SurfaceOfRevolutionRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void SurfaceOfRevolutionRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void SurfaceOfRevolutionRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // SurfaceOfRevolutionCopyType
    // 

    const SurfaceOfRevolutionCopyType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution () const
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    SurfaceOfRevolutionCopyType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution ()
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    void SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution (const BaseSurfaceOfRevolution_type& x)
    {
      this->BaseSurfaceOfRevolution_.set (x);
    }

    void SurfaceOfRevolutionCopyType::
    BaseSurfaceOfRevolution (::std::auto_ptr< BaseSurfaceOfRevolution_type > x)
    {
      this->BaseSurfaceOfRevolution_.set (x);
    }


    // SurfaceOfRevolutionCastType
    // 

    const SurfaceOfRevolutionCastType::BaseFeature_type& SurfaceOfRevolutionCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    SurfaceOfRevolutionCastType::BaseFeature_type& SurfaceOfRevolutionCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void SurfaceOfRevolutionCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void SurfaceOfRevolutionCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // SurfaceOfRevolutionTransformType
    // 

    const SurfaceOfRevolutionTransformType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution () const
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    SurfaceOfRevolutionTransformType::BaseSurfaceOfRevolution_type& SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution ()
    {
      return this->BaseSurfaceOfRevolution_.get ();
    }

    void SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution (const BaseSurfaceOfRevolution_type& x)
    {
      this->BaseSurfaceOfRevolution_.set (x);
    }

    void SurfaceOfRevolutionTransformType::
    BaseSurfaceOfRevolution (::std::auto_ptr< BaseSurfaceOfRevolution_type > x)
    {
      this->BaseSurfaceOfRevolution_.set (x);
    }

    const SurfaceOfRevolutionTransformType::Transformation_type& SurfaceOfRevolutionTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    SurfaceOfRevolutionTransformType::Transformation_type& SurfaceOfRevolutionTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void SurfaceOfRevolutionTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void SurfaceOfRevolutionTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // SurfaceOfRevolutionCheckedType
    // 

    const SurfaceOfRevolutionCheckedType::Measured_optional& SurfaceOfRevolutionCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    SurfaceOfRevolutionCheckedType::Measured_optional& SurfaceOfRevolutionCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void SurfaceOfRevolutionCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void SurfaceOfRevolutionCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void SurfaceOfRevolutionCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const SurfaceOfRevolutionCheckedType::Constructed_optional& SurfaceOfRevolutionCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    SurfaceOfRevolutionCheckedType::Constructed_optional& SurfaceOfRevolutionCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void SurfaceOfRevolutionCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void SurfaceOfRevolutionCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void SurfaceOfRevolutionCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // SurfaceOfRevolutionCheckedFeatureType
    // 

    const SurfaceOfRevolutionCheckedFeatureType::CheckDetails_optional& SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    SurfaceOfRevolutionCheckedFeatureType::CheckDetails_optional& SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // SurfaceOfRevolutionActualDeterminationType
    // 

    const SurfaceOfRevolutionActualDeterminationType::Checked_optional& SurfaceOfRevolutionActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    SurfaceOfRevolutionActualDeterminationType::Checked_optional& SurfaceOfRevolutionActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const SurfaceOfRevolutionActualDeterminationType::Set_optional& SurfaceOfRevolutionActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    SurfaceOfRevolutionActualDeterminationType::Set_optional& SurfaceOfRevolutionActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void SurfaceOfRevolutionActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // SurfaceOfRevolutionFeatureItemType
    // 

    const SurfaceOfRevolutionFeatureItemType::DeterminationMode_type& SurfaceOfRevolutionFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    SurfaceOfRevolutionFeatureItemType::DeterminationMode_type& SurfaceOfRevolutionFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void SurfaceOfRevolutionFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void SurfaceOfRevolutionFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const SurfaceOfRevolutionFeatureItemType::SubstituteFeatureAlgorithm_optional& SurfaceOfRevolutionFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    SurfaceOfRevolutionFeatureItemType::SubstituteFeatureAlgorithm_optional& SurfaceOfRevolutionFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void SurfaceOfRevolutionFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void SurfaceOfRevolutionFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void SurfaceOfRevolutionFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // SurfaceOfRevolutionFeatureDefinitionType
    // 

    const SurfaceOfRevolutionFeatureDefinitionType::InternalExternal_type& SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    SurfaceOfRevolutionFeatureDefinitionType::InternalExternal_type& SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const SurfaceOfRevolutionFeatureDefinitionType::Length_optional& SurfaceOfRevolutionFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    SurfaceOfRevolutionFeatureDefinitionType::Length_optional& SurfaceOfRevolutionFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }


    // SurfaceOfRevolutionFeatureNominalType
    // 

    const SurfaceOfRevolutionFeatureNominalType::Axis_type& SurfaceOfRevolutionFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    SurfaceOfRevolutionFeatureNominalType::Axis_type& SurfaceOfRevolutionFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const SurfaceOfRevolutionFeatureNominalType::Sweep_optional& SurfaceOfRevolutionFeatureNominalType::
    Sweep () const
    {
      return this->Sweep_;
    }

    SurfaceOfRevolutionFeatureNominalType::Sweep_optional& SurfaceOfRevolutionFeatureNominalType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void SurfaceOfRevolutionFeatureNominalType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const SurfaceOfRevolutionFeatureNominalType::ReferenceFeatureNominalId_type& SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId () const
    {
      return this->ReferenceFeatureNominalId_.get ();
    }

    SurfaceOfRevolutionFeatureNominalType::ReferenceFeatureNominalId_type& SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId ()
    {
      return this->ReferenceFeatureNominalId_.get ();
    }

    void SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId (const ReferenceFeatureNominalId_type& x)
    {
      this->ReferenceFeatureNominalId_.set (x);
    }

    void SurfaceOfRevolutionFeatureNominalType::
    ReferenceFeatureNominalId (::std::auto_ptr< ReferenceFeatureNominalId_type > x)
    {
      this->ReferenceFeatureNominalId_.set (x);
    }


    // SurfaceOfRevolutionFeatureActualType
    // 

    const SurfaceOfRevolutionFeatureActualType::Axis_optional& SurfaceOfRevolutionFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    SurfaceOfRevolutionFeatureActualType::Axis_optional& SurfaceOfRevolutionFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void SurfaceOfRevolutionFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const SurfaceOfRevolutionFeatureActualType::Sweep_optional& SurfaceOfRevolutionFeatureActualType::
    Sweep () const
    {
      return this->Sweep_;
    }

    SurfaceOfRevolutionFeatureActualType::Sweep_optional& SurfaceOfRevolutionFeatureActualType::
    Sweep ()
    {
      return this->Sweep_;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Sweep (const Sweep_type& x)
    {
      this->Sweep_.set (x);
    }

    void SurfaceOfRevolutionFeatureActualType::
    Sweep (const Sweep_optional& x)
    {
      this->Sweep_ = x;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Sweep (::std::auto_ptr< Sweep_type > x)
    {
      this->Sweep_.set (x);
    }

    const SurfaceOfRevolutionFeatureActualType::Length_optional& SurfaceOfRevolutionFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    SurfaceOfRevolutionFeatureActualType::Length_optional& SurfaceOfRevolutionFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void SurfaceOfRevolutionFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const SurfaceOfRevolutionFeatureActualType::Form_optional& SurfaceOfRevolutionFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    SurfaceOfRevolutionFeatureActualType::Form_optional& SurfaceOfRevolutionFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void SurfaceOfRevolutionFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void SurfaceOfRevolutionFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // ThreadedFeatureConstructionMethodType
    // 

    const ThreadedFeatureConstructionMethodType::BestFit_optional& ThreadedFeatureConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ThreadedFeatureConstructionMethodType::BestFit_optional& ThreadedFeatureConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ThreadedFeatureConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ThreadedFeatureConstructionMethodType::Recompensated_optional& ThreadedFeatureConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ThreadedFeatureConstructionMethodType::Recompensated_optional& ThreadedFeatureConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ThreadedFeatureConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ThreadedFeatureConstructionMethodType::Copy_optional& ThreadedFeatureConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ThreadedFeatureConstructionMethodType::Copy_optional& ThreadedFeatureConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ThreadedFeatureConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ThreadedFeatureConstructionMethodType::Cast_optional& ThreadedFeatureConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ThreadedFeatureConstructionMethodType::Cast_optional& ThreadedFeatureConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ThreadedFeatureConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ThreadedFeatureConstructionMethodType::Transform_optional& ThreadedFeatureConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ThreadedFeatureConstructionMethodType::Transform_optional& ThreadedFeatureConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ThreadedFeatureConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const ThreadedFeatureConstructionMethodType::FromCylinder_optional& ThreadedFeatureConstructionMethodType::
    FromCylinder () const
    {
      return this->FromCylinder_;
    }

    ThreadedFeatureConstructionMethodType::FromCylinder_optional& ThreadedFeatureConstructionMethodType::
    FromCylinder ()
    {
      return this->FromCylinder_;
    }

    void ThreadedFeatureConstructionMethodType::
    FromCylinder (const FromCylinder_type& x)
    {
      this->FromCylinder_.set (x);
    }

    void ThreadedFeatureConstructionMethodType::
    FromCylinder (const FromCylinder_optional& x)
    {
      this->FromCylinder_ = x;
    }

    void ThreadedFeatureConstructionMethodType::
    FromCylinder (::std::auto_ptr< FromCylinder_type > x)
    {
      this->FromCylinder_.set (x);
    }


    // ThreadedFeatureBestFitType
    // 

    const ThreadedFeatureBestFitType::BaseFeature_sequence& ThreadedFeatureBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ThreadedFeatureBestFitType::BaseFeature_sequence& ThreadedFeatureBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ThreadedFeatureBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ThreadedFeatureRecompType
    // 

    const ThreadedFeatureRecompType::BaseFeaturePointList_type& ThreadedFeatureRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ThreadedFeatureRecompType::BaseFeaturePointList_type& ThreadedFeatureRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ThreadedFeatureRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ThreadedFeatureRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ThreadedFeatureCopyType
    // 

    const ThreadedFeatureCopyType::BaseThreadedFeature_type& ThreadedFeatureCopyType::
    BaseThreadedFeature () const
    {
      return this->BaseThreadedFeature_.get ();
    }

    ThreadedFeatureCopyType::BaseThreadedFeature_type& ThreadedFeatureCopyType::
    BaseThreadedFeature ()
    {
      return this->BaseThreadedFeature_.get ();
    }

    void ThreadedFeatureCopyType::
    BaseThreadedFeature (const BaseThreadedFeature_type& x)
    {
      this->BaseThreadedFeature_.set (x);
    }

    void ThreadedFeatureCopyType::
    BaseThreadedFeature (::std::auto_ptr< BaseThreadedFeature_type > x)
    {
      this->BaseThreadedFeature_.set (x);
    }


    // ThreadedFeatureCastType
    // 

    const ThreadedFeatureCastType::BaseFeature_type& ThreadedFeatureCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ThreadedFeatureCastType::BaseFeature_type& ThreadedFeatureCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ThreadedFeatureCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ThreadedFeatureCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ThreadedFeatureTransformType
    // 

    const ThreadedFeatureTransformType::BaseThreadedFeature_type& ThreadedFeatureTransformType::
    BaseThreadedFeature () const
    {
      return this->BaseThreadedFeature_.get ();
    }

    ThreadedFeatureTransformType::BaseThreadedFeature_type& ThreadedFeatureTransformType::
    BaseThreadedFeature ()
    {
      return this->BaseThreadedFeature_.get ();
    }

    void ThreadedFeatureTransformType::
    BaseThreadedFeature (const BaseThreadedFeature_type& x)
    {
      this->BaseThreadedFeature_.set (x);
    }

    void ThreadedFeatureTransformType::
    BaseThreadedFeature (::std::auto_ptr< BaseThreadedFeature_type > x)
    {
      this->BaseThreadedFeature_.set (x);
    }

    const ThreadedFeatureTransformType::Transformation_type& ThreadedFeatureTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ThreadedFeatureTransformType::Transformation_type& ThreadedFeatureTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ThreadedFeatureTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ThreadedFeatureTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ThreadedFeatureFromCylinderType
    // 

    const ThreadedFeatureFromCylinderType::BaseCylinder_type& ThreadedFeatureFromCylinderType::
    BaseCylinder () const
    {
      return this->BaseCylinder_.get ();
    }

    ThreadedFeatureFromCylinderType::BaseCylinder_type& ThreadedFeatureFromCylinderType::
    BaseCylinder ()
    {
      return this->BaseCylinder_.get ();
    }

    void ThreadedFeatureFromCylinderType::
    BaseCylinder (const BaseCylinder_type& x)
    {
      this->BaseCylinder_.set (x);
    }

    void ThreadedFeatureFromCylinderType::
    BaseCylinder (::std::auto_ptr< BaseCylinder_type > x)
    {
      this->BaseCylinder_.set (x);
    }

    const ThreadedFeatureFromCylinderType::Offset_optional& ThreadedFeatureFromCylinderType::
    Offset () const
    {
      return this->Offset_;
    }

    ThreadedFeatureFromCylinderType::Offset_optional& ThreadedFeatureFromCylinderType::
    Offset ()
    {
      return this->Offset_;
    }

    void ThreadedFeatureFromCylinderType::
    Offset (const Offset_type& x)
    {
      this->Offset_.set (x);
    }

    void ThreadedFeatureFromCylinderType::
    Offset (const Offset_optional& x)
    {
      this->Offset_ = x;
    }

    void ThreadedFeatureFromCylinderType::
    Offset (::std::auto_ptr< Offset_type > x)
    {
      this->Offset_.set (x);
    }


    // ThreadedFeatureCheckedType
    // 

    const ThreadedFeatureCheckedType::Measured_optional& ThreadedFeatureCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ThreadedFeatureCheckedType::Measured_optional& ThreadedFeatureCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ThreadedFeatureCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ThreadedFeatureCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ThreadedFeatureCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ThreadedFeatureCheckedType::Constructed_optional& ThreadedFeatureCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ThreadedFeatureCheckedType::Constructed_optional& ThreadedFeatureCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ThreadedFeatureCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ThreadedFeatureCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ThreadedFeatureCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ThreadedFeatureCheckedFeatureType
    // 

    const ThreadedFeatureCheckedFeatureType::CheckDetails_optional& ThreadedFeatureCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ThreadedFeatureCheckedFeatureType::CheckDetails_optional& ThreadedFeatureCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ThreadedFeatureCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ThreadedFeatureCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ThreadedFeatureCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ThreadedFeatureActualDeterminationType
    // 

    const ThreadedFeatureActualDeterminationType::Checked_optional& ThreadedFeatureActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ThreadedFeatureActualDeterminationType::Checked_optional& ThreadedFeatureActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ThreadedFeatureActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ThreadedFeatureActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ThreadedFeatureActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ThreadedFeatureActualDeterminationType::Set_optional& ThreadedFeatureActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ThreadedFeatureActualDeterminationType::Set_optional& ThreadedFeatureActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ThreadedFeatureActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ThreadedFeatureActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ThreadedFeatureActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ThreadedFeatureItemType
    // 

    const ThreadedFeatureItemType::DeterminationMode_type& ThreadedFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ThreadedFeatureItemType::DeterminationMode_type& ThreadedFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ThreadedFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ThreadedFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ThreadedFeatureItemType::SubstituteFeatureAlgorithm_optional& ThreadedFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ThreadedFeatureItemType::SubstituteFeatureAlgorithm_optional& ThreadedFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ThreadedFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ThreadedFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ThreadedFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ThreadedFeatureDefinitionType
    // 

    const ThreadedFeatureDefinitionType::InternalExternal_type& ThreadedFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ThreadedFeatureDefinitionType::InternalExternal_type& ThreadedFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ThreadedFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ThreadedFeatureDefinitionType::ThreadSpecificationId_type& ThreadedFeatureDefinitionType::
    ThreadSpecificationId () const
    {
      return this->ThreadSpecificationId_.get ();
    }

    ThreadedFeatureDefinitionType::ThreadSpecificationId_type& ThreadedFeatureDefinitionType::
    ThreadSpecificationId ()
    {
      return this->ThreadSpecificationId_.get ();
    }

    void ThreadedFeatureDefinitionType::
    ThreadSpecificationId (const ThreadSpecificationId_type& x)
    {
      this->ThreadSpecificationId_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    ThreadSpecificationId (::std::auto_ptr< ThreadSpecificationId_type > x)
    {
      this->ThreadSpecificationId_.set (x);
    }

    const ThreadedFeatureDefinitionType::Length_optional& ThreadedFeatureDefinitionType::
    Length () const
    {
      return this->Length_;
    }

    ThreadedFeatureDefinitionType::Length_optional& ThreadedFeatureDefinitionType::
    Length ()
    {
      return this->Length_;
    }

    void ThreadedFeatureDefinitionType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ThreadedFeatureDefinitionType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }

    const ThreadedFeatureDefinitionType::Bottom_optional& ThreadedFeatureDefinitionType::
    Bottom () const
    {
      return this->Bottom_;
    }

    ThreadedFeatureDefinitionType::Bottom_optional& ThreadedFeatureDefinitionType::
    Bottom ()
    {
      return this->Bottom_;
    }

    void ThreadedFeatureDefinitionType::
    Bottom (const Bottom_type& x)
    {
      this->Bottom_.set (x);
    }

    void ThreadedFeatureDefinitionType::
    Bottom (const Bottom_optional& x)
    {
      this->Bottom_ = x;
    }

    void ThreadedFeatureDefinitionType::
    Bottom (::std::auto_ptr< Bottom_type > x)
    {
      this->Bottom_.set (x);
    }


    // ThreadedFeatureNominalType
    // 

    const ThreadedFeatureNominalType::Axis_type& ThreadedFeatureNominalType::
    Axis () const
    {
      return this->Axis_.get ();
    }

    ThreadedFeatureNominalType::Axis_type& ThreadedFeatureNominalType::
    Axis ()
    {
      return this->Axis_.get ();
    }

    void ThreadedFeatureNominalType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ThreadedFeatureNominalType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }


    // ThreadedFeatureActualType
    // 

    const ThreadedFeatureActualType::Axis_optional& ThreadedFeatureActualType::
    Axis () const
    {
      return this->Axis_;
    }

    ThreadedFeatureActualType::Axis_optional& ThreadedFeatureActualType::
    Axis ()
    {
      return this->Axis_;
    }

    void ThreadedFeatureActualType::
    Axis (const Axis_type& x)
    {
      this->Axis_.set (x);
    }

    void ThreadedFeatureActualType::
    Axis (const Axis_optional& x)
    {
      this->Axis_ = x;
    }

    void ThreadedFeatureActualType::
    Axis (::std::auto_ptr< Axis_type > x)
    {
      this->Axis_.set (x);
    }

    const ThreadedFeatureActualType::PitchDiameter_optional& ThreadedFeatureActualType::
    PitchDiameter () const
    {
      return this->PitchDiameter_;
    }

    ThreadedFeatureActualType::PitchDiameter_optional& ThreadedFeatureActualType::
    PitchDiameter ()
    {
      return this->PitchDiameter_;
    }

    void ThreadedFeatureActualType::
    PitchDiameter (const PitchDiameter_type& x)
    {
      this->PitchDiameter_.set (x);
    }

    void ThreadedFeatureActualType::
    PitchDiameter (const PitchDiameter_optional& x)
    {
      this->PitchDiameter_ = x;
    }

    void ThreadedFeatureActualType::
    PitchDiameter (::std::auto_ptr< PitchDiameter_type > x)
    {
      this->PitchDiameter_.set (x);
    }

    const ThreadedFeatureActualType::FunctionalSize_optional& ThreadedFeatureActualType::
    FunctionalSize () const
    {
      return this->FunctionalSize_;
    }

    ThreadedFeatureActualType::FunctionalSize_optional& ThreadedFeatureActualType::
    FunctionalSize ()
    {
      return this->FunctionalSize_;
    }

    void ThreadedFeatureActualType::
    FunctionalSize (const FunctionalSize_type& x)
    {
      this->FunctionalSize_.set (x);
    }

    void ThreadedFeatureActualType::
    FunctionalSize (const FunctionalSize_optional& x)
    {
      this->FunctionalSize_ = x;
    }

    void ThreadedFeatureActualType::
    FunctionalSize (::std::auto_ptr< FunctionalSize_type > x)
    {
      this->FunctionalSize_.set (x);
    }

    const ThreadedFeatureActualType::Length_optional& ThreadedFeatureActualType::
    Length () const
    {
      return this->Length_;
    }

    ThreadedFeatureActualType::Length_optional& ThreadedFeatureActualType::
    Length ()
    {
      return this->Length_;
    }

    void ThreadedFeatureActualType::
    Length (const Length_type& x)
    {
      this->Length_.set (x);
    }

    void ThreadedFeatureActualType::
    Length (const Length_optional& x)
    {
      this->Length_ = x;
    }

    void ThreadedFeatureActualType::
    Length (::std::auto_ptr< Length_type > x)
    {
      this->Length_.set (x);
    }


    // ToroidalSegmentConstructionMethodType
    // 

    const ToroidalSegmentConstructionMethodType::BestFit_optional& ToroidalSegmentConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    ToroidalSegmentConstructionMethodType::BestFit_optional& ToroidalSegmentConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void ToroidalSegmentConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const ToroidalSegmentConstructionMethodType::Recompensated_optional& ToroidalSegmentConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    ToroidalSegmentConstructionMethodType::Recompensated_optional& ToroidalSegmentConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void ToroidalSegmentConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const ToroidalSegmentConstructionMethodType::Copy_optional& ToroidalSegmentConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    ToroidalSegmentConstructionMethodType::Copy_optional& ToroidalSegmentConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void ToroidalSegmentConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const ToroidalSegmentConstructionMethodType::Cast_optional& ToroidalSegmentConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    ToroidalSegmentConstructionMethodType::Cast_optional& ToroidalSegmentConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void ToroidalSegmentConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const ToroidalSegmentConstructionMethodType::Transform_optional& ToroidalSegmentConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    ToroidalSegmentConstructionMethodType::Transform_optional& ToroidalSegmentConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void ToroidalSegmentConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void ToroidalSegmentConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void ToroidalSegmentConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }


    // ToroidalSegmentBestFitType
    // 

    const ToroidalSegmentBestFitType::BaseFeature_sequence& ToroidalSegmentBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    ToroidalSegmentBestFitType::BaseFeature_sequence& ToroidalSegmentBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void ToroidalSegmentBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // ToroidalSegmentRecompType
    // 

    const ToroidalSegmentRecompType::BaseFeaturePointList_type& ToroidalSegmentRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    ToroidalSegmentRecompType::BaseFeaturePointList_type& ToroidalSegmentRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void ToroidalSegmentRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void ToroidalSegmentRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // ToroidalSegmentCopyType
    // 

    const ToroidalSegmentCopyType::BaseToroidalSegment_type& ToroidalSegmentCopyType::
    BaseToroidalSegment () const
    {
      return this->BaseToroidalSegment_.get ();
    }

    ToroidalSegmentCopyType::BaseToroidalSegment_type& ToroidalSegmentCopyType::
    BaseToroidalSegment ()
    {
      return this->BaseToroidalSegment_.get ();
    }

    void ToroidalSegmentCopyType::
    BaseToroidalSegment (const BaseToroidalSegment_type& x)
    {
      this->BaseToroidalSegment_.set (x);
    }

    void ToroidalSegmentCopyType::
    BaseToroidalSegment (::std::auto_ptr< BaseToroidalSegment_type > x)
    {
      this->BaseToroidalSegment_.set (x);
    }


    // ToroidalSegmentCastType
    // 

    const ToroidalSegmentCastType::BaseFeature_type& ToroidalSegmentCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    ToroidalSegmentCastType::BaseFeature_type& ToroidalSegmentCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void ToroidalSegmentCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void ToroidalSegmentCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // ToroidalSegmentTransformType
    // 

    const ToroidalSegmentTransformType::BaseToroidalSegment_type& ToroidalSegmentTransformType::
    BaseToroidalSegment () const
    {
      return this->BaseToroidalSegment_.get ();
    }

    ToroidalSegmentTransformType::BaseToroidalSegment_type& ToroidalSegmentTransformType::
    BaseToroidalSegment ()
    {
      return this->BaseToroidalSegment_.get ();
    }

    void ToroidalSegmentTransformType::
    BaseToroidalSegment (const BaseToroidalSegment_type& x)
    {
      this->BaseToroidalSegment_.set (x);
    }

    void ToroidalSegmentTransformType::
    BaseToroidalSegment (::std::auto_ptr< BaseToroidalSegment_type > x)
    {
      this->BaseToroidalSegment_.set (x);
    }

    const ToroidalSegmentTransformType::Transformation_type& ToroidalSegmentTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    ToroidalSegmentTransformType::Transformation_type& ToroidalSegmentTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void ToroidalSegmentTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void ToroidalSegmentTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // ToroidalSegmentCheckedType
    // 

    const ToroidalSegmentCheckedType::Measured_optional& ToroidalSegmentCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    ToroidalSegmentCheckedType::Measured_optional& ToroidalSegmentCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void ToroidalSegmentCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void ToroidalSegmentCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void ToroidalSegmentCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const ToroidalSegmentCheckedType::Constructed_optional& ToroidalSegmentCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    ToroidalSegmentCheckedType::Constructed_optional& ToroidalSegmentCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void ToroidalSegmentCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void ToroidalSegmentCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void ToroidalSegmentCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // ToroidalSegmentCheckedFeatureType
    // 

    const ToroidalSegmentCheckedFeatureType::CheckDetails_optional& ToroidalSegmentCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    ToroidalSegmentCheckedFeatureType::CheckDetails_optional& ToroidalSegmentCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void ToroidalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void ToroidalSegmentCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void ToroidalSegmentCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // ToroidalSegmentActualDeterminationType
    // 

    const ToroidalSegmentActualDeterminationType::Checked_optional& ToroidalSegmentActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    ToroidalSegmentActualDeterminationType::Checked_optional& ToroidalSegmentActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void ToroidalSegmentActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void ToroidalSegmentActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void ToroidalSegmentActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const ToroidalSegmentActualDeterminationType::Set_optional& ToroidalSegmentActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    ToroidalSegmentActualDeterminationType::Set_optional& ToroidalSegmentActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void ToroidalSegmentActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void ToroidalSegmentActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void ToroidalSegmentActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // ToroidalSegmentFeatureItemType
    // 

    const ToroidalSegmentFeatureItemType::DeterminationMode_type& ToroidalSegmentFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    ToroidalSegmentFeatureItemType::DeterminationMode_type& ToroidalSegmentFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void ToroidalSegmentFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void ToroidalSegmentFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const ToroidalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& ToroidalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    ToroidalSegmentFeatureItemType::SubstituteFeatureAlgorithm_optional& ToroidalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void ToroidalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void ToroidalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void ToroidalSegmentFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // ToroidalSegmentFeatureDefinitionType
    // 

    const ToroidalSegmentFeatureDefinitionType::InternalExternal_type& ToroidalSegmentFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    ToroidalSegmentFeatureDefinitionType::InternalExternal_type& ToroidalSegmentFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void ToroidalSegmentFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void ToroidalSegmentFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const ToroidalSegmentFeatureDefinitionType::MinorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MinorDiameter () const
    {
      return this->MinorDiameter_.get ();
    }

    ToroidalSegmentFeatureDefinitionType::MinorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MinorDiameter ()
    {
      return this->MinorDiameter_.get ();
    }

    void ToroidalSegmentFeatureDefinitionType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureDefinitionType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }

    const ToroidalSegmentFeatureDefinitionType::MajorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MajorDiameter () const
    {
      return this->MajorDiameter_.get ();
    }

    ToroidalSegmentFeatureDefinitionType::MajorDiameter_type& ToroidalSegmentFeatureDefinitionType::
    MajorDiameter ()
    {
      return this->MajorDiameter_.get ();
    }

    void ToroidalSegmentFeatureDefinitionType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureDefinitionType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }


    // ToroidalSegmentFeatureNominalType
    // 

    const ToroidalSegmentFeatureNominalType::Location_type& ToroidalSegmentFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    ToroidalSegmentFeatureNominalType::Location_type& ToroidalSegmentFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void ToroidalSegmentFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void ToroidalSegmentFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const ToroidalSegmentFeatureNominalType::AxisVector_type& ToroidalSegmentFeatureNominalType::
    AxisVector () const
    {
      return this->AxisVector_.get ();
    }

    ToroidalSegmentFeatureNominalType::AxisVector_type& ToroidalSegmentFeatureNominalType::
    AxisVector ()
    {
      return this->AxisVector_.get ();
    }

    void ToroidalSegmentFeatureNominalType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void ToroidalSegmentFeatureNominalType::
    AxisVector (::std::auto_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (x);
    }

    const ToroidalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    ToroidalSegmentFeatureNominalType::LatitudeLongitudeSweep_type& ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_.get ();
    }

    void ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void ToroidalSegmentFeatureNominalType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }


    // ToroidalSegmentFeatureActualType
    // 

    const ToroidalSegmentFeatureActualType::Location_optional& ToroidalSegmentFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    ToroidalSegmentFeatureActualType::Location_optional& ToroidalSegmentFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void ToroidalSegmentFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const ToroidalSegmentFeatureActualType::AxisVector_optional& ToroidalSegmentFeatureActualType::
    AxisVector () const
    {
      return this->AxisVector_;
    }

    ToroidalSegmentFeatureActualType::AxisVector_optional& ToroidalSegmentFeatureActualType::
    AxisVector ()
    {
      return this->AxisVector_;
    }

    void ToroidalSegmentFeatureActualType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    AxisVector (const AxisVector_optional& x)
    {
      this->AxisVector_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    AxisVector (::std::auto_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (x);
    }

    const ToroidalSegmentFeatureActualType::MinorDiameter_optional& ToroidalSegmentFeatureActualType::
    MinorDiameter () const
    {
      return this->MinorDiameter_;
    }

    ToroidalSegmentFeatureActualType::MinorDiameter_optional& ToroidalSegmentFeatureActualType::
    MinorDiameter ()
    {
      return this->MinorDiameter_;
    }

    void ToroidalSegmentFeatureActualType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    MinorDiameter (const MinorDiameter_optional& x)
    {
      this->MinorDiameter_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }

    const ToroidalSegmentFeatureActualType::MajorDiameter_optional& ToroidalSegmentFeatureActualType::
    MajorDiameter () const
    {
      return this->MajorDiameter_;
    }

    ToroidalSegmentFeatureActualType::MajorDiameter_optional& ToroidalSegmentFeatureActualType::
    MajorDiameter ()
    {
      return this->MajorDiameter_;
    }

    void ToroidalSegmentFeatureActualType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    MajorDiameter (const MajorDiameter_optional& x)
    {
      this->MajorDiameter_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }

    const ToroidalSegmentFeatureActualType::LatitudeLongitudeSweep_optional& ToroidalSegmentFeatureActualType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    ToroidalSegmentFeatureActualType::LatitudeLongitudeSweep_optional& ToroidalSegmentFeatureActualType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void ToroidalSegmentFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    const ToroidalSegmentFeatureActualType::Form_optional& ToroidalSegmentFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    ToroidalSegmentFeatureActualType::Form_optional& ToroidalSegmentFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void ToroidalSegmentFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void ToroidalSegmentFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void ToroidalSegmentFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // TorusConstructionMethodType
    // 

    const TorusConstructionMethodType::BestFit_optional& TorusConstructionMethodType::
    BestFit () const
    {
      return this->BestFit_;
    }

    TorusConstructionMethodType::BestFit_optional& TorusConstructionMethodType::
    BestFit ()
    {
      return this->BestFit_;
    }

    void TorusConstructionMethodType::
    BestFit (const BestFit_type& x)
    {
      this->BestFit_.set (x);
    }

    void TorusConstructionMethodType::
    BestFit (const BestFit_optional& x)
    {
      this->BestFit_ = x;
    }

    void TorusConstructionMethodType::
    BestFit (::std::auto_ptr< BestFit_type > x)
    {
      this->BestFit_.set (x);
    }

    const TorusConstructionMethodType::Recompensated_optional& TorusConstructionMethodType::
    Recompensated () const
    {
      return this->Recompensated_;
    }

    TorusConstructionMethodType::Recompensated_optional& TorusConstructionMethodType::
    Recompensated ()
    {
      return this->Recompensated_;
    }

    void TorusConstructionMethodType::
    Recompensated (const Recompensated_type& x)
    {
      this->Recompensated_.set (x);
    }

    void TorusConstructionMethodType::
    Recompensated (const Recompensated_optional& x)
    {
      this->Recompensated_ = x;
    }

    void TorusConstructionMethodType::
    Recompensated (::std::auto_ptr< Recompensated_type > x)
    {
      this->Recompensated_.set (x);
    }

    const TorusConstructionMethodType::Copy_optional& TorusConstructionMethodType::
    Copy () const
    {
      return this->Copy_;
    }

    TorusConstructionMethodType::Copy_optional& TorusConstructionMethodType::
    Copy ()
    {
      return this->Copy_;
    }

    void TorusConstructionMethodType::
    Copy (const Copy_type& x)
    {
      this->Copy_.set (x);
    }

    void TorusConstructionMethodType::
    Copy (const Copy_optional& x)
    {
      this->Copy_ = x;
    }

    void TorusConstructionMethodType::
    Copy (::std::auto_ptr< Copy_type > x)
    {
      this->Copy_.set (x);
    }

    const TorusConstructionMethodType::Cast_optional& TorusConstructionMethodType::
    Cast () const
    {
      return this->Cast_;
    }

    TorusConstructionMethodType::Cast_optional& TorusConstructionMethodType::
    Cast ()
    {
      return this->Cast_;
    }

    void TorusConstructionMethodType::
    Cast (const Cast_type& x)
    {
      this->Cast_.set (x);
    }

    void TorusConstructionMethodType::
    Cast (const Cast_optional& x)
    {
      this->Cast_ = x;
    }

    void TorusConstructionMethodType::
    Cast (::std::auto_ptr< Cast_type > x)
    {
      this->Cast_.set (x);
    }

    const TorusConstructionMethodType::Transform_optional& TorusConstructionMethodType::
    Transform () const
    {
      return this->Transform_;
    }

    TorusConstructionMethodType::Transform_optional& TorusConstructionMethodType::
    Transform ()
    {
      return this->Transform_;
    }

    void TorusConstructionMethodType::
    Transform (const Transform_type& x)
    {
      this->Transform_.set (x);
    }

    void TorusConstructionMethodType::
    Transform (const Transform_optional& x)
    {
      this->Transform_ = x;
    }

    void TorusConstructionMethodType::
    Transform (::std::auto_ptr< Transform_type > x)
    {
      this->Transform_.set (x);
    }

    const TorusConstructionMethodType::FromScan_optional& TorusConstructionMethodType::
    FromScan () const
    {
      return this->FromScan_;
    }

    TorusConstructionMethodType::FromScan_optional& TorusConstructionMethodType::
    FromScan ()
    {
      return this->FromScan_;
    }

    void TorusConstructionMethodType::
    FromScan (const FromScan_type& x)
    {
      this->FromScan_.set (x);
    }

    void TorusConstructionMethodType::
    FromScan (const FromScan_optional& x)
    {
      this->FromScan_ = x;
    }

    void TorusConstructionMethodType::
    FromScan (::std::auto_ptr< FromScan_type > x)
    {
      this->FromScan_.set (x);
    }


    // TorusBestFitType
    // 

    const TorusBestFitType::BaseFeature_sequence& TorusBestFitType::
    BaseFeature () const
    {
      return this->BaseFeature_;
    }

    TorusBestFitType::BaseFeature_sequence& TorusBestFitType::
    BaseFeature ()
    {
      return this->BaseFeature_;
    }

    void TorusBestFitType::
    BaseFeature (const BaseFeature_sequence& s)
    {
      this->BaseFeature_ = s;
    }


    // TorusRecompType
    // 

    const TorusRecompType::BaseFeaturePointList_type& TorusRecompType::
    BaseFeaturePointList () const
    {
      return this->BaseFeaturePointList_.get ();
    }

    TorusRecompType::BaseFeaturePointList_type& TorusRecompType::
    BaseFeaturePointList ()
    {
      return this->BaseFeaturePointList_.get ();
    }

    void TorusRecompType::
    BaseFeaturePointList (const BaseFeaturePointList_type& x)
    {
      this->BaseFeaturePointList_.set (x);
    }

    void TorusRecompType::
    BaseFeaturePointList (::std::auto_ptr< BaseFeaturePointList_type > x)
    {
      this->BaseFeaturePointList_.set (x);
    }


    // TorusCopyType
    // 

    const TorusCopyType::BaseTorus_type& TorusCopyType::
    BaseTorus () const
    {
      return this->BaseTorus_.get ();
    }

    TorusCopyType::BaseTorus_type& TorusCopyType::
    BaseTorus ()
    {
      return this->BaseTorus_.get ();
    }

    void TorusCopyType::
    BaseTorus (const BaseTorus_type& x)
    {
      this->BaseTorus_.set (x);
    }

    void TorusCopyType::
    BaseTorus (::std::auto_ptr< BaseTorus_type > x)
    {
      this->BaseTorus_.set (x);
    }


    // TorusCastType
    // 

    const TorusCastType::BaseFeature_type& TorusCastType::
    BaseFeature () const
    {
      return this->BaseFeature_.get ();
    }

    TorusCastType::BaseFeature_type& TorusCastType::
    BaseFeature ()
    {
      return this->BaseFeature_.get ();
    }

    void TorusCastType::
    BaseFeature (const BaseFeature_type& x)
    {
      this->BaseFeature_.set (x);
    }

    void TorusCastType::
    BaseFeature (::std::auto_ptr< BaseFeature_type > x)
    {
      this->BaseFeature_.set (x);
    }


    // TorusTransformType
    // 

    const TorusTransformType::BaseTorus_type& TorusTransformType::
    BaseTorus () const
    {
      return this->BaseTorus_.get ();
    }

    TorusTransformType::BaseTorus_type& TorusTransformType::
    BaseTorus ()
    {
      return this->BaseTorus_.get ();
    }

    void TorusTransformType::
    BaseTorus (const BaseTorus_type& x)
    {
      this->BaseTorus_.set (x);
    }

    void TorusTransformType::
    BaseTorus (::std::auto_ptr< BaseTorus_type > x)
    {
      this->BaseTorus_.set (x);
    }

    const TorusTransformType::Transformation_type& TorusTransformType::
    Transformation () const
    {
      return this->Transformation_.get ();
    }

    TorusTransformType::Transformation_type& TorusTransformType::
    Transformation ()
    {
      return this->Transformation_.get ();
    }

    void TorusTransformType::
    Transformation (const Transformation_type& x)
    {
      this->Transformation_.set (x);
    }

    void TorusTransformType::
    Transformation (::std::auto_ptr< Transformation_type > x)
    {
      this->Transformation_.set (x);
    }


    // TorusFromScanType
    // 

    const TorusFromScanType::SurfaceFeature_type& TorusFromScanType::
    SurfaceFeature () const
    {
      return this->SurfaceFeature_.get ();
    }

    TorusFromScanType::SurfaceFeature_type& TorusFromScanType::
    SurfaceFeature ()
    {
      return this->SurfaceFeature_.get ();
    }

    void TorusFromScanType::
    SurfaceFeature (const SurfaceFeature_type& x)
    {
      this->SurfaceFeature_.set (x);
    }

    void TorusFromScanType::
    SurfaceFeature (::std::auto_ptr< SurfaceFeature_type > x)
    {
      this->SurfaceFeature_.set (x);
    }

    const TorusFromScanType::SearchRadius_type& TorusFromScanType::
    SearchRadius () const
    {
      return this->SearchRadius_.get ();
    }

    TorusFromScanType::SearchRadius_type& TorusFromScanType::
    SearchRadius ()
    {
      return this->SearchRadius_.get ();
    }

    void TorusFromScanType::
    SearchRadius (const SearchRadius_type& x)
    {
      this->SearchRadius_.set (x);
    }

    void TorusFromScanType::
    SearchRadius (::std::auto_ptr< SearchRadius_type > x)
    {
      this->SearchRadius_.set (x);
    }


    // TorusCheckedType
    // 

    const TorusCheckedType::Measured_optional& TorusCheckedType::
    Measured () const
    {
      return this->Measured_;
    }

    TorusCheckedType::Measured_optional& TorusCheckedType::
    Measured ()
    {
      return this->Measured_;
    }

    void TorusCheckedType::
    Measured (const Measured_type& x)
    {
      this->Measured_.set (x);
    }

    void TorusCheckedType::
    Measured (const Measured_optional& x)
    {
      this->Measured_ = x;
    }

    void TorusCheckedType::
    Measured (::std::auto_ptr< Measured_type > x)
    {
      this->Measured_.set (x);
    }

    const TorusCheckedType::Constructed_optional& TorusCheckedType::
    Constructed () const
    {
      return this->Constructed_;
    }

    TorusCheckedType::Constructed_optional& TorusCheckedType::
    Constructed ()
    {
      return this->Constructed_;
    }

    void TorusCheckedType::
    Constructed (const Constructed_type& x)
    {
      this->Constructed_.set (x);
    }

    void TorusCheckedType::
    Constructed (const Constructed_optional& x)
    {
      this->Constructed_ = x;
    }

    void TorusCheckedType::
    Constructed (::std::auto_ptr< Constructed_type > x)
    {
      this->Constructed_.set (x);
    }


    // TorusCheckedFeatureType
    // 

    const TorusCheckedFeatureType::CheckDetails_optional& TorusCheckedFeatureType::
    CheckDetails () const
    {
      return this->CheckDetails_;
    }

    TorusCheckedFeatureType::CheckDetails_optional& TorusCheckedFeatureType::
    CheckDetails ()
    {
      return this->CheckDetails_;
    }

    void TorusCheckedFeatureType::
    CheckDetails (const CheckDetails_type& x)
    {
      this->CheckDetails_.set (x);
    }

    void TorusCheckedFeatureType::
    CheckDetails (const CheckDetails_optional& x)
    {
      this->CheckDetails_ = x;
    }

    void TorusCheckedFeatureType::
    CheckDetails (::std::auto_ptr< CheckDetails_type > x)
    {
      this->CheckDetails_.set (x);
    }


    // TorusActualDeterminationType
    // 

    const TorusActualDeterminationType::Checked_optional& TorusActualDeterminationType::
    Checked () const
    {
      return this->Checked_;
    }

    TorusActualDeterminationType::Checked_optional& TorusActualDeterminationType::
    Checked ()
    {
      return this->Checked_;
    }

    void TorusActualDeterminationType::
    Checked (const Checked_type& x)
    {
      this->Checked_.set (x);
    }

    void TorusActualDeterminationType::
    Checked (const Checked_optional& x)
    {
      this->Checked_ = x;
    }

    void TorusActualDeterminationType::
    Checked (::std::auto_ptr< Checked_type > x)
    {
      this->Checked_.set (x);
    }

    const TorusActualDeterminationType::Set_optional& TorusActualDeterminationType::
    Set () const
    {
      return this->Set_;
    }

    TorusActualDeterminationType::Set_optional& TorusActualDeterminationType::
    Set ()
    {
      return this->Set_;
    }

    void TorusActualDeterminationType::
    Set (const Set_type& x)
    {
      this->Set_.set (x);
    }

    void TorusActualDeterminationType::
    Set (const Set_optional& x)
    {
      this->Set_ = x;
    }

    void TorusActualDeterminationType::
    Set (::std::auto_ptr< Set_type > x)
    {
      this->Set_.set (x);
    }


    // TorusFeatureItemType
    // 

    const TorusFeatureItemType::DeterminationMode_type& TorusFeatureItemType::
    DeterminationMode () const
    {
      return this->DeterminationMode_.get ();
    }

    TorusFeatureItemType::DeterminationMode_type& TorusFeatureItemType::
    DeterminationMode ()
    {
      return this->DeterminationMode_.get ();
    }

    void TorusFeatureItemType::
    DeterminationMode (const DeterminationMode_type& x)
    {
      this->DeterminationMode_.set (x);
    }

    void TorusFeatureItemType::
    DeterminationMode (::std::auto_ptr< DeterminationMode_type > x)
    {
      this->DeterminationMode_.set (x);
    }

    const TorusFeatureItemType::SubstituteFeatureAlgorithm_optional& TorusFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    TorusFeatureItemType::SubstituteFeatureAlgorithm_optional& TorusFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void TorusFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void TorusFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void TorusFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // TorusFeatureDefinitionType
    // 

    const TorusFeatureDefinitionType::InternalExternal_type& TorusFeatureDefinitionType::
    InternalExternal () const
    {
      return this->InternalExternal_.get ();
    }

    TorusFeatureDefinitionType::InternalExternal_type& TorusFeatureDefinitionType::
    InternalExternal ()
    {
      return this->InternalExternal_.get ();
    }

    void TorusFeatureDefinitionType::
    InternalExternal (const InternalExternal_type& x)
    {
      this->InternalExternal_.set (x);
    }

    void TorusFeatureDefinitionType::
    InternalExternal (::std::auto_ptr< InternalExternal_type > x)
    {
      this->InternalExternal_.set (x);
    }

    const TorusFeatureDefinitionType::MinorDiameter_type& TorusFeatureDefinitionType::
    MinorDiameter () const
    {
      return this->MinorDiameter_.get ();
    }

    TorusFeatureDefinitionType::MinorDiameter_type& TorusFeatureDefinitionType::
    MinorDiameter ()
    {
      return this->MinorDiameter_.get ();
    }

    void TorusFeatureDefinitionType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void TorusFeatureDefinitionType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }

    const TorusFeatureDefinitionType::MajorDiameter_type& TorusFeatureDefinitionType::
    MajorDiameter () const
    {
      return this->MajorDiameter_.get ();
    }

    TorusFeatureDefinitionType::MajorDiameter_type& TorusFeatureDefinitionType::
    MajorDiameter ()
    {
      return this->MajorDiameter_.get ();
    }

    void TorusFeatureDefinitionType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void TorusFeatureDefinitionType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }


    // TorusFeatureNominalType
    // 

    const TorusFeatureNominalType::Location_type& TorusFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    TorusFeatureNominalType::Location_type& TorusFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void TorusFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void TorusFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const TorusFeatureNominalType::AxisVector_type& TorusFeatureNominalType::
    AxisVector () const
    {
      return this->AxisVector_.get ();
    }

    TorusFeatureNominalType::AxisVector_type& TorusFeatureNominalType::
    AxisVector ()
    {
      return this->AxisVector_.get ();
    }

    void TorusFeatureNominalType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void TorusFeatureNominalType::
    AxisVector (::std::auto_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (x);
    }

    const TorusFeatureNominalType::LatitudeLongitudeSweep_optional& TorusFeatureNominalType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    TorusFeatureNominalType::LatitudeLongitudeSweep_optional& TorusFeatureNominalType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void TorusFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void TorusFeatureNominalType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void TorusFeatureNominalType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }


    // TorusFeatureActualType
    // 

    const TorusFeatureActualType::Location_optional& TorusFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    TorusFeatureActualType::Location_optional& TorusFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void TorusFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void TorusFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void TorusFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const TorusFeatureActualType::AxisVector_optional& TorusFeatureActualType::
    AxisVector () const
    {
      return this->AxisVector_;
    }

    TorusFeatureActualType::AxisVector_optional& TorusFeatureActualType::
    AxisVector ()
    {
      return this->AxisVector_;
    }

    void TorusFeatureActualType::
    AxisVector (const AxisVector_type& x)
    {
      this->AxisVector_.set (x);
    }

    void TorusFeatureActualType::
    AxisVector (const AxisVector_optional& x)
    {
      this->AxisVector_ = x;
    }

    void TorusFeatureActualType::
    AxisVector (::std::auto_ptr< AxisVector_type > x)
    {
      this->AxisVector_.set (x);
    }

    const TorusFeatureActualType::MinorDiameter_optional& TorusFeatureActualType::
    MinorDiameter () const
    {
      return this->MinorDiameter_;
    }

    TorusFeatureActualType::MinorDiameter_optional& TorusFeatureActualType::
    MinorDiameter ()
    {
      return this->MinorDiameter_;
    }

    void TorusFeatureActualType::
    MinorDiameter (const MinorDiameter_type& x)
    {
      this->MinorDiameter_.set (x);
    }

    void TorusFeatureActualType::
    MinorDiameter (const MinorDiameter_optional& x)
    {
      this->MinorDiameter_ = x;
    }

    void TorusFeatureActualType::
    MinorDiameter (::std::auto_ptr< MinorDiameter_type > x)
    {
      this->MinorDiameter_.set (x);
    }

    const TorusFeatureActualType::MajorDiameter_optional& TorusFeatureActualType::
    MajorDiameter () const
    {
      return this->MajorDiameter_;
    }

    TorusFeatureActualType::MajorDiameter_optional& TorusFeatureActualType::
    MajorDiameter ()
    {
      return this->MajorDiameter_;
    }

    void TorusFeatureActualType::
    MajorDiameter (const MajorDiameter_type& x)
    {
      this->MajorDiameter_.set (x);
    }

    void TorusFeatureActualType::
    MajorDiameter (const MajorDiameter_optional& x)
    {
      this->MajorDiameter_ = x;
    }

    void TorusFeatureActualType::
    MajorDiameter (::std::auto_ptr< MajorDiameter_type > x)
    {
      this->MajorDiameter_.set (x);
    }

    const TorusFeatureActualType::LatitudeLongitudeSweep_optional& TorusFeatureActualType::
    LatitudeLongitudeSweep () const
    {
      return this->LatitudeLongitudeSweep_;
    }

    TorusFeatureActualType::LatitudeLongitudeSweep_optional& TorusFeatureActualType::
    LatitudeLongitudeSweep ()
    {
      return this->LatitudeLongitudeSweep_;
    }

    void TorusFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_type& x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    void TorusFeatureActualType::
    LatitudeLongitudeSweep (const LatitudeLongitudeSweep_optional& x)
    {
      this->LatitudeLongitudeSweep_ = x;
    }

    void TorusFeatureActualType::
    LatitudeLongitudeSweep (::std::auto_ptr< LatitudeLongitudeSweep_type > x)
    {
      this->LatitudeLongitudeSweep_.set (x);
    }

    const TorusFeatureActualType::Form_optional& TorusFeatureActualType::
    Form () const
    {
      return this->Form_;
    }

    TorusFeatureActualType::Form_optional& TorusFeatureActualType::
    Form ()
    {
      return this->Form_;
    }

    void TorusFeatureActualType::
    Form (const Form_type& x)
    {
      this->Form_.set (x);
    }

    void TorusFeatureActualType::
    Form (const Form_optional& x)
    {
      this->Form_ = x;
    }

    void TorusFeatureActualType::
    Form (::std::auto_ptr< Form_type > x)
    {
      this->Form_.set (x);
    }


    // CompositeFeatureItemBaseType
    // 


    // CompositeFeatureDefinitionBaseType
    // 


    // CompositeFeatureNominalBaseType
    // 

    const CompositeFeatureNominalBaseType::FeatureNominalIds_type& CompositeFeatureNominalBaseType::
    FeatureNominalIds () const
    {
      return this->FeatureNominalIds_.get ();
    }

    CompositeFeatureNominalBaseType::FeatureNominalIds_type& CompositeFeatureNominalBaseType::
    FeatureNominalIds ()
    {
      return this->FeatureNominalIds_.get ();
    }

    void CompositeFeatureNominalBaseType::
    FeatureNominalIds (const FeatureNominalIds_type& x)
    {
      this->FeatureNominalIds_.set (x);
    }

    void CompositeFeatureNominalBaseType::
    FeatureNominalIds (::std::auto_ptr< FeatureNominalIds_type > x)
    {
      this->FeatureNominalIds_.set (x);
    }


    // CompositeFeatureActualBaseType
    // 


    // CompoundFeatureItemType
    // 

    const CompoundFeatureItemType::SubstituteFeatureAlgorithm_optional& CompoundFeatureItemType::
    SubstituteFeatureAlgorithm () const
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    CompoundFeatureItemType::SubstituteFeatureAlgorithm_optional& CompoundFeatureItemType::
    SubstituteFeatureAlgorithm ()
    {
      return this->SubstituteFeatureAlgorithm_;
    }

    void CompoundFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_type& x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }

    void CompoundFeatureItemType::
    SubstituteFeatureAlgorithm (const SubstituteFeatureAlgorithm_optional& x)
    {
      this->SubstituteFeatureAlgorithm_ = x;
    }

    void CompoundFeatureItemType::
    SubstituteFeatureAlgorithm (::std::auto_ptr< SubstituteFeatureAlgorithm_type > x)
    {
      this->SubstituteFeatureAlgorithm_.set (x);
    }


    // CompoundFeatureDefinitionType
    // 


    // CompoundFeatureNominalType
    // 

    const CompoundFeatureNominalType::Location_type& CompoundFeatureNominalType::
    Location () const
    {
      return this->Location_.get ();
    }

    CompoundFeatureNominalType::Location_type& CompoundFeatureNominalType::
    Location ()
    {
      return this->Location_.get ();
    }

    void CompoundFeatureNominalType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CompoundFeatureNominalType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CompoundFeatureNominalType::Direction_type& CompoundFeatureNominalType::
    Direction () const
    {
      return this->Direction_.get ();
    }

    CompoundFeatureNominalType::Direction_type& CompoundFeatureNominalType::
    Direction ()
    {
      return this->Direction_.get ();
    }

    void CompoundFeatureNominalType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void CompoundFeatureNominalType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }

    const CompoundFeatureNominalType::CompoundFeatureForm_type& CompoundFeatureNominalType::
    CompoundFeatureForm () const
    {
      return this->CompoundFeatureForm_.get ();
    }

    CompoundFeatureNominalType::CompoundFeatureForm_type& CompoundFeatureNominalType::
    CompoundFeatureForm ()
    {
      return this->CompoundFeatureForm_.get ();
    }

    void CompoundFeatureNominalType::
    CompoundFeatureForm (const CompoundFeatureForm_type& x)
    {
      this->CompoundFeatureForm_.set (x);
    }

    void CompoundFeatureNominalType::
    CompoundFeatureForm (::std::auto_ptr< CompoundFeatureForm_type > x)
    {
      this->CompoundFeatureForm_.set (x);
    }


    // CompoundFeatureActualType
    // 

    const CompoundFeatureActualType::Location_optional& CompoundFeatureActualType::
    Location () const
    {
      return this->Location_;
    }

    CompoundFeatureActualType::Location_optional& CompoundFeatureActualType::
    Location ()
    {
      return this->Location_;
    }

    void CompoundFeatureActualType::
    Location (const Location_type& x)
    {
      this->Location_.set (x);
    }

    void CompoundFeatureActualType::
    Location (const Location_optional& x)
    {
      this->Location_ = x;
    }

    void CompoundFeatureActualType::
    Location (::std::auto_ptr< Location_type > x)
    {
      this->Location_.set (x);
    }

    const CompoundFeatureActualType::Direction_optional& CompoundFeatureActualType::
    Direction () const
    {
      return this->Direction_;
    }

    CompoundFeatureActualType::Direction_optional& CompoundFeatureActualType::
    Direction ()
    {
      return this->Direction_;
    }

    void CompoundFeatureActualType::
    Direction (const Direction_type& x)
    {
      this->Direction_.set (x);
    }

    void CompoundFeatureActualType::
    Direction (const Direction_optional& x)
    {
      this->Direction_ = x;
    }

    void CompoundFeatureActualType::
    Direction (::std::auto_ptr< Direction_type > x)
    {
      this->Direction_.set (x);
    }


    // PatternFeatureItemType
    // 


    // PatternFeatureDefinitionType
    // 


    // PatternFeatureNominalType
    // 


    // PatternFeatureActualType
    // 


    // ProfileGroupFeatureItemType
    // 


    // ProfileGroupFeatureDefinitionType
    // 


    // ProfileGroupFeatureNominalType
    // 


    // ProfileGroupFeatureActualType
    // 


    // RunoutGroupFeatureItemType
    // 


    // RunoutGroupFeatureDefinitionType
    // 


    // RunoutGroupFeatureNominalType
    // 


    // RunoutGroupFeatureActualType
    // 


    // FeatureAspectsListsType
    // 

    const FeatureAspectsListsType::FeatureDefinitions_optional& FeatureAspectsListsType::
    FeatureDefinitions () const
    {
      return this->FeatureDefinitions_;
    }

    FeatureAspectsListsType::FeatureDefinitions_optional& FeatureAspectsListsType::
    FeatureDefinitions ()
    {
      return this->FeatureDefinitions_;
    }

    void FeatureAspectsListsType::
    FeatureDefinitions (const FeatureDefinitions_type& x)
    {
      this->FeatureDefinitions_.set (x);
    }

    void FeatureAspectsListsType::
    FeatureDefinitions (const FeatureDefinitions_optional& x)
    {
      this->FeatureDefinitions_ = x;
    }

    void FeatureAspectsListsType::
    FeatureDefinitions (::std::auto_ptr< FeatureDefinitions_type > x)
    {
      this->FeatureDefinitions_.set (x);
    }

    const FeatureAspectsListsType::FeatureNominals_optional& FeatureAspectsListsType::
    FeatureNominals () const
    {
      return this->FeatureNominals_;
    }

    FeatureAspectsListsType::FeatureNominals_optional& FeatureAspectsListsType::
    FeatureNominals ()
    {
      return this->FeatureNominals_;
    }

    void FeatureAspectsListsType::
    FeatureNominals (const FeatureNominals_type& x)
    {
      this->FeatureNominals_.set (x);
    }

    void FeatureAspectsListsType::
    FeatureNominals (const FeatureNominals_optional& x)
    {
      this->FeatureNominals_ = x;
    }

    void FeatureAspectsListsType::
    FeatureNominals (::std::auto_ptr< FeatureNominals_type > x)
    {
      this->FeatureNominals_.set (x);
    }

    const FeatureAspectsListsType::FeatureItems_optional& FeatureAspectsListsType::
    FeatureItems () const
    {
      return this->FeatureItems_;
    }

    FeatureAspectsListsType::FeatureItems_optional& FeatureAspectsListsType::
    FeatureItems ()
    {
      return this->FeatureItems_;
    }

    void FeatureAspectsListsType::
    FeatureItems (const FeatureItems_type& x)
    {
      this->FeatureItems_.set (x);
    }

    void FeatureAspectsListsType::
    FeatureItems (const FeatureItems_optional& x)
    {
      this->FeatureItems_ = x;
    }

    void FeatureAspectsListsType::
    FeatureItems (::std::auto_ptr< FeatureItems_type > x)
    {
      this->FeatureItems_.set (x);
    }


    // MeasuredFeaturesType
    // 

    const MeasuredFeaturesType::FeatureActuals_type& MeasuredFeaturesType::
    FeatureActuals () const
    {
      return this->FeatureActuals_.get ();
    }

    MeasuredFeaturesType::FeatureActuals_type& MeasuredFeaturesType::
    FeatureActuals ()
    {
      return this->FeatureActuals_.get ();
    }

    void MeasuredFeaturesType::
    FeatureActuals (const FeatureActuals_type& x)
    {
      this->FeatureActuals_.set (x);
    }

    void MeasuredFeaturesType::
    FeatureActuals (::std::auto_ptr< FeatureActuals_type > x)
    {
      this->FeatureActuals_.set (x);
    }


    // FeatureDefinitionsType
    // 

    const FeatureDefinitionsType::FeatureDefinition_sequence& FeatureDefinitionsType::
    FeatureDefinition () const
    {
      return this->FeatureDefinition_;
    }

    FeatureDefinitionsType::FeatureDefinition_sequence& FeatureDefinitionsType::
    FeatureDefinition ()
    {
      return this->FeatureDefinition_;
    }

    void FeatureDefinitionsType::
    FeatureDefinition (const FeatureDefinition_sequence& s)
    {
      this->FeatureDefinition_ = s;
    }


    // FeatureNominalsType
    // 

    const FeatureNominalsType::FeatureNominal_sequence& FeatureNominalsType::
    FeatureNominal () const
    {
      return this->FeatureNominal_;
    }

    FeatureNominalsType::FeatureNominal_sequence& FeatureNominalsType::
    FeatureNominal ()
    {
      return this->FeatureNominal_;
    }

    void FeatureNominalsType::
    FeatureNominal (const FeatureNominal_sequence& s)
    {
      this->FeatureNominal_ = s;
    }


    // FeatureItemsType
    // 

    const FeatureItemsType::FeatureItem_sequence& FeatureItemsType::
    FeatureItem () const
    {
      return this->FeatureItem_;
    }

    FeatureItemsType::FeatureItem_sequence& FeatureItemsType::
    FeatureItem ()
    {
      return this->FeatureItem_;
    }

    void FeatureItemsType::
    FeatureItem (const FeatureItem_sequence& s)
    {
      this->FeatureItem_ = s;
    }


    // FeatureActualsType
    // 

    const FeatureActualsType::FeatureActual_sequence& FeatureActualsType::
    FeatureActual () const
    {
      return this->FeatureActual_;
    }

    FeatureActualsType::FeatureActual_sequence& FeatureActualsType::
    FeatureActual ()
    {
      return this->FeatureActual_;
    }

    void FeatureActualsType::
    FeatureActual (const FeatureActual_sequence& s)
    {
      this->FeatureActual_ = s;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    // FeatureBaseType
    //

    FeatureBaseType::
    FeatureBaseType (const id_type& id)
    : ::xml_schema::type (),
      Attributes_ (this),
      id_ (id, this)
    {
    }

    FeatureBaseType::
    FeatureBaseType (const FeatureBaseType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Attributes_ (x.Attributes_, f, this),
      id_ (x.id_, f, this)
    {
    }

    FeatureBaseType::
    FeatureBaseType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Attributes_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Attributes
        //
        if (n.name () == "Attributes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Attributes_type > r (
            Attributes_traits::create (i, f, this));

          if (!this->Attributes_)
          {
            this->Attributes_.set (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (id_traits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    FeatureBaseType* FeatureBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureBaseType (*this, f, c);
    }

    FeatureBaseType& FeatureBaseType::
    operator= (const FeatureBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Attributes_ = x.Attributes_;
        this->id_ = x.id_;
      }

      return *this;
    }

    FeatureBaseType::
    ~FeatureBaseType ()
    {
    }

    // FeatureItemBaseType
    //

    FeatureItemBaseType::
    FeatureItemBaseType (const id_type& id,
                         const FeatureName_type& FeatureName)
    : ::xsd::qif2::FeatureBaseType (id),
      FeatureNominalId_ (this),
      ParentFeatureItemId_ (this),
      FeatureName_ (FeatureName, this),
      QPId_ (this),
      NotableEventIds_ (this),
      CoordinateSystemId_ (this)
    {
    }

    FeatureItemBaseType::
    FeatureItemBaseType (const FeatureItemBaseType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (x, f, c),
      FeatureNominalId_ (x.FeatureNominalId_, f, this),
      ParentFeatureItemId_ (x.ParentFeatureItemId_, f, this),
      FeatureName_ (x.FeatureName_, f, this),
      QPId_ (x.QPId_, f, this),
      NotableEventIds_ (x.NotableEventIds_, f, this),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this)
    {
    }

    FeatureItemBaseType::
    FeatureItemBaseType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (e, f | ::xml_schema::flags::base, c),
      FeatureNominalId_ (this),
      ParentFeatureItemId_ (this),
      FeatureName_ (this),
      QPId_ (this),
      NotableEventIds_ (this),
      CoordinateSystemId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureItemBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureNominalId
        //
        if (n.name () == "FeatureNominalId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureNominalId_type > r (
            FeatureNominalId_traits::create (i, f, this));

          if (!this->FeatureNominalId_)
          {
            this->FeatureNominalId_.set (r);
            continue;
          }
        }

        // ParentFeatureItemId
        //
        if (n.name () == "ParentFeatureItemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ParentFeatureItemId_type > r (
            ParentFeatureItemId_traits::create (i, f, this));

          if (!this->ParentFeatureItemId_)
          {
            this->ParentFeatureItemId_.set (r);
            continue;
          }
        }

        // FeatureName
        //
        if (n.name () == "FeatureName" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureName_type > r (
            FeatureName_traits::create (i, f, this));

          if (!FeatureName_.present ())
          {
            this->FeatureName_.set (r);
            continue;
          }
        }

        // QPId
        //
        if (n.name () == "QPId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< QPId_type > r (
            QPId_traits::create (i, f, this));

          if (!this->QPId_)
          {
            this->QPId_.set (r);
            continue;
          }
        }

        // NotableEventIds
        //
        if (n.name () == "NotableEventIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NotableEventIds_type > r (
            NotableEventIds_traits::create (i, f, this));

          if (!this->NotableEventIds_)
          {
            this->NotableEventIds_.set (r);
            continue;
          }
        }

        // CoordinateSystemId
        //
        if (n.name () == "CoordinateSystemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!this->CoordinateSystemId_)
          {
            this->CoordinateSystemId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureName_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureName",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FeatureItemBaseType* FeatureItemBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureItemBaseType (*this, f, c);
    }

    FeatureItemBaseType& FeatureItemBaseType::
    operator= (const FeatureItemBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureBaseType& > (*this) = x;
        this->FeatureNominalId_ = x.FeatureNominalId_;
        this->ParentFeatureItemId_ = x.ParentFeatureItemId_;
        this->FeatureName_ = x.FeatureName_;
        this->QPId_ = x.QPId_;
        this->NotableEventIds_ = x.NotableEventIds_;
        this->CoordinateSystemId_ = x.CoordinateSystemId_;
      }

      return *this;
    }

    FeatureItemBaseType::
    ~FeatureItemBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FeatureItemBaseType >
    _xsd_FeatureItemBaseType_type_factory_init (
      "FeatureItemBaseType",
      "http://qifstandards.org/xsd/qif2");

    // FeatureDefinitionBaseType
    //

    FeatureDefinitionBaseType::
    FeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif2::FeatureBaseType (id)
    {
    }

    FeatureDefinitionBaseType::
    FeatureDefinitionBaseType (const FeatureDefinitionBaseType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (x, f, c)
    {
    }

    FeatureDefinitionBaseType::
    FeatureDefinitionBaseType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (e, f, c)
    {
    }

    FeatureDefinitionBaseType* FeatureDefinitionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureDefinitionBaseType (*this, f, c);
    }

    FeatureDefinitionBaseType::
    ~FeatureDefinitionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FeatureDefinitionBaseType >
    _xsd_FeatureDefinitionBaseType_type_factory_init (
      "FeatureDefinitionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // PointListNominalType
    //

    PointListNominalType::
    PointListNominalType ()
    : ::xml_schema::type (),
      MeasurePoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    PointListNominalType::
    PointListNominalType (const PointListNominalType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasurePoint_ (x.MeasurePoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    PointListNominalType::
    PointListNominalType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasurePoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointListNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MeasurePoint
        //
        if (n.name () == "MeasurePoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurePoint_type > r (
            MeasurePoint_traits::create (i, f, this));

          this->MeasurePoint_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }
      }
    }

    PointListNominalType* PointListNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointListNominalType (*this, f, c);
    }

    PointListNominalType& PointListNominalType::
    operator= (const PointListNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasurePoint_ = x.MeasurePoint_;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
      }

      return *this;
    }

    PointListNominalType::
    ~PointListNominalType ()
    {
    }

    // FeatureNominalBaseType
    //

    FeatureNominalBaseType::
    FeatureNominalBaseType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif2::FeatureBaseType (id),
      Name_ (this),
      PointList_ (this),
      FeatureDefinitionId_ (FeatureDefinitionId, this),
      EntityInternalIds_ (this),
      EntityExternalIds_ (this)
    {
    }

    FeatureNominalBaseType::
    FeatureNominalBaseType (const FeatureNominalBaseType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (x, f, c),
      Name_ (x.Name_, f, this),
      PointList_ (x.PointList_, f, this),
      FeatureDefinitionId_ (x.FeatureDefinitionId_, f, this),
      EntityInternalIds_ (x.EntityInternalIds_, f, this),
      EntityExternalIds_ (x.EntityExternalIds_, f, this)
    {
    }

    FeatureNominalBaseType::
    FeatureNominalBaseType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (e, f | ::xml_schema::flags::base, c),
      Name_ (this),
      PointList_ (this),
      FeatureDefinitionId_ (this),
      EntityInternalIds_ (this),
      EntityExternalIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureNominalBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Name
        //
        if (n.name () == "Name" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Name_type > r (
            Name_traits::create (i, f, this));

          if (!this->Name_)
          {
            this->Name_.set (r);
            continue;
          }
        }

        // PointList
        //
        if (n.name () == "PointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointList_type > r (
            PointList_traits::create (i, f, this));

          if (!this->PointList_)
          {
            this->PointList_.set (r);
            continue;
          }
        }

        // FeatureDefinitionId
        //
        if (n.name () == "FeatureDefinitionId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureDefinitionId_type > r (
            FeatureDefinitionId_traits::create (i, f, this));

          if (!FeatureDefinitionId_.present ())
          {
            this->FeatureDefinitionId_.set (r);
            continue;
          }
        }

        // EntityInternalIds
        //
        if (n.name () == "EntityInternalIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EntityInternalIds_type > r (
            EntityInternalIds_traits::create (i, f, this));

          if (!this->EntityInternalIds_)
          {
            this->EntityInternalIds_.set (r);
            continue;
          }
        }

        // EntityExternalIds
        //
        if (n.name () == "EntityExternalIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EntityExternalIds_type > r (
            EntityExternalIds_traits::create (i, f, this));

          if (!this->EntityExternalIds_)
          {
            this->EntityExternalIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureDefinitionId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureDefinitionId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FeatureNominalBaseType* FeatureNominalBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureNominalBaseType (*this, f, c);
    }

    FeatureNominalBaseType& FeatureNominalBaseType::
    operator= (const FeatureNominalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureBaseType& > (*this) = x;
        this->Name_ = x.Name_;
        this->PointList_ = x.PointList_;
        this->FeatureDefinitionId_ = x.FeatureDefinitionId_;
        this->EntityInternalIds_ = x.EntityInternalIds_;
        this->EntityExternalIds_ = x.EntityExternalIds_;
      }

      return *this;
    }

    FeatureNominalBaseType::
    ~FeatureNominalBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FeatureNominalBaseType >
    _xsd_FeatureNominalBaseType_type_factory_init (
      "FeatureNominalBaseType",
      "http://qifstandards.org/xsd/qif2");

    // PointListActualType
    //

    PointListActualType::
    PointListActualType ()
    : ::xml_schema::type (),
      MeasurePoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this)
    {
    }

    PointListActualType::
    PointListActualType (const PointListActualType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      MeasurePoint_ (x.MeasurePoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this),
      xCombinedUncertainty_ (x.xCombinedUncertainty_, f, this),
      xMeanError_ (x.xMeanError_, f, this),
      yCombinedUncertainty_ (x.yCombinedUncertainty_, f, this),
      yMeanError_ (x.yMeanError_, f, this),
      zCombinedUncertainty_ (x.zCombinedUncertainty_, f, this),
      zMeanError_ (x.zMeanError_, f, this)
    {
    }

    PointListActualType::
    PointListActualType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      MeasurePoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointListActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // MeasurePoint
        //
        if (n.name () == "MeasurePoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurePoint_type > r (
            MeasurePoint_traits::create (i, f, this));

          this->MeasurePoint_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->xCombinedUncertainty_.set (xCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xMeanError" && n.namespace_ ().empty ())
        {
          this->xMeanError_.set (xMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->yCombinedUncertainty_.set (yCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yMeanError" && n.namespace_ ().empty ())
        {
          this->yMeanError_.set (yMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->zCombinedUncertainty_.set (zCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zMeanError" && n.namespace_ ().empty ())
        {
          this->zMeanError_.set (zMeanError_traits::create (i, f, this));
          continue;
        }
      }
    }

    PointListActualType* PointListActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointListActualType (*this, f, c);
    }

    PointListActualType& PointListActualType::
    operator= (const PointListActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->MeasurePoint_ = x.MeasurePoint_;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
        this->combinedUncertainty_ = x.combinedUncertainty_;
        this->meanError_ = x.meanError_;
        this->xCombinedUncertainty_ = x.xCombinedUncertainty_;
        this->xMeanError_ = x.xMeanError_;
        this->yCombinedUncertainty_ = x.yCombinedUncertainty_;
        this->yMeanError_ = x.yMeanError_;
        this->zCombinedUncertainty_ = x.zCombinedUncertainty_;
        this->zMeanError_ = x.zMeanError_;
      }

      return *this;
    }

    PointListActualType::
    ~PointListActualType ()
    {
    }

    // FeatureActualBaseType
    //

    FeatureActualBaseType::
    FeatureActualBaseType (const id_type& id,
                           const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureBaseType (id),
      PointList_ (this),
      FeatureItemId_ (FeatureItemId, this),
      ActualComponentId_ (this),
      ManufacturingProcessId_ (this),
      MeasurementDeviceIds_ (this),
      NotedEventIds_ (this)
    {
    }

    FeatureActualBaseType::
    FeatureActualBaseType (const id_type& id,
                           ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureBaseType (id),
      PointList_ (this),
      FeatureItemId_ (FeatureItemId, this),
      ActualComponentId_ (this),
      ManufacturingProcessId_ (this),
      MeasurementDeviceIds_ (this),
      NotedEventIds_ (this)
    {
    }

    FeatureActualBaseType::
    FeatureActualBaseType (const FeatureActualBaseType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (x, f, c),
      PointList_ (x.PointList_, f, this),
      FeatureItemId_ (x.FeatureItemId_, f, this),
      ActualComponentId_ (x.ActualComponentId_, f, this),
      ManufacturingProcessId_ (x.ManufacturingProcessId_, f, this),
      MeasurementDeviceIds_ (x.MeasurementDeviceIds_, f, this),
      NotedEventIds_ (x.NotedEventIds_, f, this)
    {
    }

    FeatureActualBaseType::
    FeatureActualBaseType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureBaseType (e, f | ::xml_schema::flags::base, c),
      PointList_ (this),
      FeatureItemId_ (this),
      ActualComponentId_ (this),
      ManufacturingProcessId_ (this),
      MeasurementDeviceIds_ (this),
      NotedEventIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FeatureActualBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointList
        //
        if (n.name () == "PointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointList_type > r (
            PointList_traits::create (i, f, this));

          if (!this->PointList_)
          {
            this->PointList_.set (r);
            continue;
          }
        }

        // FeatureItemId
        //
        if (n.name () == "FeatureItemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureItemId_type > r (
            FeatureItemId_traits::create (i, f, this));

          if (!FeatureItemId_.present ())
          {
            this->FeatureItemId_.set (r);
            continue;
          }
        }

        // ActualComponentId
        //
        if (n.name () == "ActualComponentId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ActualComponentId_type > r (
            ActualComponentId_traits::create (i, f, this));

          if (!this->ActualComponentId_)
          {
            this->ActualComponentId_.set (r);
            continue;
          }
        }

        // ManufacturingProcessId
        //
        if (n.name () == "ManufacturingProcessId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ManufacturingProcessId_type > r (
            ManufacturingProcessId_traits::create (i, f, this));

          if (!this->ManufacturingProcessId_)
          {
            this->ManufacturingProcessId_.set (r);
            continue;
          }
        }

        // MeasurementDeviceIds
        //
        if (n.name () == "MeasurementDeviceIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MeasurementDeviceIds_type > r (
            MeasurementDeviceIds_traits::create (i, f, this));

          if (!this->MeasurementDeviceIds_)
          {
            this->MeasurementDeviceIds_.set (r);
            continue;
          }
        }

        // NotedEventIds
        //
        if (n.name () == "NotedEventIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< NotedEventIds_type > r (
            NotedEventIds_traits::create (i, f, this));

          if (!this->NotedEventIds_)
          {
            this->NotedEventIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureItemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureItemId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    FeatureActualBaseType* FeatureActualBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureActualBaseType (*this, f, c);
    }

    FeatureActualBaseType& FeatureActualBaseType::
    operator= (const FeatureActualBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureBaseType& > (*this) = x;
        this->PointList_ = x.PointList_;
        this->FeatureItemId_ = x.FeatureItemId_;
        this->ActualComponentId_ = x.ActualComponentId_;
        this->ManufacturingProcessId_ = x.ManufacturingProcessId_;
        this->MeasurementDeviceIds_ = x.MeasurementDeviceIds_;
        this->NotedEventIds_ = x.NotedEventIds_;
      }

      return *this;
    }

    FeatureActualBaseType::
    ~FeatureActualBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FeatureActualBaseType >
    _xsd_FeatureActualBaseType_type_factory_init (
      "FeatureActualBaseType",
      "http://qifstandards.org/xsd/qif2");

    // SetFeatureType
    //

    SetFeatureType::
    SetFeatureType ()
    : ::xml_schema::type ()
    {
    }

    SetFeatureType::
    SetFeatureType (const SetFeatureType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    SetFeatureType::
    SetFeatureType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    SetFeatureType::
    SetFeatureType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    SetFeatureType::
    SetFeatureType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    SetFeatureType* SetFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SetFeatureType (*this, f, c);
    }

    SetFeatureType::
    ~SetFeatureType ()
    {
    }

    // MeasuredFeatureType
    //

    MeasuredFeatureType::
    MeasuredFeatureType ()
    : ::xml_schema::type (),
      PointList_ (this)
    {
    }

    MeasuredFeatureType::
    MeasuredFeatureType (const MeasuredFeatureType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      PointList_ (x.PointList_, f, this)
    {
    }

    MeasuredFeatureType::
    MeasuredFeatureType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      PointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasuredFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PointList
        //
        if (n.name () == "PointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointList_type > r (
            PointList_traits::create (i, f, this));

          if (!this->PointList_)
          {
            this->PointList_.set (r);
            continue;
          }
        }

        break;
      }
    }

    MeasuredFeatureType* MeasuredFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredFeatureType (*this, f, c);
    }

    MeasuredFeatureType& MeasuredFeatureType::
    operator= (const MeasuredFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->PointList_ = x.PointList_;
      }

      return *this;
    }

    MeasuredFeatureType::
    ~MeasuredFeatureType ()
    {
    }

    // ConstructionMethodBaseType
    //

    ConstructionMethodBaseType::
    ConstructionMethodBaseType ()
    : ::xml_schema::type (),
      NominalsCalculated_ (this)
    {
    }

    ConstructionMethodBaseType::
    ConstructionMethodBaseType (const ConstructionMethodBaseType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      NominalsCalculated_ (x.NominalsCalculated_, f, this)
    {
    }

    ConstructionMethodBaseType::
    ConstructionMethodBaseType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      NominalsCalculated_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConstructionMethodBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // NominalsCalculated
        //
        if (n.name () == "NominalsCalculated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->NominalsCalculated_)
          {
            this->NominalsCalculated_.set (NominalsCalculated_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }
    }

    ConstructionMethodBaseType* ConstructionMethodBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConstructionMethodBaseType (*this, f, c);
    }

    ConstructionMethodBaseType& ConstructionMethodBaseType::
    operator= (const ConstructionMethodBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->NominalsCalculated_ = x.NominalsCalculated_;
      }

      return *this;
    }

    ConstructionMethodBaseType::
    ~ConstructionMethodBaseType ()
    {
    }

    // PointRangeType
    //

    PointRangeType::
    PointRangeType (const Start_type& Start,
                    const Stop_type& Stop)
    : ::xml_schema::type (),
      Start_ (Start, this),
      Stop_ (Stop, this)
    {
    }

    PointRangeType::
    PointRangeType (const PointRangeType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Start_ (x.Start_, f, this),
      Stop_ (x.Stop_, f, this)
    {
    }

    PointRangeType::
    PointRangeType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Start_ (this),
      Stop_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointRangeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Start
        //
        if (n.name () == "Start" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!Start_.present ())
          {
            this->Start_.set (Start_traits::create (i, f, this));
            continue;
          }
        }

        // Stop
        //
        if (n.name () == "Stop" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!Stop_.present ())
          {
            this->Stop_.set (Stop_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!Start_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Start",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Stop_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Stop",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointRangeType* PointRangeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointRangeType (*this, f, c);
    }

    PointRangeType& PointRangeType::
    operator= (const PointRangeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Start_ = x.Start_;
        this->Stop_ = x.Stop_;
      }

      return *this;
    }

    PointRangeType::
    ~PointRangeType ()
    {
    }

    // PointIndexType
    //

    const PointIndexType::All_type PointIndexType::All_default_value_ (
      "All");

    PointIndexType::
    PointIndexType ()
    : ::xml_schema::type (),
      Single_ (this),
      Range_ (this),
      All_ (this)
    {
    }

    PointIndexType::
    PointIndexType (const PointIndexType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Single_ (x.Single_, f, this),
      Range_ (x.Range_, f, this),
      All_ (x.All_, f, this)
    {
    }

    PointIndexType::
    PointIndexType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Single_ (this),
      Range_ (this),
      All_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointIndexType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Single
        //
        if (n.name () == "Single" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->Single_)
          {
            this->Single_.set (Single_traits::create (i, f, this));
            continue;
          }
        }

        // Range
        //
        if (n.name () == "Range" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Range_type > r (
            Range_traits::create (i, f, this));

          if (!this->Range_)
          {
            this->Range_.set (r);
            continue;
          }
        }

        // All
        //
        if (n.name () == "All" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< All_type > r (
            All_traits::create (i, f, this));

          if (!this->All_)
          {
            this->All_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointIndexType* PointIndexType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointIndexType (*this, f, c);
    }

    PointIndexType& PointIndexType::
    operator= (const PointIndexType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Single_ = x.Single_;
        this->Range_ = x.Range_;
        this->All_ = x.All_;
      }

      return *this;
    }

    PointIndexType::
    ~PointIndexType ()
    {
    }

    // BaseFeaturePointSetType
    //

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (const FeatureItemId_type& FeatureItemId,
                             const PointIndex_type& PointIndex,
                             const ReferencedComponent_type& ReferencedComponent,
                             const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      FeatureItemId_ (FeatureItemId, this),
      PointIndex_ (PointIndex, this),
      ReferencedComponent_ (ReferencedComponent, this),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (::std::auto_ptr< FeatureItemId_type > FeatureItemId,
                             ::std::auto_ptr< PointIndex_type > PointIndex,
                             const ReferencedComponent_type& ReferencedComponent,
                             const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      FeatureItemId_ (FeatureItemId, this),
      PointIndex_ (PointIndex, this),
      ReferencedComponent_ (ReferencedComponent, this),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (const BaseFeaturePointSetType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureItemId_ (x.FeatureItemId_, f, this),
      PointIndex_ (x.PointIndex_, f, this),
      ReferencedComponent_ (x.ReferencedComponent_, f, this),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    BaseFeaturePointSetType::
    BaseFeaturePointSetType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureItemId_ (this),
      PointIndex_ (this),
      ReferencedComponent_ (this),
      SequenceNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BaseFeaturePointSetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureItemId
        //
        if (n.name () == "FeatureItemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureItemId_type > r (
            FeatureItemId_traits::create (i, f, this));

          if (!FeatureItemId_.present ())
          {
            this->FeatureItemId_.set (r);
            continue;
          }
        }

        // PointIndex
        //
        if (n.name () == "PointIndex" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointIndex_type > r (
            PointIndex_traits::create (i, f, this));

          if (!PointIndex_.present ())
          {
            this->PointIndex_.set (r);
            continue;
          }
        }

        // ReferencedComponent
        //
        if (n.name () == "ReferencedComponent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReferencedComponent_type > r (
            ReferencedComponent_traits::create (i, f, this));

          if (!ReferencedComponent_.present ())
          {
            this->ReferencedComponent_.set (r);
            continue;
          }
        }

        // SequenceNumber
        //
        if (n.name () == "SequenceNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (SequenceNumber_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!FeatureItemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureItemId",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointIndex_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointIndex",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ReferencedComponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ReferencedComponent",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SequenceNumber",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    BaseFeaturePointSetType* BaseFeaturePointSetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BaseFeaturePointSetType (*this, f, c);
    }

    BaseFeaturePointSetType& BaseFeaturePointSetType::
    operator= (const BaseFeaturePointSetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureItemId_ = x.FeatureItemId_;
        this->PointIndex_ = x.PointIndex_;
        this->ReferencedComponent_ = x.ReferencedComponent_;
        this->SequenceNumber_ = x.SequenceNumber_;
      }

      return *this;
    }

    BaseFeaturePointSetType::
    ~BaseFeaturePointSetType ()
    {
    }

    // BaseFeaturePointListType
    //

    BaseFeaturePointListType::
    BaseFeaturePointListType ()
    : ::xml_schema::type (),
      BaseFeaturePointSet_ (this)
    {
    }

    BaseFeaturePointListType::
    BaseFeaturePointListType (const BaseFeaturePointListType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BaseFeaturePointSet_ (x.BaseFeaturePointSet_, f, this)
    {
    }

    BaseFeaturePointListType::
    BaseFeaturePointListType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointSet_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BaseFeaturePointListType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointSet
        //
        if (n.name () == "BaseFeaturePointSet" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointSet_type > r (
            BaseFeaturePointSet_traits::create (i, f, this));

          this->BaseFeaturePointSet_.push_back (r);
          continue;
        }

        break;
      }
    }

    BaseFeaturePointListType* BaseFeaturePointListType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BaseFeaturePointListType (*this, f, c);
    }

    BaseFeaturePointListType& BaseFeaturePointListType::
    operator= (const BaseFeaturePointListType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BaseFeaturePointSet_ = x.BaseFeaturePointSet_;
      }

      return *this;
    }

    BaseFeaturePointListType::
    ~BaseFeaturePointListType ()
    {
    }

    // TransformationReferenceType
    //

    TransformationReferenceType::
    TransformationReferenceType (const ReferencedComponent_type& ReferencedComponent,
                                 const CoordinateSystemId_type& CoordinateSystemId,
                                 const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      ReferencedComponent_ (ReferencedComponent, this),
      CoordinateSystemId_ (CoordinateSystemId, this),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    TransformationReferenceType::
    TransformationReferenceType (const ReferencedComponent_type& ReferencedComponent,
                                 ::std::auto_ptr< CoordinateSystemId_type > CoordinateSystemId,
                                 const SequenceNumber_type& SequenceNumber)
    : ::xml_schema::type (),
      ReferencedComponent_ (ReferencedComponent, this),
      CoordinateSystemId_ (CoordinateSystemId, this),
      SequenceNumber_ (SequenceNumber, this)
    {
    }

    TransformationReferenceType::
    TransformationReferenceType (const TransformationReferenceType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ReferencedComponent_ (x.ReferencedComponent_, f, this),
      CoordinateSystemId_ (x.CoordinateSystemId_, f, this),
      SequenceNumber_ (x.SequenceNumber_, f, this)
    {
    }

    TransformationReferenceType::
    TransformationReferenceType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ReferencedComponent_ (this),
      CoordinateSystemId_ (this),
      SequenceNumber_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TransformationReferenceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ReferencedComponent
        //
        if (n.name () == "ReferencedComponent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReferencedComponent_type > r (
            ReferencedComponent_traits::create (i, f, this));

          if (!ReferencedComponent_.present ())
          {
            this->ReferencedComponent_.set (r);
            continue;
          }
        }

        // CoordinateSystemId
        //
        if (n.name () == "CoordinateSystemId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CoordinateSystemId_type > r (
            CoordinateSystemId_traits::create (i, f, this));

          if (!CoordinateSystemId_.present ())
          {
            this->CoordinateSystemId_.set (r);
            continue;
          }
        }

        // SequenceNumber
        //
        if (n.name () == "SequenceNumber" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!SequenceNumber_.present ())
          {
            this->SequenceNumber_.set (SequenceNumber_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!ReferencedComponent_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ReferencedComponent",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CoordinateSystemId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CoordinateSystemId",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SequenceNumber_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SequenceNumber",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TransformationReferenceType* TransformationReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformationReferenceType (*this, f, c);
    }

    TransformationReferenceType& TransformationReferenceType::
    operator= (const TransformationReferenceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->ReferencedComponent_ = x.ReferencedComponent_;
        this->CoordinateSystemId_ = x.CoordinateSystemId_;
        this->SequenceNumber_ = x.SequenceNumber_;
      }

      return *this;
    }

    TransformationReferenceType::
    ~TransformationReferenceType ()
    {
    }

    // ArcConstructionMethodType
    //

    ArcConstructionMethodType::
    ArcConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this),
      Extract_ (this)
    {
    }

    ArcConstructionMethodType::
    ArcConstructionMethodType (const ArcConstructionMethodType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    ArcConstructionMethodType::
    ArcConstructionMethodType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this),
      Extract_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        // Extract
        //
        if (n.name () == "Extract" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcConstructionMethodType* ArcConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcConstructionMethodType (*this, f, c);
    }

    ArcConstructionMethodType& ArcConstructionMethodType::
    operator= (const ArcConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
        this->Extract_ = x.Extract_;
      }

      return *this;
    }

    ArcConstructionMethodType::
    ~ArcConstructionMethodType ()
    {
    }

    // ArcBestFitType
    //

    ArcBestFitType::
    ArcBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ArcBestFitType::
    ArcBestFitType (const ArcBestFitType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ArcBestFitType::
    ArcBestFitType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ArcBestFitType* ArcBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcBestFitType (*this, f, c);
    }

    ArcBestFitType& ArcBestFitType::
    operator= (const ArcBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ArcBestFitType::
    ~ArcBestFitType ()
    {
    }

    // ArcRecompType
    //

    ArcRecompType::
    ArcRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ArcRecompType::
    ArcRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ArcRecompType::
    ArcRecompType (const ArcRecompType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ArcRecompType::
    ArcRecompType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcRecompType* ArcRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcRecompType (*this, f, c);
    }

    ArcRecompType& ArcRecompType::
    operator= (const ArcRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ArcRecompType::
    ~ArcRecompType ()
    {
    }

    // ArcProjectionType
    //

    ArcProjectionType::
    ArcProjectionType (const ProjectionArc_type& ProjectionArc,
                       const ProjectionPlane_type& ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionArc_ (ProjectionArc, this),
      ProjectionPlane_ (ProjectionPlane, this)
    {
    }

    ArcProjectionType::
    ArcProjectionType (::std::auto_ptr< ProjectionArc_type > ProjectionArc,
                       ::std::auto_ptr< ProjectionPlane_type > ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionArc_ (ProjectionArc, this),
      ProjectionPlane_ (ProjectionPlane, this)
    {
    }

    ArcProjectionType::
    ArcProjectionType (const ArcProjectionType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionArc_ (x.ProjectionArc_, f, this),
      ProjectionPlane_ (x.ProjectionPlane_, f, this)
    {
    }

    ArcProjectionType::
    ArcProjectionType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionArc_ (this),
      ProjectionPlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionArc
        //
        if (n.name () == "ProjectionArc" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionArc_type > r (
            ProjectionArc_traits::create (i, f, this));

          if (!ProjectionArc_.present ())
          {
            this->ProjectionArc_.set (r);
            continue;
          }
        }

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionArc",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcProjectionType* ArcProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcProjectionType (*this, f, c);
    }

    ArcProjectionType& ArcProjectionType::
    operator= (const ArcProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionArc_ = x.ProjectionArc_;
        this->ProjectionPlane_ = x.ProjectionPlane_;
      }

      return *this;
    }

    ArcProjectionType::
    ~ArcProjectionType ()
    {
    }

    // ArcCopyType
    //

    ArcCopyType::
    ArcCopyType (const BaseArc_type& BaseArc)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseArc_ (BaseArc, this)
    {
    }

    ArcCopyType::
    ArcCopyType (::std::auto_ptr< BaseArc_type > BaseArc)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseArc_ (BaseArc, this)
    {
    }

    ArcCopyType::
    ArcCopyType (const ArcCopyType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseArc_ (x.BaseArc_, f, this)
    {
    }

    ArcCopyType::
    ArcCopyType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseArc_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseArc
        //
        if (n.name () == "BaseArc" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseArc_type > r (
            BaseArc_traits::create (i, f, this));

          if (!BaseArc_.present ())
          {
            this->BaseArc_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseArc",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcCopyType* ArcCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCopyType (*this, f, c);
    }

    ArcCopyType& ArcCopyType::
    operator= (const ArcCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseArc_ = x.BaseArc_;
      }

      return *this;
    }

    ArcCopyType::
    ~ArcCopyType ()
    {
    }

    // ArcCastType
    //

    ArcCastType::
    ArcCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ArcCastType::
    ArcCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ArcCastType::
    ArcCastType (const ArcCastType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ArcCastType::
    ArcCastType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcCastType* ArcCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCastType (*this, f, c);
    }

    ArcCastType& ArcCastType::
    operator= (const ArcCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ArcCastType::
    ~ArcCastType ()
    {
    }

    // ArcTransformType
    //

    ArcTransformType::
    ArcTransformType (const BaseArc_type& BaseArc,
                      const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseArc_ (BaseArc, this),
      Transformation_ (Transformation, this)
    {
    }

    ArcTransformType::
    ArcTransformType (::std::auto_ptr< BaseArc_type > BaseArc,
                      ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseArc_ (BaseArc, this),
      Transformation_ (Transformation, this)
    {
    }

    ArcTransformType::
    ArcTransformType (const ArcTransformType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseArc_ (x.BaseArc_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ArcTransformType::
    ArcTransformType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseArc_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseArc
        //
        if (n.name () == "BaseArc" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseArc_type > r (
            BaseArc_traits::create (i, f, this));

          if (!BaseArc_.present ())
          {
            this->BaseArc_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseArc_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseArc",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcTransformType* ArcTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcTransformType (*this, f, c);
    }

    ArcTransformType& ArcTransformType::
    operator= (const ArcTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseArc_ = x.BaseArc_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ArcTransformType::
    ~ArcTransformType ()
    {
    }

    // ArcFromScanType
    //

    ArcFromScanType::
    ArcFromScanType (const SurfaceFeature_type& SurfaceFeature,
                     const SearchRadius_type& SearchRadius,
                     const Depth_type& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    ArcFromScanType::
    ArcFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                     ::std::auto_ptr< SearchRadius_type > SearchRadius,
                     ::std::auto_ptr< Depth_type > Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    ArcFromScanType::
    ArcFromScanType (const ArcFromScanType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    ArcFromScanType::
    ArcFromScanType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Depth",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcFromScanType* ArcFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcFromScanType (*this, f, c);
    }

    ArcFromScanType& ArcFromScanType::
    operator= (const ArcFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    ArcFromScanType::
    ~ArcFromScanType ()
    {
    }

    // ArcExtractType
    //

    ArcExtractType::
    ArcExtractType (const CurveFeature_type& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, this)
    {
    }

    ArcExtractType::
    ArcExtractType (::std::auto_ptr< CurveFeature_type > CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, this)
    {
    }

    ArcExtractType::
    ArcExtractType (const ArcExtractType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    ArcExtractType::
    ArcExtractType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      CurveFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcExtractType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CurveFeature
        //
        if (n.name () == "CurveFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CurveFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcExtractType* ArcExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcExtractType (*this, f, c);
    }

    ArcExtractType& ArcExtractType::
    operator= (const ArcExtractType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->CurveFeature_ = x.CurveFeature_;
      }

      return *this;
    }

    ArcExtractType::
    ~ArcExtractType ()
    {
    }

    // ArcCheckedType
    //

    ArcCheckedType::
    ArcCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ArcCheckedType::
    ArcCheckedType (const ArcCheckedType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ArcCheckedType::
    ArcCheckedType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcCheckedType* ArcCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCheckedType (*this, f, c);
    }

    ArcCheckedType& ArcCheckedType::
    operator= (const ArcCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ArcCheckedType::
    ~ArcCheckedType ()
    {
    }

    // ArcCheckedFeatureType
    //

    ArcCheckedFeatureType::
    ArcCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ArcCheckedFeatureType::
    ArcCheckedFeatureType (const ArcCheckedFeatureType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ArcCheckedFeatureType::
    ArcCheckedFeatureType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcCheckedFeatureType* ArcCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcCheckedFeatureType (*this, f, c);
    }

    ArcCheckedFeatureType& ArcCheckedFeatureType::
    operator= (const ArcCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ArcCheckedFeatureType::
    ~ArcCheckedFeatureType ()
    {
    }

    // ArcActualDeterminationType
    //

    ArcActualDeterminationType::
    ArcActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ArcActualDeterminationType::
    ArcActualDeterminationType (const ArcActualDeterminationType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ArcActualDeterminationType::
    ArcActualDeterminationType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArcActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcActualDeterminationType* ArcActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcActualDeterminationType (*this, f, c);
    }

    ArcActualDeterminationType& ArcActualDeterminationType::
    operator= (const ArcActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ArcActualDeterminationType::
    ~ArcActualDeterminationType ()
    {
    }

    // ArcFeatureItemType
    //

    ArcFeatureItemType::
    ArcFeatureItemType (const id_type& id,
                        const FeatureName_type& FeatureName,
                        const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ArcFeatureItemType::
    ArcFeatureItemType (const id_type& id,
                        const FeatureName_type& FeatureName,
                        ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ArcFeatureItemType::
    ArcFeatureItemType (const ArcFeatureItemType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ArcFeatureItemType::
    ArcFeatureItemType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcFeatureItemType* ArcFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcFeatureItemType (*this, f, c);
    }

    ArcFeatureItemType& ArcFeatureItemType::
    operator= (const ArcFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    ArcFeatureItemType::
    ~ArcFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArcFeatureItemType >
    _xsd_ArcFeatureItemType_type_factory_init (
      "ArcFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // ArcFeatureDefinitionType
    //

    ArcFeatureDefinitionType::
    ArcFeatureDefinitionType (const id_type& id,
                              const InternalExternal_type& InternalExternal,
                              const Radius_type& Radius)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Radius_ (Radius, this)
    {
    }

    ArcFeatureDefinitionType::
    ArcFeatureDefinitionType (const id_type& id,
                              const InternalExternal_type& InternalExternal,
                              ::std::auto_ptr< Radius_type > Radius)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Radius_ (Radius, this)
    {
    }

    ArcFeatureDefinitionType::
    ArcFeatureDefinitionType (const ArcFeatureDefinitionType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Radius_ (x.Radius_, f, this)
    {
    }

    ArcFeatureDefinitionType::
    ArcFeatureDefinitionType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Radius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Radius
        //
        if (n.name () == "Radius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Radius_type > r (
            Radius_traits::create (i, f, this));

          if (!Radius_.present ())
          {
            this->Radius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Radius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Radius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcFeatureDefinitionType* ArcFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcFeatureDefinitionType (*this, f, c);
    }

    ArcFeatureDefinitionType& ArcFeatureDefinitionType::
    operator= (const ArcFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Radius_ = x.Radius_;
      }

      return *this;
    }

    ArcFeatureDefinitionType::
    ~ArcFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArcFeatureDefinitionType >
    _xsd_ArcFeatureDefinitionType_type_factory_init (
      "ArcFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // ArcFeatureNominalType
    //

    ArcFeatureNominalType::
    ArcFeatureNominalType (const id_type& id,
                           const FeatureDefinitionId_type& FeatureDefinitionId,
                           const Location_type& Location,
                           const Sweep_type& Sweep,
                           const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Sweep_ (Sweep, this),
      Normal_ (Normal, this)
    {
    }

    ArcFeatureNominalType::
    ArcFeatureNominalType (const id_type& id,
                           const FeatureDefinitionId_type& FeatureDefinitionId,
                           ::std::auto_ptr< Location_type > Location,
                           ::std::auto_ptr< Sweep_type > Sweep,
                           ::std::auto_ptr< Normal_type > Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Sweep_ (Sweep, this),
      Normal_ (Normal, this)
    {
    }

    ArcFeatureNominalType::
    ArcFeatureNominalType (const ArcFeatureNominalType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    ArcFeatureNominalType::
    ArcFeatureNominalType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Sweep_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Sweep",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ArcFeatureNominalType* ArcFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcFeatureNominalType (*this, f, c);
    }

    ArcFeatureNominalType& ArcFeatureNominalType::
    operator= (const ArcFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Sweep_ = x.Sweep_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    ArcFeatureNominalType::
    ~ArcFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArcFeatureNominalType >
    _xsd_ArcFeatureNominalType_type_factory_init (
      "ArcFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // ArcFeatureActualType
    //

    ArcFeatureActualType::
    ArcFeatureActualType (const id_type& id,
                          const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Normal_ (this),
      Radius_ (this),
      RadiusMin_ (this),
      RadiusMax_ (this),
      Sweep_ (this),
      Form_ (this)
    {
    }

    ArcFeatureActualType::
    ArcFeatureActualType (const id_type& id,
                          ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Normal_ (this),
      Radius_ (this),
      RadiusMin_ (this),
      RadiusMax_ (this),
      Sweep_ (this),
      Form_ (this)
    {
    }

    ArcFeatureActualType::
    ArcFeatureActualType (const ArcFeatureActualType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      Radius_ (x.Radius_, f, this),
      RadiusMin_ (x.RadiusMin_, f, this),
      RadiusMax_ (x.RadiusMax_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ArcFeatureActualType::
    ArcFeatureActualType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      Radius_ (this),
      RadiusMin_ (this),
      RadiusMax_ (this),
      Sweep_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ArcFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // Radius
        //
        if (n.name () == "Radius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Radius_type > r (
            Radius_traits::create (i, f, this));

          if (!this->Radius_)
          {
            this->Radius_.set (r);
            continue;
          }
        }

        // RadiusMin
        //
        if (n.name () == "RadiusMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RadiusMin_type > r (
            RadiusMin_traits::create (i, f, this));

          if (!this->RadiusMin_)
          {
            this->RadiusMin_.set (r);
            continue;
          }
        }

        // RadiusMax
        //
        if (n.name () == "RadiusMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RadiusMax_type > r (
            RadiusMax_traits::create (i, f, this));

          if (!this->RadiusMax_)
          {
            this->RadiusMax_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ArcFeatureActualType* ArcFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArcFeatureActualType (*this, f, c);
    }

    ArcFeatureActualType& ArcFeatureActualType::
    operator= (const ArcFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->Radius_ = x.Radius_;
        this->RadiusMin_ = x.RadiusMin_;
        this->RadiusMax_ = x.RadiusMax_;
        this->Sweep_ = x.Sweep_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ArcFeatureActualType::
    ~ArcFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArcFeatureActualType >
    _xsd_ArcFeatureActualType_type_factory_init (
      "ArcFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // CircleConstructionMethodType
    //

    CircleConstructionMethodType::
    CircleConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Tangent_ (this),
      TangentThrough_ (this),
      Transform_ (this),
      FromCone_ (this),
      FromScan_ (this)
    {
    }

    CircleConstructionMethodType::
    CircleConstructionMethodType (const CircleConstructionMethodType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Tangent_ (x.Tangent_, f, this),
      TangentThrough_ (x.TangentThrough_, f, this),
      Transform_ (x.Transform_, f, this),
      FromCone_ (x.FromCone_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    CircleConstructionMethodType::
    CircleConstructionMethodType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Tangent_ (this),
      TangentThrough_ (this),
      Transform_ (this),
      FromCone_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == "Intersection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Tangent
        //
        if (n.name () == "Tangent" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Tangent_type > r (
            Tangent_traits::create (i, f, this));

          if (!this->Tangent_)
          {
            this->Tangent_.set (r);
            continue;
          }
        }

        // TangentThrough
        //
        if (n.name () == "TangentThrough" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentThrough_type > r (
            TangentThrough_traits::create (i, f, this));

          if (!this->TangentThrough_)
          {
            this->TangentThrough_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromCone
        //
        if (n.name () == "FromCone" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromCone_type > r (
            FromCone_traits::create (i, f, this));

          if (!this->FromCone_)
          {
            this->FromCone_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleConstructionMethodType* CircleConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleConstructionMethodType (*this, f, c);
    }

    CircleConstructionMethodType& CircleConstructionMethodType::
    operator= (const CircleConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Intersection_ = x.Intersection_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Tangent_ = x.Tangent_;
        this->TangentThrough_ = x.TangentThrough_;
        this->Transform_ = x.Transform_;
        this->FromCone_ = x.FromCone_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    CircleConstructionMethodType::
    ~CircleConstructionMethodType ()
    {
    }

    // CircleBestFitType
    //

    CircleBestFitType::
    CircleBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    CircleBestFitType::
    CircleBestFitType (const CircleBestFitType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CircleBestFitType::
    CircleBestFitType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    CircleBestFitType* CircleBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleBestFitType (*this, f, c);
    }

    CircleBestFitType& CircleBestFitType::
    operator= (const CircleBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CircleBestFitType::
    ~CircleBestFitType ()
    {
    }

    // CircleRecompType
    //

    CircleRecompType::
    CircleRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CircleRecompType::
    CircleRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CircleRecompType::
    CircleRecompType (const CircleRecompType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CircleRecompType::
    CircleRecompType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleRecompType* CircleRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleRecompType (*this, f, c);
    }

    CircleRecompType& CircleRecompType::
    operator= (const CircleRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    CircleRecompType::
    ~CircleRecompType ()
    {
    }

    // CircleIntersectionType
    //

    CircleIntersectionType::
    CircleIntersectionType (const IntersectionPlane_type& IntersectionPlane,
                            const IntersectionFeature_type& IntersectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, this),
      IntersectionFeature_ (IntersectionFeature, this)
    {
    }

    CircleIntersectionType::
    CircleIntersectionType (::std::auto_ptr< IntersectionPlane_type > IntersectionPlane,
                            ::std::auto_ptr< IntersectionFeature_type > IntersectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, this),
      IntersectionFeature_ (IntersectionFeature, this)
    {
    }

    CircleIntersectionType::
    CircleIntersectionType (const CircleIntersectionType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      IntersectionPlane_ (x.IntersectionPlane_, f, this),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    CircleIntersectionType::
    CircleIntersectionType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionPlane_ (this),
      IntersectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IntersectionPlane
        //
        if (n.name () == "IntersectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IntersectionPlane_type > r (
            IntersectionPlane_traits::create (i, f, this));

          if (!IntersectionPlane_.present ())
          {
            this->IntersectionPlane_.set (r);
            continue;
          }
        }

        // IntersectionFeature
        //
        if (n.name () == "IntersectionFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          if (!IntersectionFeature_.present ())
          {
            this->IntersectionFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!IntersectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IntersectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!IntersectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IntersectionFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleIntersectionType* CircleIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleIntersectionType (*this, f, c);
    }

    CircleIntersectionType& CircleIntersectionType::
    operator= (const CircleIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->IntersectionPlane_ = x.IntersectionPlane_;
        this->IntersectionFeature_ = x.IntersectionFeature_;
      }

      return *this;
    }

    CircleIntersectionType::
    ~CircleIntersectionType ()
    {
    }

    // CircleProjectionType
    //

    CircleProjectionType::
    CircleProjectionType (const ProjectionCircle_type& ProjectionCircle,
                          const ProjectionPlane_type& ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionCircle_ (ProjectionCircle, this),
      ProjectionPlane_ (ProjectionPlane, this)
    {
    }

    CircleProjectionType::
    CircleProjectionType (::std::auto_ptr< ProjectionCircle_type > ProjectionCircle,
                          ::std::auto_ptr< ProjectionPlane_type > ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionCircle_ (ProjectionCircle, this),
      ProjectionPlane_ (ProjectionPlane, this)
    {
    }

    CircleProjectionType::
    CircleProjectionType (const CircleProjectionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionCircle_ (x.ProjectionCircle_, f, this),
      ProjectionPlane_ (x.ProjectionPlane_, f, this)
    {
    }

    CircleProjectionType::
    CircleProjectionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionCircle_ (this),
      ProjectionPlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionCircle
        //
        if (n.name () == "ProjectionCircle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionCircle_type > r (
            ProjectionCircle_traits::create (i, f, this));

          if (!ProjectionCircle_.present ())
          {
            this->ProjectionCircle_.set (r);
            continue;
          }
        }

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionCircle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionCircle",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleProjectionType* CircleProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleProjectionType (*this, f, c);
    }

    CircleProjectionType& CircleProjectionType::
    operator= (const CircleProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionCircle_ = x.ProjectionCircle_;
        this->ProjectionPlane_ = x.ProjectionPlane_;
      }

      return *this;
    }

    CircleProjectionType::
    ~CircleProjectionType ()
    {
    }

    // CircleCopyType
    //

    CircleCopyType::
    CircleCopyType (const BaseCircle_type& BaseCircle)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCircle_ (BaseCircle, this)
    {
    }

    CircleCopyType::
    CircleCopyType (::std::auto_ptr< BaseCircle_type > BaseCircle)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCircle_ (BaseCircle, this)
    {
    }

    CircleCopyType::
    CircleCopyType (const CircleCopyType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCircle_ (x.BaseCircle_, f, this)
    {
    }

    CircleCopyType::
    CircleCopyType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCircle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCircle
        //
        if (n.name () == "BaseCircle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCircle_type > r (
            BaseCircle_traits::create (i, f, this));

          if (!BaseCircle_.present ())
          {
            this->BaseCircle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCircle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCircle",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleCopyType* CircleCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCopyType (*this, f, c);
    }

    CircleCopyType& CircleCopyType::
    operator= (const CircleCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCircle_ = x.BaseCircle_;
      }

      return *this;
    }

    CircleCopyType::
    ~CircleCopyType ()
    {
    }

    // CircleCastType
    //

    CircleCastType::
    CircleCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CircleCastType::
    CircleCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CircleCastType::
    CircleCastType (const CircleCastType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CircleCastType::
    CircleCastType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleCastType* CircleCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCastType (*this, f, c);
    }

    CircleCastType& CircleCastType::
    operator= (const CircleCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CircleCastType::
    ~CircleCastType ()
    {
    }

    // CircleTangentType
    //

    CircleTangentType::
    CircleTangentType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (this)
    {
    }

    CircleTangentType::
    CircleTangentType (const CircleTangentType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this)
    {
    }

    CircleTangentType::
    CircleTangentType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleTangentType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TangentFeature
        //
        if (n.name () == "TangentFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          this->TangentFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    CircleTangentType* CircleTangentType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleTangentType (*this, f, c);
    }

    CircleTangentType& CircleTangentType::
    operator= (const CircleTangentType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->TangentFeature_ = x.TangentFeature_;
      }

      return *this;
    }

    CircleTangentType::
    ~CircleTangentType ()
    {
    }

    // CircleTangentThroughType
    //

    CircleTangentThroughType::
    CircleTangentThroughType (const TangentFeature_type& TangentFeature,
                              const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    CircleTangentThroughType::
    CircleTangentThroughType (::std::auto_ptr< TangentFeature_type > TangentFeature,
                              ::std::auto_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    CircleTangentThroughType::
    CircleTangentThroughType (const CircleTangentThroughType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    CircleTangentThroughType::
    CircleTangentThroughType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleTangentThroughType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TangentFeature
        //
        if (n.name () == "TangentFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          if (!TangentFeature_.present ())
          {
            this->TangentFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!TangentFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TangentFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleTangentThroughType* CircleTangentThroughType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleTangentThroughType (*this, f, c);
    }

    CircleTangentThroughType& CircleTangentThroughType::
    operator= (const CircleTangentThroughType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->TangentFeature_ = x.TangentFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    CircleTangentThroughType::
    ~CircleTangentThroughType ()
    {
    }

    // CircleTransformType
    //

    CircleTransformType::
    CircleTransformType (const BaseCircle_type& BaseCircle,
                         const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCircle_ (BaseCircle, this),
      Transformation_ (Transformation, this)
    {
    }

    CircleTransformType::
    CircleTransformType (::std::auto_ptr< BaseCircle_type > BaseCircle,
                         ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCircle_ (BaseCircle, this),
      Transformation_ (Transformation, this)
    {
    }

    CircleTransformType::
    CircleTransformType (const CircleTransformType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCircle_ (x.BaseCircle_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CircleTransformType::
    CircleTransformType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCircle_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCircle
        //
        if (n.name () == "BaseCircle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCircle_type > r (
            BaseCircle_traits::create (i, f, this));

          if (!BaseCircle_.present ())
          {
            this->BaseCircle_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCircle_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCircle",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleTransformType* CircleTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleTransformType (*this, f, c);
    }

    CircleTransformType& CircleTransformType::
    operator= (const CircleTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCircle_ = x.BaseCircle_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    CircleTransformType::
    ~CircleTransformType ()
    {
    }

    // CircleFromConeType
    //

    CircleFromConeType::
    CircleFromConeType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      Diameter_ (this),
      Distance_ (this)
    {
    }

    CircleFromConeType::
    CircleFromConeType (const CircleFromConeType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      Distance_ (x.Distance_, f, this)
    {
    }

    CircleFromConeType::
    CircleFromConeType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      Diameter_ (this),
      Distance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleFromConeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Distance
        //
        if (n.name () == "Distance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!this->Distance_)
          {
            this->Distance_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleFromConeType* CircleFromConeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFromConeType (*this, f, c);
    }

    CircleFromConeType& CircleFromConeType::
    operator= (const CircleFromConeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->Diameter_ = x.Diameter_;
        this->Distance_ = x.Distance_;
      }

      return *this;
    }

    CircleFromConeType::
    ~CircleFromConeType ()
    {
    }

    // CircleFromScanType
    //

    CircleFromScanType::
    CircleFromScanType (const SurfaceFeature_type& SurfaceFeature,
                        const SearchRadius_type& SearchRadius,
                        const Depth_type& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    CircleFromScanType::
    CircleFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                        ::std::auto_ptr< SearchRadius_type > SearchRadius,
                        ::std::auto_ptr< Depth_type > Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    CircleFromScanType::
    CircleFromScanType (const CircleFromScanType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    CircleFromScanType::
    CircleFromScanType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Depth",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleFromScanType* CircleFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFromScanType (*this, f, c);
    }

    CircleFromScanType& CircleFromScanType::
    operator= (const CircleFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    CircleFromScanType::
    ~CircleFromScanType ()
    {
    }

    // CircleCheckedType
    //

    CircleCheckedType::
    CircleCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    CircleCheckedType::
    CircleCheckedType (const CircleCheckedType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CircleCheckedType::
    CircleCheckedType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleCheckedType* CircleCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCheckedType (*this, f, c);
    }

    CircleCheckedType& CircleCheckedType::
    operator= (const CircleCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CircleCheckedType::
    ~CircleCheckedType ()
    {
    }

    // CircleCheckedFeatureType
    //

    CircleCheckedFeatureType::
    CircleCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    CircleCheckedFeatureType::
    CircleCheckedFeatureType (const CircleCheckedFeatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CircleCheckedFeatureType::
    CircleCheckedFeatureType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleCheckedFeatureType* CircleCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleCheckedFeatureType (*this, f, c);
    }

    CircleCheckedFeatureType& CircleCheckedFeatureType::
    operator= (const CircleCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    CircleCheckedFeatureType::
    ~CircleCheckedFeatureType ()
    {
    }

    // CircleActualDeterminationType
    //

    CircleActualDeterminationType::
    CircleActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    CircleActualDeterminationType::
    CircleActualDeterminationType (const CircleActualDeterminationType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CircleActualDeterminationType::
    CircleActualDeterminationType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CircleActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleActualDeterminationType* CircleActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleActualDeterminationType (*this, f, c);
    }

    CircleActualDeterminationType& CircleActualDeterminationType::
    operator= (const CircleActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    CircleActualDeterminationType::
    ~CircleActualDeterminationType ()
    {
    }

    // CircleFeatureItemType
    //

    CircleFeatureItemType::
    CircleFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    CircleFeatureItemType::
    CircleFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    CircleFeatureItemType::
    CircleFeatureItemType (const CircleFeatureItemType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    CircleFeatureItemType::
    CircleFeatureItemType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleFeatureItemType* CircleFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureItemType (*this, f, c);
    }

    CircleFeatureItemType& CircleFeatureItemType::
    operator= (const CircleFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    CircleFeatureItemType::
    ~CircleFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CircleFeatureItemType >
    _xsd_CircleFeatureItemType_type_factory_init (
      "CircleFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // CircleFeatureDefinitionType
    //

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this)
    {
    }

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 ::std::auto_ptr< Diameter_type > Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this)
    {
    }

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const CircleFeatureDefinitionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this)
    {
    }

    CircleFeatureDefinitionType::
    CircleFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleFeatureDefinitionType* CircleFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureDefinitionType (*this, f, c);
    }

    CircleFeatureDefinitionType& CircleFeatureDefinitionType::
    operator= (const CircleFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
      }

      return *this;
    }

    CircleFeatureDefinitionType::
    ~CircleFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CircleFeatureDefinitionType >
    _xsd_CircleFeatureDefinitionType_type_factory_init (
      "CircleFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // CircleFeatureNominalType
    //

    CircleFeatureNominalType::
    CircleFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              const Location_type& Location,
                              const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (Normal, this)
    {
    }

    CircleFeatureNominalType::
    CircleFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              ::std::auto_ptr< Location_type > Location,
                              ::std::auto_ptr< Normal_type > Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (Normal, this)
    {
    }

    CircleFeatureNominalType::
    CircleFeatureNominalType (const CircleFeatureNominalType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    CircleFeatureNominalType::
    CircleFeatureNominalType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CircleFeatureNominalType* CircleFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureNominalType (*this, f, c);
    }

    CircleFeatureNominalType& CircleFeatureNominalType::
    operator= (const CircleFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    CircleFeatureNominalType::
    ~CircleFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CircleFeatureNominalType >
    _xsd_CircleFeatureNominalType_type_factory_init (
      "CircleFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // CircleFeatureActualType
    //

    CircleFeatureActualType::
    CircleFeatureActualType (const id_type& id,
                             const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Normal_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Form_ (this)
    {
    }

    CircleFeatureActualType::
    CircleFeatureActualType (const id_type& id,
                             ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Normal_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Form_ (this)
    {
    }

    CircleFeatureActualType::
    CircleFeatureActualType (const CircleFeatureActualType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    CircleFeatureActualType::
    CircleFeatureActualType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CircleFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CircleFeatureActualType* CircleFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CircleFeatureActualType (*this, f, c);
    }

    CircleFeatureActualType& CircleFeatureActualType::
    operator= (const CircleFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    CircleFeatureActualType::
    ~CircleFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CircleFeatureActualType >
    _xsd_CircleFeatureActualType_type_factory_init (
      "CircleFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // ConeConstructionMethodType
    //

    ConeConstructionMethodType::
    ConeConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    ConeConstructionMethodType::
    ConeConstructionMethodType (const ConeConstructionMethodType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    ConeConstructionMethodType::
    ConeConstructionMethodType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConeConstructionMethodType* ConeConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeConstructionMethodType (*this, f, c);
    }

    ConeConstructionMethodType& ConeConstructionMethodType::
    operator= (const ConeConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    ConeConstructionMethodType::
    ~ConeConstructionMethodType ()
    {
    }

    // ConeBestFitType
    //

    ConeBestFitType::
    ConeBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ConeBestFitType::
    ConeBestFitType (const ConeBestFitType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ConeBestFitType::
    ConeBestFitType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ConeBestFitType* ConeBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeBestFitType (*this, f, c);
    }

    ConeBestFitType& ConeBestFitType::
    operator= (const ConeBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ConeBestFitType::
    ~ConeBestFitType ()
    {
    }

    // ConeRecompType
    //

    ConeRecompType::
    ConeRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ConeRecompType::
    ConeRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ConeRecompType::
    ConeRecompType (const ConeRecompType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ConeRecompType::
    ConeRecompType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeRecompType* ConeRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeRecompType (*this, f, c);
    }

    ConeRecompType& ConeRecompType::
    operator= (const ConeRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ConeRecompType::
    ~ConeRecompType ()
    {
    }

    // ConeCopyType
    //

    ConeCopyType::
    ConeCopyType (const BaseCone_type& BaseCone)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, this)
    {
    }

    ConeCopyType::
    ConeCopyType (::std::auto_ptr< BaseCone_type > BaseCone)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, this)
    {
    }

    ConeCopyType::
    ConeCopyType (const ConeCopyType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCone_ (x.BaseCone_, f, this)
    {
    }

    ConeCopyType::
    ConeCopyType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCone_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCone
        //
        if (n.name () == "BaseCone" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCone_type > r (
            BaseCone_traits::create (i, f, this));

          if (!BaseCone_.present ())
          {
            this->BaseCone_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCone_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCone",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeCopyType* ConeCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCopyType (*this, f, c);
    }

    ConeCopyType& ConeCopyType::
    operator= (const ConeCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCone_ = x.BaseCone_;
      }

      return *this;
    }

    ConeCopyType::
    ~ConeCopyType ()
    {
    }

    // ConeCastType
    //

    ConeCastType::
    ConeCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ConeCastType::
    ConeCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ConeCastType::
    ConeCastType (const ConeCastType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ConeCastType::
    ConeCastType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeCastType* ConeCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCastType (*this, f, c);
    }

    ConeCastType& ConeCastType::
    operator= (const ConeCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ConeCastType::
    ~ConeCastType ()
    {
    }

    // ConeTransformType
    //

    ConeTransformType::
    ConeTransformType (const BaseCone_type& BaseCone,
                       const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, this),
      Transformation_ (Transformation, this)
    {
    }

    ConeTransformType::
    ConeTransformType (::std::auto_ptr< BaseCone_type > BaseCone,
                       ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, this),
      Transformation_ (Transformation, this)
    {
    }

    ConeTransformType::
    ConeTransformType (const ConeTransformType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCone_ (x.BaseCone_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ConeTransformType::
    ConeTransformType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCone_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCone
        //
        if (n.name () == "BaseCone" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCone_type > r (
            BaseCone_traits::create (i, f, this));

          if (!BaseCone_.present ())
          {
            this->BaseCone_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCone_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCone",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeTransformType* ConeTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeTransformType (*this, f, c);
    }

    ConeTransformType& ConeTransformType::
    operator= (const ConeTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCone_ = x.BaseCone_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ConeTransformType::
    ~ConeTransformType ()
    {
    }

    // ConeFromScanType
    //

    ConeFromScanType::
    ConeFromScanType (const SurfaceFeature_type& SurfaceFeature,
                      const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    ConeFromScanType::
    ConeFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                      ::std::auto_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    ConeFromScanType::
    ConeFromScanType (const ConeFromScanType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    ConeFromScanType::
    ConeFromScanType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeFromScanType* ConeFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFromScanType (*this, f, c);
    }

    ConeFromScanType& ConeFromScanType::
    operator= (const ConeFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    ConeFromScanType::
    ~ConeFromScanType ()
    {
    }

    // ConeCheckedType
    //

    ConeCheckedType::
    ConeCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ConeCheckedType::
    ConeCheckedType (const ConeCheckedType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ConeCheckedType::
    ConeCheckedType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConeCheckedType* ConeCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCheckedType (*this, f, c);
    }

    ConeCheckedType& ConeCheckedType::
    operator= (const ConeCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ConeCheckedType::
    ~ConeCheckedType ()
    {
    }

    // ConeCheckedFeatureType
    //

    ConeCheckedFeatureType::
    ConeCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ConeCheckedFeatureType::
    ConeCheckedFeatureType (const ConeCheckedFeatureType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ConeCheckedFeatureType::
    ConeCheckedFeatureType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConeCheckedFeatureType* ConeCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeCheckedFeatureType (*this, f, c);
    }

    ConeCheckedFeatureType& ConeCheckedFeatureType::
    operator= (const ConeCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ConeCheckedFeatureType::
    ~ConeCheckedFeatureType ()
    {
    }

    // ConeActualDeterminationType
    //

    ConeActualDeterminationType::
    ConeActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ConeActualDeterminationType::
    ConeActualDeterminationType (const ConeActualDeterminationType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ConeActualDeterminationType::
    ConeActualDeterminationType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConeActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConeActualDeterminationType* ConeActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeActualDeterminationType (*this, f, c);
    }

    ConeActualDeterminationType& ConeActualDeterminationType::
    operator= (const ConeActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ConeActualDeterminationType::
    ~ConeActualDeterminationType ()
    {
    }

    // ConeFeatureItemType
    //

    ConeFeatureItemType::
    ConeFeatureItemType (const id_type& id,
                         const FeatureName_type& FeatureName,
                         const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ConeFeatureItemType::
    ConeFeatureItemType (const id_type& id,
                         const FeatureName_type& FeatureName,
                         ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ConeFeatureItemType::
    ConeFeatureItemType (const ConeFeatureItemType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ConeFeatureItemType::
    ConeFeatureItemType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeFeatureItemType* ConeFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureItemType (*this, f, c);
    }

    ConeFeatureItemType& ConeFeatureItemType::
    operator= (const ConeFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    ConeFeatureItemType::
    ~ConeFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConeFeatureItemType >
    _xsd_ConeFeatureItemType_type_factory_init (
      "ConeFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // ConeFeatureDefinitionType
    //

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const id_type& id,
                               const InternalExternal_type& InternalExternal,
                               const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
    }

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const id_type& id,
                               const InternalExternal_type& InternalExternal,
                               ::std::auto_ptr< Diameter_type > Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
    }

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const ConeFeatureDefinitionType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this)
    {
    }

    ConeFeatureDefinitionType::
    ConeFeatureDefinitionType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == "HalfAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (r);
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == "FullAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (r);
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == "LargeEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (r);
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == "SmallEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeFeatureDefinitionType* ConeFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureDefinitionType (*this, f, c);
    }

    ConeFeatureDefinitionType& ConeFeatureDefinitionType::
    operator= (const ConeFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
        this->HalfAngle_ = x.HalfAngle_;
        this->FullAngle_ = x.FullAngle_;
        this->LargeEndDistance_ = x.LargeEndDistance_;
        this->SmallEndDistance_ = x.SmallEndDistance_;
      }

      return *this;
    }

    ConeFeatureDefinitionType::
    ~ConeFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConeFeatureDefinitionType >
    _xsd_ConeFeatureDefinitionType_type_factory_init (
      "ConeFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // ConeFeatureNominalType
    //

    ConeFeatureNominalType::
    ConeFeatureNominalType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId,
                            const Axis_type& Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (this)
    {
    }

    ConeFeatureNominalType::
    ConeFeatureNominalType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId,
                            ::std::auto_ptr< Axis_type > Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (this)
    {
    }

    ConeFeatureNominalType::
    ConeFeatureNominalType (const ConeFeatureNominalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this)
    {
    }

    ConeFeatureNominalType::
    ConeFeatureNominalType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Sweep_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConeFeatureNominalType* ConeFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureNominalType (*this, f, c);
    }

    ConeFeatureNominalType& ConeFeatureNominalType::
    operator= (const ConeFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
      }

      return *this;
    }

    ConeFeatureNominalType::
    ~ConeFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConeFeatureNominalType >
    _xsd_ConeFeatureNominalType_type_factory_init (
      "ConeFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // ConeFeatureActualType
    //

    ConeFeatureActualType::
    ConeFeatureActualType (const id_type& id,
                           const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      Sweep_ (this),
      Form_ (this)
    {
    }

    ConeFeatureActualType::
    ConeFeatureActualType (const id_type& id,
                           ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      Sweep_ (this),
      Form_ (this)
    {
    }

    ConeFeatureActualType::
    ConeFeatureActualType (const ConeFeatureActualType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ConeFeatureActualType::
    ConeFeatureActualType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      Sweep_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConeFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == "HalfAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (r);
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == "FullAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (r);
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == "SmallEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (r);
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == "LargeEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConeFeatureActualType* ConeFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConeFeatureActualType (*this, f, c);
    }

    ConeFeatureActualType& ConeFeatureActualType::
    operator= (const ConeFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->HalfAngle_ = x.HalfAngle_;
        this->FullAngle_ = x.FullAngle_;
        this->SmallEndDistance_ = x.SmallEndDistance_;
        this->LargeEndDistance_ = x.LargeEndDistance_;
        this->Sweep_ = x.Sweep_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ConeFeatureActualType::
    ~ConeFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConeFeatureActualType >
    _xsd_ConeFeatureActualType_type_factory_init (
      "ConeFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // ConicalSegmentConstructionMethodType
    //

    ConicalSegmentConstructionMethodType::
    ConicalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    ConicalSegmentConstructionMethodType::
    ConicalSegmentConstructionMethodType (const ConicalSegmentConstructionMethodType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ConicalSegmentConstructionMethodType::
    ConicalSegmentConstructionMethodType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentConstructionMethodType* ConicalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentConstructionMethodType (*this, f, c);
    }

    ConicalSegmentConstructionMethodType& ConicalSegmentConstructionMethodType::
    operator= (const ConicalSegmentConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    ConicalSegmentConstructionMethodType::
    ~ConicalSegmentConstructionMethodType ()
    {
    }

    // ConicalSegmentBestFitType
    //

    ConicalSegmentBestFitType::
    ConicalSegmentBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ConicalSegmentBestFitType::
    ConicalSegmentBestFitType (const ConicalSegmentBestFitType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ConicalSegmentBestFitType::
    ConicalSegmentBestFitType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ConicalSegmentBestFitType* ConicalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentBestFitType (*this, f, c);
    }

    ConicalSegmentBestFitType& ConicalSegmentBestFitType::
    operator= (const ConicalSegmentBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ConicalSegmentBestFitType::
    ~ConicalSegmentBestFitType ()
    {
    }

    // ConicalSegmentRecompType
    //

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (const ConicalSegmentRecompType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ConicalSegmentRecompType::
    ConicalSegmentRecompType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentRecompType* ConicalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentRecompType (*this, f, c);
    }

    ConicalSegmentRecompType& ConicalSegmentRecompType::
    operator= (const ConicalSegmentRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ConicalSegmentRecompType::
    ~ConicalSegmentRecompType ()
    {
    }

    // ConicalSegmentCopyType
    //

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (const BaseConicalSegment_type& BaseConicalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseConicalSegment_ (BaseConicalSegment, this)
    {
    }

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (::std::auto_ptr< BaseConicalSegment_type > BaseConicalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseConicalSegment_ (BaseConicalSegment, this)
    {
    }

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (const ConicalSegmentCopyType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseConicalSegment_ (x.BaseConicalSegment_, f, this)
    {
    }

    ConicalSegmentCopyType::
    ConicalSegmentCopyType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseConicalSegment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseConicalSegment
        //
        if (n.name () == "BaseConicalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseConicalSegment_type > r (
            BaseConicalSegment_traits::create (i, f, this));

          if (!BaseConicalSegment_.present ())
          {
            this->BaseConicalSegment_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseConicalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseConicalSegment",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentCopyType* ConicalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCopyType (*this, f, c);
    }

    ConicalSegmentCopyType& ConicalSegmentCopyType::
    operator= (const ConicalSegmentCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseConicalSegment_ = x.BaseConicalSegment_;
      }

      return *this;
    }

    ConicalSegmentCopyType::
    ~ConicalSegmentCopyType ()
    {
    }

    // ConicalSegmentCastType
    //

    ConicalSegmentCastType::
    ConicalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ConicalSegmentCastType::
    ConicalSegmentCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ConicalSegmentCastType::
    ConicalSegmentCastType (const ConicalSegmentCastType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ConicalSegmentCastType::
    ConicalSegmentCastType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentCastType* ConicalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCastType (*this, f, c);
    }

    ConicalSegmentCastType& ConicalSegmentCastType::
    operator= (const ConicalSegmentCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ConicalSegmentCastType::
    ~ConicalSegmentCastType ()
    {
    }

    // ConicalSegmentTransformType
    //

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (const BaseConicalSegment_type& BaseConicalSegment,
                                 const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseConicalSegment_ (BaseConicalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (::std::auto_ptr< BaseConicalSegment_type > BaseConicalSegment,
                                 ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseConicalSegment_ (BaseConicalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (const ConicalSegmentTransformType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseConicalSegment_ (x.BaseConicalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ConicalSegmentTransformType::
    ConicalSegmentTransformType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseConicalSegment_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseConicalSegment
        //
        if (n.name () == "BaseConicalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseConicalSegment_type > r (
            BaseConicalSegment_traits::create (i, f, this));

          if (!BaseConicalSegment_.present ())
          {
            this->BaseConicalSegment_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseConicalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseConicalSegment",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentTransformType* ConicalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentTransformType (*this, f, c);
    }

    ConicalSegmentTransformType& ConicalSegmentTransformType::
    operator= (const ConicalSegmentTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseConicalSegment_ = x.BaseConicalSegment_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ConicalSegmentTransformType::
    ~ConicalSegmentTransformType ()
    {
    }

    // ConicalSegmentCheckedType
    //

    ConicalSegmentCheckedType::
    ConicalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ConicalSegmentCheckedType::
    ConicalSegmentCheckedType (const ConicalSegmentCheckedType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ConicalSegmentCheckedType::
    ConicalSegmentCheckedType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentCheckedType* ConicalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCheckedType (*this, f, c);
    }

    ConicalSegmentCheckedType& ConicalSegmentCheckedType::
    operator= (const ConicalSegmentCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ConicalSegmentCheckedType::
    ~ConicalSegmentCheckedType ()
    {
    }

    // ConicalSegmentCheckedFeatureType
    //

    ConicalSegmentCheckedFeatureType::
    ConicalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ConicalSegmentCheckedFeatureType::
    ConicalSegmentCheckedFeatureType (const ConicalSegmentCheckedFeatureType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ConicalSegmentCheckedFeatureType::
    ConicalSegmentCheckedFeatureType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentCheckedFeatureType* ConicalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentCheckedFeatureType (*this, f, c);
    }

    ConicalSegmentCheckedFeatureType& ConicalSegmentCheckedFeatureType::
    operator= (const ConicalSegmentCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ConicalSegmentCheckedFeatureType::
    ~ConicalSegmentCheckedFeatureType ()
    {
    }

    // ConicalSegmentActualDeterminationType
    //

    ConicalSegmentActualDeterminationType::
    ConicalSegmentActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ConicalSegmentActualDeterminationType::
    ConicalSegmentActualDeterminationType (const ConicalSegmentActualDeterminationType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ConicalSegmentActualDeterminationType::
    ConicalSegmentActualDeterminationType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ConicalSegmentActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentActualDeterminationType* ConicalSegmentActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentActualDeterminationType (*this, f, c);
    }

    ConicalSegmentActualDeterminationType& ConicalSegmentActualDeterminationType::
    operator= (const ConicalSegmentActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ConicalSegmentActualDeterminationType::
    ~ConicalSegmentActualDeterminationType ()
    {
    }

    // ConicalSegmentFeatureItemType
    //

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const id_type& id,
                                   const FeatureName_type& FeatureName,
                                   const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const id_type& id,
                                   const FeatureName_type& FeatureName,
                                   ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const ConicalSegmentFeatureItemType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ConicalSegmentFeatureItemType::
    ConicalSegmentFeatureItemType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentFeatureItemType* ConicalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureItemType (*this, f, c);
    }

    ConicalSegmentFeatureItemType& ConicalSegmentFeatureItemType::
    operator= (const ConicalSegmentFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    ConicalSegmentFeatureItemType::
    ~ConicalSegmentFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConicalSegmentFeatureItemType >
    _xsd_ConicalSegmentFeatureItemType_type_factory_init (
      "ConicalSegmentFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // ConicalSegmentFeatureDefinitionType
    //

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const id_type& id,
                                         const InternalExternal_type& InternalExternal,
                                         const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
    }

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const id_type& id,
                                         const InternalExternal_type& InternalExternal,
                                         ::std::auto_ptr< Diameter_type > Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
    }

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const ConicalSegmentFeatureDefinitionType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this)
    {
    }

    ConicalSegmentFeatureDefinitionType::
    ConicalSegmentFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      LargeEndDistance_ (this),
      SmallEndDistance_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == "HalfAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (r);
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == "FullAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (r);
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == "LargeEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (r);
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == "SmallEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentFeatureDefinitionType* ConicalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureDefinitionType (*this, f, c);
    }

    ConicalSegmentFeatureDefinitionType& ConicalSegmentFeatureDefinitionType::
    operator= (const ConicalSegmentFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
        this->HalfAngle_ = x.HalfAngle_;
        this->FullAngle_ = x.FullAngle_;
        this->LargeEndDistance_ = x.LargeEndDistance_;
        this->SmallEndDistance_ = x.SmallEndDistance_;
      }

      return *this;
    }

    ConicalSegmentFeatureDefinitionType::
    ~ConicalSegmentFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConicalSegmentFeatureDefinitionType >
    _xsd_ConicalSegmentFeatureDefinitionType_type_factory_init (
      "ConicalSegmentFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // ConicalSegmentFeatureNominalType
    //

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const id_type& id,
                                      const FeatureDefinitionId_type& FeatureDefinitionId,
                                      const Axis_type& Axis,
                                      const Sweep_type& Sweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (Sweep, this)
    {
    }

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const id_type& id,
                                      const FeatureDefinitionId_type& FeatureDefinitionId,
                                      ::std::auto_ptr< Axis_type > Axis,
                                      ::std::auto_ptr< Sweep_type > Sweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (Sweep, this)
    {
    }

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const ConicalSegmentFeatureNominalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this)
    {
    }

    ConicalSegmentFeatureNominalType::
    ConicalSegmentFeatureNominalType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Sweep_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Sweep",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ConicalSegmentFeatureNominalType* ConicalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureNominalType (*this, f, c);
    }

    ConicalSegmentFeatureNominalType& ConicalSegmentFeatureNominalType::
    operator= (const ConicalSegmentFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
      }

      return *this;
    }

    ConicalSegmentFeatureNominalType::
    ~ConicalSegmentFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConicalSegmentFeatureNominalType >
    _xsd_ConicalSegmentFeatureNominalType_type_factory_init (
      "ConicalSegmentFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // ConicalSegmentFeatureActualType
    //

    ConicalSegmentFeatureActualType::
    ConicalSegmentFeatureActualType (const id_type& id,
                                     const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      Sweep_ (this),
      Form_ (this)
    {
    }

    ConicalSegmentFeatureActualType::
    ConicalSegmentFeatureActualType (const id_type& id,
                                     ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      Sweep_ (this),
      Form_ (this)
    {
    }

    ConicalSegmentFeatureActualType::
    ConicalSegmentFeatureActualType (const ConicalSegmentFeatureActualType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      HalfAngle_ (x.HalfAngle_, f, this),
      FullAngle_ (x.FullAngle_, f, this),
      SmallEndDistance_ (x.SmallEndDistance_, f, this),
      LargeEndDistance_ (x.LargeEndDistance_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ConicalSegmentFeatureActualType::
    ConicalSegmentFeatureActualType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      HalfAngle_ (this),
      FullAngle_ (this),
      SmallEndDistance_ (this),
      LargeEndDistance_ (this),
      Sweep_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConicalSegmentFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // HalfAngle
        //
        if (n.name () == "HalfAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HalfAngle_type > r (
            HalfAngle_traits::create (i, f, this));

          if (!this->HalfAngle_)
          {
            this->HalfAngle_.set (r);
            continue;
          }
        }

        // FullAngle
        //
        if (n.name () == "FullAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FullAngle_type > r (
            FullAngle_traits::create (i, f, this));

          if (!this->FullAngle_)
          {
            this->FullAngle_.set (r);
            continue;
          }
        }

        // SmallEndDistance
        //
        if (n.name () == "SmallEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SmallEndDistance_type > r (
            SmallEndDistance_traits::create (i, f, this));

          if (!this->SmallEndDistance_)
          {
            this->SmallEndDistance_.set (r);
            continue;
          }
        }

        // LargeEndDistance
        //
        if (n.name () == "LargeEndDistance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LargeEndDistance_type > r (
            LargeEndDistance_traits::create (i, f, this));

          if (!this->LargeEndDistance_)
          {
            this->LargeEndDistance_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ConicalSegmentFeatureActualType* ConicalSegmentFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConicalSegmentFeatureActualType (*this, f, c);
    }

    ConicalSegmentFeatureActualType& ConicalSegmentFeatureActualType::
    operator= (const ConicalSegmentFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->HalfAngle_ = x.HalfAngle_;
        this->FullAngle_ = x.FullAngle_;
        this->SmallEndDistance_ = x.SmallEndDistance_;
        this->LargeEndDistance_ = x.LargeEndDistance_;
        this->Sweep_ = x.Sweep_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ConicalSegmentFeatureActualType::
    ~ConicalSegmentFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConicalSegmentFeatureActualType >
    _xsd_ConicalSegmentFeatureActualType_type_factory_init (
      "ConicalSegmentFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // CuboidConstructionMethodType
    //

    CuboidConstructionMethodType::
    CuboidConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    CuboidConstructionMethodType::
    CuboidConstructionMethodType (const CuboidConstructionMethodType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    CuboidConstructionMethodType::
    CuboidConstructionMethodType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CuboidConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidConstructionMethodType* CuboidConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidConstructionMethodType (*this, f, c);
    }

    CuboidConstructionMethodType& CuboidConstructionMethodType::
    operator= (const CuboidConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    CuboidConstructionMethodType::
    ~CuboidConstructionMethodType ()
    {
    }

    // CuboidBestFitType
    //

    CuboidBestFitType::
    CuboidBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    CuboidBestFitType::
    CuboidBestFitType (const CuboidBestFitType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CuboidBestFitType::
    CuboidBestFitType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CuboidBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    CuboidBestFitType* CuboidBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidBestFitType (*this, f, c);
    }

    CuboidBestFitType& CuboidBestFitType::
    operator= (const CuboidBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CuboidBestFitType::
    ~CuboidBestFitType ()
    {
    }

    // CuboidRecompType
    //

    CuboidRecompType::
    CuboidRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CuboidRecompType::
    CuboidRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CuboidRecompType::
    CuboidRecompType (const CuboidRecompType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CuboidRecompType::
    CuboidRecompType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CuboidRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidRecompType* CuboidRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidRecompType (*this, f, c);
    }

    CuboidRecompType& CuboidRecompType::
    operator= (const CuboidRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    CuboidRecompType::
    ~CuboidRecompType ()
    {
    }

    // CuboidCopyType
    //

    CuboidCopyType::
    CuboidCopyType (const BaseCuboid_type& BaseCuboid)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCuboid_ (BaseCuboid, this)
    {
    }

    CuboidCopyType::
    CuboidCopyType (::std::auto_ptr< BaseCuboid_type > BaseCuboid)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCuboid_ (BaseCuboid, this)
    {
    }

    CuboidCopyType::
    CuboidCopyType (const CuboidCopyType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCuboid_ (x.BaseCuboid_, f, this)
    {
    }

    CuboidCopyType::
    CuboidCopyType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCuboid_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CuboidCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCuboid
        //
        if (n.name () == "BaseCuboid" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCuboid_type > r (
            BaseCuboid_traits::create (i, f, this));

          if (!BaseCuboid_.present ())
          {
            this->BaseCuboid_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCuboid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCuboid",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidCopyType* CuboidCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidCopyType (*this, f, c);
    }

    CuboidCopyType& CuboidCopyType::
    operator= (const CuboidCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCuboid_ = x.BaseCuboid_;
      }

      return *this;
    }

    CuboidCopyType::
    ~CuboidCopyType ()
    {
    }

    // CuboidCastType
    //

    CuboidCastType::
    CuboidCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CuboidCastType::
    CuboidCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CuboidCastType::
    CuboidCastType (const CuboidCastType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CuboidCastType::
    CuboidCastType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CuboidCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidCastType* CuboidCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidCastType (*this, f, c);
    }

    CuboidCastType& CuboidCastType::
    operator= (const CuboidCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CuboidCastType::
    ~CuboidCastType ()
    {
    }

    // CuboidTransformType
    //

    CuboidTransformType::
    CuboidTransformType (const BaseCuboid_type& BaseCuboid,
                         const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCuboid_ (BaseCuboid, this),
      Transformation_ (Transformation, this)
    {
    }

    CuboidTransformType::
    CuboidTransformType (::std::auto_ptr< BaseCuboid_type > BaseCuboid,
                         ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCuboid_ (BaseCuboid, this),
      Transformation_ (Transformation, this)
    {
    }

    CuboidTransformType::
    CuboidTransformType (const CuboidTransformType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCuboid_ (x.BaseCuboid_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CuboidTransformType::
    CuboidTransformType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCuboid_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CuboidTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCuboid
        //
        if (n.name () == "BaseCuboid" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCuboid_type > r (
            BaseCuboid_traits::create (i, f, this));

          if (!BaseCuboid_.present ())
          {
            this->BaseCuboid_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCuboid_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCuboid",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidTransformType* CuboidTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidTransformType (*this, f, c);
    }

    CuboidTransformType& CuboidTransformType::
    operator= (const CuboidTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCuboid_ = x.BaseCuboid_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    CuboidTransformType::
    ~CuboidTransformType ()
    {
    }

    // CuboidCheckedType
    //

    CuboidCheckedType::
    CuboidCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    CuboidCheckedType::
    CuboidCheckedType (const CuboidCheckedType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CuboidCheckedType::
    CuboidCheckedType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CuboidCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidCheckedType* CuboidCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidCheckedType (*this, f, c);
    }

    CuboidCheckedType& CuboidCheckedType::
    operator= (const CuboidCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CuboidCheckedType::
    ~CuboidCheckedType ()
    {
    }

    // CuboidCheckedFeatureType
    //

    CuboidCheckedFeatureType::
    CuboidCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    CuboidCheckedFeatureType::
    CuboidCheckedFeatureType (const CuboidCheckedFeatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CuboidCheckedFeatureType::
    CuboidCheckedFeatureType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CuboidCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidCheckedFeatureType* CuboidCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidCheckedFeatureType (*this, f, c);
    }

    CuboidCheckedFeatureType& CuboidCheckedFeatureType::
    operator= (const CuboidCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    CuboidCheckedFeatureType::
    ~CuboidCheckedFeatureType ()
    {
    }

    // CuboidActualDeterminationType
    //

    CuboidActualDeterminationType::
    CuboidActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    CuboidActualDeterminationType::
    CuboidActualDeterminationType (const CuboidActualDeterminationType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CuboidActualDeterminationType::
    CuboidActualDeterminationType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CuboidActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidActualDeterminationType* CuboidActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidActualDeterminationType (*this, f, c);
    }

    CuboidActualDeterminationType& CuboidActualDeterminationType::
    operator= (const CuboidActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    CuboidActualDeterminationType::
    ~CuboidActualDeterminationType ()
    {
    }

    // CuboidFeatureItemType
    //

    CuboidFeatureItemType::
    CuboidFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    CuboidFeatureItemType::
    CuboidFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    CuboidFeatureItemType::
    CuboidFeatureItemType (const CuboidFeatureItemType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    CuboidFeatureItemType::
    CuboidFeatureItemType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CuboidFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidFeatureItemType* CuboidFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidFeatureItemType (*this, f, c);
    }

    CuboidFeatureItemType& CuboidFeatureItemType::
    operator= (const CuboidFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    CuboidFeatureItemType::
    ~CuboidFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CuboidFeatureItemType >
    _xsd_CuboidFeatureItemType_type_factory_init (
      "CuboidFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // CuboidFeatureDefinitionType
    //

    CuboidFeatureDefinitionType::
    CuboidFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 const Length_type& Length,
                                 const Width_type& Width,
                                 const Height_type& Height)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Length_ (Length, this),
      Width_ (Width, this),
      Height_ (Height, this)
    {
    }

    CuboidFeatureDefinitionType::
    CuboidFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 ::std::auto_ptr< Length_type > Length,
                                 ::std::auto_ptr< Width_type > Width,
                                 ::std::auto_ptr< Height_type > Height)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Length_ (Length, this),
      Width_ (Width, this),
      Height_ (Height, this)
    {
    }

    CuboidFeatureDefinitionType::
    CuboidFeatureDefinitionType (const CuboidFeatureDefinitionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Length_ (x.Length_, f, this),
      Width_ (x.Width_, f, this),
      Height_ (x.Height_, f, this)
    {
    }

    CuboidFeatureDefinitionType::
    CuboidFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Length_ (this),
      Width_ (this),
      Height_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CuboidFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (r);
            continue;
          }
        }

        // Height
        //
        if (n.name () == "Height" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Height_type > r (
            Height_traits::create (i, f, this));

          if (!Height_.present ())
          {
            this->Height_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Length",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Width",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Height_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Height",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidFeatureDefinitionType* CuboidFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidFeatureDefinitionType (*this, f, c);
    }

    CuboidFeatureDefinitionType& CuboidFeatureDefinitionType::
    operator= (const CuboidFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Length_ = x.Length_;
        this->Width_ = x.Width_;
        this->Height_ = x.Height_;
      }

      return *this;
    }

    CuboidFeatureDefinitionType::
    ~CuboidFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CuboidFeatureDefinitionType >
    _xsd_CuboidFeatureDefinitionType_type_factory_init (
      "CuboidFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // CuboidFeatureNominalType
    //

    CuboidFeatureNominalType::
    CuboidFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              const Location_type& Location,
                              const LengthVector_type& LengthVector,
                              const HeightVector_type& HeightVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      LengthVector_ (LengthVector, this),
      HeightVector_ (HeightVector, this)
    {
    }

    CuboidFeatureNominalType::
    CuboidFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              ::std::auto_ptr< Location_type > Location,
                              ::std::auto_ptr< LengthVector_type > LengthVector,
                              ::std::auto_ptr< HeightVector_type > HeightVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      LengthVector_ (LengthVector, this),
      HeightVector_ (HeightVector, this)
    {
    }

    CuboidFeatureNominalType::
    CuboidFeatureNominalType (const CuboidFeatureNominalType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      HeightVector_ (x.HeightVector_, f, this)
    {
    }

    CuboidFeatureNominalType::
    CuboidFeatureNominalType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      LengthVector_ (this),
      HeightVector_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CuboidFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == "LengthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!LengthVector_.present ())
          {
            this->LengthVector_.set (r);
            continue;
          }
        }

        // HeightVector
        //
        if (n.name () == "HeightVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HeightVector_type > r (
            HeightVector_traits::create (i, f, this));

          if (!HeightVector_.present ())
          {
            this->HeightVector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!LengthVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LengthVector",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!HeightVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "HeightVector",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CuboidFeatureNominalType* CuboidFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidFeatureNominalType (*this, f, c);
    }

    CuboidFeatureNominalType& CuboidFeatureNominalType::
    operator= (const CuboidFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->LengthVector_ = x.LengthVector_;
        this->HeightVector_ = x.HeightVector_;
      }

      return *this;
    }

    CuboidFeatureNominalType::
    ~CuboidFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CuboidFeatureNominalType >
    _xsd_CuboidFeatureNominalType_type_factory_init (
      "CuboidFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // CuboidFeatureActualType
    //

    CuboidFeatureActualType::
    CuboidFeatureActualType (const id_type& id,
                             const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      LengthVector_ (this),
      Width_ (this),
      WidthMax_ (this),
      WidthMin_ (this),
      Height_ (this),
      HeightMax_ (this),
      HeightMin_ (this),
      HeightVector_ (this),
      Form_ (this)
    {
    }

    CuboidFeatureActualType::
    CuboidFeatureActualType (const id_type& id,
                             ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      LengthVector_ (this),
      Width_ (this),
      WidthMax_ (this),
      WidthMin_ (this),
      Height_ (this),
      HeightMax_ (this),
      HeightMin_ (this),
      HeightVector_ (this),
      Form_ (this)
    {
    }

    CuboidFeatureActualType::
    CuboidFeatureActualType (const CuboidFeatureActualType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Length_ (x.Length_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      Width_ (x.Width_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      Height_ (x.Height_, f, this),
      HeightMax_ (x.HeightMax_, f, this),
      HeightMin_ (x.HeightMin_, f, this),
      HeightVector_ (x.HeightVector_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    CuboidFeatureActualType::
    CuboidFeatureActualType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      LengthVector_ (this),
      Width_ (this),
      WidthMax_ (this),
      WidthMin_ (this),
      Height_ (this),
      HeightMax_ (this),
      HeightMin_ (this),
      HeightVector_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CuboidFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == "LengthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (r);
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == "LengthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (r);
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == "LengthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!this->LengthVector_)
          {
            this->LengthVector_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (r);
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == "WidthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (r);
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == "WidthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (r);
            continue;
          }
        }

        // Height
        //
        if (n.name () == "Height" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Height_type > r (
            Height_traits::create (i, f, this));

          if (!this->Height_)
          {
            this->Height_.set (r);
            continue;
          }
        }

        // HeightMax
        //
        if (n.name () == "HeightMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HeightMax_type > r (
            HeightMax_traits::create (i, f, this));

          if (!this->HeightMax_)
          {
            this->HeightMax_.set (r);
            continue;
          }
        }

        // HeightMin
        //
        if (n.name () == "HeightMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HeightMin_type > r (
            HeightMin_traits::create (i, f, this));

          if (!this->HeightMin_)
          {
            this->HeightMin_.set (r);
            continue;
          }
        }

        // HeightVector
        //
        if (n.name () == "HeightVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< HeightVector_type > r (
            HeightVector_traits::create (i, f, this));

          if (!this->HeightVector_)
          {
            this->HeightVector_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CuboidFeatureActualType* CuboidFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CuboidFeatureActualType (*this, f, c);
    }

    CuboidFeatureActualType& CuboidFeatureActualType::
    operator= (const CuboidFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Length_ = x.Length_;
        this->LengthMax_ = x.LengthMax_;
        this->LengthMin_ = x.LengthMin_;
        this->LengthVector_ = x.LengthVector_;
        this->Width_ = x.Width_;
        this->WidthMax_ = x.WidthMax_;
        this->WidthMin_ = x.WidthMin_;
        this->Height_ = x.Height_;
        this->HeightMax_ = x.HeightMax_;
        this->HeightMin_ = x.HeightMin_;
        this->HeightVector_ = x.HeightVector_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    CuboidFeatureActualType::
    ~CuboidFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CuboidFeatureActualType >
    _xsd_CuboidFeatureActualType_type_factory_init (
      "CuboidFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // CylinderConstructionMethodType
    //

    CylinderConstructionMethodType::
    CylinderConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    CylinderConstructionMethodType::
    CylinderConstructionMethodType (const CylinderConstructionMethodType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    CylinderConstructionMethodType::
    CylinderConstructionMethodType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderConstructionMethodType* CylinderConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderConstructionMethodType (*this, f, c);
    }

    CylinderConstructionMethodType& CylinderConstructionMethodType::
    operator= (const CylinderConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    CylinderConstructionMethodType::
    ~CylinderConstructionMethodType ()
    {
    }

    // CylinderBestFitType
    //

    CylinderBestFitType::
    CylinderBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    CylinderBestFitType::
    CylinderBestFitType (const CylinderBestFitType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CylinderBestFitType::
    CylinderBestFitType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    CylinderBestFitType* CylinderBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderBestFitType (*this, f, c);
    }

    CylinderBestFitType& CylinderBestFitType::
    operator= (const CylinderBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CylinderBestFitType::
    ~CylinderBestFitType ()
    {
    }

    // CylinderRecompType
    //

    CylinderRecompType::
    CylinderRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CylinderRecompType::
    CylinderRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CylinderRecompType::
    CylinderRecompType (const CylinderRecompType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CylinderRecompType::
    CylinderRecompType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderRecompType* CylinderRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderRecompType (*this, f, c);
    }

    CylinderRecompType& CylinderRecompType::
    operator= (const CylinderRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    CylinderRecompType::
    ~CylinderRecompType ()
    {
    }

    // CylinderCopyType
    //

    CylinderCopyType::
    CylinderCopyType (const BaseCylinder_type& BaseCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, this)
    {
    }

    CylinderCopyType::
    CylinderCopyType (::std::auto_ptr< BaseCylinder_type > BaseCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, this)
    {
    }

    CylinderCopyType::
    CylinderCopyType (const CylinderCopyType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCylinder_ (x.BaseCylinder_, f, this)
    {
    }

    CylinderCopyType::
    CylinderCopyType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylinder_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCylinder
        //
        if (n.name () == "BaseCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCylinder_type > r (
            BaseCylinder_traits::create (i, f, this));

          if (!BaseCylinder_.present ())
          {
            this->BaseCylinder_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCylinder",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderCopyType* CylinderCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCopyType (*this, f, c);
    }

    CylinderCopyType& CylinderCopyType::
    operator= (const CylinderCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCylinder_ = x.BaseCylinder_;
      }

      return *this;
    }

    CylinderCopyType::
    ~CylinderCopyType ()
    {
    }

    // CylinderCastType
    //

    CylinderCastType::
    CylinderCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CylinderCastType::
    CylinderCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CylinderCastType::
    CylinderCastType (const CylinderCastType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CylinderCastType::
    CylinderCastType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderCastType* CylinderCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCastType (*this, f, c);
    }

    CylinderCastType& CylinderCastType::
    operator= (const CylinderCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CylinderCastType::
    ~CylinderCastType ()
    {
    }

    // CylinderTransformType
    //

    CylinderTransformType::
    CylinderTransformType (const BaseCylinder_type& BaseCylinder,
                           const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, this),
      Transformation_ (Transformation, this)
    {
    }

    CylinderTransformType::
    CylinderTransformType (::std::auto_ptr< BaseCylinder_type > BaseCylinder,
                           ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, this),
      Transformation_ (Transformation, this)
    {
    }

    CylinderTransformType::
    CylinderTransformType (const CylinderTransformType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCylinder_ (x.BaseCylinder_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CylinderTransformType::
    CylinderTransformType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylinder_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCylinder
        //
        if (n.name () == "BaseCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCylinder_type > r (
            BaseCylinder_traits::create (i, f, this));

          if (!BaseCylinder_.present ())
          {
            this->BaseCylinder_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCylinder",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderTransformType* CylinderTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderTransformType (*this, f, c);
    }

    CylinderTransformType& CylinderTransformType::
    operator= (const CylinderTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCylinder_ = x.BaseCylinder_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    CylinderTransformType::
    ~CylinderTransformType ()
    {
    }

    // CylinderFromScanType
    //

    CylinderFromScanType::
    CylinderFromScanType (const SurfaceFeature_type& SurfaceFeature,
                          const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    CylinderFromScanType::
    CylinderFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                          ::std::auto_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    CylinderFromScanType::
    CylinderFromScanType (const CylinderFromScanType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    CylinderFromScanType::
    CylinderFromScanType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderFromScanType* CylinderFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFromScanType (*this, f, c);
    }

    CylinderFromScanType& CylinderFromScanType::
    operator= (const CylinderFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    CylinderFromScanType::
    ~CylinderFromScanType ()
    {
    }

    // CylinderCheckedType
    //

    CylinderCheckedType::
    CylinderCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    CylinderCheckedType::
    CylinderCheckedType (const CylinderCheckedType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CylinderCheckedType::
    CylinderCheckedType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderCheckedType* CylinderCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCheckedType (*this, f, c);
    }

    CylinderCheckedType& CylinderCheckedType::
    operator= (const CylinderCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CylinderCheckedType::
    ~CylinderCheckedType ()
    {
    }

    // CylinderCheckedFeatureType
    //

    CylinderCheckedFeatureType::
    CylinderCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    CylinderCheckedFeatureType::
    CylinderCheckedFeatureType (const CylinderCheckedFeatureType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CylinderCheckedFeatureType::
    CylinderCheckedFeatureType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderCheckedFeatureType* CylinderCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderCheckedFeatureType (*this, f, c);
    }

    CylinderCheckedFeatureType& CylinderCheckedFeatureType::
    operator= (const CylinderCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    CylinderCheckedFeatureType::
    ~CylinderCheckedFeatureType ()
    {
    }

    // CylinderActualDeterminationType
    //

    CylinderActualDeterminationType::
    CylinderActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    CylinderActualDeterminationType::
    CylinderActualDeterminationType (const CylinderActualDeterminationType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CylinderActualDeterminationType::
    CylinderActualDeterminationType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylinderActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderActualDeterminationType* CylinderActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderActualDeterminationType (*this, f, c);
    }

    CylinderActualDeterminationType& CylinderActualDeterminationType::
    operator= (const CylinderActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    CylinderActualDeterminationType::
    ~CylinderActualDeterminationType ()
    {
    }

    // CylinderFeatureItemType
    //

    CylinderFeatureItemType::
    CylinderFeatureItemType (const id_type& id,
                             const FeatureName_type& FeatureName,
                             const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    CylinderFeatureItemType::
    CylinderFeatureItemType (const id_type& id,
                             const FeatureName_type& FeatureName,
                             ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    CylinderFeatureItemType::
    CylinderFeatureItemType (const CylinderFeatureItemType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    CylinderFeatureItemType::
    CylinderFeatureItemType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderFeatureItemType* CylinderFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureItemType (*this, f, c);
    }

    CylinderFeatureItemType& CylinderFeatureItemType::
    operator= (const CylinderFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    CylinderFeatureItemType::
    ~CylinderFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CylinderFeatureItemType >
    _xsd_CylinderFeatureItemType_type_factory_init (
      "CylinderFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // CylinderFeatureDefinitionType
    //

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   ::std::auto_ptr< Diameter_type > Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const CylinderFeatureDefinitionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      Bottom_ (x.Bottom_, f, this)
    {
    }

    CylinderFeatureDefinitionType::
    CylinderFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this),
      Length_ (this),
      Bottom_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == "Bottom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderFeatureDefinitionType* CylinderFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureDefinitionType (*this, f, c);
    }

    CylinderFeatureDefinitionType& CylinderFeatureDefinitionType::
    operator= (const CylinderFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
        this->Bottom_ = x.Bottom_;
      }

      return *this;
    }

    CylinderFeatureDefinitionType::
    ~CylinderFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CylinderFeatureDefinitionType >
    _xsd_CylinderFeatureDefinitionType_type_factory_init (
      "CylinderFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // CylinderFeatureNominalType
    //

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                const Axis_type& Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (this)
    {
    }

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                ::std::auto_ptr< Axis_type > Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (this)
    {
    }

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const CylinderFeatureNominalType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this)
    {
    }

    CylinderFeatureNominalType::
    CylinderFeatureNominalType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Sweep_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylinderFeatureNominalType* CylinderFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureNominalType (*this, f, c);
    }

    CylinderFeatureNominalType& CylinderFeatureNominalType::
    operator= (const CylinderFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
      }

      return *this;
    }

    CylinderFeatureNominalType::
    ~CylinderFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CylinderFeatureNominalType >
    _xsd_CylinderFeatureNominalType_type_factory_init (
      "CylinderFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // CylinderFeatureActualType
    //

    CylinderFeatureActualType::
    CylinderFeatureActualType (const id_type& id,
                               const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Sweep_ (this),
      Form_ (this)
    {
    }

    CylinderFeatureActualType::
    CylinderFeatureActualType (const id_type& id,
                               ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Sweep_ (this),
      Form_ (this)
    {
    }

    CylinderFeatureActualType::
    CylinderFeatureActualType (const CylinderFeatureActualType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    CylinderFeatureActualType::
    CylinderFeatureActualType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Sweep_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylinderFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylinderFeatureActualType* CylinderFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylinderFeatureActualType (*this, f, c);
    }

    CylinderFeatureActualType& CylinderFeatureActualType::
    operator= (const CylinderFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->Sweep_ = x.Sweep_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    CylinderFeatureActualType::
    ~CylinderFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CylinderFeatureActualType >
    _xsd_CylinderFeatureActualType_type_factory_init (
      "CylinderFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // CylindricalSegmentConstructionMethodType
    //

    CylindricalSegmentConstructionMethodType::
    CylindricalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    CylindricalSegmentConstructionMethodType::
    CylindricalSegmentConstructionMethodType (const CylindricalSegmentConstructionMethodType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    CylindricalSegmentConstructionMethodType::
    CylindricalSegmentConstructionMethodType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentConstructionMethodType* CylindricalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentConstructionMethodType (*this, f, c);
    }

    CylindricalSegmentConstructionMethodType& CylindricalSegmentConstructionMethodType::
    operator= (const CylindricalSegmentConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    CylindricalSegmentConstructionMethodType::
    ~CylindricalSegmentConstructionMethodType ()
    {
    }

    // CylindricalSegmentBestFitType
    //

    CylindricalSegmentBestFitType::
    CylindricalSegmentBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    CylindricalSegmentBestFitType::
    CylindricalSegmentBestFitType (const CylindricalSegmentBestFitType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CylindricalSegmentBestFitType::
    CylindricalSegmentBestFitType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    CylindricalSegmentBestFitType* CylindricalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentBestFitType (*this, f, c);
    }

    CylindricalSegmentBestFitType& CylindricalSegmentBestFitType::
    operator= (const CylindricalSegmentBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CylindricalSegmentBestFitType::
    ~CylindricalSegmentBestFitType ()
    {
    }

    // CylindricalSegmentRecompType
    //

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (const CylindricalSegmentRecompType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    CylindricalSegmentRecompType::
    CylindricalSegmentRecompType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentRecompType* CylindricalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentRecompType (*this, f, c);
    }

    CylindricalSegmentRecompType& CylindricalSegmentRecompType::
    operator= (const CylindricalSegmentRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    CylindricalSegmentRecompType::
    ~CylindricalSegmentRecompType ()
    {
    }

    // CylindricalSegmentCopyType
    //

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (const BaseCylindricalSegment_type& BaseCylindricalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (BaseCylindricalSegment, this)
    {
    }

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (::std::auto_ptr< BaseCylindricalSegment_type > BaseCylindricalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (BaseCylindricalSegment, this)
    {
    }

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (const CylindricalSegmentCopyType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCylindricalSegment_ (x.BaseCylindricalSegment_, f, this)
    {
    }

    CylindricalSegmentCopyType::
    CylindricalSegmentCopyType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylindricalSegment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCylindricalSegment
        //
        if (n.name () == "BaseCylindricalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCylindricalSegment_type > r (
            BaseCylindricalSegment_traits::create (i, f, this));

          if (!BaseCylindricalSegment_.present ())
          {
            this->BaseCylindricalSegment_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCylindricalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCylindricalSegment",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentCopyType* CylindricalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCopyType (*this, f, c);
    }

    CylindricalSegmentCopyType& CylindricalSegmentCopyType::
    operator= (const CylindricalSegmentCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCylindricalSegment_ = x.BaseCylindricalSegment_;
      }

      return *this;
    }

    CylindricalSegmentCopyType::
    ~CylindricalSegmentCopyType ()
    {
    }

    // CylindricalSegmentCastType
    //

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (const CylindricalSegmentCastType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    CylindricalSegmentCastType::
    CylindricalSegmentCastType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentCastType* CylindricalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCastType (*this, f, c);
    }

    CylindricalSegmentCastType& CylindricalSegmentCastType::
    operator= (const CylindricalSegmentCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    CylindricalSegmentCastType::
    ~CylindricalSegmentCastType ()
    {
    }

    // CylindricalSegmentTransformType
    //

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (const BaseCylindricalSegment_type& BaseCylindricalSegment,
                                     const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (BaseCylindricalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (::std::auto_ptr< BaseCylindricalSegment_type > BaseCylindricalSegment,
                                     ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylindricalSegment_ (BaseCylindricalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (const CylindricalSegmentTransformType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCylindricalSegment_ (x.BaseCylindricalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    CylindricalSegmentTransformType::
    CylindricalSegmentTransformType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylindricalSegment_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCylindricalSegment
        //
        if (n.name () == "BaseCylindricalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCylindricalSegment_type > r (
            BaseCylindricalSegment_traits::create (i, f, this));

          if (!BaseCylindricalSegment_.present ())
          {
            this->BaseCylindricalSegment_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCylindricalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCylindricalSegment",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentTransformType* CylindricalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentTransformType (*this, f, c);
    }

    CylindricalSegmentTransformType& CylindricalSegmentTransformType::
    operator= (const CylindricalSegmentTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCylindricalSegment_ = x.BaseCylindricalSegment_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    CylindricalSegmentTransformType::
    ~CylindricalSegmentTransformType ()
    {
    }

    // CylindricalSegmentCheckedType
    //

    CylindricalSegmentCheckedType::
    CylindricalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    CylindricalSegmentCheckedType::
    CylindricalSegmentCheckedType (const CylindricalSegmentCheckedType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    CylindricalSegmentCheckedType::
    CylindricalSegmentCheckedType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentCheckedType* CylindricalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCheckedType (*this, f, c);
    }

    CylindricalSegmentCheckedType& CylindricalSegmentCheckedType::
    operator= (const CylindricalSegmentCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    CylindricalSegmentCheckedType::
    ~CylindricalSegmentCheckedType ()
    {
    }

    // CylindricalSegmentCheckedFeatureType
    //

    CylindricalSegmentCheckedFeatureType::
    CylindricalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    CylindricalSegmentCheckedFeatureType::
    CylindricalSegmentCheckedFeatureType (const CylindricalSegmentCheckedFeatureType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    CylindricalSegmentCheckedFeatureType::
    CylindricalSegmentCheckedFeatureType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentCheckedFeatureType* CylindricalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentCheckedFeatureType (*this, f, c);
    }

    CylindricalSegmentCheckedFeatureType& CylindricalSegmentCheckedFeatureType::
    operator= (const CylindricalSegmentCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    CylindricalSegmentCheckedFeatureType::
    ~CylindricalSegmentCheckedFeatureType ()
    {
    }

    // CylindricalSegmentActualDeterminationType
    //

    CylindricalSegmentActualDeterminationType::
    CylindricalSegmentActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    CylindricalSegmentActualDeterminationType::
    CylindricalSegmentActualDeterminationType (const CylindricalSegmentActualDeterminationType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    CylindricalSegmentActualDeterminationType::
    CylindricalSegmentActualDeterminationType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentActualDeterminationType* CylindricalSegmentActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentActualDeterminationType (*this, f, c);
    }

    CylindricalSegmentActualDeterminationType& CylindricalSegmentActualDeterminationType::
    operator= (const CylindricalSegmentActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    CylindricalSegmentActualDeterminationType::
    ~CylindricalSegmentActualDeterminationType ()
    {
    }

    // CylindricalSegmentFeatureItemType
    //

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const id_type& id,
                                       const FeatureName_type& FeatureName,
                                       const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const id_type& id,
                                       const FeatureName_type& FeatureName,
                                       ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const CylindricalSegmentFeatureItemType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    CylindricalSegmentFeatureItemType::
    CylindricalSegmentFeatureItemType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentFeatureItemType* CylindricalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureItemType (*this, f, c);
    }

    CylindricalSegmentFeatureItemType& CylindricalSegmentFeatureItemType::
    operator= (const CylindricalSegmentFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    CylindricalSegmentFeatureItemType::
    ~CylindricalSegmentFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CylindricalSegmentFeatureItemType >
    _xsd_CylindricalSegmentFeatureItemType_type_factory_init (
      "CylindricalSegmentFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // CylindricalSegmentFeatureDefinitionType
    //

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const id_type& id,
                                             const InternalExternal_type& InternalExternal,
                                             const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const id_type& id,
                                             const InternalExternal_type& InternalExternal,
                                             ::std::auto_ptr< Diameter_type > Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const CylindricalSegmentFeatureDefinitionType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      Bottom_ (x.Bottom_, f, this)
    {
    }

    CylindricalSegmentFeatureDefinitionType::
    CylindricalSegmentFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this),
      Length_ (this),
      Bottom_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == "Bottom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentFeatureDefinitionType* CylindricalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureDefinitionType (*this, f, c);
    }

    CylindricalSegmentFeatureDefinitionType& CylindricalSegmentFeatureDefinitionType::
    operator= (const CylindricalSegmentFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
        this->Bottom_ = x.Bottom_;
      }

      return *this;
    }

    CylindricalSegmentFeatureDefinitionType::
    ~CylindricalSegmentFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CylindricalSegmentFeatureDefinitionType >
    _xsd_CylindricalSegmentFeatureDefinitionType_type_factory_init (
      "CylindricalSegmentFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // CylindricalSegmentFeatureNominalType
    //

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const id_type& id,
                                          const FeatureDefinitionId_type& FeatureDefinitionId,
                                          const Axis_type& Axis,
                                          const Sweep_type& Sweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (Sweep, this)
    {
    }

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const id_type& id,
                                          const FeatureDefinitionId_type& FeatureDefinitionId,
                                          ::std::auto_ptr< Axis_type > Axis,
                                          ::std::auto_ptr< Sweep_type > Sweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (Sweep, this)
    {
    }

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const CylindricalSegmentFeatureNominalType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this)
    {
    }

    CylindricalSegmentFeatureNominalType::
    CylindricalSegmentFeatureNominalType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Sweep_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!Sweep_.present ())
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Sweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Sweep",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CylindricalSegmentFeatureNominalType* CylindricalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureNominalType (*this, f, c);
    }

    CylindricalSegmentFeatureNominalType& CylindricalSegmentFeatureNominalType::
    operator= (const CylindricalSegmentFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
      }

      return *this;
    }

    CylindricalSegmentFeatureNominalType::
    ~CylindricalSegmentFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CylindricalSegmentFeatureNominalType >
    _xsd_CylindricalSegmentFeatureNominalType_type_factory_init (
      "CylindricalSegmentFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // CylindricalSegmentFeatureActualType
    //

    CylindricalSegmentFeatureActualType::
    CylindricalSegmentFeatureActualType (const id_type& id,
                                         const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Sweep_ (this),
      Form_ (this)
    {
    }

    CylindricalSegmentFeatureActualType::
    CylindricalSegmentFeatureActualType (const id_type& id,
                                         ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Sweep_ (this),
      Form_ (this)
    {
    }

    CylindricalSegmentFeatureActualType::
    CylindricalSegmentFeatureActualType (const CylindricalSegmentFeatureActualType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    CylindricalSegmentFeatureActualType::
    CylindricalSegmentFeatureActualType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Diameter_ (this),
      Length_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      Sweep_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CylindricalSegmentFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CylindricalSegmentFeatureActualType* CylindricalSegmentFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CylindricalSegmentFeatureActualType (*this, f, c);
    }

    CylindricalSegmentFeatureActualType& CylindricalSegmentFeatureActualType::
    operator= (const CylindricalSegmentFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->Sweep_ = x.Sweep_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    CylindricalSegmentFeatureActualType::
    ~CylindricalSegmentFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CylindricalSegmentFeatureActualType >
    _xsd_CylindricalSegmentFeatureActualType_type_factory_init (
      "CylindricalSegmentFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // EdgePointConstructionMethodType
    //

    EdgePointConstructionMethodType::
    EdgePointConstructionMethodType ()
    : ::xml_schema::type (),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    EdgePointConstructionMethodType::
    EdgePointConstructionMethodType (const EdgePointConstructionMethodType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    EdgePointConstructionMethodType::
    EdgePointConstructionMethodType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EdgePointConstructionMethodType* EdgePointConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointConstructionMethodType (*this, f, c);
    }

    EdgePointConstructionMethodType& EdgePointConstructionMethodType::
    operator= (const EdgePointConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    EdgePointConstructionMethodType::
    ~EdgePointConstructionMethodType ()
    {
    }

    // EdgePointCopyType
    //

    EdgePointCopyType::
    EdgePointCopyType (const BaseEdgePoint_type& BaseEdgePoint)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEdgePoint_ (BaseEdgePoint, this)
    {
    }

    EdgePointCopyType::
    EdgePointCopyType (::std::auto_ptr< BaseEdgePoint_type > BaseEdgePoint)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEdgePoint_ (BaseEdgePoint, this)
    {
    }

    EdgePointCopyType::
    EdgePointCopyType (const EdgePointCopyType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseEdgePoint_ (x.BaseEdgePoint_, f, this)
    {
    }

    EdgePointCopyType::
    EdgePointCopyType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEdgePoint_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseEdgePoint
        //
        if (n.name () == "BaseEdgePoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseEdgePoint_type > r (
            BaseEdgePoint_traits::create (i, f, this));

          if (!BaseEdgePoint_.present ())
          {
            this->BaseEdgePoint_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseEdgePoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseEdgePoint",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointCopyType* EdgePointCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCopyType (*this, f, c);
    }

    EdgePointCopyType& EdgePointCopyType::
    operator= (const EdgePointCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseEdgePoint_ = x.BaseEdgePoint_;
      }

      return *this;
    }

    EdgePointCopyType::
    ~EdgePointCopyType ()
    {
    }

    // EdgePointCastType
    //

    EdgePointCastType::
    EdgePointCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    EdgePointCastType::
    EdgePointCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    EdgePointCastType::
    EdgePointCastType (const EdgePointCastType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    EdgePointCastType::
    EdgePointCastType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointCastType* EdgePointCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCastType (*this, f, c);
    }

    EdgePointCastType& EdgePointCastType::
    operator= (const EdgePointCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    EdgePointCastType::
    ~EdgePointCastType ()
    {
    }

    // EdgePointTransformType
    //

    EdgePointTransformType::
    EdgePointTransformType (const BaseEdgePoint_type& BaseEdgePoint,
                            const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEdgePoint_ (BaseEdgePoint, this),
      Transformation_ (Transformation, this)
    {
    }

    EdgePointTransformType::
    EdgePointTransformType (::std::auto_ptr< BaseEdgePoint_type > BaseEdgePoint,
                            ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEdgePoint_ (BaseEdgePoint, this),
      Transformation_ (Transformation, this)
    {
    }

    EdgePointTransformType::
    EdgePointTransformType (const EdgePointTransformType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseEdgePoint_ (x.BaseEdgePoint_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    EdgePointTransformType::
    EdgePointTransformType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEdgePoint_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseEdgePoint
        //
        if (n.name () == "BaseEdgePoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseEdgePoint_type > r (
            BaseEdgePoint_traits::create (i, f, this));

          if (!BaseEdgePoint_.present ())
          {
            this->BaseEdgePoint_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseEdgePoint_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseEdgePoint",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointTransformType* EdgePointTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointTransformType (*this, f, c);
    }

    EdgePointTransformType& EdgePointTransformType::
    operator= (const EdgePointTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseEdgePoint_ = x.BaseEdgePoint_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    EdgePointTransformType::
    ~EdgePointTransformType ()
    {
    }

    // EdgePointFromScanType
    //

    EdgePointFromScanType::
    EdgePointFromScanType (const SurfaceFeature_type& SurfaceFeature,
                           const SearchRadius_type& SearchRadius,
                           const PatchRadius_type& PatchRadius,
                           const Distance_type& Distance,
                           const Depth_type& Depth,
                           const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      PatchRadius_ (PatchRadius, this),
      Distance_ (Distance, this),
      Depth_ (Depth, this),
      RetrievalMethod_ (RetrievalMethod, this)
    {
    }

    EdgePointFromScanType::
    EdgePointFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                           ::std::auto_ptr< SearchRadius_type > SearchRadius,
                           ::std::auto_ptr< PatchRadius_type > PatchRadius,
                           ::std::auto_ptr< Distance_type > Distance,
                           ::std::auto_ptr< Depth_type > Depth,
                           const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      PatchRadius_ (PatchRadius, this),
      Distance_ (Distance, this),
      Depth_ (Depth, this),
      RetrievalMethod_ (RetrievalMethod, this)
    {
    }

    EdgePointFromScanType::
    EdgePointFromScanType (const EdgePointFromScanType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      PatchRadius_ (x.PatchRadius_, f, this),
      Distance_ (x.Distance_, f, this),
      Depth_ (x.Depth_, f, this),
      RetrievalMethod_ (x.RetrievalMethod_, f, this)
    {
    }

    EdgePointFromScanType::
    EdgePointFromScanType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      PatchRadius_ (this),
      Distance_ (this),
      Depth_ (this),
      RetrievalMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // PatchRadius
        //
        if (n.name () == "PatchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PatchRadius_type > r (
            PatchRadius_traits::create (i, f, this));

          if (!PatchRadius_.present ())
          {
            this->PatchRadius_.set (r);
            continue;
          }
        }

        // Distance
        //
        if (n.name () == "Distance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!Distance_.present ())
          {
            this->Distance_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (r);
            continue;
          }
        }

        // RetrievalMethod
        //
        if (n.name () == "RetrievalMethod" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RetrievalMethod_type > r (
            RetrievalMethod_traits::create (i, f, this));

          if (!RetrievalMethod_.present ())
          {
            this->RetrievalMethod_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PatchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PatchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Distance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Distance",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Depth",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RetrievalMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RetrievalMethod",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointFromScanType* EdgePointFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFromScanType (*this, f, c);
    }

    EdgePointFromScanType& EdgePointFromScanType::
    operator= (const EdgePointFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->PatchRadius_ = x.PatchRadius_;
        this->Distance_ = x.Distance_;
        this->Depth_ = x.Depth_;
        this->RetrievalMethod_ = x.RetrievalMethod_;
      }

      return *this;
    }

    EdgePointFromScanType::
    ~EdgePointFromScanType ()
    {
    }

    // EdgePointCheckedType
    //

    EdgePointCheckedType::
    EdgePointCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    EdgePointCheckedType::
    EdgePointCheckedType (const EdgePointCheckedType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    EdgePointCheckedType::
    EdgePointCheckedType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EdgePointCheckedType* EdgePointCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCheckedType (*this, f, c);
    }

    EdgePointCheckedType& EdgePointCheckedType::
    operator= (const EdgePointCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    EdgePointCheckedType::
    ~EdgePointCheckedType ()
    {
    }

    // EdgePointCheckedFeatureType
    //

    EdgePointCheckedFeatureType::
    EdgePointCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    EdgePointCheckedFeatureType::
    EdgePointCheckedFeatureType (const EdgePointCheckedFeatureType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    EdgePointCheckedFeatureType::
    EdgePointCheckedFeatureType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EdgePointCheckedFeatureType* EdgePointCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointCheckedFeatureType (*this, f, c);
    }

    EdgePointCheckedFeatureType& EdgePointCheckedFeatureType::
    operator= (const EdgePointCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    EdgePointCheckedFeatureType::
    ~EdgePointCheckedFeatureType ()
    {
    }

    // EdgePointActualDeterminationType
    //

    EdgePointActualDeterminationType::
    EdgePointActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    EdgePointActualDeterminationType::
    EdgePointActualDeterminationType (const EdgePointActualDeterminationType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    EdgePointActualDeterminationType::
    EdgePointActualDeterminationType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EdgePointActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EdgePointActualDeterminationType* EdgePointActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointActualDeterminationType (*this, f, c);
    }

    EdgePointActualDeterminationType& EdgePointActualDeterminationType::
    operator= (const EdgePointActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    EdgePointActualDeterminationType::
    ~EdgePointActualDeterminationType ()
    {
    }

    // EdgePointFeatureItemType
    //

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const id_type& id,
                              const FeatureName_type& FeatureName,
                              const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const id_type& id,
                              const FeatureName_type& FeatureName,
                              ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const EdgePointFeatureItemType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    EdgePointFeatureItemType::
    EdgePointFeatureItemType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointFeatureItemType* EdgePointFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureItemType (*this, f, c);
    }

    EdgePointFeatureItemType& EdgePointFeatureItemType::
    operator= (const EdgePointFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    EdgePointFeatureItemType::
    ~EdgePointFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EdgePointFeatureItemType >
    _xsd_EdgePointFeatureItemType_type_factory_init (
      "EdgePointFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // EdgePointFeatureDefinitionType
    //

    EdgePointFeatureDefinitionType::
    EdgePointFeatureDefinitionType (const id_type& id,
                                    const InternalExternal_type& InternalExternal)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this)
    {
    }

    EdgePointFeatureDefinitionType::
    EdgePointFeatureDefinitionType (const EdgePointFeatureDefinitionType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this)
    {
    }

    EdgePointFeatureDefinitionType::
    EdgePointFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointFeatureDefinitionType* EdgePointFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureDefinitionType (*this, f, c);
    }

    EdgePointFeatureDefinitionType& EdgePointFeatureDefinitionType::
    operator= (const EdgePointFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
      }

      return *this;
    }

    EdgePointFeatureDefinitionType::
    ~EdgePointFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EdgePointFeatureDefinitionType >
    _xsd_EdgePointFeatureDefinitionType_type_factory_init (
      "EdgePointFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // EdgePointFeatureNominalType
    //

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const id_type& id,
                                 const FeatureDefinitionId_type& FeatureDefinitionId,
                                 const Location_type& Location,
                                 const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (Normal, this),
      AdjacentNormal_ (this)
    {
    }

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const id_type& id,
                                 const FeatureDefinitionId_type& FeatureDefinitionId,
                                 ::std::auto_ptr< Location_type > Location,
                                 ::std::auto_ptr< Normal_type > Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (Normal, this),
      AdjacentNormal_ (this)
    {
    }

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const EdgePointFeatureNominalType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      AdjacentNormal_ (x.AdjacentNormal_, f, this)
    {
    }

    EdgePointFeatureNominalType::
    EdgePointFeatureNominalType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      AdjacentNormal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // AdjacentNormal
        //
        if (n.name () == "AdjacentNormal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AdjacentNormal_type > r (
            AdjacentNormal_traits::create (i, f, this));

          if (!this->AdjacentNormal_)
          {
            this->AdjacentNormal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EdgePointFeatureNominalType* EdgePointFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureNominalType (*this, f, c);
    }

    EdgePointFeatureNominalType& EdgePointFeatureNominalType::
    operator= (const EdgePointFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->AdjacentNormal_ = x.AdjacentNormal_;
      }

      return *this;
    }

    EdgePointFeatureNominalType::
    ~EdgePointFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EdgePointFeatureNominalType >
    _xsd_EdgePointFeatureNominalType_type_factory_init (
      "EdgePointFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // EdgePointFeatureActualType
    //

    EdgePointFeatureActualType::
    EdgePointFeatureActualType (const id_type& id,
                                const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Normal_ (this),
      AdjacentNormal_ (this)
    {
    }

    EdgePointFeatureActualType::
    EdgePointFeatureActualType (const id_type& id,
                                ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Normal_ (this),
      AdjacentNormal_ (this)
    {
    }

    EdgePointFeatureActualType::
    EdgePointFeatureActualType (const EdgePointFeatureActualType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      AdjacentNormal_ (x.AdjacentNormal_, f, this)
    {
    }

    EdgePointFeatureActualType::
    EdgePointFeatureActualType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      AdjacentNormal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EdgePointFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // AdjacentNormal
        //
        if (n.name () == "AdjacentNormal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AdjacentNormal_type > r (
            AdjacentNormal_traits::create (i, f, this));

          if (!this->AdjacentNormal_)
          {
            this->AdjacentNormal_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EdgePointFeatureActualType* EdgePointFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EdgePointFeatureActualType (*this, f, c);
    }

    EdgePointFeatureActualType& EdgePointFeatureActualType::
    operator= (const EdgePointFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->AdjacentNormal_ = x.AdjacentNormal_;
      }

      return *this;
    }

    EdgePointFeatureActualType::
    ~EdgePointFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EdgePointFeatureActualType >
    _xsd_EdgePointFeatureActualType_type_factory_init (
      "EdgePointFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // EllipseConstructionMethodType
    //

    EllipseConstructionMethodType::
    EllipseConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    EllipseConstructionMethodType::
    EllipseConstructionMethodType (const EllipseConstructionMethodType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    EllipseConstructionMethodType::
    EllipseConstructionMethodType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == "Intersection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipseConstructionMethodType* EllipseConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseConstructionMethodType (*this, f, c);
    }

    EllipseConstructionMethodType& EllipseConstructionMethodType::
    operator= (const EllipseConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Intersection_ = x.Intersection_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    EllipseConstructionMethodType::
    ~EllipseConstructionMethodType ()
    {
    }

    // EllipseBestFitType
    //

    EllipseBestFitType::
    EllipseBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    EllipseBestFitType::
    EllipseBestFitType (const EllipseBestFitType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    EllipseBestFitType::
    EllipseBestFitType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    EllipseBestFitType* EllipseBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseBestFitType (*this, f, c);
    }

    EllipseBestFitType& EllipseBestFitType::
    operator= (const EllipseBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    EllipseBestFitType::
    ~EllipseBestFitType ()
    {
    }

    // EllipseRecompType
    //

    EllipseRecompType::
    EllipseRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    EllipseRecompType::
    EllipseRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    EllipseRecompType::
    EllipseRecompType (const EllipseRecompType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    EllipseRecompType::
    EllipseRecompType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseRecompType* EllipseRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseRecompType (*this, f, c);
    }

    EllipseRecompType& EllipseRecompType::
    operator= (const EllipseRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    EllipseRecompType::
    ~EllipseRecompType ()
    {
    }

    // EllipseProjectionType
    //

    EllipseProjectionType::
    EllipseProjectionType (const ProjectionFeature_type& ProjectionFeature,
                           const ProjectionPlane_type& ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionFeature_ (ProjectionFeature, this),
      ProjectionPlane_ (ProjectionPlane, this)
    {
    }

    EllipseProjectionType::
    EllipseProjectionType (::std::auto_ptr< ProjectionFeature_type > ProjectionFeature,
                           ::std::auto_ptr< ProjectionPlane_type > ProjectionPlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionFeature_ (ProjectionFeature, this),
      ProjectionPlane_ (ProjectionPlane, this)
    {
    }

    EllipseProjectionType::
    EllipseProjectionType (const EllipseProjectionType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionFeature_ (x.ProjectionFeature_, f, this),
      ProjectionPlane_ (x.ProjectionPlane_, f, this)
    {
    }

    EllipseProjectionType::
    EllipseProjectionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionFeature_ (this),
      ProjectionPlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionFeature
        //
        if (n.name () == "ProjectionFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionFeature_type > r (
            ProjectionFeature_traits::create (i, f, this));

          if (!ProjectionFeature_.present ())
          {
            this->ProjectionFeature_.set (r);
            continue;
          }
        }

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseProjectionType* EllipseProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseProjectionType (*this, f, c);
    }

    EllipseProjectionType& EllipseProjectionType::
    operator= (const EllipseProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionFeature_ = x.ProjectionFeature_;
        this->ProjectionPlane_ = x.ProjectionPlane_;
      }

      return *this;
    }

    EllipseProjectionType::
    ~EllipseProjectionType ()
    {
    }

    // EllipseIntersectionType
    //

    EllipseIntersectionType::
    EllipseIntersectionType (const IntersectionPlane_type& IntersectionPlane,
                             const IntersectionFeature_type& IntersectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, this),
      IntersectionFeature_ (IntersectionFeature, this)
    {
    }

    EllipseIntersectionType::
    EllipseIntersectionType (::std::auto_ptr< IntersectionPlane_type > IntersectionPlane,
                             ::std::auto_ptr< IntersectionFeature_type > IntersectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      IntersectionPlane_ (IntersectionPlane, this),
      IntersectionFeature_ (IntersectionFeature, this)
    {
    }

    EllipseIntersectionType::
    EllipseIntersectionType (const EllipseIntersectionType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      IntersectionPlane_ (x.IntersectionPlane_, f, this),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    EllipseIntersectionType::
    EllipseIntersectionType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionPlane_ (this),
      IntersectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IntersectionPlane
        //
        if (n.name () == "IntersectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IntersectionPlane_type > r (
            IntersectionPlane_traits::create (i, f, this));

          if (!IntersectionPlane_.present ())
          {
            this->IntersectionPlane_.set (r);
            continue;
          }
        }

        // IntersectionFeature
        //
        if (n.name () == "IntersectionFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          if (!IntersectionFeature_.present ())
          {
            this->IntersectionFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!IntersectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IntersectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!IntersectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "IntersectionFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseIntersectionType* EllipseIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseIntersectionType (*this, f, c);
    }

    EllipseIntersectionType& EllipseIntersectionType::
    operator= (const EllipseIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->IntersectionPlane_ = x.IntersectionPlane_;
        this->IntersectionFeature_ = x.IntersectionFeature_;
      }

      return *this;
    }

    EllipseIntersectionType::
    ~EllipseIntersectionType ()
    {
    }

    // EllipseCopyType
    //

    EllipseCopyType::
    EllipseCopyType (const BaseEllipse_type& BaseEllipse)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEllipse_ (BaseEllipse, this)
    {
    }

    EllipseCopyType::
    EllipseCopyType (::std::auto_ptr< BaseEllipse_type > BaseEllipse)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEllipse_ (BaseEllipse, this)
    {
    }

    EllipseCopyType::
    EllipseCopyType (const EllipseCopyType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseEllipse_ (x.BaseEllipse_, f, this)
    {
    }

    EllipseCopyType::
    EllipseCopyType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEllipse_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseEllipse
        //
        if (n.name () == "BaseEllipse" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseEllipse_type > r (
            BaseEllipse_traits::create (i, f, this));

          if (!BaseEllipse_.present ())
          {
            this->BaseEllipse_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseEllipse_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseEllipse",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseCopyType* EllipseCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCopyType (*this, f, c);
    }

    EllipseCopyType& EllipseCopyType::
    operator= (const EllipseCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseEllipse_ = x.BaseEllipse_;
      }

      return *this;
    }

    EllipseCopyType::
    ~EllipseCopyType ()
    {
    }

    // EllipseCastType
    //

    EllipseCastType::
    EllipseCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    EllipseCastType::
    EllipseCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    EllipseCastType::
    EllipseCastType (const EllipseCastType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    EllipseCastType::
    EllipseCastType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseCastType* EllipseCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCastType (*this, f, c);
    }

    EllipseCastType& EllipseCastType::
    operator= (const EllipseCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    EllipseCastType::
    ~EllipseCastType ()
    {
    }

    // EllipseTransformType
    //

    EllipseTransformType::
    EllipseTransformType (const BaseEllipse_type& BaseEllipse,
                          const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEllipse_ (BaseEllipse, this),
      Transformation_ (Transformation, this)
    {
    }

    EllipseTransformType::
    EllipseTransformType (::std::auto_ptr< BaseEllipse_type > BaseEllipse,
                          ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseEllipse_ (BaseEllipse, this),
      Transformation_ (Transformation, this)
    {
    }

    EllipseTransformType::
    EllipseTransformType (const EllipseTransformType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseEllipse_ (x.BaseEllipse_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    EllipseTransformType::
    EllipseTransformType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseEllipse_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseEllipse
        //
        if (n.name () == "BaseEllipse" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseEllipse_type > r (
            BaseEllipse_traits::create (i, f, this));

          if (!BaseEllipse_.present ())
          {
            this->BaseEllipse_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseEllipse_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseEllipse",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseTransformType* EllipseTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseTransformType (*this, f, c);
    }

    EllipseTransformType& EllipseTransformType::
    operator= (const EllipseTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseEllipse_ = x.BaseEllipse_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    EllipseTransformType::
    ~EllipseTransformType ()
    {
    }

    // EllipseFromScanType
    //

    EllipseFromScanType::
    EllipseFromScanType (const SurfaceFeature_type& SurfaceFeature,
                         const SearchRadius_type& SearchRadius,
                         const Depth_type& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    EllipseFromScanType::
    EllipseFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                         ::std::auto_ptr< SearchRadius_type > SearchRadius,
                         ::std::auto_ptr< Depth_type > Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    EllipseFromScanType::
    EllipseFromScanType (const EllipseFromScanType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    EllipseFromScanType::
    EllipseFromScanType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Depth",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseFromScanType* EllipseFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFromScanType (*this, f, c);
    }

    EllipseFromScanType& EllipseFromScanType::
    operator= (const EllipseFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    EllipseFromScanType::
    ~EllipseFromScanType ()
    {
    }

    // EllipseCheckedType
    //

    EllipseCheckedType::
    EllipseCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    EllipseCheckedType::
    EllipseCheckedType (const EllipseCheckedType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    EllipseCheckedType::
    EllipseCheckedType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipseCheckedType* EllipseCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCheckedType (*this, f, c);
    }

    EllipseCheckedType& EllipseCheckedType::
    operator= (const EllipseCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    EllipseCheckedType::
    ~EllipseCheckedType ()
    {
    }

    // EllipseCheckedFeatureType
    //

    EllipseCheckedFeatureType::
    EllipseCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    EllipseCheckedFeatureType::
    EllipseCheckedFeatureType (const EllipseCheckedFeatureType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    EllipseCheckedFeatureType::
    EllipseCheckedFeatureType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipseCheckedFeatureType* EllipseCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseCheckedFeatureType (*this, f, c);
    }

    EllipseCheckedFeatureType& EllipseCheckedFeatureType::
    operator= (const EllipseCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    EllipseCheckedFeatureType::
    ~EllipseCheckedFeatureType ()
    {
    }

    // EllipseActualDeterminationType
    //

    EllipseActualDeterminationType::
    EllipseActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    EllipseActualDeterminationType::
    EllipseActualDeterminationType (const EllipseActualDeterminationType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    EllipseActualDeterminationType::
    EllipseActualDeterminationType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void EllipseActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipseActualDeterminationType* EllipseActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseActualDeterminationType (*this, f, c);
    }

    EllipseActualDeterminationType& EllipseActualDeterminationType::
    operator= (const EllipseActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    EllipseActualDeterminationType::
    ~EllipseActualDeterminationType ()
    {
    }

    // EllipseFeatureItemType
    //

    EllipseFeatureItemType::
    EllipseFeatureItemType (const id_type& id,
                            const FeatureName_type& FeatureName,
                            const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    EllipseFeatureItemType::
    EllipseFeatureItemType (const id_type& id,
                            const FeatureName_type& FeatureName,
                            ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    EllipseFeatureItemType::
    EllipseFeatureItemType (const EllipseFeatureItemType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    EllipseFeatureItemType::
    EllipseFeatureItemType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseFeatureItemType* EllipseFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureItemType (*this, f, c);
    }

    EllipseFeatureItemType& EllipseFeatureItemType::
    operator= (const EllipseFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    EllipseFeatureItemType::
    ~EllipseFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EllipseFeatureItemType >
    _xsd_EllipseFeatureItemType_type_factory_init (
      "EllipseFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // EllipseFeatureDefinitionType
    //

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const id_type& id,
                                  const InternalExternal_type& InternalExternal,
                                  const MajorDiameter_type& MajorDiameter,
                                  const MinorDiameter_type& MinorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MajorDiameter_ (MajorDiameter, this),
      MinorDiameter_ (MinorDiameter, this)
    {
    }

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const id_type& id,
                                  const InternalExternal_type& InternalExternal,
                                  ::std::auto_ptr< MajorDiameter_type > MajorDiameter,
                                  ::std::auto_ptr< MinorDiameter_type > MinorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MajorDiameter_ (MajorDiameter, this),
      MinorDiameter_ (MinorDiameter, this)
    {
    }

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const EllipseFeatureDefinitionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this)
    {
    }

    EllipseFeatureDefinitionType::
    EllipseFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!MajorDiameter_.present ())
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!MinorDiameter_.present ())
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MajorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MajorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MinorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MinorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseFeatureDefinitionType* EllipseFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureDefinitionType (*this, f, c);
    }

    EllipseFeatureDefinitionType& EllipseFeatureDefinitionType::
    operator= (const EllipseFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->MajorDiameter_ = x.MajorDiameter_;
        this->MinorDiameter_ = x.MinorDiameter_;
      }

      return *this;
    }

    EllipseFeatureDefinitionType::
    ~EllipseFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EllipseFeatureDefinitionType >
    _xsd_EllipseFeatureDefinitionType_type_factory_init (
      "EllipseFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // EllipseFeatureNominalType
    //

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId,
                               const Axis_type& Axis,
                               const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Normal_ (Normal, this)
    {
    }

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId,
                               ::std::auto_ptr< Axis_type > Axis,
                               ::std::auto_ptr< Normal_type > Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Normal_ (Normal, this)
    {
    }

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const EllipseFeatureNominalType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    EllipseFeatureNominalType::
    EllipseFeatureNominalType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    EllipseFeatureNominalType* EllipseFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureNominalType (*this, f, c);
    }

    EllipseFeatureNominalType& EllipseFeatureNominalType::
    operator= (const EllipseFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    EllipseFeatureNominalType::
    ~EllipseFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EllipseFeatureNominalType >
    _xsd_EllipseFeatureNominalType_type_factory_init (
      "EllipseFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // EllipseFeatureActualType
    //

    EllipseFeatureActualType::
    EllipseFeatureActualType (const id_type& id,
                              const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Normal_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this),
      Form_ (this)
    {
    }

    EllipseFeatureActualType::
    EllipseFeatureActualType (const id_type& id,
                              ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Normal_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this),
      Form_ (this)
    {
    }

    EllipseFeatureActualType::
    EllipseFeatureActualType (const EllipseFeatureActualType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Normal_ (x.Normal_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    EllipseFeatureActualType::
    EllipseFeatureActualType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Normal_ (this),
      MajorDiameter_ (this),
      MinorDiameter_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EllipseFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!this->MajorDiameter_)
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!this->MinorDiameter_)
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    EllipseFeatureActualType* EllipseFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EllipseFeatureActualType (*this, f, c);
    }

    EllipseFeatureActualType& EllipseFeatureActualType::
    operator= (const EllipseFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Normal_ = x.Normal_;
        this->MajorDiameter_ = x.MajorDiameter_;
        this->MinorDiameter_ = x.MinorDiameter_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    EllipseFeatureActualType::
    ~EllipseFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EllipseFeatureActualType >
    _xsd_EllipseFeatureActualType_type_factory_init (
      "EllipseFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // ElongatedCylinderConstructionMethodType
    //

    ElongatedCylinderConstructionMethodType::
    ElongatedCylinderConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    ElongatedCylinderConstructionMethodType::
    ElongatedCylinderConstructionMethodType (const ElongatedCylinderConstructionMethodType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ElongatedCylinderConstructionMethodType::
    ElongatedCylinderConstructionMethodType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderConstructionMethodType* ElongatedCylinderConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderConstructionMethodType (*this, f, c);
    }

    ElongatedCylinderConstructionMethodType& ElongatedCylinderConstructionMethodType::
    operator= (const ElongatedCylinderConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    ElongatedCylinderConstructionMethodType::
    ~ElongatedCylinderConstructionMethodType ()
    {
    }

    // ElongatedCylinderBestFitType
    //

    ElongatedCylinderBestFitType::
    ElongatedCylinderBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ElongatedCylinderBestFitType::
    ElongatedCylinderBestFitType (const ElongatedCylinderBestFitType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ElongatedCylinderBestFitType::
    ElongatedCylinderBestFitType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ElongatedCylinderBestFitType* ElongatedCylinderBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderBestFitType (*this, f, c);
    }

    ElongatedCylinderBestFitType& ElongatedCylinderBestFitType::
    operator= (const ElongatedCylinderBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ElongatedCylinderBestFitType::
    ~ElongatedCylinderBestFitType ()
    {
    }

    // ElongatedCylinderRecompType
    //

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (const ElongatedCylinderRecompType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ElongatedCylinderRecompType::
    ElongatedCylinderRecompType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderRecompType* ElongatedCylinderRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderRecompType (*this, f, c);
    }

    ElongatedCylinderRecompType& ElongatedCylinderRecompType::
    operator= (const ElongatedCylinderRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ElongatedCylinderRecompType::
    ~ElongatedCylinderRecompType ()
    {
    }

    // ElongatedCylinderCopyType
    //

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (const BaseElongatedCylinder_type& BaseElongatedCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (BaseElongatedCylinder, this)
    {
    }

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (::std::auto_ptr< BaseElongatedCylinder_type > BaseElongatedCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (BaseElongatedCylinder, this)
    {
    }

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (const ElongatedCylinderCopyType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseElongatedCylinder_ (x.BaseElongatedCylinder_, f, this)
    {
    }

    ElongatedCylinderCopyType::
    ElongatedCylinderCopyType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseElongatedCylinder_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseElongatedCylinder
        //
        if (n.name () == "BaseElongatedCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseElongatedCylinder_type > r (
            BaseElongatedCylinder_traits::create (i, f, this));

          if (!BaseElongatedCylinder_.present ())
          {
            this->BaseElongatedCylinder_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseElongatedCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseElongatedCylinder",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderCopyType* ElongatedCylinderCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCopyType (*this, f, c);
    }

    ElongatedCylinderCopyType& ElongatedCylinderCopyType::
    operator= (const ElongatedCylinderCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseElongatedCylinder_ = x.BaseElongatedCylinder_;
      }

      return *this;
    }

    ElongatedCylinderCopyType::
    ~ElongatedCylinderCopyType ()
    {
    }

    // ElongatedCylinderCastType
    //

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (const ElongatedCylinderCastType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ElongatedCylinderCastType::
    ElongatedCylinderCastType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderCastType* ElongatedCylinderCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCastType (*this, f, c);
    }

    ElongatedCylinderCastType& ElongatedCylinderCastType::
    operator= (const ElongatedCylinderCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ElongatedCylinderCastType::
    ~ElongatedCylinderCastType ()
    {
    }

    // ElongatedCylinderTransformType
    //

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (const BaseElongatedCylinder_type& BaseElongatedCylinder,
                                    const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (BaseElongatedCylinder, this),
      Transformation_ (Transformation, this)
    {
    }

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (::std::auto_ptr< BaseElongatedCylinder_type > BaseElongatedCylinder,
                                    ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseElongatedCylinder_ (BaseElongatedCylinder, this),
      Transformation_ (Transformation, this)
    {
    }

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (const ElongatedCylinderTransformType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseElongatedCylinder_ (x.BaseElongatedCylinder_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ElongatedCylinderTransformType::
    ElongatedCylinderTransformType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseElongatedCylinder_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseElongatedCylinder
        //
        if (n.name () == "BaseElongatedCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseElongatedCylinder_type > r (
            BaseElongatedCylinder_traits::create (i, f, this));

          if (!BaseElongatedCylinder_.present ())
          {
            this->BaseElongatedCylinder_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseElongatedCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseElongatedCylinder",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderTransformType* ElongatedCylinderTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderTransformType (*this, f, c);
    }

    ElongatedCylinderTransformType& ElongatedCylinderTransformType::
    operator= (const ElongatedCylinderTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseElongatedCylinder_ = x.BaseElongatedCylinder_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ElongatedCylinderTransformType::
    ~ElongatedCylinderTransformType ()
    {
    }

    // ElongatedCylinderCheckedType
    //

    ElongatedCylinderCheckedType::
    ElongatedCylinderCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ElongatedCylinderCheckedType::
    ElongatedCylinderCheckedType (const ElongatedCylinderCheckedType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ElongatedCylinderCheckedType::
    ElongatedCylinderCheckedType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderCheckedType* ElongatedCylinderCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCheckedType (*this, f, c);
    }

    ElongatedCylinderCheckedType& ElongatedCylinderCheckedType::
    operator= (const ElongatedCylinderCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ElongatedCylinderCheckedType::
    ~ElongatedCylinderCheckedType ()
    {
    }

    // ElongatedCylinderCheckedFeatureType
    //

    ElongatedCylinderCheckedFeatureType::
    ElongatedCylinderCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ElongatedCylinderCheckedFeatureType::
    ElongatedCylinderCheckedFeatureType (const ElongatedCylinderCheckedFeatureType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ElongatedCylinderCheckedFeatureType::
    ElongatedCylinderCheckedFeatureType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderCheckedFeatureType* ElongatedCylinderCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderCheckedFeatureType (*this, f, c);
    }

    ElongatedCylinderCheckedFeatureType& ElongatedCylinderCheckedFeatureType::
    operator= (const ElongatedCylinderCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ElongatedCylinderCheckedFeatureType::
    ~ElongatedCylinderCheckedFeatureType ()
    {
    }

    // ElongatedCylinderActualDeterminationType
    //

    ElongatedCylinderActualDeterminationType::
    ElongatedCylinderActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ElongatedCylinderActualDeterminationType::
    ElongatedCylinderActualDeterminationType (const ElongatedCylinderActualDeterminationType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ElongatedCylinderActualDeterminationType::
    ElongatedCylinderActualDeterminationType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderActualDeterminationType* ElongatedCylinderActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderActualDeterminationType (*this, f, c);
    }

    ElongatedCylinderActualDeterminationType& ElongatedCylinderActualDeterminationType::
    operator= (const ElongatedCylinderActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ElongatedCylinderActualDeterminationType::
    ~ElongatedCylinderActualDeterminationType ()
    {
    }

    // ElongatedCylinderFeatureItemType
    //

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const id_type& id,
                                      const FeatureName_type& FeatureName,
                                      const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const id_type& id,
                                      const FeatureName_type& FeatureName,
                                      ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const ElongatedCylinderFeatureItemType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ElongatedCylinderFeatureItemType::
    ElongatedCylinderFeatureItemType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderFeatureItemType* ElongatedCylinderFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureItemType (*this, f, c);
    }

    ElongatedCylinderFeatureItemType& ElongatedCylinderFeatureItemType::
    operator= (const ElongatedCylinderFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    ElongatedCylinderFeatureItemType::
    ~ElongatedCylinderFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ElongatedCylinderFeatureItemType >
    _xsd_ElongatedCylinderFeatureItemType_type_factory_init (
      "ElongatedCylinderFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // ElongatedCylinderFeatureDefinitionType
    //

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const id_type& id,
                                            const InternalExternal_type& InternalExternal,
                                            const Diameter_type& Diameter,
                                            const Length_type& Length)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      Length_ (Length, this),
      Width_ (this),
      Depth_ (this)
    {
    }

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const id_type& id,
                                            const InternalExternal_type& InternalExternal,
                                            ::std::auto_ptr< Diameter_type > Diameter,
                                            ::std::auto_ptr< Length_type > Length)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this),
      Length_ (Length, this),
      Width_ (this),
      Depth_ (this)
    {
    }

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const ElongatedCylinderFeatureDefinitionType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this),
      Length_ (x.Length_, f, this),
      Width_ (x.Width_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    ElongatedCylinderFeatureDefinitionType::
    ElongatedCylinderFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this),
      Length_ (this),
      Width_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Length",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderFeatureDefinitionType* ElongatedCylinderFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureDefinitionType (*this, f, c);
    }

    ElongatedCylinderFeatureDefinitionType& ElongatedCylinderFeatureDefinitionType::
    operator= (const ElongatedCylinderFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
        this->Length_ = x.Length_;
        this->Width_ = x.Width_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    ElongatedCylinderFeatureDefinitionType::
    ~ElongatedCylinderFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ElongatedCylinderFeatureDefinitionType >
    _xsd_ElongatedCylinderFeatureDefinitionType_type_factory_init (
      "ElongatedCylinderFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // ElongatedCylinderFeatureNominalType
    //

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const id_type& id,
                                         const FeatureDefinitionId_type& FeatureDefinitionId,
                                         const CenterPlane_type& CenterPlane,
                                         const DepthVector_type& DepthVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterPlane_ (CenterPlane, this),
      DepthVector_ (DepthVector, this)
    {
    }

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const id_type& id,
                                         const FeatureDefinitionId_type& FeatureDefinitionId,
                                         ::std::auto_ptr< CenterPlane_type > CenterPlane,
                                         ::std::auto_ptr< DepthVector_type > DepthVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterPlane_ (CenterPlane, this),
      DepthVector_ (DepthVector, this)
    {
    }

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const ElongatedCylinderFeatureNominalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      CenterPlane_ (x.CenterPlane_, f, this),
      DepthVector_ (x.DepthVector_, f, this)
    {
    }

    ElongatedCylinderFeatureNominalType::
    ElongatedCylinderFeatureNominalType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterPlane_ (this),
      DepthVector_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterPlane
        //
        if (n.name () == "CenterPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!CenterPlane_.present ())
          {
            this->CenterPlane_.set (r);
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == "DepthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!DepthVector_.present ())
          {
            this->DepthVector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CenterPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CenterPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!DepthVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DepthVector",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ElongatedCylinderFeatureNominalType* ElongatedCylinderFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureNominalType (*this, f, c);
    }

    ElongatedCylinderFeatureNominalType& ElongatedCylinderFeatureNominalType::
    operator= (const ElongatedCylinderFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->CenterPlane_ = x.CenterPlane_;
        this->DepthVector_ = x.DepthVector_;
      }

      return *this;
    }

    ElongatedCylinderFeatureNominalType::
    ~ElongatedCylinderFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ElongatedCylinderFeatureNominalType >
    _xsd_ElongatedCylinderFeatureNominalType_type_factory_init (
      "ElongatedCylinderFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // ElongatedCylinderFeatureActualType
    //

    ElongatedCylinderFeatureActualType::
    ElongatedCylinderFeatureActualType (const id_type& id,
                                        const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      CenterPlane_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      Width_ (this),
      WidthMax_ (this),
      WidthMin_ (this),
      Depth_ (this),
      DepthMax_ (this),
      DepthMin_ (this),
      DepthVector_ (this),
      Form_ (this)
    {
    }

    ElongatedCylinderFeatureActualType::
    ElongatedCylinderFeatureActualType (const id_type& id,
                                        ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      CenterPlane_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      Width_ (this),
      WidthMax_ (this),
      WidthMin_ (this),
      Depth_ (this),
      DepthMax_ (this),
      DepthMin_ (this),
      DepthVector_ (this),
      Form_ (this)
    {
    }

    ElongatedCylinderFeatureActualType::
    ElongatedCylinderFeatureActualType (const ElongatedCylinderFeatureActualType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      CenterPlane_ (x.CenterPlane_, f, this),
      Length_ (x.Length_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      Width_ (x.Width_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      Depth_ (x.Depth_, f, this),
      DepthMax_ (x.DepthMax_, f, this),
      DepthMin_ (x.DepthMin_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ElongatedCylinderFeatureActualType::
    ElongatedCylinderFeatureActualType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      CenterPlane_ (this),
      Length_ (this),
      LengthMax_ (this),
      LengthMin_ (this),
      Width_ (this),
      WidthMax_ (this),
      WidthMin_ (this),
      Depth_ (this),
      DepthMax_ (this),
      DepthMin_ (this),
      DepthVector_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ElongatedCylinderFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // CenterPlane
        //
        if (n.name () == "CenterPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!this->CenterPlane_)
          {
            this->CenterPlane_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == "LengthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (r);
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == "LengthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (r);
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == "WidthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (r);
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == "WidthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (r);
            continue;
          }
        }

        // DepthMax
        //
        if (n.name () == "DepthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthMax_type > r (
            DepthMax_traits::create (i, f, this));

          if (!this->DepthMax_)
          {
            this->DepthMax_.set (r);
            continue;
          }
        }

        // DepthMin
        //
        if (n.name () == "DepthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthMin_type > r (
            DepthMin_traits::create (i, f, this));

          if (!this->DepthMin_)
          {
            this->DepthMin_.set (r);
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == "DepthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!this->DepthVector_)
          {
            this->DepthVector_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ElongatedCylinderFeatureActualType* ElongatedCylinderFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ElongatedCylinderFeatureActualType (*this, f, c);
    }

    ElongatedCylinderFeatureActualType& ElongatedCylinderFeatureActualType::
    operator= (const ElongatedCylinderFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->CenterPlane_ = x.CenterPlane_;
        this->Length_ = x.Length_;
        this->LengthMax_ = x.LengthMax_;
        this->LengthMin_ = x.LengthMin_;
        this->Width_ = x.Width_;
        this->WidthMax_ = x.WidthMax_;
        this->WidthMin_ = x.WidthMin_;
        this->Depth_ = x.Depth_;
        this->DepthMax_ = x.DepthMax_;
        this->DepthMin_ = x.DepthMin_;
        this->DepthVector_ = x.DepthVector_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ElongatedCylinderFeatureActualType::
    ~ElongatedCylinderFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ElongatedCylinderFeatureActualType >
    _xsd_ElongatedCylinderFeatureActualType_type_factory_init (
      "ElongatedCylinderFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // ExtrudedCrossSectionConstructionMethodType
    //

    ExtrudedCrossSectionConstructionMethodType::
    ExtrudedCrossSectionConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    ExtrudedCrossSectionConstructionMethodType::
    ExtrudedCrossSectionConstructionMethodType (const ExtrudedCrossSectionConstructionMethodType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ExtrudedCrossSectionConstructionMethodType::
    ExtrudedCrossSectionConstructionMethodType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionConstructionMethodType* ExtrudedCrossSectionConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionConstructionMethodType (*this, f, c);
    }

    ExtrudedCrossSectionConstructionMethodType& ExtrudedCrossSectionConstructionMethodType::
    operator= (const ExtrudedCrossSectionConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    ExtrudedCrossSectionConstructionMethodType::
    ~ExtrudedCrossSectionConstructionMethodType ()
    {
    }

    // ExtrudedCrossSectionBestFitType
    //

    ExtrudedCrossSectionBestFitType::
    ExtrudedCrossSectionBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ExtrudedCrossSectionBestFitType::
    ExtrudedCrossSectionBestFitType (const ExtrudedCrossSectionBestFitType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ExtrudedCrossSectionBestFitType::
    ExtrudedCrossSectionBestFitType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ExtrudedCrossSectionBestFitType* ExtrudedCrossSectionBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionBestFitType (*this, f, c);
    }

    ExtrudedCrossSectionBestFitType& ExtrudedCrossSectionBestFitType::
    operator= (const ExtrudedCrossSectionBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ExtrudedCrossSectionBestFitType::
    ~ExtrudedCrossSectionBestFitType ()
    {
    }

    // ExtrudedCrossSectionRecompType
    //

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (const ExtrudedCrossSectionRecompType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ExtrudedCrossSectionRecompType::
    ExtrudedCrossSectionRecompType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionRecompType* ExtrudedCrossSectionRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionRecompType (*this, f, c);
    }

    ExtrudedCrossSectionRecompType& ExtrudedCrossSectionRecompType::
    operator= (const ExtrudedCrossSectionRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ExtrudedCrossSectionRecompType::
    ~ExtrudedCrossSectionRecompType ()
    {
    }

    // ExtrudedCrossSectionCopyType
    //

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (const BaseExtrudedCrossSection_type& BaseExtrudedCrossSection)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (BaseExtrudedCrossSection, this)
    {
    }

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (::std::auto_ptr< BaseExtrudedCrossSection_type > BaseExtrudedCrossSection)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (BaseExtrudedCrossSection, this)
    {
    }

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (const ExtrudedCrossSectionCopyType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseExtrudedCrossSection_ (x.BaseExtrudedCrossSection_, f, this)
    {
    }

    ExtrudedCrossSectionCopyType::
    ExtrudedCrossSectionCopyType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseExtrudedCrossSection_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseExtrudedCrossSection
        //
        if (n.name () == "BaseExtrudedCrossSection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseExtrudedCrossSection_type > r (
            BaseExtrudedCrossSection_traits::create (i, f, this));

          if (!BaseExtrudedCrossSection_.present ())
          {
            this->BaseExtrudedCrossSection_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseExtrudedCrossSection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseExtrudedCrossSection",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionCopyType* ExtrudedCrossSectionCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCopyType (*this, f, c);
    }

    ExtrudedCrossSectionCopyType& ExtrudedCrossSectionCopyType::
    operator= (const ExtrudedCrossSectionCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseExtrudedCrossSection_ = x.BaseExtrudedCrossSection_;
      }

      return *this;
    }

    ExtrudedCrossSectionCopyType::
    ~ExtrudedCrossSectionCopyType ()
    {
    }

    // ExtrudedCrossSectionCastType
    //

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (const ExtrudedCrossSectionCastType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ExtrudedCrossSectionCastType::
    ExtrudedCrossSectionCastType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionCastType* ExtrudedCrossSectionCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCastType (*this, f, c);
    }

    ExtrudedCrossSectionCastType& ExtrudedCrossSectionCastType::
    operator= (const ExtrudedCrossSectionCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ExtrudedCrossSectionCastType::
    ~ExtrudedCrossSectionCastType ()
    {
    }

    // ExtrudedCrossSectionTransformType
    //

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (const BaseExtrudedCrossSection_type& BaseExtrudedCrossSection,
                                       const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (BaseExtrudedCrossSection, this),
      Transformation_ (Transformation, this)
    {
    }

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (::std::auto_ptr< BaseExtrudedCrossSection_type > BaseExtrudedCrossSection,
                                       ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseExtrudedCrossSection_ (BaseExtrudedCrossSection, this),
      Transformation_ (Transformation, this)
    {
    }

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (const ExtrudedCrossSectionTransformType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseExtrudedCrossSection_ (x.BaseExtrudedCrossSection_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ExtrudedCrossSectionTransformType::
    ExtrudedCrossSectionTransformType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseExtrudedCrossSection_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseExtrudedCrossSection
        //
        if (n.name () == "BaseExtrudedCrossSection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseExtrudedCrossSection_type > r (
            BaseExtrudedCrossSection_traits::create (i, f, this));

          if (!BaseExtrudedCrossSection_.present ())
          {
            this->BaseExtrudedCrossSection_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseExtrudedCrossSection_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseExtrudedCrossSection",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionTransformType* ExtrudedCrossSectionTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionTransformType (*this, f, c);
    }

    ExtrudedCrossSectionTransformType& ExtrudedCrossSectionTransformType::
    operator= (const ExtrudedCrossSectionTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseExtrudedCrossSection_ = x.BaseExtrudedCrossSection_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ExtrudedCrossSectionTransformType::
    ~ExtrudedCrossSectionTransformType ()
    {
    }

    // ExtrudedCrossSectionCheckedType
    //

    ExtrudedCrossSectionCheckedType::
    ExtrudedCrossSectionCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ExtrudedCrossSectionCheckedType::
    ExtrudedCrossSectionCheckedType (const ExtrudedCrossSectionCheckedType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ExtrudedCrossSectionCheckedType::
    ExtrudedCrossSectionCheckedType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionCheckedType* ExtrudedCrossSectionCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCheckedType (*this, f, c);
    }

    ExtrudedCrossSectionCheckedType& ExtrudedCrossSectionCheckedType::
    operator= (const ExtrudedCrossSectionCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ExtrudedCrossSectionCheckedType::
    ~ExtrudedCrossSectionCheckedType ()
    {
    }

    // ExtrudedCrossSectionCheckedFeatureType
    //

    ExtrudedCrossSectionCheckedFeatureType::
    ExtrudedCrossSectionCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ExtrudedCrossSectionCheckedFeatureType::
    ExtrudedCrossSectionCheckedFeatureType (const ExtrudedCrossSectionCheckedFeatureType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ExtrudedCrossSectionCheckedFeatureType::
    ExtrudedCrossSectionCheckedFeatureType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionCheckedFeatureType* ExtrudedCrossSectionCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionCheckedFeatureType (*this, f, c);
    }

    ExtrudedCrossSectionCheckedFeatureType& ExtrudedCrossSectionCheckedFeatureType::
    operator= (const ExtrudedCrossSectionCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ExtrudedCrossSectionCheckedFeatureType::
    ~ExtrudedCrossSectionCheckedFeatureType ()
    {
    }

    // ExtrudedCrossSectionActualDeterminationType
    //

    ExtrudedCrossSectionActualDeterminationType::
    ExtrudedCrossSectionActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ExtrudedCrossSectionActualDeterminationType::
    ExtrudedCrossSectionActualDeterminationType (const ExtrudedCrossSectionActualDeterminationType& x,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ExtrudedCrossSectionActualDeterminationType::
    ExtrudedCrossSectionActualDeterminationType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::flags f,
                                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionActualDeterminationType* ExtrudedCrossSectionActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionActualDeterminationType (*this, f, c);
    }

    ExtrudedCrossSectionActualDeterminationType& ExtrudedCrossSectionActualDeterminationType::
    operator= (const ExtrudedCrossSectionActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ExtrudedCrossSectionActualDeterminationType::
    ~ExtrudedCrossSectionActualDeterminationType ()
    {
    }

    // ExtrudedCrossSectionFeatureItemType
    //

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const id_type& id,
                                         const FeatureName_type& FeatureName,
                                         const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const id_type& id,
                                         const FeatureName_type& FeatureName,
                                         ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const ExtrudedCrossSectionFeatureItemType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureItemType::
    ExtrudedCrossSectionFeatureItemType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionFeatureItemType* ExtrudedCrossSectionFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureItemType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureItemType& ExtrudedCrossSectionFeatureItemType::
    operator= (const ExtrudedCrossSectionFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    ExtrudedCrossSectionFeatureItemType::
    ~ExtrudedCrossSectionFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ExtrudedCrossSectionFeatureItemType >
    _xsd_ExtrudedCrossSectionFeatureItemType_type_factory_init (
      "ExtrudedCrossSectionFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // ExtrudedCrossSectionFeatureDefinitionType
    //

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const id_type& id,
                                               const InternalExternal_type& InternalExternal,
                                               const Length_type& Length)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Length_ (Length, this)
    {
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const id_type& id,
                                               const InternalExternal_type& InternalExternal,
                                               ::std::auto_ptr< Length_type > Length)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Length_ (Length, this)
    {
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const ExtrudedCrossSectionFeatureDefinitionType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ExtrudedCrossSectionFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Length_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!Length_.present ())
          {
            this->Length_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Length_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Length",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionFeatureDefinitionType* ExtrudedCrossSectionFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureDefinitionType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureDefinitionType& ExtrudedCrossSectionFeatureDefinitionType::
    operator= (const ExtrudedCrossSectionFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Length_ = x.Length_;
      }

      return *this;
    }

    ExtrudedCrossSectionFeatureDefinitionType::
    ~ExtrudedCrossSectionFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ExtrudedCrossSectionFeatureDefinitionType >
    _xsd_ExtrudedCrossSectionFeatureDefinitionType_type_factory_init (
      "ExtrudedCrossSectionFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // ExtrudedCrossSectionFeatureNominalType
    //

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const id_type& id,
                                            const FeatureDefinitionId_type& FeatureDefinitionId,
                                            const Direction_type& Direction,
                                            const CrossSectionReferenceFeatureId_type& CrossSectionReferenceFeatureId)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Direction_ (Direction, this),
      CrossSectionReferenceFeatureId_ (CrossSectionReferenceFeatureId, this)
    {
    }

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const id_type& id,
                                            const FeatureDefinitionId_type& FeatureDefinitionId,
                                            ::std::auto_ptr< Direction_type > Direction,
                                            ::std::auto_ptr< CrossSectionReferenceFeatureId_type > CrossSectionReferenceFeatureId)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Direction_ (Direction, this),
      CrossSectionReferenceFeatureId_ (CrossSectionReferenceFeatureId, this)
    {
    }

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const ExtrudedCrossSectionFeatureNominalType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Direction_ (x.Direction_, f, this),
      CrossSectionReferenceFeatureId_ (x.CrossSectionReferenceFeatureId_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureNominalType::
    ExtrudedCrossSectionFeatureNominalType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Direction_ (this),
      CrossSectionReferenceFeatureId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (r);
            continue;
          }
        }

        // CrossSectionReferenceFeatureId
        //
        if (n.name () == "CrossSectionReferenceFeatureId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CrossSectionReferenceFeatureId_type > r (
            CrossSectionReferenceFeatureId_traits::create (i, f, this));

          if (!CrossSectionReferenceFeatureId_.present ())
          {
            this->CrossSectionReferenceFeatureId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Direction",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CrossSectionReferenceFeatureId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CrossSectionReferenceFeatureId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ExtrudedCrossSectionFeatureNominalType* ExtrudedCrossSectionFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureNominalType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureNominalType& ExtrudedCrossSectionFeatureNominalType::
    operator= (const ExtrudedCrossSectionFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Direction_ = x.Direction_;
        this->CrossSectionReferenceFeatureId_ = x.CrossSectionReferenceFeatureId_;
      }

      return *this;
    }

    ExtrudedCrossSectionFeatureNominalType::
    ~ExtrudedCrossSectionFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ExtrudedCrossSectionFeatureNominalType >
    _xsd_ExtrudedCrossSectionFeatureNominalType_type_factory_init (
      "ExtrudedCrossSectionFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // ExtrudedCrossSectionFeatureActualType
    //

    ExtrudedCrossSectionFeatureActualType::
    ExtrudedCrossSectionFeatureActualType (const id_type& id,
                                           const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Direction_ (this),
      Length_ (this),
      Form_ (this)
    {
    }

    ExtrudedCrossSectionFeatureActualType::
    ExtrudedCrossSectionFeatureActualType (const id_type& id,
                                           ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Direction_ (this),
      Length_ (this),
      Form_ (this)
    {
    }

    ExtrudedCrossSectionFeatureActualType::
    ExtrudedCrossSectionFeatureActualType (const ExtrudedCrossSectionFeatureActualType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Direction_ (x.Direction_, f, this),
      Length_ (x.Length_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ExtrudedCrossSectionFeatureActualType::
    ExtrudedCrossSectionFeatureActualType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Direction_ (this),
      Length_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExtrudedCrossSectionFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!this->Direction_)
          {
            this->Direction_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ExtrudedCrossSectionFeatureActualType* ExtrudedCrossSectionFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ExtrudedCrossSectionFeatureActualType (*this, f, c);
    }

    ExtrudedCrossSectionFeatureActualType& ExtrudedCrossSectionFeatureActualType::
    operator= (const ExtrudedCrossSectionFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Direction_ = x.Direction_;
        this->Length_ = x.Length_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ExtrudedCrossSectionFeatureActualType::
    ~ExtrudedCrossSectionFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ExtrudedCrossSectionFeatureActualType >
    _xsd_ExtrudedCrossSectionFeatureActualType_type_factory_init (
      "ExtrudedCrossSectionFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // GenericFeatureItemType
    //

    GenericFeatureItemType::
    GenericFeatureItemType (const id_type& id,
                            const FeatureName_type& FeatureName)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName)
    {
    }

    GenericFeatureItemType::
    GenericFeatureItemType (const GenericFeatureItemType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c)
    {
    }

    GenericFeatureItemType::
    GenericFeatureItemType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f, c)
    {
    }

    GenericFeatureItemType* GenericFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GenericFeatureItemType (*this, f, c);
    }

    GenericFeatureItemType::
    ~GenericFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, GenericFeatureItemType >
    _xsd_GenericFeatureItemType_type_factory_init (
      "GenericFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // GenericFeatureDefinitionType
    //

    GenericFeatureDefinitionType::
    GenericFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    GenericFeatureDefinitionType::
    GenericFeatureDefinitionType (const GenericFeatureDefinitionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    GenericFeatureDefinitionType::
    GenericFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    GenericFeatureDefinitionType* GenericFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GenericFeatureDefinitionType (*this, f, c);
    }

    GenericFeatureDefinitionType::
    ~GenericFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, GenericFeatureDefinitionType >
    _xsd_GenericFeatureDefinitionType_type_factory_init (
      "GenericFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // GenericFeatureNominalType
    //

    GenericFeatureNominalType::
    GenericFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (this),
      ReferenceFeatureNominalId_ (this)
    {
    }

    GenericFeatureNominalType::
    GenericFeatureNominalType (const GenericFeatureNominalType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      ReferenceFeatureNominalId_ (x.ReferenceFeatureNominalId_, f, this)
    {
    }

    GenericFeatureNominalType::
    GenericFeatureNominalType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      ReferenceFeatureNominalId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void GenericFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // ReferenceFeatureNominalId
        //
        if (n.name () == "ReferenceFeatureNominalId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReferenceFeatureNominalId_type > r (
            ReferenceFeatureNominalId_traits::create (i, f, this));

          this->ReferenceFeatureNominalId_.push_back (r);
          continue;
        }

        break;
      }
    }

    GenericFeatureNominalType* GenericFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GenericFeatureNominalType (*this, f, c);
    }

    GenericFeatureNominalType& GenericFeatureNominalType::
    operator= (const GenericFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->ReferenceFeatureNominalId_ = x.ReferenceFeatureNominalId_;
      }

      return *this;
    }

    GenericFeatureNominalType::
    ~GenericFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, GenericFeatureNominalType >
    _xsd_GenericFeatureNominalType_type_factory_init (
      "GenericFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // GenericFeatureActualType
    //

    GenericFeatureActualType::
    GenericFeatureActualType (const id_type& id,
                              const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId)
    {
    }

    GenericFeatureActualType::
    GenericFeatureActualType (const id_type& id,
                              ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId)
    {
    }

    GenericFeatureActualType::
    GenericFeatureActualType (const GenericFeatureActualType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c)
    {
    }

    GenericFeatureActualType::
    GenericFeatureActualType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f, c)
    {
    }

    GenericFeatureActualType* GenericFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GenericFeatureActualType (*this, f, c);
    }

    GenericFeatureActualType::
    ~GenericFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, GenericFeatureActualType >
    _xsd_GenericFeatureActualType_type_factory_init (
      "GenericFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // LineConstructionMethodType
    //

    LineConstructionMethodType::
    LineConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Midline_ (this),
      Intersection_ (this),
      Projection_ (this),
      Perpendicular_ (this),
      Parallel_ (this),
      Copy_ (this),
      Cast_ (this),
      TangentThrough_ (this),
      Transform_ (this),
      Extract_ (this),
      FromScan_ (this)
    {
    }

    LineConstructionMethodType::
    LineConstructionMethodType (const LineConstructionMethodType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Midline_ (x.Midline_, f, this),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Perpendicular_ (x.Perpendicular_, f, this),
      Parallel_ (x.Parallel_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      TangentThrough_ (x.TangentThrough_, f, this),
      Transform_ (x.Transform_, f, this),
      Extract_ (x.Extract_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    LineConstructionMethodType::
    LineConstructionMethodType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Midline_ (this),
      Intersection_ (this),
      Projection_ (this),
      Perpendicular_ (this),
      Parallel_ (this),
      Copy_ (this),
      Cast_ (this),
      TangentThrough_ (this),
      Transform_ (this),
      Extract_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Midline
        //
        if (n.name () == "Midline" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Midline_type > r (
            Midline_traits::create (i, f, this));

          if (!this->Midline_)
          {
            this->Midline_.set (r);
            continue;
          }
        }

        // Intersection
        //
        if (n.name () == "Intersection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Perpendicular
        //
        if (n.name () == "Perpendicular" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Perpendicular_type > r (
            Perpendicular_traits::create (i, f, this));

          if (!this->Perpendicular_)
          {
            this->Perpendicular_.set (r);
            continue;
          }
        }

        // Parallel
        //
        if (n.name () == "Parallel" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Parallel_type > r (
            Parallel_traits::create (i, f, this));

          if (!this->Parallel_)
          {
            this->Parallel_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // TangentThrough
        //
        if (n.name () == "TangentThrough" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentThrough_type > r (
            TangentThrough_traits::create (i, f, this));

          if (!this->TangentThrough_)
          {
            this->TangentThrough_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // Extract
        //
        if (n.name () == "Extract" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LineConstructionMethodType* LineConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineConstructionMethodType (*this, f, c);
    }

    LineConstructionMethodType& LineConstructionMethodType::
    operator= (const LineConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Midline_ = x.Midline_;
        this->Intersection_ = x.Intersection_;
        this->Projection_ = x.Projection_;
        this->Perpendicular_ = x.Perpendicular_;
        this->Parallel_ = x.Parallel_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->TangentThrough_ = x.TangentThrough_;
        this->Transform_ = x.Transform_;
        this->Extract_ = x.Extract_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    LineConstructionMethodType::
    ~LineConstructionMethodType ()
    {
    }

    // LineBestFitType
    //

    LineBestFitType::
    LineBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    LineBestFitType::
    LineBestFitType (const LineBestFitType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    LineBestFitType::
    LineBestFitType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    LineBestFitType* LineBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineBestFitType (*this, f, c);
    }

    LineBestFitType& LineBestFitType::
    operator= (const LineBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    LineBestFitType::
    ~LineBestFitType ()
    {
    }

    // LineRecompType
    //

    LineRecompType::
    LineRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    LineRecompType::
    LineRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    LineRecompType::
    LineRecompType (const LineRecompType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    LineRecompType::
    LineRecompType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineRecompType* LineRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineRecompType (*this, f, c);
    }

    LineRecompType& LineRecompType::
    operator= (const LineRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    LineRecompType::
    ~LineRecompType ()
    {
    }

    // LineMidlineType
    //

    LineMidlineType::
    LineMidlineType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLine_ (this)
    {
    }

    LineMidlineType::
    LineMidlineType (const LineMidlineType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseLine_ (x.BaseLine_, f, this)
    {
    }

    LineMidlineType::
    LineMidlineType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLine_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineMidlineType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseLine
        //
        if (n.name () == "BaseLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseLine_type > r (
            BaseLine_traits::create (i, f, this));

          this->BaseLine_.push_back (r);
          continue;
        }

        break;
      }
    }

    LineMidlineType* LineMidlineType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineMidlineType (*this, f, c);
    }

    LineMidlineType& LineMidlineType::
    operator= (const LineMidlineType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseLine_ = x.BaseLine_;
      }

      return *this;
    }

    LineMidlineType::
    ~LineMidlineType ()
    {
    }

    // LineIntersectionType
    //

    LineIntersectionType::
    LineIntersectionType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (this)
    {
    }

    LineIntersectionType::
    LineIntersectionType (const LineIntersectionType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this)
    {
    }

    LineIntersectionType::
    LineIntersectionType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePlane
        //
        if (n.name () == "BasePlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          this->BasePlane_.push_back (r);
          continue;
        }

        break;
      }
    }

    LineIntersectionType* LineIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineIntersectionType (*this, f, c);
    }

    LineIntersectionType& LineIntersectionType::
    operator= (const LineIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BasePlane_ = x.BasePlane_;
      }

      return *this;
    }

    LineIntersectionType::
    ~LineIntersectionType ()
    {
    }

    // LineProjectionType
    //

    LineProjectionType::
    LineProjectionType (const ProjectionPlane_type& ProjectionPlane,
                        const ProjectionLine_type& ProjectionLine)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, this),
      ProjectionLine_ (ProjectionLine, this)
    {
    }

    LineProjectionType::
    LineProjectionType (::std::auto_ptr< ProjectionPlane_type > ProjectionPlane,
                        ::std::auto_ptr< ProjectionLine_type > ProjectionLine)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, this),
      ProjectionLine_ (ProjectionLine, this)
    {
    }

    LineProjectionType::
    LineProjectionType (const LineProjectionType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionPlane_ (x.ProjectionPlane_, f, this),
      ProjectionLine_ (x.ProjectionLine_, f, this)
    {
    }

    LineProjectionType::
    LineProjectionType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionPlane_ (this),
      ProjectionLine_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        // ProjectionLine
        //
        if (n.name () == "ProjectionLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionLine_type > r (
            ProjectionLine_traits::create (i, f, this));

          if (!ProjectionLine_.present ())
          {
            this->ProjectionLine_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionLine",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineProjectionType* LineProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineProjectionType (*this, f, c);
    }

    LineProjectionType& LineProjectionType::
    operator= (const LineProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionPlane_ = x.ProjectionPlane_;
        this->ProjectionLine_ = x.ProjectionLine_;
      }

      return *this;
    }

    LineProjectionType::
    ~LineProjectionType ()
    {
    }

    // LinePerpendicularType
    //

    LinePerpendicularType::
    LinePerpendicularType (const PerpendicularFeature_type& PerpendicularFeature,
                           const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      PerpendicularFeature_ (PerpendicularFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    LinePerpendicularType::
    LinePerpendicularType (::std::auto_ptr< PerpendicularFeature_type > PerpendicularFeature,
                           ::std::auto_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      PerpendicularFeature_ (PerpendicularFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    LinePerpendicularType::
    LinePerpendicularType (const LinePerpendicularType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      PerpendicularFeature_ (x.PerpendicularFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    LinePerpendicularType::
    LinePerpendicularType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      PerpendicularFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LinePerpendicularType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PerpendicularFeature
        //
        if (n.name () == "PerpendicularFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PerpendicularFeature_type > r (
            PerpendicularFeature_traits::create (i, f, this));

          if (!PerpendicularFeature_.present ())
          {
            this->PerpendicularFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!PerpendicularFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PerpendicularFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LinePerpendicularType* LinePerpendicularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LinePerpendicularType (*this, f, c);
    }

    LinePerpendicularType& LinePerpendicularType::
    operator= (const LinePerpendicularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->PerpendicularFeature_ = x.PerpendicularFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    LinePerpendicularType::
    ~LinePerpendicularType ()
    {
    }

    // LineParallelType
    //

    LineParallelType::
    LineParallelType (const ParallelFeature_type& ParallelFeature,
                      const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ParallelFeature_ (ParallelFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    LineParallelType::
    LineParallelType (::std::auto_ptr< ParallelFeature_type > ParallelFeature,
                      ::std::auto_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ParallelFeature_ (ParallelFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    LineParallelType::
    LineParallelType (const LineParallelType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ParallelFeature_ (x.ParallelFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    LineParallelType::
    LineParallelType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ParallelFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineParallelType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ParallelFeature
        //
        if (n.name () == "ParallelFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ParallelFeature_type > r (
            ParallelFeature_traits::create (i, f, this));

          if (!ParallelFeature_.present ())
          {
            this->ParallelFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ParallelFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ParallelFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineParallelType* LineParallelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineParallelType (*this, f, c);
    }

    LineParallelType& LineParallelType::
    operator= (const LineParallelType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->ParallelFeature_ = x.ParallelFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    LineParallelType::
    ~LineParallelType ()
    {
    }

    // LineCopyType
    //

    LineCopyType::
    LineCopyType (const BaseLine_type& BaseLine)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLine_ (BaseLine, this)
    {
    }

    LineCopyType::
    LineCopyType (::std::auto_ptr< BaseLine_type > BaseLine)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLine_ (BaseLine, this)
    {
    }

    LineCopyType::
    LineCopyType (const LineCopyType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseLine_ (x.BaseLine_, f, this)
    {
    }

    LineCopyType::
    LineCopyType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLine_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseLine
        //
        if (n.name () == "BaseLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseLine_type > r (
            BaseLine_traits::create (i, f, this));

          if (!BaseLine_.present ())
          {
            this->BaseLine_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseLine",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineCopyType* LineCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCopyType (*this, f, c);
    }

    LineCopyType& LineCopyType::
    operator= (const LineCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseLine_ = x.BaseLine_;
      }

      return *this;
    }

    LineCopyType::
    ~LineCopyType ()
    {
    }

    // LineCastType
    //

    LineCastType::
    LineCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    LineCastType::
    LineCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    LineCastType::
    LineCastType (const LineCastType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    LineCastType::
    LineCastType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineCastType* LineCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCastType (*this, f, c);
    }

    LineCastType& LineCastType::
    operator= (const LineCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    LineCastType::
    ~LineCastType ()
    {
    }

    // LineTangentThroughType
    //

    LineTangentThroughType::
    LineTangentThroughType (const TangentFeature_type& TangentFeature,
                            const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    LineTangentThroughType::
    LineTangentThroughType (::std::auto_ptr< TangentFeature_type > TangentFeature,
                            ::std::auto_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    LineTangentThroughType::
    LineTangentThroughType (const LineTangentThroughType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    LineTangentThroughType::
    LineTangentThroughType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineTangentThroughType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TangentFeature
        //
        if (n.name () == "TangentFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          if (!TangentFeature_.present ())
          {
            this->TangentFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!TangentFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TangentFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineTangentThroughType* LineTangentThroughType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineTangentThroughType (*this, f, c);
    }

    LineTangentThroughType& LineTangentThroughType::
    operator= (const LineTangentThroughType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->TangentFeature_ = x.TangentFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    LineTangentThroughType::
    ~LineTangentThroughType ()
    {
    }

    // LineTransformType
    //

    LineTransformType::
    LineTransformType (const BaseLine_type& BaseLine,
                       const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLine_ (BaseLine, this),
      Transformation_ (Transformation, this)
    {
    }

    LineTransformType::
    LineTransformType (::std::auto_ptr< BaseLine_type > BaseLine,
                       ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLine_ (BaseLine, this),
      Transformation_ (Transformation, this)
    {
    }

    LineTransformType::
    LineTransformType (const LineTransformType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseLine_ (x.BaseLine_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    LineTransformType::
    LineTransformType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLine_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseLine
        //
        if (n.name () == "BaseLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseLine_type > r (
            BaseLine_traits::create (i, f, this));

          if (!BaseLine_.present ())
          {
            this->BaseLine_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseLine",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineTransformType* LineTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineTransformType (*this, f, c);
    }

    LineTransformType& LineTransformType::
    operator= (const LineTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseLine_ = x.BaseLine_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    LineTransformType::
    ~LineTransformType ()
    {
    }

    // LineFromScanType
    //

    LineFromScanType::
    LineFromScanType (const SurfaceFeature_type& SurfaceFeature,
                      const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    LineFromScanType::
    LineFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                      ::std::auto_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    LineFromScanType::
    LineFromScanType (const LineFromScanType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    LineFromScanType::
    LineFromScanType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineFromScanType* LineFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFromScanType (*this, f, c);
    }

    LineFromScanType& LineFromScanType::
    operator= (const LineFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    LineFromScanType::
    ~LineFromScanType ()
    {
    }

    // LineExtractType
    //

    LineExtractType::
    LineExtractType (const CurveFeature_type& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, this)
    {
    }

    LineExtractType::
    LineExtractType (::std::auto_ptr< CurveFeature_type > CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, this)
    {
    }

    LineExtractType::
    LineExtractType (const LineExtractType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    LineExtractType::
    LineExtractType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      CurveFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineExtractType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CurveFeature
        //
        if (n.name () == "CurveFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CurveFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineExtractType* LineExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineExtractType (*this, f, c);
    }

    LineExtractType& LineExtractType::
    operator= (const LineExtractType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->CurveFeature_ = x.CurveFeature_;
      }

      return *this;
    }

    LineExtractType::
    ~LineExtractType ()
    {
    }

    // LineCheckedType
    //

    LineCheckedType::
    LineCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    LineCheckedType::
    LineCheckedType (const LineCheckedType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    LineCheckedType::
    LineCheckedType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LineCheckedType* LineCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCheckedType (*this, f, c);
    }

    LineCheckedType& LineCheckedType::
    operator= (const LineCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    LineCheckedType::
    ~LineCheckedType ()
    {
    }

    // LineCheckedFeatureType
    //

    LineCheckedFeatureType::
    LineCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    LineCheckedFeatureType::
    LineCheckedFeatureType (const LineCheckedFeatureType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    LineCheckedFeatureType::
    LineCheckedFeatureType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LineCheckedFeatureType* LineCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineCheckedFeatureType (*this, f, c);
    }

    LineCheckedFeatureType& LineCheckedFeatureType::
    operator= (const LineCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    LineCheckedFeatureType::
    ~LineCheckedFeatureType ()
    {
    }

    // LineActualDeterminationType
    //

    LineActualDeterminationType::
    LineActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    LineActualDeterminationType::
    LineActualDeterminationType (const LineActualDeterminationType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    LineActualDeterminationType::
    LineActualDeterminationType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void LineActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LineActualDeterminationType* LineActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineActualDeterminationType (*this, f, c);
    }

    LineActualDeterminationType& LineActualDeterminationType::
    operator= (const LineActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    LineActualDeterminationType::
    ~LineActualDeterminationType ()
    {
    }

    // LineFeatureItemType
    //

    LineFeatureItemType::
    LineFeatureItemType (const id_type& id,
                         const FeatureName_type& FeatureName,
                         const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    LineFeatureItemType::
    LineFeatureItemType (const id_type& id,
                         const FeatureName_type& FeatureName,
                         ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    LineFeatureItemType::
    LineFeatureItemType (const LineFeatureItemType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    LineFeatureItemType::
    LineFeatureItemType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LineFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineFeatureItemType* LineFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureItemType (*this, f, c);
    }

    LineFeatureItemType& LineFeatureItemType::
    operator= (const LineFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    LineFeatureItemType::
    ~LineFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LineFeatureItemType >
    _xsd_LineFeatureItemType_type_factory_init (
      "LineFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // LineFeatureDefinitionType
    //

    LineFeatureDefinitionType::
    LineFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    LineFeatureDefinitionType::
    LineFeatureDefinitionType (const LineFeatureDefinitionType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    LineFeatureDefinitionType::
    LineFeatureDefinitionType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    LineFeatureDefinitionType* LineFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureDefinitionType (*this, f, c);
    }

    LineFeatureDefinitionType::
    ~LineFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LineFeatureDefinitionType >
    _xsd_LineFeatureDefinitionType_type_factory_init (
      "LineFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // LineFeatureNominalType
    //

    LineFeatureNominalType::
    LineFeatureNominalType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId,
                            const Location_type& Location,
                            const Direction_type& Direction)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Direction_ (Direction, this),
      Length_ (this),
      Normal_ (this)
    {
    }

    LineFeatureNominalType::
    LineFeatureNominalType (const id_type& id,
                            const FeatureDefinitionId_type& FeatureDefinitionId,
                            ::std::auto_ptr< Location_type > Location,
                            ::std::auto_ptr< Direction_type > Direction)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Direction_ (Direction, this),
      Length_ (this),
      Normal_ (this)
    {
    }

    LineFeatureNominalType::
    LineFeatureNominalType (const LineFeatureNominalType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Direction_ (x.Direction_, f, this),
      Length_ (x.Length_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    LineFeatureNominalType::
    LineFeatureNominalType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Direction_ (this),
      Length_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LineFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Direction",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    LineFeatureNominalType* LineFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureNominalType (*this, f, c);
    }

    LineFeatureNominalType& LineFeatureNominalType::
    operator= (const LineFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Direction_ = x.Direction_;
        this->Length_ = x.Length_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    LineFeatureNominalType::
    ~LineFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LineFeatureNominalType >
    _xsd_LineFeatureNominalType_type_factory_init (
      "LineFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // LineFeatureActualType
    //

    LineFeatureActualType::
    LineFeatureActualType (const id_type& id,
                           const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Direction_ (this),
      Length_ (this),
      Normal_ (this),
      Form_ (this)
    {
    }

    LineFeatureActualType::
    LineFeatureActualType (const id_type& id,
                           ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Direction_ (this),
      Length_ (this),
      Normal_ (this),
      Form_ (this)
    {
    }

    LineFeatureActualType::
    LineFeatureActualType (const LineFeatureActualType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Direction_ (x.Direction_, f, this),
      Length_ (x.Length_, f, this),
      Normal_ (x.Normal_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    LineFeatureActualType::
    LineFeatureActualType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Direction_ (this),
      Length_ (this),
      Normal_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void LineFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!this->Direction_)
          {
            this->Direction_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    LineFeatureActualType* LineFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LineFeatureActualType (*this, f, c);
    }

    LineFeatureActualType& LineFeatureActualType::
    operator= (const LineFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Direction_ = x.Direction_;
        this->Length_ = x.Length_;
        this->Normal_ = x.Normal_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    LineFeatureActualType::
    ~LineFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LineFeatureActualType >
    _xsd_LineFeatureActualType_type_factory_init (
      "LineFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // OppositeLinesConstructionMethodType
    //

    OppositeLinesConstructionMethodType::
    OppositeLinesConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    OppositeLinesConstructionMethodType::
    OppositeLinesConstructionMethodType (const OppositeLinesConstructionMethodType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    OppositeLinesConstructionMethodType::
    OppositeLinesConstructionMethodType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesConstructionMethodType* OppositeLinesConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesConstructionMethodType (*this, f, c);
    }

    OppositeLinesConstructionMethodType& OppositeLinesConstructionMethodType::
    operator= (const OppositeLinesConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    OppositeLinesConstructionMethodType::
    ~OppositeLinesConstructionMethodType ()
    {
    }

    // OppositeLinesBestFitType
    //

    OppositeLinesBestFitType::
    OppositeLinesBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    OppositeLinesBestFitType::
    OppositeLinesBestFitType (const OppositeLinesBestFitType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositeLinesBestFitType::
    OppositeLinesBestFitType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    OppositeLinesBestFitType* OppositeLinesBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesBestFitType (*this, f, c);
    }

    OppositeLinesBestFitType& OppositeLinesBestFitType::
    operator= (const OppositeLinesBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    OppositeLinesBestFitType::
    ~OppositeLinesBestFitType ()
    {
    }

    // OppositeLinesRecompType
    //

    OppositeLinesRecompType::
    OppositeLinesRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    OppositeLinesRecompType::
    OppositeLinesRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    OppositeLinesRecompType::
    OppositeLinesRecompType (const OppositeLinesRecompType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    OppositeLinesRecompType::
    OppositeLinesRecompType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesRecompType* OppositeLinesRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesRecompType (*this, f, c);
    }

    OppositeLinesRecompType& OppositeLinesRecompType::
    operator= (const OppositeLinesRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    OppositeLinesRecompType::
    ~OppositeLinesRecompType ()
    {
    }

    // OppositeLinesProjectionType
    //

    OppositeLinesProjectionType::
    OppositeLinesProjectionType (const ProjectionPlane_type& ProjectionPlane,
                                 const ProjectionOppositeLines_type& ProjectionOppositeLines)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, this),
      ProjectionOppositeLines_ (ProjectionOppositeLines, this)
    {
    }

    OppositeLinesProjectionType::
    OppositeLinesProjectionType (::std::auto_ptr< ProjectionPlane_type > ProjectionPlane,
                                 ::std::auto_ptr< ProjectionOppositeLines_type > ProjectionOppositeLines)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, this),
      ProjectionOppositeLines_ (ProjectionOppositeLines, this)
    {
    }

    OppositeLinesProjectionType::
    OppositeLinesProjectionType (const OppositeLinesProjectionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionPlane_ (x.ProjectionPlane_, f, this),
      ProjectionOppositeLines_ (x.ProjectionOppositeLines_, f, this)
    {
    }

    OppositeLinesProjectionType::
    OppositeLinesProjectionType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionPlane_ (this),
      ProjectionOppositeLines_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        // ProjectionOppositeLines
        //
        if (n.name () == "ProjectionOppositeLines" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionOppositeLines_type > r (
            ProjectionOppositeLines_traits::create (i, f, this));

          if (!ProjectionOppositeLines_.present ())
          {
            this->ProjectionOppositeLines_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionOppositeLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionOppositeLines",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesProjectionType* OppositeLinesProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesProjectionType (*this, f, c);
    }

    OppositeLinesProjectionType& OppositeLinesProjectionType::
    operator= (const OppositeLinesProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionPlane_ = x.ProjectionPlane_;
        this->ProjectionOppositeLines_ = x.ProjectionOppositeLines_;
      }

      return *this;
    }

    OppositeLinesProjectionType::
    ~OppositeLinesProjectionType ()
    {
    }

    // OppositeLinesCopyType
    //

    OppositeLinesCopyType::
    OppositeLinesCopyType (const BaseOppositeLines_type& BaseOppositeLines)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositeLines_ (BaseOppositeLines, this)
    {
    }

    OppositeLinesCopyType::
    OppositeLinesCopyType (::std::auto_ptr< BaseOppositeLines_type > BaseOppositeLines)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositeLines_ (BaseOppositeLines, this)
    {
    }

    OppositeLinesCopyType::
    OppositeLinesCopyType (const OppositeLinesCopyType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseOppositeLines_ (x.BaseOppositeLines_, f, this)
    {
    }

    OppositeLinesCopyType::
    OppositeLinesCopyType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeLines_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseOppositeLines
        //
        if (n.name () == "BaseOppositeLines" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseOppositeLines_type > r (
            BaseOppositeLines_traits::create (i, f, this));

          if (!BaseOppositeLines_.present ())
          {
            this->BaseOppositeLines_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseOppositeLines",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesCopyType* OppositeLinesCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesCopyType (*this, f, c);
    }

    OppositeLinesCopyType& OppositeLinesCopyType::
    operator= (const OppositeLinesCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositeLines_ = x.BaseOppositeLines_;
      }

      return *this;
    }

    OppositeLinesCopyType::
    ~OppositeLinesCopyType ()
    {
    }

    // OppositeLinesCastType
    //

    OppositeLinesCastType::
    OppositeLinesCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    OppositeLinesCastType::
    OppositeLinesCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    OppositeLinesCastType::
    OppositeLinesCastType (const OppositeLinesCastType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositeLinesCastType::
    OppositeLinesCastType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesCastType* OppositeLinesCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesCastType (*this, f, c);
    }

    OppositeLinesCastType& OppositeLinesCastType::
    operator= (const OppositeLinesCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    OppositeLinesCastType::
    ~OppositeLinesCastType ()
    {
    }

    // OppositeLinesTransformType
    //

    OppositeLinesTransformType::
    OppositeLinesTransformType (const BaseOppositeLines_type& BaseOppositeLines,
                                const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositeLines_ (BaseOppositeLines, this),
      Transformation_ (Transformation, this)
    {
    }

    OppositeLinesTransformType::
    OppositeLinesTransformType (::std::auto_ptr< BaseOppositeLines_type > BaseOppositeLines,
                                ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositeLines_ (BaseOppositeLines, this),
      Transformation_ (Transformation, this)
    {
    }

    OppositeLinesTransformType::
    OppositeLinesTransformType (const OppositeLinesTransformType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseOppositeLines_ (x.BaseOppositeLines_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    OppositeLinesTransformType::
    OppositeLinesTransformType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositeLines_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseOppositeLines
        //
        if (n.name () == "BaseOppositeLines" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseOppositeLines_type > r (
            BaseOppositeLines_traits::create (i, f, this));

          if (!BaseOppositeLines_.present ())
          {
            this->BaseOppositeLines_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseOppositeLines_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseOppositeLines",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesTransformType* OppositeLinesTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesTransformType (*this, f, c);
    }

    OppositeLinesTransformType& OppositeLinesTransformType::
    operator= (const OppositeLinesTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositeLines_ = x.BaseOppositeLines_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    OppositeLinesTransformType::
    ~OppositeLinesTransformType ()
    {
    }

    // OppositeLinesFromScanType
    //

    OppositeLinesFromScanType::
    OppositeLinesFromScanType (const SurfaceFeature_type& SurfaceFeature,
                               const SearchRadius_type& SearchRadius,
                               const Depth_type& Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    OppositeLinesFromScanType::
    OppositeLinesFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                               ::std::auto_ptr< SearchRadius_type > SearchRadius,
                               ::std::auto_ptr< Depth_type > Depth)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Depth_ (Depth, this)
    {
    }

    OppositeLinesFromScanType::
    OppositeLinesFromScanType (const OppositeLinesFromScanType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Depth_ (x.Depth_, f, this)
    {
    }

    OppositeLinesFromScanType::
    OppositeLinesFromScanType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Depth_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!Depth_.present ())
          {
            this->Depth_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Depth_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Depth",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesFromScanType* OppositeLinesFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesFromScanType (*this, f, c);
    }

    OppositeLinesFromScanType& OppositeLinesFromScanType::
    operator= (const OppositeLinesFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Depth_ = x.Depth_;
      }

      return *this;
    }

    OppositeLinesFromScanType::
    ~OppositeLinesFromScanType ()
    {
    }

    // OppositeLinesCheckedType
    //

    OppositeLinesCheckedType::
    OppositeLinesCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    OppositeLinesCheckedType::
    OppositeLinesCheckedType (const OppositeLinesCheckedType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositeLinesCheckedType::
    OppositeLinesCheckedType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesCheckedType* OppositeLinesCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesCheckedType (*this, f, c);
    }

    OppositeLinesCheckedType& OppositeLinesCheckedType::
    operator= (const OppositeLinesCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OppositeLinesCheckedType::
    ~OppositeLinesCheckedType ()
    {
    }

    // OppositeLinesCheckedFeatureType
    //

    OppositeLinesCheckedFeatureType::
    OppositeLinesCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    OppositeLinesCheckedFeatureType::
    OppositeLinesCheckedFeatureType (const OppositeLinesCheckedFeatureType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    OppositeLinesCheckedFeatureType::
    OppositeLinesCheckedFeatureType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesCheckedFeatureType* OppositeLinesCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesCheckedFeatureType (*this, f, c);
    }

    OppositeLinesCheckedFeatureType& OppositeLinesCheckedFeatureType::
    operator= (const OppositeLinesCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    OppositeLinesCheckedFeatureType::
    ~OppositeLinesCheckedFeatureType ()
    {
    }

    // OppositeLinesActualDeterminationType
    //

    OppositeLinesActualDeterminationType::
    OppositeLinesActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    OppositeLinesActualDeterminationType::
    OppositeLinesActualDeterminationType (const OppositeLinesActualDeterminationType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    OppositeLinesActualDeterminationType::
    OppositeLinesActualDeterminationType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositeLinesActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesActualDeterminationType* OppositeLinesActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesActualDeterminationType (*this, f, c);
    }

    OppositeLinesActualDeterminationType& OppositeLinesActualDeterminationType::
    operator= (const OppositeLinesActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    OppositeLinesActualDeterminationType::
    ~OppositeLinesActualDeterminationType ()
    {
    }

    // OppositeLinesFeatureItemType
    //

    OppositeLinesFeatureItemType::
    OppositeLinesFeatureItemType (const id_type& id,
                                  const FeatureName_type& FeatureName,
                                  const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    OppositeLinesFeatureItemType::
    OppositeLinesFeatureItemType (const id_type& id,
                                  const FeatureName_type& FeatureName,
                                  ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    OppositeLinesFeatureItemType::
    OppositeLinesFeatureItemType (const OppositeLinesFeatureItemType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    OppositeLinesFeatureItemType::
    OppositeLinesFeatureItemType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeLinesFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesFeatureItemType* OppositeLinesFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesFeatureItemType (*this, f, c);
    }

    OppositeLinesFeatureItemType& OppositeLinesFeatureItemType::
    operator= (const OppositeLinesFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    OppositeLinesFeatureItemType::
    ~OppositeLinesFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OppositeLinesFeatureItemType >
    _xsd_OppositeLinesFeatureItemType_type_factory_init (
      "OppositeLinesFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // OppositeLinesFeatureDefinitionType
    //

    OppositeLinesFeatureDefinitionType::
    OppositeLinesFeatureDefinitionType (const id_type& id,
                                        const InternalExternal_type& InternalExternal,
                                        const Width_type& Width,
                                        const EndType_type& EndType)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (Width, this),
      Length_ (this),
      EndType_ (EndType, this),
      TaperAngle_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
    }

    OppositeLinesFeatureDefinitionType::
    OppositeLinesFeatureDefinitionType (const id_type& id,
                                        const InternalExternal_type& InternalExternal,
                                        ::std::auto_ptr< Width_type > Width,
                                        ::std::auto_ptr< EndType_type > EndType)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (Width, this),
      Length_ (this),
      EndType_ (EndType, this),
      TaperAngle_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
    }

    OppositeLinesFeatureDefinitionType::
    OppositeLinesFeatureDefinitionType (const OppositeLinesFeatureDefinitionType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Width_ (x.Width_, f, this),
      Length_ (x.Length_, f, this),
      EndType_ (x.EndType_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      SingleOpenEnd_ (x.SingleOpenEnd_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this)
    {
    }

    OppositeLinesFeatureDefinitionType::
    OppositeLinesFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Width_ (this),
      Length_ (this),
      EndType_ (this),
      TaperAngle_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeLinesFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // EndType
        //
        if (n.name () == "EndType" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndType_type > r (
            EndType_traits::create (i, f, this));

          if (!EndType_.present ())
          {
            this->EndType_.set (r);
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == "TaperAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!this->TaperAngle_)
          {
            this->TaperAngle_.set (r);
            continue;
          }
        }

        // SingleOpenEnd
        //
        if (n.name () == "SingleOpenEnd" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->SingleOpenEnd_)
          {
            this->SingleOpenEnd_.set (SingleOpenEnd_traits::create (i, f, this));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == "EndRadius1" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (r);
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == "EndRadius2" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Width",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!EndType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndType",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesFeatureDefinitionType* OppositeLinesFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesFeatureDefinitionType (*this, f, c);
    }

    OppositeLinesFeatureDefinitionType& OppositeLinesFeatureDefinitionType::
    operator= (const OppositeLinesFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Width_ = x.Width_;
        this->Length_ = x.Length_;
        this->EndType_ = x.EndType_;
        this->TaperAngle_ = x.TaperAngle_;
        this->SingleOpenEnd_ = x.SingleOpenEnd_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
      }

      return *this;
    }

    OppositeLinesFeatureDefinitionType::
    ~OppositeLinesFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OppositeLinesFeatureDefinitionType >
    _xsd_OppositeLinesFeatureDefinitionType_type_factory_init (
      "OppositeLinesFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // OppositeLinesFeatureNominalType
    //

    OppositeLinesFeatureNominalType::
    OppositeLinesFeatureNominalType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId,
                                     const CenterLine_type& CenterLine,
                                     const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterLine_ (CenterLine, this),
      Normal_ (Normal, this)
    {
    }

    OppositeLinesFeatureNominalType::
    OppositeLinesFeatureNominalType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId,
                                     ::std::auto_ptr< CenterLine_type > CenterLine,
                                     ::std::auto_ptr< Normal_type > Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterLine_ (CenterLine, this),
      Normal_ (Normal, this)
    {
    }

    OppositeLinesFeatureNominalType::
    OppositeLinesFeatureNominalType (const OppositeLinesFeatureNominalType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      CenterLine_ (x.CenterLine_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    OppositeLinesFeatureNominalType::
    OppositeLinesFeatureNominalType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterLine_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeLinesFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterLine
        //
        if (n.name () == "CenterLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterLine_type > r (
            CenterLine_traits::create (i, f, this));

          if (!CenterLine_.present ())
          {
            this->CenterLine_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CenterLine_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CenterLine",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositeLinesFeatureNominalType* OppositeLinesFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesFeatureNominalType (*this, f, c);
    }

    OppositeLinesFeatureNominalType& OppositeLinesFeatureNominalType::
    operator= (const OppositeLinesFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->CenterLine_ = x.CenterLine_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    OppositeLinesFeatureNominalType::
    ~OppositeLinesFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OppositeLinesFeatureNominalType >
    _xsd_OppositeLinesFeatureNominalType_type_factory_init (
      "OppositeLinesFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // OppositeLinesFeatureActualType
    //

    OppositeLinesFeatureActualType::
    OppositeLinesFeatureActualType (const id_type& id,
                                    const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      CenterLine_ (this),
      Normal_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      TaperAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositeLinesFeatureActualType::
    OppositeLinesFeatureActualType (const id_type& id,
                                    ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      CenterLine_ (this),
      Normal_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      TaperAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositeLinesFeatureActualType::
    OppositeLinesFeatureActualType (const OppositeLinesFeatureActualType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      CenterLine_ (x.CenterLine_, f, this),
      Normal_ (x.Normal_, f, this),
      Width_ (x.Width_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      Length_ (x.Length_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    OppositeLinesFeatureActualType::
    OppositeLinesFeatureActualType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      CenterLine_ (this),
      Normal_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      TaperAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositeLinesFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterLine
        //
        if (n.name () == "CenterLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterLine_type > r (
            CenterLine_traits::create (i, f, this));

          if (!this->CenterLine_)
          {
            this->CenterLine_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (r);
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == "WidthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (r);
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == "WidthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == "LengthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (r);
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == "LengthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (r);
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == "TaperAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!this->TaperAngle_)
          {
            this->TaperAngle_.set (r);
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == "EndRadius1" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (r);
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == "EndRadius2" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositeLinesFeatureActualType* OppositeLinesFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositeLinesFeatureActualType (*this, f, c);
    }

    OppositeLinesFeatureActualType& OppositeLinesFeatureActualType::
    operator= (const OppositeLinesFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->CenterLine_ = x.CenterLine_;
        this->Normal_ = x.Normal_;
        this->Width_ = x.Width_;
        this->WidthMin_ = x.WidthMin_;
        this->WidthMax_ = x.WidthMax_;
        this->Length_ = x.Length_;
        this->LengthMin_ = x.LengthMin_;
        this->LengthMax_ = x.LengthMax_;
        this->TaperAngle_ = x.TaperAngle_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    OppositeLinesFeatureActualType::
    ~OppositeLinesFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OppositeLinesFeatureActualType >
    _xsd_OppositeLinesFeatureActualType_type_factory_init (
      "OppositeLinesFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // OppositePlanesConstructionMethodType
    //

    OppositePlanesConstructionMethodType::
    OppositePlanesConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    OppositePlanesConstructionMethodType::
    OppositePlanesConstructionMethodType (const OppositePlanesConstructionMethodType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    OppositePlanesConstructionMethodType::
    OppositePlanesConstructionMethodType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesConstructionMethodType* OppositePlanesConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesConstructionMethodType (*this, f, c);
    }

    OppositePlanesConstructionMethodType& OppositePlanesConstructionMethodType::
    operator= (const OppositePlanesConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    OppositePlanesConstructionMethodType::
    ~OppositePlanesConstructionMethodType ()
    {
    }

    // OppositePlanesBestFitType
    //

    OppositePlanesBestFitType::
    OppositePlanesBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    OppositePlanesBestFitType::
    OppositePlanesBestFitType (const OppositePlanesBestFitType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositePlanesBestFitType::
    OppositePlanesBestFitType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    OppositePlanesBestFitType* OppositePlanesBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesBestFitType (*this, f, c);
    }

    OppositePlanesBestFitType& OppositePlanesBestFitType::
    operator= (const OppositePlanesBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    OppositePlanesBestFitType::
    ~OppositePlanesBestFitType ()
    {
    }

    // OppositePlanesRecompType
    //

    OppositePlanesRecompType::
    OppositePlanesRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    OppositePlanesRecompType::
    OppositePlanesRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    OppositePlanesRecompType::
    OppositePlanesRecompType (const OppositePlanesRecompType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    OppositePlanesRecompType::
    OppositePlanesRecompType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesRecompType* OppositePlanesRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesRecompType (*this, f, c);
    }

    OppositePlanesRecompType& OppositePlanesRecompType::
    operator= (const OppositePlanesRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    OppositePlanesRecompType::
    ~OppositePlanesRecompType ()
    {
    }

    // OppositePlanesCopyType
    //

    OppositePlanesCopyType::
    OppositePlanesCopyType (const BaseOppositePlanes_type& BaseOppositePlanes)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositePlanes_ (BaseOppositePlanes, this)
    {
    }

    OppositePlanesCopyType::
    OppositePlanesCopyType (::std::auto_ptr< BaseOppositePlanes_type > BaseOppositePlanes)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositePlanes_ (BaseOppositePlanes, this)
    {
    }

    OppositePlanesCopyType::
    OppositePlanesCopyType (const OppositePlanesCopyType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseOppositePlanes_ (x.BaseOppositePlanes_, f, this)
    {
    }

    OppositePlanesCopyType::
    OppositePlanesCopyType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositePlanes_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseOppositePlanes
        //
        if (n.name () == "BaseOppositePlanes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseOppositePlanes_type > r (
            BaseOppositePlanes_traits::create (i, f, this));

          if (!BaseOppositePlanes_.present ())
          {
            this->BaseOppositePlanes_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseOppositePlanes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseOppositePlanes",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesCopyType* OppositePlanesCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesCopyType (*this, f, c);
    }

    OppositePlanesCopyType& OppositePlanesCopyType::
    operator= (const OppositePlanesCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositePlanes_ = x.BaseOppositePlanes_;
      }

      return *this;
    }

    OppositePlanesCopyType::
    ~OppositePlanesCopyType ()
    {
    }

    // OppositePlanesCastType
    //

    OppositePlanesCastType::
    OppositePlanesCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    OppositePlanesCastType::
    OppositePlanesCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    OppositePlanesCastType::
    OppositePlanesCastType (const OppositePlanesCastType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    OppositePlanesCastType::
    OppositePlanesCastType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesCastType* OppositePlanesCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesCastType (*this, f, c);
    }

    OppositePlanesCastType& OppositePlanesCastType::
    operator= (const OppositePlanesCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    OppositePlanesCastType::
    ~OppositePlanesCastType ()
    {
    }

    // OppositePlanesTransformType
    //

    OppositePlanesTransformType::
    OppositePlanesTransformType (const BaseOppositePlanes_type& BaseOppositePlanes,
                                 const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositePlanes_ (BaseOppositePlanes, this),
      Transformation_ (Transformation, this)
    {
    }

    OppositePlanesTransformType::
    OppositePlanesTransformType (::std::auto_ptr< BaseOppositePlanes_type > BaseOppositePlanes,
                                 ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseOppositePlanes_ (BaseOppositePlanes, this),
      Transformation_ (Transformation, this)
    {
    }

    OppositePlanesTransformType::
    OppositePlanesTransformType (const OppositePlanesTransformType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseOppositePlanes_ (x.BaseOppositePlanes_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    OppositePlanesTransformType::
    OppositePlanesTransformType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseOppositePlanes_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseOppositePlanes
        //
        if (n.name () == "BaseOppositePlanes" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseOppositePlanes_type > r (
            BaseOppositePlanes_traits::create (i, f, this));

          if (!BaseOppositePlanes_.present ())
          {
            this->BaseOppositePlanes_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseOppositePlanes_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseOppositePlanes",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesTransformType* OppositePlanesTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesTransformType (*this, f, c);
    }

    OppositePlanesTransformType& OppositePlanesTransformType::
    operator= (const OppositePlanesTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseOppositePlanes_ = x.BaseOppositePlanes_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    OppositePlanesTransformType::
    ~OppositePlanesTransformType ()
    {
    }

    // OppositePlanesFromScanType
    //

    OppositePlanesFromScanType::
    OppositePlanesFromScanType (const SurfaceFeature_type& SurfaceFeature,
                                const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    OppositePlanesFromScanType::
    OppositePlanesFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                                ::std::auto_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    OppositePlanesFromScanType::
    OppositePlanesFromScanType (const OppositePlanesFromScanType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    OppositePlanesFromScanType::
    OppositePlanesFromScanType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesFromScanType* OppositePlanesFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesFromScanType (*this, f, c);
    }

    OppositePlanesFromScanType& OppositePlanesFromScanType::
    operator= (const OppositePlanesFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    OppositePlanesFromScanType::
    ~OppositePlanesFromScanType ()
    {
    }

    // OppositePlanesCheckedType
    //

    OppositePlanesCheckedType::
    OppositePlanesCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    OppositePlanesCheckedType::
    OppositePlanesCheckedType (const OppositePlanesCheckedType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    OppositePlanesCheckedType::
    OppositePlanesCheckedType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesCheckedType* OppositePlanesCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesCheckedType (*this, f, c);
    }

    OppositePlanesCheckedType& OppositePlanesCheckedType::
    operator= (const OppositePlanesCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    OppositePlanesCheckedType::
    ~OppositePlanesCheckedType ()
    {
    }

    // OppositePlanesCheckedFeatureType
    //

    OppositePlanesCheckedFeatureType::
    OppositePlanesCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    OppositePlanesCheckedFeatureType::
    OppositePlanesCheckedFeatureType (const OppositePlanesCheckedFeatureType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    OppositePlanesCheckedFeatureType::
    OppositePlanesCheckedFeatureType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesCheckedFeatureType* OppositePlanesCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesCheckedFeatureType (*this, f, c);
    }

    OppositePlanesCheckedFeatureType& OppositePlanesCheckedFeatureType::
    operator= (const OppositePlanesCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    OppositePlanesCheckedFeatureType::
    ~OppositePlanesCheckedFeatureType ()
    {
    }

    // OppositePlanesActualDeterminationType
    //

    OppositePlanesActualDeterminationType::
    OppositePlanesActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    OppositePlanesActualDeterminationType::
    OppositePlanesActualDeterminationType (const OppositePlanesActualDeterminationType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    OppositePlanesActualDeterminationType::
    OppositePlanesActualDeterminationType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OppositePlanesActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesActualDeterminationType* OppositePlanesActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesActualDeterminationType (*this, f, c);
    }

    OppositePlanesActualDeterminationType& OppositePlanesActualDeterminationType::
    operator= (const OppositePlanesActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    OppositePlanesActualDeterminationType::
    ~OppositePlanesActualDeterminationType ()
    {
    }

    // OppositePlanesFeatureItemType
    //

    OppositePlanesFeatureItemType::
    OppositePlanesFeatureItemType (const id_type& id,
                                   const FeatureName_type& FeatureName,
                                   const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    OppositePlanesFeatureItemType::
    OppositePlanesFeatureItemType (const id_type& id,
                                   const FeatureName_type& FeatureName,
                                   ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    OppositePlanesFeatureItemType::
    OppositePlanesFeatureItemType (const OppositePlanesFeatureItemType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    OppositePlanesFeatureItemType::
    OppositePlanesFeatureItemType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositePlanesFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesFeatureItemType* OppositePlanesFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesFeatureItemType (*this, f, c);
    }

    OppositePlanesFeatureItemType& OppositePlanesFeatureItemType::
    operator= (const OppositePlanesFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    OppositePlanesFeatureItemType::
    ~OppositePlanesFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OppositePlanesFeatureItemType >
    _xsd_OppositePlanesFeatureItemType_type_factory_init (
      "OppositePlanesFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // OppositePlanesFeatureDefinitionType
    //

    OppositePlanesFeatureDefinitionType::
    OppositePlanesFeatureDefinitionType (const id_type& id,
                                         const InternalExternal_type& InternalExternal,
                                         const Width_type& Width,
                                         const EndType_type& EndType)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (Width, this),
      Length_ (this),
      EndType_ (EndType, this),
      Depth_ (this),
      Bottom_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this)
    {
    }

    OppositePlanesFeatureDefinitionType::
    OppositePlanesFeatureDefinitionType (const id_type& id,
                                         const InternalExternal_type& InternalExternal,
                                         ::std::auto_ptr< Width_type > Width,
                                         ::std::auto_ptr< EndType_type > EndType)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Width_ (Width, this),
      Length_ (this),
      EndType_ (EndType, this),
      Depth_ (this),
      Bottom_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this)
    {
    }

    OppositePlanesFeatureDefinitionType::
    OppositePlanesFeatureDefinitionType (const OppositePlanesFeatureDefinitionType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Width_ (x.Width_, f, this),
      Length_ (x.Length_, f, this),
      EndType_ (x.EndType_, f, this),
      Depth_ (x.Depth_, f, this),
      Bottom_ (x.Bottom_, f, this),
      SingleOpenEnd_ (x.SingleOpenEnd_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      DraftAngle_ (x.DraftAngle_, f, this)
    {
    }

    OppositePlanesFeatureDefinitionType::
    OppositePlanesFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Width_ (this),
      Length_ (this),
      EndType_ (this),
      Depth_ (this),
      Bottom_ (this),
      SingleOpenEnd_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositePlanesFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!Width_.present ())
          {
            this->Width_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // EndType
        //
        if (n.name () == "EndType" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndType_type > r (
            EndType_traits::create (i, f, this));

          if (!EndType_.present ())
          {
            this->EndType_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (r);
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == "Bottom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (r);
            continue;
          }
        }

        // SingleOpenEnd
        //
        if (n.name () == "SingleOpenEnd" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!this->SingleOpenEnd_)
          {
            this->SingleOpenEnd_.set (SingleOpenEnd_traits::create (i, f, this));
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == "EndRadius1" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (r);
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == "EndRadius2" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (r);
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == "TaperAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!this->TaperAngle_)
          {
            this->TaperAngle_.set (r);
            continue;
          }
        }

        // DraftAngle
        //
        if (n.name () == "DraftAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DraftAngle_type > r (
            DraftAngle_traits::create (i, f, this));

          if (!this->DraftAngle_)
          {
            this->DraftAngle_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Width_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Width",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!EndType_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "EndType",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesFeatureDefinitionType* OppositePlanesFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesFeatureDefinitionType (*this, f, c);
    }

    OppositePlanesFeatureDefinitionType& OppositePlanesFeatureDefinitionType::
    operator= (const OppositePlanesFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Width_ = x.Width_;
        this->Length_ = x.Length_;
        this->EndType_ = x.EndType_;
        this->Depth_ = x.Depth_;
        this->Bottom_ = x.Bottom_;
        this->SingleOpenEnd_ = x.SingleOpenEnd_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
        this->TaperAngle_ = x.TaperAngle_;
        this->DraftAngle_ = x.DraftAngle_;
      }

      return *this;
    }

    OppositePlanesFeatureDefinitionType::
    ~OppositePlanesFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OppositePlanesFeatureDefinitionType >
    _xsd_OppositePlanesFeatureDefinitionType_type_factory_init (
      "OppositePlanesFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // OppositePlanesFeatureNominalType
    //

    OppositePlanesFeatureNominalType::
    OppositePlanesFeatureNominalType (const id_type& id,
                                      const FeatureDefinitionId_type& FeatureDefinitionId,
                                      const CenterPlane_type& CenterPlane)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterPlane_ (CenterPlane, this),
      LengthVector_ (this),
      DepthVector_ (this),
      DraftVector_ (this)
    {
    }

    OppositePlanesFeatureNominalType::
    OppositePlanesFeatureNominalType (const id_type& id,
                                      const FeatureDefinitionId_type& FeatureDefinitionId,
                                      ::std::auto_ptr< CenterPlane_type > CenterPlane)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      CenterPlane_ (CenterPlane, this),
      LengthVector_ (this),
      DepthVector_ (this),
      DraftVector_ (this)
    {
    }

    OppositePlanesFeatureNominalType::
    OppositePlanesFeatureNominalType (const OppositePlanesFeatureNominalType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      CenterPlane_ (x.CenterPlane_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      DraftVector_ (x.DraftVector_, f, this)
    {
    }

    OppositePlanesFeatureNominalType::
    OppositePlanesFeatureNominalType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      DraftVector_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositePlanesFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterPlane
        //
        if (n.name () == "CenterPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!CenterPlane_.present ())
          {
            this->CenterPlane_.set (r);
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == "LengthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!this->LengthVector_)
          {
            this->LengthVector_.set (r);
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == "DepthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!this->DepthVector_)
          {
            this->DepthVector_.set (r);
            continue;
          }
        }

        // DraftVector
        //
        if (n.name () == "DraftVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DraftVector_type > r (
            DraftVector_traits::create (i, f, this));

          if (!this->DraftVector_)
          {
            this->DraftVector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CenterPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CenterPlane",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    OppositePlanesFeatureNominalType* OppositePlanesFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesFeatureNominalType (*this, f, c);
    }

    OppositePlanesFeatureNominalType& OppositePlanesFeatureNominalType::
    operator= (const OppositePlanesFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->CenterPlane_ = x.CenterPlane_;
        this->LengthVector_ = x.LengthVector_;
        this->DepthVector_ = x.DepthVector_;
        this->DraftVector_ = x.DraftVector_;
      }

      return *this;
    }

    OppositePlanesFeatureNominalType::
    ~OppositePlanesFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OppositePlanesFeatureNominalType >
    _xsd_OppositePlanesFeatureNominalType_type_factory_init (
      "OppositePlanesFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // OppositePlanesFeatureActualType
    //

    OppositePlanesFeatureActualType::
    OppositePlanesFeatureActualType (const id_type& id,
                                     const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      Depth_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositePlanesFeatureActualType::
    OppositePlanesFeatureActualType (const id_type& id,
                                     ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      Depth_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
    }

    OppositePlanesFeatureActualType::
    OppositePlanesFeatureActualType (const OppositePlanesFeatureActualType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      CenterPlane_ (x.CenterPlane_, f, this),
      LengthVector_ (x.LengthVector_, f, this),
      DepthVector_ (x.DepthVector_, f, this),
      Width_ (x.Width_, f, this),
      WidthMin_ (x.WidthMin_, f, this),
      WidthMax_ (x.WidthMax_, f, this),
      Length_ (x.Length_, f, this),
      LengthMin_ (x.LengthMin_, f, this),
      LengthMax_ (x.LengthMax_, f, this),
      Depth_ (x.Depth_, f, this),
      TaperAngle_ (x.TaperAngle_, f, this),
      DraftAngle_ (x.DraftAngle_, f, this),
      EndRadius1_ (x.EndRadius1_, f, this),
      EndRadius2_ (x.EndRadius2_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    OppositePlanesFeatureActualType::
    OppositePlanesFeatureActualType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      CenterPlane_ (this),
      LengthVector_ (this),
      DepthVector_ (this),
      Width_ (this),
      WidthMin_ (this),
      WidthMax_ (this),
      Length_ (this),
      LengthMin_ (this),
      LengthMax_ (this),
      Depth_ (this),
      TaperAngle_ (this),
      DraftAngle_ (this),
      EndRadius1_ (this),
      EndRadius2_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void OppositePlanesFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CenterPlane
        //
        if (n.name () == "CenterPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterPlane_type > r (
            CenterPlane_traits::create (i, f, this));

          if (!this->CenterPlane_)
          {
            this->CenterPlane_.set (r);
            continue;
          }
        }

        // LengthVector
        //
        if (n.name () == "LengthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthVector_type > r (
            LengthVector_traits::create (i, f, this));

          if (!this->LengthVector_)
          {
            this->LengthVector_.set (r);
            continue;
          }
        }

        // DepthVector
        //
        if (n.name () == "DepthVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DepthVector_type > r (
            DepthVector_traits::create (i, f, this));

          if (!this->DepthVector_)
          {
            this->DepthVector_.set (r);
            continue;
          }
        }

        // Width
        //
        if (n.name () == "Width" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Width_type > r (
            Width_traits::create (i, f, this));

          if (!this->Width_)
          {
            this->Width_.set (r);
            continue;
          }
        }

        // WidthMin
        //
        if (n.name () == "WidthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMin_type > r (
            WidthMin_traits::create (i, f, this));

          if (!this->WidthMin_)
          {
            this->WidthMin_.set (r);
            continue;
          }
        }

        // WidthMax
        //
        if (n.name () == "WidthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< WidthMax_type > r (
            WidthMax_traits::create (i, f, this));

          if (!this->WidthMax_)
          {
            this->WidthMax_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // LengthMin
        //
        if (n.name () == "LengthMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMin_type > r (
            LengthMin_traits::create (i, f, this));

          if (!this->LengthMin_)
          {
            this->LengthMin_.set (r);
            continue;
          }
        }

        // LengthMax
        //
        if (n.name () == "LengthMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LengthMax_type > r (
            LengthMax_traits::create (i, f, this));

          if (!this->LengthMax_)
          {
            this->LengthMax_.set (r);
            continue;
          }
        }

        // Depth
        //
        if (n.name () == "Depth" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Depth_type > r (
            Depth_traits::create (i, f, this));

          if (!this->Depth_)
          {
            this->Depth_.set (r);
            continue;
          }
        }

        // TaperAngle
        //
        if (n.name () == "TaperAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TaperAngle_type > r (
            TaperAngle_traits::create (i, f, this));

          if (!this->TaperAngle_)
          {
            this->TaperAngle_.set (r);
            continue;
          }
        }

        // DraftAngle
        //
        if (n.name () == "DraftAngle" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DraftAngle_type > r (
            DraftAngle_traits::create (i, f, this));

          if (!this->DraftAngle_)
          {
            this->DraftAngle_.set (r);
            continue;
          }
        }

        // EndRadius1
        //
        if (n.name () == "EndRadius1" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius1_type > r (
            EndRadius1_traits::create (i, f, this));

          if (!this->EndRadius1_)
          {
            this->EndRadius1_.set (r);
            continue;
          }
        }

        // EndRadius2
        //
        if (n.name () == "EndRadius2" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< EndRadius2_type > r (
            EndRadius2_traits::create (i, f, this));

          if (!this->EndRadius2_)
          {
            this->EndRadius2_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    OppositePlanesFeatureActualType* OppositePlanesFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OppositePlanesFeatureActualType (*this, f, c);
    }

    OppositePlanesFeatureActualType& OppositePlanesFeatureActualType::
    operator= (const OppositePlanesFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->CenterPlane_ = x.CenterPlane_;
        this->LengthVector_ = x.LengthVector_;
        this->DepthVector_ = x.DepthVector_;
        this->Width_ = x.Width_;
        this->WidthMin_ = x.WidthMin_;
        this->WidthMax_ = x.WidthMax_;
        this->Length_ = x.Length_;
        this->LengthMin_ = x.LengthMin_;
        this->LengthMax_ = x.LengthMax_;
        this->Depth_ = x.Depth_;
        this->TaperAngle_ = x.TaperAngle_;
        this->DraftAngle_ = x.DraftAngle_;
        this->EndRadius1_ = x.EndRadius1_;
        this->EndRadius2_ = x.EndRadius2_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    OppositePlanesFeatureActualType::
    ~OppositePlanesFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OppositePlanesFeatureActualType >
    _xsd_OppositePlanesFeatureActualType_type_factory_init (
      "OppositePlanesFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // PlaneConstructionMethodType
    //

    PlaneConstructionMethodType::
    PlaneConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Midplane_ (this),
      Offset_ (this),
      Perpendicular_ (this),
      Parallel_ (this),
      Copy_ (this),
      Cast_ (this),
      TangentThrough_ (this),
      Transform_ (this),
      Extract_ (this)
    {
    }

    PlaneConstructionMethodType::
    PlaneConstructionMethodType (const PlaneConstructionMethodType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Midplane_ (x.Midplane_, f, this),
      Offset_ (x.Offset_, f, this),
      Perpendicular_ (x.Perpendicular_, f, this),
      Parallel_ (x.Parallel_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      TangentThrough_ (x.TangentThrough_, f, this),
      Transform_ (x.Transform_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    PlaneConstructionMethodType::
    PlaneConstructionMethodType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Midplane_ (this),
      Offset_ (this),
      Perpendicular_ (this),
      Parallel_ (this),
      Copy_ (this),
      Cast_ (this),
      TangentThrough_ (this),
      Transform_ (this),
      Extract_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Midplane
        //
        if (n.name () == "Midplane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Midplane_type > r (
            Midplane_traits::create (i, f, this));

          if (!this->Midplane_)
          {
            this->Midplane_.set (r);
            continue;
          }
        }

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!this->Offset_)
          {
            this->Offset_.set (r);
            continue;
          }
        }

        // Perpendicular
        //
        if (n.name () == "Perpendicular" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Perpendicular_type > r (
            Perpendicular_traits::create (i, f, this));

          if (!this->Perpendicular_)
          {
            this->Perpendicular_.set (r);
            continue;
          }
        }

        // Parallel
        //
        if (n.name () == "Parallel" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Parallel_type > r (
            Parallel_traits::create (i, f, this));

          if (!this->Parallel_)
          {
            this->Parallel_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // TangentThrough
        //
        if (n.name () == "TangentThrough" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentThrough_type > r (
            TangentThrough_traits::create (i, f, this));

          if (!this->TangentThrough_)
          {
            this->TangentThrough_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // Extract
        //
        if (n.name () == "Extract" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlaneConstructionMethodType* PlaneConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneConstructionMethodType (*this, f, c);
    }

    PlaneConstructionMethodType& PlaneConstructionMethodType::
    operator= (const PlaneConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Midplane_ = x.Midplane_;
        this->Offset_ = x.Offset_;
        this->Perpendicular_ = x.Perpendicular_;
        this->Parallel_ = x.Parallel_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->TangentThrough_ = x.TangentThrough_;
        this->Transform_ = x.Transform_;
        this->Extract_ = x.Extract_;
      }

      return *this;
    }

    PlaneConstructionMethodType::
    ~PlaneConstructionMethodType ()
    {
    }

    // PlaneBestFitType
    //

    PlaneBestFitType::
    PlaneBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    PlaneBestFitType::
    PlaneBestFitType (const PlaneBestFitType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PlaneBestFitType::
    PlaneBestFitType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PlaneBestFitType* PlaneBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneBestFitType (*this, f, c);
    }

    PlaneBestFitType& PlaneBestFitType::
    operator= (const PlaneBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    PlaneBestFitType::
    ~PlaneBestFitType ()
    {
    }

    // PlaneRecompType
    //

    PlaneRecompType::
    PlaneRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    PlaneRecompType::
    PlaneRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    PlaneRecompType::
    PlaneRecompType (const PlaneRecompType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    PlaneRecompType::
    PlaneRecompType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneRecompType* PlaneRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneRecompType (*this, f, c);
    }

    PlaneRecompType& PlaneRecompType::
    operator= (const PlaneRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    PlaneRecompType::
    ~PlaneRecompType ()
    {
    }

    // PlaneMidplaneType
    //

    PlaneMidplaneType::
    PlaneMidplaneType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (this)
    {
    }

    PlaneMidplaneType::
    PlaneMidplaneType (const PlaneMidplaneType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this)
    {
    }

    PlaneMidplaneType::
    PlaneMidplaneType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneMidplaneType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePlane
        //
        if (n.name () == "BasePlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          this->BasePlane_.push_back (r);
          continue;
        }

        break;
      }
    }

    PlaneMidplaneType* PlaneMidplaneType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneMidplaneType (*this, f, c);
    }

    PlaneMidplaneType& PlaneMidplaneType::
    operator= (const PlaneMidplaneType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BasePlane_ = x.BasePlane_;
      }

      return *this;
    }

    PlaneMidplaneType::
    ~PlaneMidplaneType ()
    {
    }

    // PlaneOffsetType
    //

    PlaneOffsetType::
    PlaneOffsetType (const BasePlane_type& BasePlane,
                     const Offset_type& Offset)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, this),
      Offset_ (Offset, this)
    {
    }

    PlaneOffsetType::
    PlaneOffsetType (::std::auto_ptr< BasePlane_type > BasePlane,
                     ::std::auto_ptr< Offset_type > Offset)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, this),
      Offset_ (Offset, this)
    {
    }

    PlaneOffsetType::
    PlaneOffsetType (const PlaneOffsetType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this),
      Offset_ (x.Offset_, f, this)
    {
    }

    PlaneOffsetType::
    PlaneOffsetType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (this),
      Offset_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneOffsetType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePlane
        //
        if (n.name () == "BasePlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          if (!BasePlane_.present ())
          {
            this->BasePlane_.set (r);
            continue;
          }
        }

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!Offset_.present ())
          {
            this->Offset_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Offset_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Offset",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneOffsetType* PlaneOffsetType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneOffsetType (*this, f, c);
    }

    PlaneOffsetType& PlaneOffsetType::
    operator= (const PlaneOffsetType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BasePlane_ = x.BasePlane_;
        this->Offset_ = x.Offset_;
      }

      return *this;
    }

    PlaneOffsetType::
    ~PlaneOffsetType ()
    {
    }

    // PlanePerpendicularType
    //

    PlanePerpendicularType::
    PlanePerpendicularType (const PerpendicularFeature_type& PerpendicularFeature,
                            const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      PerpendicularFeature_ (PerpendicularFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    PlanePerpendicularType::
    PlanePerpendicularType (::std::auto_ptr< PerpendicularFeature_type > PerpendicularFeature,
                            ::std::auto_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      PerpendicularFeature_ (PerpendicularFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    PlanePerpendicularType::
    PlanePerpendicularType (const PlanePerpendicularType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      PerpendicularFeature_ (x.PerpendicularFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    PlanePerpendicularType::
    PlanePerpendicularType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      PerpendicularFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlanePerpendicularType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // PerpendicularFeature
        //
        if (n.name () == "PerpendicularFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PerpendicularFeature_type > r (
            PerpendicularFeature_traits::create (i, f, this));

          if (!PerpendicularFeature_.present ())
          {
            this->PerpendicularFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!PerpendicularFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PerpendicularFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlanePerpendicularType* PlanePerpendicularType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlanePerpendicularType (*this, f, c);
    }

    PlanePerpendicularType& PlanePerpendicularType::
    operator= (const PlanePerpendicularType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->PerpendicularFeature_ = x.PerpendicularFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    PlanePerpendicularType::
    ~PlanePerpendicularType ()
    {
    }

    // PlaneParallelType
    //

    PlaneParallelType::
    PlaneParallelType (const ParallelFeature_type& ParallelFeature,
                       const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ParallelFeature_ (ParallelFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    PlaneParallelType::
    PlaneParallelType (::std::auto_ptr< ParallelFeature_type > ParallelFeature,
                       ::std::auto_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ParallelFeature_ (ParallelFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    PlaneParallelType::
    PlaneParallelType (const PlaneParallelType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ParallelFeature_ (x.ParallelFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    PlaneParallelType::
    PlaneParallelType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ParallelFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneParallelType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ParallelFeature
        //
        if (n.name () == "ParallelFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ParallelFeature_type > r (
            ParallelFeature_traits::create (i, f, this));

          if (!ParallelFeature_.present ())
          {
            this->ParallelFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ParallelFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ParallelFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneParallelType* PlaneParallelType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneParallelType (*this, f, c);
    }

    PlaneParallelType& PlaneParallelType::
    operator= (const PlaneParallelType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->ParallelFeature_ = x.ParallelFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    PlaneParallelType::
    ~PlaneParallelType ()
    {
    }

    // PlaneCopyType
    //

    PlaneCopyType::
    PlaneCopyType (const BasePlane_type& BasePlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, this)
    {
    }

    PlaneCopyType::
    PlaneCopyType (::std::auto_ptr< BasePlane_type > BasePlane)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, this)
    {
    }

    PlaneCopyType::
    PlaneCopyType (const PlaneCopyType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this)
    {
    }

    PlaneCopyType::
    PlaneCopyType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePlane
        //
        if (n.name () == "BasePlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          if (!BasePlane_.present ())
          {
            this->BasePlane_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePlane",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneCopyType* PlaneCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCopyType (*this, f, c);
    }

    PlaneCopyType& PlaneCopyType::
    operator= (const PlaneCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BasePlane_ = x.BasePlane_;
      }

      return *this;
    }

    PlaneCopyType::
    ~PlaneCopyType ()
    {
    }

    // PlaneCastType
    //

    PlaneCastType::
    PlaneCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    PlaneCastType::
    PlaneCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    PlaneCastType::
    PlaneCastType (const PlaneCastType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PlaneCastType::
    PlaneCastType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneCastType* PlaneCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCastType (*this, f, c);
    }

    PlaneCastType& PlaneCastType::
    operator= (const PlaneCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    PlaneCastType::
    ~PlaneCastType ()
    {
    }

    // PlaneTangentThroughType
    //

    PlaneTangentThroughType::
    PlaneTangentThroughType (const TangentFeature_type& TangentFeature,
                             const PointFeature_type& PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    PlaneTangentThroughType::
    PlaneTangentThroughType (::std::auto_ptr< TangentFeature_type > TangentFeature,
                             ::std::auto_ptr< PointFeature_type > PointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      TangentFeature_ (TangentFeature, this),
      PointFeature_ (PointFeature, this)
    {
    }

    PlaneTangentThroughType::
    PlaneTangentThroughType (const PlaneTangentThroughType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      TangentFeature_ (x.TangentFeature_, f, this),
      PointFeature_ (x.PointFeature_, f, this)
    {
    }

    PlaneTangentThroughType::
    PlaneTangentThroughType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      TangentFeature_ (this),
      PointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneTangentThroughType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TangentFeature
        //
        if (n.name () == "TangentFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TangentFeature_type > r (
            TangentFeature_traits::create (i, f, this));

          if (!TangentFeature_.present ())
          {
            this->TangentFeature_.set (r);
            continue;
          }
        }

        // PointFeature
        //
        if (n.name () == "PointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PointFeature_type > r (
            PointFeature_traits::create (i, f, this));

          if (!PointFeature_.present ())
          {
            this->PointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!TangentFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "TangentFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!PointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "PointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneTangentThroughType* PlaneTangentThroughType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneTangentThroughType (*this, f, c);
    }

    PlaneTangentThroughType& PlaneTangentThroughType::
    operator= (const PlaneTangentThroughType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->TangentFeature_ = x.TangentFeature_;
        this->PointFeature_ = x.PointFeature_;
      }

      return *this;
    }

    PlaneTangentThroughType::
    ~PlaneTangentThroughType ()
    {
    }

    // PlaneTransformType
    //

    PlaneTransformType::
    PlaneTransformType (const BasePlane_type& BasePlane,
                        const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, this),
      Transformation_ (Transformation, this)
    {
    }

    PlaneTransformType::
    PlaneTransformType (::std::auto_ptr< BasePlane_type > BasePlane,
                        ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePlane_ (BasePlane, this),
      Transformation_ (Transformation, this)
    {
    }

    PlaneTransformType::
    PlaneTransformType (const PlaneTransformType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePlane_ (x.BasePlane_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PlaneTransformType::
    PlaneTransformType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePlane_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePlane
        //
        if (n.name () == "BasePlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePlane_type > r (
            BasePlane_traits::create (i, f, this));

          if (!BasePlane_.present ())
          {
            this->BasePlane_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneTransformType* PlaneTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneTransformType (*this, f, c);
    }

    PlaneTransformType& PlaneTransformType::
    operator= (const PlaneTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BasePlane_ = x.BasePlane_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    PlaneTransformType::
    ~PlaneTransformType ()
    {
    }

    // PlaneExtractType
    //

    PlaneExtractType::
    PlaneExtractType (const SurfaceFeature_type& SurfaceFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this)
    {
    }

    PlaneExtractType::
    PlaneExtractType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this)
    {
    }

    PlaneExtractType::
    PlaneExtractType (const PlaneExtractType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this)
    {
    }

    PlaneExtractType::
    PlaneExtractType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneExtractType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneExtractType* PlaneExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneExtractType (*this, f, c);
    }

    PlaneExtractType& PlaneExtractType::
    operator= (const PlaneExtractType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
      }

      return *this;
    }

    PlaneExtractType::
    ~PlaneExtractType ()
    {
    }

    // PlaneCheckedType
    //

    PlaneCheckedType::
    PlaneCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    PlaneCheckedType::
    PlaneCheckedType (const PlaneCheckedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PlaneCheckedType::
    PlaneCheckedType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlaneCheckedType* PlaneCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCheckedType (*this, f, c);
    }

    PlaneCheckedType& PlaneCheckedType::
    operator= (const PlaneCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PlaneCheckedType::
    ~PlaneCheckedType ()
    {
    }

    // PlaneCheckedFeatureType
    //

    PlaneCheckedFeatureType::
    PlaneCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    PlaneCheckedFeatureType::
    PlaneCheckedFeatureType (const PlaneCheckedFeatureType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PlaneCheckedFeatureType::
    PlaneCheckedFeatureType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlaneCheckedFeatureType* PlaneCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneCheckedFeatureType (*this, f, c);
    }

    PlaneCheckedFeatureType& PlaneCheckedFeatureType::
    operator= (const PlaneCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    PlaneCheckedFeatureType::
    ~PlaneCheckedFeatureType ()
    {
    }

    // PlaneActualDeterminationType
    //

    PlaneActualDeterminationType::
    PlaneActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    PlaneActualDeterminationType::
    PlaneActualDeterminationType (const PlaneActualDeterminationType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PlaneActualDeterminationType::
    PlaneActualDeterminationType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PlaneActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlaneActualDeterminationType* PlaneActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneActualDeterminationType (*this, f, c);
    }

    PlaneActualDeterminationType& PlaneActualDeterminationType::
    operator= (const PlaneActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    PlaneActualDeterminationType::
    ~PlaneActualDeterminationType ()
    {
    }

    // PlaneFeatureItemType
    //

    PlaneFeatureItemType::
    PlaneFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    PlaneFeatureItemType::
    PlaneFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    PlaneFeatureItemType::
    PlaneFeatureItemType (const PlaneFeatureItemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    PlaneFeatureItemType::
    PlaneFeatureItemType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PlaneFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneFeatureItemType* PlaneFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureItemType (*this, f, c);
    }

    PlaneFeatureItemType& PlaneFeatureItemType::
    operator= (const PlaneFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    PlaneFeatureItemType::
    ~PlaneFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PlaneFeatureItemType >
    _xsd_PlaneFeatureItemType_type_factory_init (
      "PlaneFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // PlaneFeatureDefinitionType
    //

    PlaneFeatureDefinitionType::
    PlaneFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    PlaneFeatureDefinitionType::
    PlaneFeatureDefinitionType (const PlaneFeatureDefinitionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    PlaneFeatureDefinitionType::
    PlaneFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    PlaneFeatureDefinitionType* PlaneFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureDefinitionType (*this, f, c);
    }

    PlaneFeatureDefinitionType::
    ~PlaneFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PlaneFeatureDefinitionType >
    _xsd_PlaneFeatureDefinitionType_type_factory_init (
      "PlaneFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // PlaneFeatureNominalType
    //

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             const Location_type& Location,
                             const Normal_type& Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (Normal, this),
      PolyLine_ (this)
    {
    }

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             ::std::auto_ptr< Location_type > Location,
                             ::std::auto_ptr< Normal_type > Normal)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (Normal, this),
      PolyLine_ (this)
    {
    }

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const PlaneFeatureNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      PolyLine_ (x.PolyLine_, f, this)
    {
    }

    PlaneFeatureNominalType::
    PlaneFeatureNominalType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      PolyLine_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PlaneFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!Normal_.present ())
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // PolyLine
        //
        if (n.name () == "PolyLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PolyLine_type > r (
            PolyLine_traits::create (i, f, this));

          if (!this->PolyLine_)
          {
            this->PolyLine_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Normal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Normal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PlaneFeatureNominalType* PlaneFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureNominalType (*this, f, c);
    }

    PlaneFeatureNominalType& PlaneFeatureNominalType::
    operator= (const PlaneFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->PolyLine_ = x.PolyLine_;
      }

      return *this;
    }

    PlaneFeatureNominalType::
    ~PlaneFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PlaneFeatureNominalType >
    _xsd_PlaneFeatureNominalType_type_factory_init (
      "PlaneFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // PlaneFeatureActualType
    //

    PlaneFeatureActualType::
    PlaneFeatureActualType (const id_type& id,
                            const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Normal_ (this),
      PolyLine_ (this),
      Form_ (this)
    {
    }

    PlaneFeatureActualType::
    PlaneFeatureActualType (const id_type& id,
                            ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Normal_ (this),
      PolyLine_ (this),
      Form_ (this)
    {
    }

    PlaneFeatureActualType::
    PlaneFeatureActualType (const PlaneFeatureActualType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this),
      PolyLine_ (x.PolyLine_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    PlaneFeatureActualType::
    PlaneFeatureActualType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this),
      PolyLine_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PlaneFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        // PolyLine
        //
        if (n.name () == "PolyLine" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PolyLine_type > r (
            PolyLine_traits::create (i, f, this));

          if (!this->PolyLine_)
          {
            this->PolyLine_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PlaneFeatureActualType* PlaneFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlaneFeatureActualType (*this, f, c);
    }

    PlaneFeatureActualType& PlaneFeatureActualType::
    operator= (const PlaneFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
        this->PolyLine_ = x.PolyLine_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    PlaneFeatureActualType::
    ~PlaneFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PlaneFeatureActualType >
    _xsd_PlaneFeatureActualType_type_factory_init (
      "PlaneFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // PointDefinedCurveConstructionMethodType
    //

    PointDefinedCurveConstructionMethodType::
    PointDefinedCurveConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Transform_ (this),
      FromScan_ (this),
      Extract_ (this)
    {
    }

    PointDefinedCurveConstructionMethodType::
    PointDefinedCurveConstructionMethodType (const PointDefinedCurveConstructionMethodType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    PointDefinedCurveConstructionMethodType::
    PointDefinedCurveConstructionMethodType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Transform_ (this),
      FromScan_ (this),
      Extract_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        // Extract
        //
        if (n.name () == "Extract" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveConstructionMethodType* PointDefinedCurveConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveConstructionMethodType (*this, f, c);
    }

    PointDefinedCurveConstructionMethodType& PointDefinedCurveConstructionMethodType::
    operator= (const PointDefinedCurveConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
        this->Extract_ = x.Extract_;
      }

      return *this;
    }

    PointDefinedCurveConstructionMethodType::
    ~PointDefinedCurveConstructionMethodType ()
    {
    }

    // PointDefinedCurveBestFitType
    //

    PointDefinedCurveBestFitType::
    PointDefinedCurveBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    PointDefinedCurveBestFitType::
    PointDefinedCurveBestFitType (const PointDefinedCurveBestFitType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointDefinedCurveBestFitType::
    PointDefinedCurveBestFitType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PointDefinedCurveBestFitType* PointDefinedCurveBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveBestFitType (*this, f, c);
    }

    PointDefinedCurveBestFitType& PointDefinedCurveBestFitType::
    operator= (const PointDefinedCurveBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    PointDefinedCurveBestFitType::
    ~PointDefinedCurveBestFitType ()
    {
    }

    // PointDefinedCurveRecompType
    //

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (const PointDefinedCurveRecompType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    PointDefinedCurveRecompType::
    PointDefinedCurveRecompType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveRecompType* PointDefinedCurveRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveRecompType (*this, f, c);
    }

    PointDefinedCurveRecompType& PointDefinedCurveRecompType::
    operator= (const PointDefinedCurveRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    PointDefinedCurveRecompType::
    ~PointDefinedCurveRecompType ()
    {
    }

    // PointDefinedCurveCopyType
    //

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (const BasePointDefinedCurve_type& BasePointDefinedCurve)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (BasePointDefinedCurve, this)
    {
    }

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (::std::auto_ptr< BasePointDefinedCurve_type > BasePointDefinedCurve)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (BasePointDefinedCurve, this)
    {
    }

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (const PointDefinedCurveCopyType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedCurve_ (x.BasePointDefinedCurve_, f, this)
    {
    }

    PointDefinedCurveCopyType::
    PointDefinedCurveCopyType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedCurve_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointDefinedCurve
        //
        if (n.name () == "BasePointDefinedCurve" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointDefinedCurve_type > r (
            BasePointDefinedCurve_traits::create (i, f, this));

          if (!BasePointDefinedCurve_.present ())
          {
            this->BasePointDefinedCurve_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedCurve_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointDefinedCurve",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveCopyType* PointDefinedCurveCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveCopyType (*this, f, c);
    }

    PointDefinedCurveCopyType& PointDefinedCurveCopyType::
    operator= (const PointDefinedCurveCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointDefinedCurve_ = x.BasePointDefinedCurve_;
      }

      return *this;
    }

    PointDefinedCurveCopyType::
    ~PointDefinedCurveCopyType ()
    {
    }

    // PointDefinedCurveTransformType
    //

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (const BasePointDefinedCurve_type& BasePointDefinedCurve,
                                    const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (BasePointDefinedCurve, this),
      Transformation_ (Transformation, this)
    {
    }

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (::std::auto_ptr< BasePointDefinedCurve_type > BasePointDefinedCurve,
                                    ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedCurve_ (BasePointDefinedCurve, this),
      Transformation_ (Transformation, this)
    {
    }

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (const PointDefinedCurveTransformType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedCurve_ (x.BasePointDefinedCurve_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PointDefinedCurveTransformType::
    PointDefinedCurveTransformType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedCurve_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointDefinedCurve
        //
        if (n.name () == "BasePointDefinedCurve" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointDefinedCurve_type > r (
            BasePointDefinedCurve_traits::create (i, f, this));

          if (!BasePointDefinedCurve_.present ())
          {
            this->BasePointDefinedCurve_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedCurve_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointDefinedCurve",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveTransformType* PointDefinedCurveTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveTransformType (*this, f, c);
    }

    PointDefinedCurveTransformType& PointDefinedCurveTransformType::
    operator= (const PointDefinedCurveTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointDefinedCurve_ = x.BasePointDefinedCurve_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    PointDefinedCurveTransformType::
    ~PointDefinedCurveTransformType ()
    {
    }

    // PointDefinedCurveFromScanType
    //

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (const SurfaceFeature_type& SurfaceFeature,
                                   const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                                   ::std::auto_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (const PointDefinedCurveFromScanType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    PointDefinedCurveFromScanType::
    PointDefinedCurveFromScanType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveFromScanType* PointDefinedCurveFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFromScanType (*this, f, c);
    }

    PointDefinedCurveFromScanType& PointDefinedCurveFromScanType::
    operator= (const PointDefinedCurveFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    PointDefinedCurveFromScanType::
    ~PointDefinedCurveFromScanType ()
    {
    }

    // PointDefinedCurveExtractType
    //

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (const CurveFeature_type& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, this)
    {
    }

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (::std::auto_ptr< CurveFeature_type > CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      CurveFeature_ (CurveFeature, this)
    {
    }

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (const PointDefinedCurveExtractType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    PointDefinedCurveExtractType::
    PointDefinedCurveExtractType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      CurveFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveExtractType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CurveFeature
        //
        if (n.name () == "CurveFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CurveFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveExtractType* PointDefinedCurveExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveExtractType (*this, f, c);
    }

    PointDefinedCurveExtractType& PointDefinedCurveExtractType::
    operator= (const PointDefinedCurveExtractType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->CurveFeature_ = x.CurveFeature_;
      }

      return *this;
    }

    PointDefinedCurveExtractType::
    ~PointDefinedCurveExtractType ()
    {
    }

    // PointDefinedCurveCheckedType
    //

    PointDefinedCurveCheckedType::
    PointDefinedCurveCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    PointDefinedCurveCheckedType::
    PointDefinedCurveCheckedType (const PointDefinedCurveCheckedType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointDefinedCurveCheckedType::
    PointDefinedCurveCheckedType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveCheckedType* PointDefinedCurveCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveCheckedType (*this, f, c);
    }

    PointDefinedCurveCheckedType& PointDefinedCurveCheckedType::
    operator= (const PointDefinedCurveCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PointDefinedCurveCheckedType::
    ~PointDefinedCurveCheckedType ()
    {
    }

    // PointDefinedCurveCheckedFeatureType
    //

    PointDefinedCurveCheckedFeatureType::
    PointDefinedCurveCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    PointDefinedCurveCheckedFeatureType::
    PointDefinedCurveCheckedFeatureType (const PointDefinedCurveCheckedFeatureType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PointDefinedCurveCheckedFeatureType::
    PointDefinedCurveCheckedFeatureType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveCheckedFeatureType* PointDefinedCurveCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveCheckedFeatureType (*this, f, c);
    }

    PointDefinedCurveCheckedFeatureType& PointDefinedCurveCheckedFeatureType::
    operator= (const PointDefinedCurveCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    PointDefinedCurveCheckedFeatureType::
    ~PointDefinedCurveCheckedFeatureType ()
    {
    }

    // PointDefinedCurveActualDeterminationType
    //

    PointDefinedCurveActualDeterminationType::
    PointDefinedCurveActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    PointDefinedCurveActualDeterminationType::
    PointDefinedCurveActualDeterminationType (const PointDefinedCurveActualDeterminationType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PointDefinedCurveActualDeterminationType::
    PointDefinedCurveActualDeterminationType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveActualDeterminationType* PointDefinedCurveActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveActualDeterminationType (*this, f, c);
    }

    PointDefinedCurveActualDeterminationType& PointDefinedCurveActualDeterminationType::
    operator= (const PointDefinedCurveActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    PointDefinedCurveActualDeterminationType::
    ~PointDefinedCurveActualDeterminationType ()
    {
    }

    // PointDefinedCurveFeatureItemType
    //

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const id_type& id,
                                      const FeatureName_type& FeatureName,
                                      const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const id_type& id,
                                      const FeatureName_type& FeatureName,
                                      ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const PointDefinedCurveFeatureItemType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    PointDefinedCurveFeatureItemType::
    PointDefinedCurveFeatureItemType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveFeatureItemType* PointDefinedCurveFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureItemType (*this, f, c);
    }

    PointDefinedCurveFeatureItemType& PointDefinedCurveFeatureItemType::
    operator= (const PointDefinedCurveFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    PointDefinedCurveFeatureItemType::
    ~PointDefinedCurveFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointDefinedCurveFeatureItemType >
    _xsd_PointDefinedCurveFeatureItemType_type_factory_init (
      "PointDefinedCurveFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // PointDefinedCurveFeatureDefinitionType
    //

    PointDefinedCurveFeatureDefinitionType::
    PointDefinedCurveFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    PointDefinedCurveFeatureDefinitionType::
    PointDefinedCurveFeatureDefinitionType (const PointDefinedCurveFeatureDefinitionType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    PointDefinedCurveFeatureDefinitionType::
    PointDefinedCurveFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    PointDefinedCurveFeatureDefinitionType* PointDefinedCurveFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureDefinitionType (*this, f, c);
    }

    PointDefinedCurveFeatureDefinitionType::
    ~PointDefinedCurveFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointDefinedCurveFeatureDefinitionType >
    _xsd_PointDefinedCurveFeatureDefinitionType_type_factory_init (
      "PointDefinedCurveFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // PointDefinedCurveFeatureNominalType
    //

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const id_type& id,
                                         const FeatureDefinitionId_type& FeatureDefinitionId,
                                         const DefiningPoints_type& DefiningPoints)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      DefiningPoints_ (DefiningPoints, this),
      Plane_ (this)
    {
    }

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const id_type& id,
                                         const FeatureDefinitionId_type& FeatureDefinitionId,
                                         ::std::auto_ptr< DefiningPoints_type > DefiningPoints)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      DefiningPoints_ (DefiningPoints, this),
      Plane_ (this)
    {
    }

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const PointDefinedCurveFeatureNominalType& x,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this),
      Plane_ (x.Plane_, f, this)
    {
    }

    PointDefinedCurveFeatureNominalType::
    PointDefinedCurveFeatureNominalType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (this),
      Plane_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DefiningPoints
        //
        if (n.name () == "DefiningPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!DefiningPoints_.present ())
          {
            this->DefiningPoints_.set (r);
            continue;
          }
        }

        // Plane
        //
        if (n.name () == "Plane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Plane_type > r (
            Plane_traits::create (i, f, this));

          if (!this->Plane_)
          {
            this->Plane_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DefiningPoints_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefiningPoints",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedCurveFeatureNominalType* PointDefinedCurveFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureNominalType (*this, f, c);
    }

    PointDefinedCurveFeatureNominalType& PointDefinedCurveFeatureNominalType::
    operator= (const PointDefinedCurveFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->DefiningPoints_ = x.DefiningPoints_;
        this->Plane_ = x.Plane_;
      }

      return *this;
    }

    PointDefinedCurveFeatureNominalType::
    ~PointDefinedCurveFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointDefinedCurveFeatureNominalType >
    _xsd_PointDefinedCurveFeatureNominalType_type_factory_init (
      "PointDefinedCurveFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // TargetPointsActualType
    //

    TargetPointsActualType::
    TargetPointsActualType ()
    : ::xml_schema::type (),
      TargetPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this)
    {
    }

    TargetPointsActualType::
    TargetPointsActualType (const TargetPointsActualType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TargetPoint_ (x.TargetPoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this),
      combinedUncertainty_ (x.combinedUncertainty_, f, this),
      meanError_ (x.meanError_, f, this),
      xCombinedUncertainty_ (x.xCombinedUncertainty_, f, this),
      xMeanError_ (x.xMeanError_, f, this),
      yCombinedUncertainty_ (x.yCombinedUncertainty_, f, this),
      yMeanError_ (x.yMeanError_, f, this),
      zCombinedUncertainty_ (x.zCombinedUncertainty_, f, this),
      zMeanError_ (x.zMeanError_, f, this)
    {
    }

    TargetPointsActualType::
    TargetPointsActualType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TargetPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this),
      combinedUncertainty_ (this),
      meanError_ (this),
      xCombinedUncertainty_ (this),
      xMeanError_ (this),
      yCombinedUncertainty_ (this),
      yMeanError_ (this),
      zCombinedUncertainty_ (this),
      zMeanError_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TargetPointsActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TargetPoint
        //
        if (n.name () == "TargetPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TargetPoint_type > r (
            TargetPoint_traits::create (i, f, this));

          this->TargetPoint_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "combinedUncertainty" && n.namespace_ ().empty ())
        {
          this->combinedUncertainty_.set (combinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "meanError" && n.namespace_ ().empty ())
        {
          this->meanError_.set (meanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->xCombinedUncertainty_.set (xCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xMeanError" && n.namespace_ ().empty ())
        {
          this->xMeanError_.set (xMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->yCombinedUncertainty_.set (yCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yMeanError" && n.namespace_ ().empty ())
        {
          this->yMeanError_.set (yMeanError_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zCombinedUncertainty" && n.namespace_ ().empty ())
        {
          this->zCombinedUncertainty_.set (zCombinedUncertainty_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zMeanError" && n.namespace_ ().empty ())
        {
          this->zMeanError_.set (zMeanError_traits::create (i, f, this));
          continue;
        }
      }
    }

    TargetPointsActualType* TargetPointsActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TargetPointsActualType (*this, f, c);
    }

    TargetPointsActualType& TargetPointsActualType::
    operator= (const TargetPointsActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TargetPoint_ = x.TargetPoint_;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
        this->combinedUncertainty_ = x.combinedUncertainty_;
        this->meanError_ = x.meanError_;
        this->xCombinedUncertainty_ = x.xCombinedUncertainty_;
        this->xMeanError_ = x.xMeanError_;
        this->yCombinedUncertainty_ = x.yCombinedUncertainty_;
        this->yMeanError_ = x.yMeanError_;
        this->zCombinedUncertainty_ = x.zCombinedUncertainty_;
        this->zMeanError_ = x.zMeanError_;
      }

      return *this;
    }

    TargetPointsActualType::
    ~TargetPointsActualType ()
    {
    }

    // PointDefinedCurveFeatureActualType
    //

    PointDefinedCurveFeatureActualType::
    PointDefinedCurveFeatureActualType (const id_type& id,
                                        const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      DefiningPoints_ (this),
      Plane_ (this),
      Form_ (this)
    {
    }

    PointDefinedCurveFeatureActualType::
    PointDefinedCurveFeatureActualType (const id_type& id,
                                        ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      DefiningPoints_ (this),
      Plane_ (this),
      Form_ (this)
    {
    }

    PointDefinedCurveFeatureActualType::
    PointDefinedCurveFeatureActualType (const PointDefinedCurveFeatureActualType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this),
      Plane_ (x.Plane_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    PointDefinedCurveFeatureActualType::
    PointDefinedCurveFeatureActualType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (this),
      Plane_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedCurveFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DefiningPoints
        //
        if (n.name () == "DefiningPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!this->DefiningPoints_)
          {
            this->DefiningPoints_.set (r);
            continue;
          }
        }

        // Plane
        //
        if (n.name () == "Plane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Plane_type > r (
            Plane_traits::create (i, f, this));

          if (!this->Plane_)
          {
            this->Plane_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedCurveFeatureActualType* PointDefinedCurveFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedCurveFeatureActualType (*this, f, c);
    }

    PointDefinedCurveFeatureActualType& PointDefinedCurveFeatureActualType::
    operator= (const PointDefinedCurveFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->DefiningPoints_ = x.DefiningPoints_;
        this->Plane_ = x.Plane_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    PointDefinedCurveFeatureActualType::
    ~PointDefinedCurveFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointDefinedCurveFeatureActualType >
    _xsd_PointDefinedCurveFeatureActualType_type_factory_init (
      "PointDefinedCurveFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // PointDefinedSurfaceConstructionMethodType
    //

    PointDefinedSurfaceConstructionMethodType::
    PointDefinedSurfaceConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Transform_ (this),
      Extract_ (this)
    {
    }

    PointDefinedSurfaceConstructionMethodType::
    PointDefinedSurfaceConstructionMethodType (const PointDefinedSurfaceConstructionMethodType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Transform_ (x.Transform_, f, this),
      Extract_ (x.Extract_, f, this)
    {
    }

    PointDefinedSurfaceConstructionMethodType::
    PointDefinedSurfaceConstructionMethodType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Transform_ (this),
      Extract_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // Extract
        //
        if (n.name () == "Extract" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extract_type > r (
            Extract_traits::create (i, f, this));

          if (!this->Extract_)
          {
            this->Extract_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceConstructionMethodType* PointDefinedSurfaceConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceConstructionMethodType (*this, f, c);
    }

    PointDefinedSurfaceConstructionMethodType& PointDefinedSurfaceConstructionMethodType::
    operator= (const PointDefinedSurfaceConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Transform_ = x.Transform_;
        this->Extract_ = x.Extract_;
      }

      return *this;
    }

    PointDefinedSurfaceConstructionMethodType::
    ~PointDefinedSurfaceConstructionMethodType ()
    {
    }

    // PointDefinedSurfaceBestFitType
    //

    PointDefinedSurfaceBestFitType::
    PointDefinedSurfaceBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    PointDefinedSurfaceBestFitType::
    PointDefinedSurfaceBestFitType (const PointDefinedSurfaceBestFitType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointDefinedSurfaceBestFitType::
    PointDefinedSurfaceBestFitType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PointDefinedSurfaceBestFitType* PointDefinedSurfaceBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceBestFitType (*this, f, c);
    }

    PointDefinedSurfaceBestFitType& PointDefinedSurfaceBestFitType::
    operator= (const PointDefinedSurfaceBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    PointDefinedSurfaceBestFitType::
    ~PointDefinedSurfaceBestFitType ()
    {
    }

    // PointDefinedSurfaceRecompType
    //

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (const PointDefinedSurfaceRecompType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    PointDefinedSurfaceRecompType::
    PointDefinedSurfaceRecompType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceRecompType* PointDefinedSurfaceRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceRecompType (*this, f, c);
    }

    PointDefinedSurfaceRecompType& PointDefinedSurfaceRecompType::
    operator= (const PointDefinedSurfaceRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    PointDefinedSurfaceRecompType::
    ~PointDefinedSurfaceRecompType ()
    {
    }

    // PointDefinedSurfaceCopyType
    //

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (const BasePointDefinedSurface_type& BasePointDefinedSurface)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (BasePointDefinedSurface, this)
    {
    }

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (::std::auto_ptr< BasePointDefinedSurface_type > BasePointDefinedSurface)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (BasePointDefinedSurface, this)
    {
    }

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (const PointDefinedSurfaceCopyType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedSurface_ (x.BasePointDefinedSurface_, f, this)
    {
    }

    PointDefinedSurfaceCopyType::
    PointDefinedSurfaceCopyType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedSurface_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointDefinedSurface
        //
        if (n.name () == "BasePointDefinedSurface" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointDefinedSurface_type > r (
            BasePointDefinedSurface_traits::create (i, f, this));

          if (!BasePointDefinedSurface_.present ())
          {
            this->BasePointDefinedSurface_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedSurface_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointDefinedSurface",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceCopyType* PointDefinedSurfaceCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceCopyType (*this, f, c);
    }

    PointDefinedSurfaceCopyType& PointDefinedSurfaceCopyType::
    operator= (const PointDefinedSurfaceCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointDefinedSurface_ = x.BasePointDefinedSurface_;
      }

      return *this;
    }

    PointDefinedSurfaceCopyType::
    ~PointDefinedSurfaceCopyType ()
    {
    }

    // PointDefinedSurfaceTransformType
    //

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (const BasePointDefinedSurface_type& BasePointDefinedSurface,
                                      const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (BasePointDefinedSurface, this),
      Transformation_ (Transformation, this)
    {
    }

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (::std::auto_ptr< BasePointDefinedSurface_type > BasePointDefinedSurface,
                                      ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointDefinedSurface_ (BasePointDefinedSurface, this),
      Transformation_ (Transformation, this)
    {
    }

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (const PointDefinedSurfaceTransformType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointDefinedSurface_ (x.BasePointDefinedSurface_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PointDefinedSurfaceTransformType::
    PointDefinedSurfaceTransformType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointDefinedSurface_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointDefinedSurface
        //
        if (n.name () == "BasePointDefinedSurface" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointDefinedSurface_type > r (
            BasePointDefinedSurface_traits::create (i, f, this));

          if (!BasePointDefinedSurface_.present ())
          {
            this->BasePointDefinedSurface_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointDefinedSurface_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointDefinedSurface",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceTransformType* PointDefinedSurfaceTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceTransformType (*this, f, c);
    }

    PointDefinedSurfaceTransformType& PointDefinedSurfaceTransformType::
    operator= (const PointDefinedSurfaceTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointDefinedSurface_ = x.BasePointDefinedSurface_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    PointDefinedSurfaceTransformType::
    ~PointDefinedSurfaceTransformType ()
    {
    }

    // PointDefinedSurfaceExtractType
    //

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (const SurfaceFeature_type& SurfaceFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this)
    {
    }

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this)
    {
    }

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (const PointDefinedSurfaceExtractType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this)
    {
    }

    PointDefinedSurfaceExtractType::
    PointDefinedSurfaceExtractType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceExtractType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceExtractType* PointDefinedSurfaceExtractType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceExtractType (*this, f, c);
    }

    PointDefinedSurfaceExtractType& PointDefinedSurfaceExtractType::
    operator= (const PointDefinedSurfaceExtractType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
      }

      return *this;
    }

    PointDefinedSurfaceExtractType::
    ~PointDefinedSurfaceExtractType ()
    {
    }

    // PointDefinedSurfaceCheckedType
    //

    PointDefinedSurfaceCheckedType::
    PointDefinedSurfaceCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    PointDefinedSurfaceCheckedType::
    PointDefinedSurfaceCheckedType (const PointDefinedSurfaceCheckedType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointDefinedSurfaceCheckedType::
    PointDefinedSurfaceCheckedType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceCheckedType* PointDefinedSurfaceCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceCheckedType (*this, f, c);
    }

    PointDefinedSurfaceCheckedType& PointDefinedSurfaceCheckedType::
    operator= (const PointDefinedSurfaceCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PointDefinedSurfaceCheckedType::
    ~PointDefinedSurfaceCheckedType ()
    {
    }

    // PointDefinedSurfaceCheckedFeatureType
    //

    PointDefinedSurfaceCheckedFeatureType::
    PointDefinedSurfaceCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    PointDefinedSurfaceCheckedFeatureType::
    PointDefinedSurfaceCheckedFeatureType (const PointDefinedSurfaceCheckedFeatureType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PointDefinedSurfaceCheckedFeatureType::
    PointDefinedSurfaceCheckedFeatureType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceCheckedFeatureType* PointDefinedSurfaceCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceCheckedFeatureType (*this, f, c);
    }

    PointDefinedSurfaceCheckedFeatureType& PointDefinedSurfaceCheckedFeatureType::
    operator= (const PointDefinedSurfaceCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    PointDefinedSurfaceCheckedFeatureType::
    ~PointDefinedSurfaceCheckedFeatureType ()
    {
    }

    // PointDefinedSurfaceActualDeterminationType
    //

    PointDefinedSurfaceActualDeterminationType::
    PointDefinedSurfaceActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    PointDefinedSurfaceActualDeterminationType::
    PointDefinedSurfaceActualDeterminationType (const PointDefinedSurfaceActualDeterminationType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PointDefinedSurfaceActualDeterminationType::
    PointDefinedSurfaceActualDeterminationType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceActualDeterminationType* PointDefinedSurfaceActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceActualDeterminationType (*this, f, c);
    }

    PointDefinedSurfaceActualDeterminationType& PointDefinedSurfaceActualDeterminationType::
    operator= (const PointDefinedSurfaceActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    PointDefinedSurfaceActualDeterminationType::
    ~PointDefinedSurfaceActualDeterminationType ()
    {
    }

    // PointDefinedSurfaceFeatureItemType
    //

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const id_type& id,
                                        const FeatureName_type& FeatureName,
                                        const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const id_type& id,
                                        const FeatureName_type& FeatureName,
                                        ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const PointDefinedSurfaceFeatureItemType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    PointDefinedSurfaceFeatureItemType::
    PointDefinedSurfaceFeatureItemType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceFeatureItemType* PointDefinedSurfaceFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureItemType (*this, f, c);
    }

    PointDefinedSurfaceFeatureItemType& PointDefinedSurfaceFeatureItemType::
    operator= (const PointDefinedSurfaceFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    PointDefinedSurfaceFeatureItemType::
    ~PointDefinedSurfaceFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointDefinedSurfaceFeatureItemType >
    _xsd_PointDefinedSurfaceFeatureItemType_type_factory_init (
      "PointDefinedSurfaceFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // PointDefinedSurfaceFeatureDefinitionType
    //

    PointDefinedSurfaceFeatureDefinitionType::
    PointDefinedSurfaceFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    PointDefinedSurfaceFeatureDefinitionType::
    PointDefinedSurfaceFeatureDefinitionType (const PointDefinedSurfaceFeatureDefinitionType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    PointDefinedSurfaceFeatureDefinitionType::
    PointDefinedSurfaceFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    PointDefinedSurfaceFeatureDefinitionType* PointDefinedSurfaceFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureDefinitionType (*this, f, c);
    }

    PointDefinedSurfaceFeatureDefinitionType::
    ~PointDefinedSurfaceFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointDefinedSurfaceFeatureDefinitionType >
    _xsd_PointDefinedSurfaceFeatureDefinitionType_type_factory_init (
      "PointDefinedSurfaceFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // TargetPointsNominalType
    //

    TargetPointsNominalType::
    TargetPointsNominalType ()
    : ::xml_schema::type (),
      TargetPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
    }

    TargetPointsNominalType::
    TargetPointsNominalType (const TargetPointsNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      TargetPoint_ (x.TargetPoint_, f, this),
      linearUnit_ (x.linearUnit_, f, this),
      decimalPlaces_ (x.decimalPlaces_, f, this),
      significantFigures_ (x.significantFigures_, f, this),
      validity_ (x.validity_, f, this),
      xDecimalPlaces_ (x.xDecimalPlaces_, f, this),
      xSignificantFigures_ (x.xSignificantFigures_, f, this),
      xValidity_ (x.xValidity_, f, this),
      yDecimalPlaces_ (x.yDecimalPlaces_, f, this),
      ySignificantFigures_ (x.ySignificantFigures_, f, this),
      yValidity_ (x.yValidity_, f, this),
      zDecimalPlaces_ (x.zDecimalPlaces_, f, this),
      zSignificantFigures_ (x.zSignificantFigures_, f, this),
      zValidity_ (x.zValidity_, f, this)
    {
    }

    TargetPointsNominalType::
    TargetPointsNominalType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      TargetPoint_ (this),
      linearUnit_ (this),
      decimalPlaces_ (this),
      significantFigures_ (this),
      validity_ (this),
      xDecimalPlaces_ (this),
      xSignificantFigures_ (this),
      xValidity_ (this),
      yDecimalPlaces_ (this),
      ySignificantFigures_ (this),
      yValidity_ (this),
      zDecimalPlaces_ (this),
      zSignificantFigures_ (this),
      zValidity_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TargetPointsNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // TargetPoint
        //
        if (n.name () == "TargetPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< TargetPoint_type > r (
            TargetPoint_traits::create (i, f, this));

          this->TargetPoint_.push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "linearUnit" && n.namespace_ ().empty ())
        {
          this->linearUnit_.set (linearUnit_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "decimalPlaces" && n.namespace_ ().empty ())
        {
          this->decimalPlaces_.set (decimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "significantFigures" && n.namespace_ ().empty ())
        {
          this->significantFigures_.set (significantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "validity" && n.namespace_ ().empty ())
        {
          this->validity_.set (validity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->xDecimalPlaces_.set (xDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xSignificantFigures" && n.namespace_ ().empty ())
        {
          this->xSignificantFigures_.set (xSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "xValidity" && n.namespace_ ().empty ())
        {
          this->xValidity_.set (xValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->yDecimalPlaces_.set (yDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySignificantFigures" && n.namespace_ ().empty ())
        {
          this->ySignificantFigures_.set (ySignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "yValidity" && n.namespace_ ().empty ())
        {
          this->yValidity_.set (yValidity_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zDecimalPlaces" && n.namespace_ ().empty ())
        {
          this->zDecimalPlaces_.set (zDecimalPlaces_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSignificantFigures" && n.namespace_ ().empty ())
        {
          this->zSignificantFigures_.set (zSignificantFigures_traits::create (i, f, this));
          continue;
        }

        if (n.name () == "zValidity" && n.namespace_ ().empty ())
        {
          this->zValidity_.set (zValidity_traits::create (i, f, this));
          continue;
        }
      }
    }

    TargetPointsNominalType* TargetPointsNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TargetPointsNominalType (*this, f, c);
    }

    TargetPointsNominalType& TargetPointsNominalType::
    operator= (const TargetPointsNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->TargetPoint_ = x.TargetPoint_;
        this->linearUnit_ = x.linearUnit_;
        this->decimalPlaces_ = x.decimalPlaces_;
        this->significantFigures_ = x.significantFigures_;
        this->validity_ = x.validity_;
        this->xDecimalPlaces_ = x.xDecimalPlaces_;
        this->xSignificantFigures_ = x.xSignificantFigures_;
        this->xValidity_ = x.xValidity_;
        this->yDecimalPlaces_ = x.yDecimalPlaces_;
        this->ySignificantFigures_ = x.ySignificantFigures_;
        this->yValidity_ = x.yValidity_;
        this->zDecimalPlaces_ = x.zDecimalPlaces_;
        this->zSignificantFigures_ = x.zSignificantFigures_;
        this->zValidity_ = x.zValidity_;
      }

      return *this;
    }

    TargetPointsNominalType::
    ~TargetPointsNominalType ()
    {
    }

    // PointDefinedSurfaceFeatureNominalType
    //

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const id_type& id,
                                           const FeatureDefinitionId_type& FeatureDefinitionId,
                                           const DefiningPoints_type& DefiningPoints)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      DefiningPoints_ (DefiningPoints, this)
    {
    }

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const id_type& id,
                                           const FeatureDefinitionId_type& FeatureDefinitionId,
                                           ::std::auto_ptr< DefiningPoints_type > DefiningPoints)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      DefiningPoints_ (DefiningPoints, this)
    {
    }

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const PointDefinedSurfaceFeatureNominalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this)
    {
    }

    PointDefinedSurfaceFeatureNominalType::
    PointDefinedSurfaceFeatureNominalType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DefiningPoints
        //
        if (n.name () == "DefiningPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!DefiningPoints_.present ())
          {
            this->DefiningPoints_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DefiningPoints_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DefiningPoints",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointDefinedSurfaceFeatureNominalType* PointDefinedSurfaceFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureNominalType (*this, f, c);
    }

    PointDefinedSurfaceFeatureNominalType& PointDefinedSurfaceFeatureNominalType::
    operator= (const PointDefinedSurfaceFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->DefiningPoints_ = x.DefiningPoints_;
      }

      return *this;
    }

    PointDefinedSurfaceFeatureNominalType::
    ~PointDefinedSurfaceFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointDefinedSurfaceFeatureNominalType >
    _xsd_PointDefinedSurfaceFeatureNominalType_type_factory_init (
      "PointDefinedSurfaceFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // PointDefinedSurfaceFeatureActualType
    //

    PointDefinedSurfaceFeatureActualType::
    PointDefinedSurfaceFeatureActualType (const id_type& id,
                                          const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      DefiningPoints_ (this),
      Form_ (this)
    {
    }

    PointDefinedSurfaceFeatureActualType::
    PointDefinedSurfaceFeatureActualType (const id_type& id,
                                          ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      DefiningPoints_ (this),
      Form_ (this)
    {
    }

    PointDefinedSurfaceFeatureActualType::
    PointDefinedSurfaceFeatureActualType (const PointDefinedSurfaceFeatureActualType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      DefiningPoints_ (x.DefiningPoints_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    PointDefinedSurfaceFeatureActualType::
    PointDefinedSurfaceFeatureActualType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      DefiningPoints_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointDefinedSurfaceFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DefiningPoints
        //
        if (n.name () == "DefiningPoints" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DefiningPoints_type > r (
            DefiningPoints_traits::create (i, f, this));

          if (!this->DefiningPoints_)
          {
            this->DefiningPoints_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointDefinedSurfaceFeatureActualType* PointDefinedSurfaceFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointDefinedSurfaceFeatureActualType (*this, f, c);
    }

    PointDefinedSurfaceFeatureActualType& PointDefinedSurfaceFeatureActualType::
    operator= (const PointDefinedSurfaceFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->DefiningPoints_ = x.DefiningPoints_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    PointDefinedSurfaceFeatureActualType::
    ~PointDefinedSurfaceFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointDefinedSurfaceFeatureActualType >
    _xsd_PointDefinedSurfaceFeatureActualType_type_factory_init (
      "PointDefinedSurfaceFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // PointConstructionMethodType
    //

    PointConstructionMethodType::
    PointConstructionMethodType ()
    : ::xml_schema::type (),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromCone_ (this),
      FromScan_ (this),
      CenterOfGravity_ (this),
      Pierce_ (this),
      MidPoint_ (this),
      MovePoint_ (this),
      MovePointVector_ (this),
      MovePointAxis_ (this),
      Extreme_ (this)
    {
    }

    PointConstructionMethodType::
    PointConstructionMethodType (const PointConstructionMethodType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Intersection_ (x.Intersection_, f, this),
      Projection_ (x.Projection_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromCone_ (x.FromCone_, f, this),
      FromScan_ (x.FromScan_, f, this),
      CenterOfGravity_ (x.CenterOfGravity_, f, this),
      Pierce_ (x.Pierce_, f, this),
      MidPoint_ (x.MidPoint_, f, this),
      MovePoint_ (x.MovePoint_, f, this),
      MovePointVector_ (x.MovePointVector_, f, this),
      MovePointAxis_ (x.MovePointAxis_, f, this),
      Extreme_ (x.Extreme_, f, this)
    {
    }

    PointConstructionMethodType::
    PointConstructionMethodType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Intersection_ (this),
      Projection_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromCone_ (this),
      FromScan_ (this),
      CenterOfGravity_ (this),
      Pierce_ (this),
      MidPoint_ (this),
      MovePoint_ (this),
      MovePointVector_ (this),
      MovePointAxis_ (this),
      Extreme_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Intersection
        //
        if (n.name () == "Intersection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Intersection_type > r (
            Intersection_traits::create (i, f, this));

          if (!this->Intersection_)
          {
            this->Intersection_.set (r);
            continue;
          }
        }

        // Projection
        //
        if (n.name () == "Projection" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Projection_type > r (
            Projection_traits::create (i, f, this));

          if (!this->Projection_)
          {
            this->Projection_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromCone
        //
        if (n.name () == "FromCone" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromCone_type > r (
            FromCone_traits::create (i, f, this));

          if (!this->FromCone_)
          {
            this->FromCone_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        // CenterOfGravity
        //
        if (n.name () == "CenterOfGravity" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CenterOfGravity_type > r (
            CenterOfGravity_traits::create (i, f, this));

          if (!this->CenterOfGravity_)
          {
            this->CenterOfGravity_.set (r);
            continue;
          }
        }

        // Pierce
        //
        if (n.name () == "Pierce" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Pierce_type > r (
            Pierce_traits::create (i, f, this));

          if (!this->Pierce_)
          {
            this->Pierce_.set (r);
            continue;
          }
        }

        // MidPoint
        //
        if (n.name () == "MidPoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MidPoint_type > r (
            MidPoint_traits::create (i, f, this));

          if (!this->MidPoint_)
          {
            this->MidPoint_.set (r);
            continue;
          }
        }

        // MovePoint
        //
        if (n.name () == "MovePoint" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MovePoint_type > r (
            MovePoint_traits::create (i, f, this));

          if (!this->MovePoint_)
          {
            this->MovePoint_.set (r);
            continue;
          }
        }

        // MovePointVector
        //
        if (n.name () == "MovePointVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MovePointVector_type > r (
            MovePointVector_traits::create (i, f, this));

          if (!this->MovePointVector_)
          {
            this->MovePointVector_.set (r);
            continue;
          }
        }

        // MovePointAxis
        //
        if (n.name () == "MovePointAxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MovePointAxis_type > r (
            MovePointAxis_traits::create (i, f, this));

          if (!this->MovePointAxis_)
          {
            this->MovePointAxis_.set (r);
            continue;
          }
        }

        // Extreme
        //
        if (n.name () == "Extreme" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Extreme_type > r (
            Extreme_traits::create (i, f, this));

          if (!this->Extreme_)
          {
            this->Extreme_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointConstructionMethodType* PointConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointConstructionMethodType (*this, f, c);
    }

    PointConstructionMethodType& PointConstructionMethodType::
    operator= (const PointConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Intersection_ = x.Intersection_;
        this->Projection_ = x.Projection_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromCone_ = x.FromCone_;
        this->FromScan_ = x.FromScan_;
        this->CenterOfGravity_ = x.CenterOfGravity_;
        this->Pierce_ = x.Pierce_;
        this->MidPoint_ = x.MidPoint_;
        this->MovePoint_ = x.MovePoint_;
        this->MovePointVector_ = x.MovePointVector_;
        this->MovePointAxis_ = x.MovePointAxis_;
        this->Extreme_ = x.Extreme_;
      }

      return *this;
    }

    PointConstructionMethodType::
    ~PointConstructionMethodType ()
    {
    }

    // PointFeatureIntersectionType
    //

    PointFeatureIntersectionType::
    PointFeatureIntersectionType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      IntersectionFeature_ (this)
    {
    }

    PointFeatureIntersectionType::
    PointFeatureIntersectionType (const PointFeatureIntersectionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      IntersectionFeature_ (x.IntersectionFeature_, f, this)
    {
    }

    PointFeatureIntersectionType::
    PointFeatureIntersectionType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      IntersectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureIntersectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // IntersectionFeature
        //
        if (n.name () == "IntersectionFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< IntersectionFeature_type > r (
            IntersectionFeature_traits::create (i, f, this));

          this->IntersectionFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PointFeatureIntersectionType* PointFeatureIntersectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureIntersectionType (*this, f, c);
    }

    PointFeatureIntersectionType& PointFeatureIntersectionType::
    operator= (const PointFeatureIntersectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->IntersectionFeature_ = x.IntersectionFeature_;
      }

      return *this;
    }

    PointFeatureIntersectionType::
    ~PointFeatureIntersectionType ()
    {
    }

    // PointFeaturePierceType
    //

    PointFeaturePierceType::
    PointFeaturePierceType (const SurfaceFeature_type& SurfaceFeature,
                            const CurveFeature_type& CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      CurveFeature_ (CurveFeature, this)
    {
    }

    PointFeaturePierceType::
    PointFeaturePierceType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                            ::std::auto_ptr< CurveFeature_type > CurveFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      CurveFeature_ (CurveFeature, this)
    {
    }

    PointFeaturePierceType::
    PointFeaturePierceType (const PointFeaturePierceType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      CurveFeature_ (x.CurveFeature_, f, this)
    {
    }

    PointFeaturePierceType::
    PointFeaturePierceType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      CurveFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeaturePierceType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // CurveFeature
        //
        if (n.name () == "CurveFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CurveFeature_type > r (
            CurveFeature_traits::create (i, f, this));

          if (!CurveFeature_.present ())
          {
            this->CurveFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CurveFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CurveFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeaturePierceType* PointFeaturePierceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeaturePierceType (*this, f, c);
    }

    PointFeaturePierceType& PointFeaturePierceType::
    operator= (const PointFeaturePierceType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->CurveFeature_ = x.CurveFeature_;
      }

      return *this;
    }

    PointFeaturePierceType::
    ~PointFeaturePierceType ()
    {
    }

    // PointFeatureProjectionType
    //

    PointFeatureProjectionType::
    PointFeatureProjectionType (const ProjectionPlane_type& ProjectionPlane,
                                const ProjectionFeature_type& ProjectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, this),
      ProjectionFeature_ (ProjectionFeature, this)
    {
    }

    PointFeatureProjectionType::
    PointFeatureProjectionType (::std::auto_ptr< ProjectionPlane_type > ProjectionPlane,
                                ::std::auto_ptr< ProjectionFeature_type > ProjectionFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      ProjectionPlane_ (ProjectionPlane, this),
      ProjectionFeature_ (ProjectionFeature, this)
    {
    }

    PointFeatureProjectionType::
    PointFeatureProjectionType (const PointFeatureProjectionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      ProjectionPlane_ (x.ProjectionPlane_, f, this),
      ProjectionFeature_ (x.ProjectionFeature_, f, this)
    {
    }

    PointFeatureProjectionType::
    PointFeatureProjectionType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      ProjectionPlane_ (this),
      ProjectionFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureProjectionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ProjectionPlane
        //
        if (n.name () == "ProjectionPlane" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionPlane_type > r (
            ProjectionPlane_traits::create (i, f, this));

          if (!ProjectionPlane_.present ())
          {
            this->ProjectionPlane_.set (r);
            continue;
          }
        }

        // ProjectionFeature
        //
        if (n.name () == "ProjectionFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ProjectionFeature_type > r (
            ProjectionFeature_traits::create (i, f, this));

          if (!ProjectionFeature_.present ())
          {
            this->ProjectionFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!ProjectionPlane_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionPlane",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ProjectionFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ProjectionFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureProjectionType* PointFeatureProjectionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureProjectionType (*this, f, c);
    }

    PointFeatureProjectionType& PointFeatureProjectionType::
    operator= (const PointFeatureProjectionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->ProjectionPlane_ = x.ProjectionPlane_;
        this->ProjectionFeature_ = x.ProjectionFeature_;
      }

      return *this;
    }

    PointFeatureProjectionType::
    ~PointFeatureProjectionType ()
    {
    }

    // PointFeatureFromConeType
    //

    PointFeatureFromConeType::
    PointFeatureFromConeType (const BaseCone_type& BaseCone)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, this)
    {
    }

    PointFeatureFromConeType::
    PointFeatureFromConeType (::std::auto_ptr< BaseCone_type > BaseCone)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCone_ (BaseCone, this)
    {
    }

    PointFeatureFromConeType::
    PointFeatureFromConeType (const PointFeatureFromConeType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCone_ (x.BaseCone_, f, this)
    {
    }

    PointFeatureFromConeType::
    PointFeatureFromConeType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCone_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureFromConeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCone
        //
        if (n.name () == "BaseCone" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCone_type > r (
            BaseCone_traits::create (i, f, this));

          if (!BaseCone_.present ())
          {
            this->BaseCone_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCone_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCone",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureFromConeType* PointFeatureFromConeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureFromConeType (*this, f, c);
    }

    PointFeatureFromConeType& PointFeatureFromConeType::
    operator= (const PointFeatureFromConeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCone_ = x.BaseCone_;
      }

      return *this;
    }

    PointFeatureFromConeType::
    ~PointFeatureFromConeType ()
    {
    }

    // PointFeatureCopyType
    //

    PointFeatureCopyType::
    PointFeatureCopyType (const BasePointFeature_type& BasePointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointFeature_ (BasePointFeature, this)
    {
    }

    PointFeatureCopyType::
    PointFeatureCopyType (::std::auto_ptr< BasePointFeature_type > BasePointFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointFeature_ (BasePointFeature, this)
    {
    }

    PointFeatureCopyType::
    PointFeatureCopyType (const PointFeatureCopyType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointFeature_ (x.BasePointFeature_, f, this)
    {
    }

    PointFeatureCopyType::
    PointFeatureCopyType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointFeature
        //
        if (n.name () == "BasePointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointFeature_type > r (
            BasePointFeature_traits::create (i, f, this));

          if (!BasePointFeature_.present ())
          {
            this->BasePointFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureCopyType* PointFeatureCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureCopyType (*this, f, c);
    }

    PointFeatureCopyType& PointFeatureCopyType::
    operator= (const PointFeatureCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointFeature_ = x.BasePointFeature_;
      }

      return *this;
    }

    PointFeatureCopyType::
    ~PointFeatureCopyType ()
    {
    }

    // PointFeatureTransformType
    //

    PointFeatureTransformType::
    PointFeatureTransformType (const BasePointFeature_type& BasePointFeature,
                               const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointFeature_ (BasePointFeature, this),
      Transformation_ (Transformation, this)
    {
    }

    PointFeatureTransformType::
    PointFeatureTransformType (::std::auto_ptr< BasePointFeature_type > BasePointFeature,
                               ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BasePointFeature_ (BasePointFeature, this),
      Transformation_ (Transformation, this)
    {
    }

    PointFeatureTransformType::
    PointFeatureTransformType (const PointFeatureTransformType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BasePointFeature_ (x.BasePointFeature_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    PointFeatureTransformType::
    PointFeatureTransformType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BasePointFeature_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BasePointFeature
        //
        if (n.name () == "BasePointFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BasePointFeature_type > r (
            BasePointFeature_traits::create (i, f, this));

          if (!BasePointFeature_.present ())
          {
            this->BasePointFeature_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BasePointFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BasePointFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureTransformType* PointFeatureTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureTransformType (*this, f, c);
    }

    PointFeatureTransformType& PointFeatureTransformType::
    operator= (const PointFeatureTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BasePointFeature_ = x.BasePointFeature_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    PointFeatureTransformType::
    ~PointFeatureTransformType ()
    {
    }

    // PointFeatureFromScanType
    //

    PointFeatureFromScanType::
    PointFeatureFromScanType (const SurfaceFeature_type& SurfaceFeature,
                              const SearchRadius_type& SearchRadius,
                              const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      RetrievalMethod_ (RetrievalMethod, this)
    {
    }

    PointFeatureFromScanType::
    PointFeatureFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                              ::std::auto_ptr< SearchRadius_type > SearchRadius,
                              const RetrievalMethod_type& RetrievalMethod)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      RetrievalMethod_ (RetrievalMethod, this)
    {
    }

    PointFeatureFromScanType::
    PointFeatureFromScanType (const PointFeatureFromScanType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      RetrievalMethod_ (x.RetrievalMethod_, f, this)
    {
    }

    PointFeatureFromScanType::
    PointFeatureFromScanType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      RetrievalMethod_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // RetrievalMethod
        //
        if (n.name () == "RetrievalMethod" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< RetrievalMethod_type > r (
            RetrievalMethod_traits::create (i, f, this));

          if (!RetrievalMethod_.present ())
          {
            this->RetrievalMethod_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!RetrievalMethod_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "RetrievalMethod",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureFromScanType* PointFeatureFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureFromScanType (*this, f, c);
    }

    PointFeatureFromScanType& PointFeatureFromScanType::
    operator= (const PointFeatureFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->RetrievalMethod_ = x.RetrievalMethod_;
      }

      return *this;
    }

    PointFeatureFromScanType::
    ~PointFeatureFromScanType ()
    {
    }

    // PointFeatureCenterOfGravityType
    //

    PointFeatureCenterOfGravityType::
    PointFeatureCenterOfGravityType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    PointFeatureCenterOfGravityType::
    PointFeatureCenterOfGravityType (const PointFeatureCenterOfGravityType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointFeatureCenterOfGravityType::
    PointFeatureCenterOfGravityType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureCenterOfGravityType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PointFeatureCenterOfGravityType* PointFeatureCenterOfGravityType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureCenterOfGravityType (*this, f, c);
    }

    PointFeatureCenterOfGravityType& PointFeatureCenterOfGravityType::
    operator= (const PointFeatureCenterOfGravityType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    PointFeatureCenterOfGravityType::
    ~PointFeatureCenterOfGravityType ()
    {
    }

    // PointFeatureMidPointType
    //

    PointFeatureMidPointType::
    PointFeatureMidPointType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    PointFeatureMidPointType::
    PointFeatureMidPointType (const PointFeatureMidPointType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointFeatureMidPointType::
    PointFeatureMidPointType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMidPointType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    PointFeatureMidPointType* PointFeatureMidPointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMidPointType (*this, f, c);
    }

    PointFeatureMidPointType& PointFeatureMidPointType::
    operator= (const PointFeatureMidPointType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    PointFeatureMidPointType::
    ~PointFeatureMidPointType ()
    {
    }

    // PointFeatureCastType
    //

    PointFeatureCastType::
    PointFeatureCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    PointFeatureCastType::
    PointFeatureCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    PointFeatureCastType::
    PointFeatureCastType (const PointFeatureCastType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    PointFeatureCastType::
    PointFeatureCastType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureCastType* PointFeatureCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureCastType (*this, f, c);
    }

    PointFeatureCastType& PointFeatureCastType::
    operator= (const PointFeatureCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    PointFeatureCastType::
    ~PointFeatureCastType ()
    {
    }

    // PointFeatureMovePointType
    //

    PointFeatureMovePointType::
    PointFeatureMovePointType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this),
      Offset_ (this),
      DirectionalOffset_ (this)
    {
    }

    PointFeatureMovePointType::
    PointFeatureMovePointType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this),
      Offset_ (this),
      DirectionalOffset_ (this)
    {
    }

    PointFeatureMovePointType::
    PointFeatureMovePointType (const PointFeatureMovePointType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      Offset_ (x.Offset_, f, this),
      DirectionalOffset_ (x.DirectionalOffset_, f, this)
    {
    }

    PointFeatureMovePointType::
    PointFeatureMovePointType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      Offset_ (this),
      DirectionalOffset_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMovePointType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!this->Offset_)
          {
            this->Offset_.set (r);
            continue;
          }
        }

        // DirectionalOffset
        //
        if (n.name () == "DirectionalOffset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DirectionalOffset_type > r (
            DirectionalOffset_traits::create (i, f, this));

          if (!this->DirectionalOffset_)
          {
            this->DirectionalOffset_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureMovePointType* PointFeatureMovePointType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMovePointType (*this, f, c);
    }

    PointFeatureMovePointType& PointFeatureMovePointType::
    operator= (const PointFeatureMovePointType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->Offset_ = x.Offset_;
        this->DirectionalOffset_ = x.DirectionalOffset_;
      }

      return *this;
    }

    PointFeatureMovePointType::
    ~PointFeatureMovePointType ()
    {
    }

    // PointFeatureMovePointVectorType
    //

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (const BaseFeature_type& BaseFeature,
                                     const Distance_type& Distance,
                                     const Vector_type& Vector)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this),
      Distance_ (Distance, this),
      Vector_ (Vector, this)
    {
    }

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (::std::auto_ptr< BaseFeature_type > BaseFeature,
                                     ::std::auto_ptr< Distance_type > Distance,
                                     ::std::auto_ptr< Vector_type > Vector)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this),
      Distance_ (Distance, this),
      Vector_ (Vector, this)
    {
    }

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (const PointFeatureMovePointVectorType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      Distance_ (x.Distance_, f, this),
      Vector_ (x.Vector_, f, this)
    {
    }

    PointFeatureMovePointVectorType::
    PointFeatureMovePointVectorType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      Distance_ (this),
      Vector_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMovePointVectorType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        // Distance
        //
        if (n.name () == "Distance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!Distance_.present ())
          {
            this->Distance_.set (r);
            continue;
          }
        }

        // Vector
        //
        if (n.name () == "Vector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!Vector_.present ())
          {
            this->Vector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Distance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Distance",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Vector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Vector",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureMovePointVectorType* PointFeatureMovePointVectorType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMovePointVectorType (*this, f, c);
    }

    PointFeatureMovePointVectorType& PointFeatureMovePointVectorType::
    operator= (const PointFeatureMovePointVectorType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->Distance_ = x.Distance_;
        this->Vector_ = x.Vector_;
      }

      return *this;
    }

    PointFeatureMovePointVectorType::
    ~PointFeatureMovePointVectorType ()
    {
    }

    // PointFeatureMovePointAxisType
    //

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (const BaseLocationFeature_type& BaseLocationFeature,
                                   const Distance_type& Distance,
                                   const BaseAxisFeature_type& BaseAxisFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLocationFeature_ (BaseLocationFeature, this),
      Distance_ (Distance, this),
      BaseAxisFeature_ (BaseAxisFeature, this)
    {
    }

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (::std::auto_ptr< BaseLocationFeature_type > BaseLocationFeature,
                                   ::std::auto_ptr< Distance_type > Distance,
                                   ::std::auto_ptr< BaseAxisFeature_type > BaseAxisFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseLocationFeature_ (BaseLocationFeature, this),
      Distance_ (Distance, this),
      BaseAxisFeature_ (BaseAxisFeature, this)
    {
    }

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (const PointFeatureMovePointAxisType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseLocationFeature_ (x.BaseLocationFeature_, f, this),
      Distance_ (x.Distance_, f, this),
      BaseAxisFeature_ (x.BaseAxisFeature_, f, this)
    {
    }

    PointFeatureMovePointAxisType::
    PointFeatureMovePointAxisType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseLocationFeature_ (this),
      Distance_ (this),
      BaseAxisFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureMovePointAxisType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseLocationFeature
        //
        if (n.name () == "BaseLocationFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseLocationFeature_type > r (
            BaseLocationFeature_traits::create (i, f, this));

          if (!BaseLocationFeature_.present ())
          {
            this->BaseLocationFeature_.set (r);
            continue;
          }
        }

        // Distance
        //
        if (n.name () == "Distance" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Distance_type > r (
            Distance_traits::create (i, f, this));

          if (!Distance_.present ())
          {
            this->Distance_.set (r);
            continue;
          }
        }

        // BaseAxisFeature
        //
        if (n.name () == "BaseAxisFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseAxisFeature_type > r (
            BaseAxisFeature_traits::create (i, f, this));

          if (!BaseAxisFeature_.present ())
          {
            this->BaseAxisFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseLocationFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseLocationFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Distance_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Distance",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!BaseAxisFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseAxisFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureMovePointAxisType* PointFeatureMovePointAxisType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureMovePointAxisType (*this, f, c);
    }

    PointFeatureMovePointAxisType& PointFeatureMovePointAxisType::
    operator= (const PointFeatureMovePointAxisType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseLocationFeature_ = x.BaseLocationFeature_;
        this->Distance_ = x.Distance_;
        this->BaseAxisFeature_ = x.BaseAxisFeature_;
      }

      return *this;
    }

    PointFeatureMovePointAxisType::
    ~PointFeatureMovePointAxisType ()
    {
    }

    // PointFeatureExtremeType
    //

    const PointFeatureExtremeType::Radial_type PointFeatureExtremeType::Radial_default_value_ (
      "Radial");

    const PointFeatureExtremeType::Xaxis_type PointFeatureExtremeType::Xaxis_default_value_ (
      "Xaxis");

    const PointFeatureExtremeType::Yaxis_type PointFeatureExtremeType::Yaxis_default_value_ (
      "Yaxis");

    const PointFeatureExtremeType::Zaxis_type PointFeatureExtremeType::Zaxis_default_value_ (
      "Zaxis");

    PointFeatureExtremeType::
    PointFeatureExtremeType (const BaseFeature_type& BaseFeature,
                             const Minimum_type& Minimum)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this),
      Minimum_ (Minimum, this),
      BaseAxisFeature_ (this),
      Vector_ (this),
      Radial_ (this),
      Xaxis_ (this),
      Yaxis_ (this),
      Zaxis_ (this)
    {
    }

    PointFeatureExtremeType::
    PointFeatureExtremeType (::std::auto_ptr< BaseFeature_type > BaseFeature,
                             const Minimum_type& Minimum)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this),
      Minimum_ (Minimum, this),
      BaseAxisFeature_ (this),
      Vector_ (this),
      Radial_ (this),
      Xaxis_ (this),
      Yaxis_ (this),
      Zaxis_ (this)
    {
    }

    PointFeatureExtremeType::
    PointFeatureExtremeType (const PointFeatureExtremeType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this),
      Minimum_ (x.Minimum_, f, this),
      BaseAxisFeature_ (x.BaseAxisFeature_, f, this),
      Vector_ (x.Vector_, f, this),
      Radial_ (x.Radial_, f, this),
      Xaxis_ (x.Xaxis_, f, this),
      Yaxis_ (x.Yaxis_, f, this),
      Zaxis_ (x.Zaxis_, f, this)
    {
    }

    PointFeatureExtremeType::
    PointFeatureExtremeType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this),
      Minimum_ (this),
      BaseAxisFeature_ (this),
      Vector_ (this),
      Radial_ (this),
      Xaxis_ (this),
      Yaxis_ (this),
      Zaxis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointFeatureExtremeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        // Minimum
        //
        if (n.name () == "Minimum" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          if (!Minimum_.present ())
          {
            this->Minimum_.set (Minimum_traits::create (i, f, this));
            continue;
          }
        }

        // BaseAxisFeature
        //
        if (n.name () == "BaseAxisFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseAxisFeature_type > r (
            BaseAxisFeature_traits::create (i, f, this));

          if (!this->BaseAxisFeature_)
          {
            this->BaseAxisFeature_.set (r);
            continue;
          }
        }

        // Vector
        //
        if (n.name () == "Vector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!this->Vector_)
          {
            this->Vector_.set (r);
            continue;
          }
        }

        // Radial
        //
        if (n.name () == "Radial" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Radial_type > r (
            Radial_traits::create (i, f, this));

          if (!this->Radial_)
          {
            this->Radial_.set (r);
            continue;
          }
        }

        // Xaxis
        //
        if (n.name () == "Xaxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Xaxis_type > r (
            Xaxis_traits::create (i, f, this));

          if (!this->Xaxis_)
          {
            this->Xaxis_.set (r);
            continue;
          }
        }

        // Yaxis
        //
        if (n.name () == "Yaxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Yaxis_type > r (
            Yaxis_traits::create (i, f, this));

          if (!this->Yaxis_)
          {
            this->Yaxis_.set (r);
            continue;
          }
        }

        // Zaxis
        //
        if (n.name () == "Zaxis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Zaxis_type > r (
            Zaxis_traits::create (i, f, this));

          if (!this->Zaxis_)
          {
            this->Zaxis_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Minimum_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Minimum",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureExtremeType* PointFeatureExtremeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureExtremeType (*this, f, c);
    }

    PointFeatureExtremeType& PointFeatureExtremeType::
    operator= (const PointFeatureExtremeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
        this->Minimum_ = x.Minimum_;
        this->BaseAxisFeature_ = x.BaseAxisFeature_;
        this->Vector_ = x.Vector_;
        this->Radial_ = x.Radial_;
        this->Xaxis_ = x.Xaxis_;
        this->Yaxis_ = x.Yaxis_;
        this->Zaxis_ = x.Zaxis_;
      }

      return *this;
    }

    PointFeatureExtremeType::
    ~PointFeatureExtremeType ()
    {
    }

    // PointCheckedType
    //

    PointCheckedType::
    PointCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    PointCheckedType::
    PointCheckedType (const PointCheckedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    PointCheckedType::
    PointCheckedType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointCheckedType* PointCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCheckedType (*this, f, c);
    }

    PointCheckedType& PointCheckedType::
    operator= (const PointCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    PointCheckedType::
    ~PointCheckedType ()
    {
    }

    // PointCheckedFeatureType
    //

    PointCheckedFeatureType::
    PointCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    PointCheckedFeatureType::
    PointCheckedFeatureType (const PointCheckedFeatureType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    PointCheckedFeatureType::
    PointCheckedFeatureType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointCheckedFeatureType* PointCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointCheckedFeatureType (*this, f, c);
    }

    PointCheckedFeatureType& PointCheckedFeatureType::
    operator= (const PointCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    PointCheckedFeatureType::
    ~PointCheckedFeatureType ()
    {
    }

    // PointActualDeterminationType
    //

    PointActualDeterminationType::
    PointActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    PointActualDeterminationType::
    PointActualDeterminationType (const PointActualDeterminationType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    PointActualDeterminationType::
    PointActualDeterminationType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PointActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointActualDeterminationType* PointActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointActualDeterminationType (*this, f, c);
    }

    PointActualDeterminationType& PointActualDeterminationType::
    operator= (const PointActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    PointActualDeterminationType::
    ~PointActualDeterminationType ()
    {
    }

    // PointFeatureItemType
    //

    PointFeatureItemType::
    PointFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    PointFeatureItemType::
    PointFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this)
    {
    }

    PointFeatureItemType::
    PointFeatureItemType (const PointFeatureItemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this)
    {
    }

    PointFeatureItemType::
    PointFeatureItemType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureItemType* PointFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureItemType (*this, f, c);
    }

    PointFeatureItemType& PointFeatureItemType::
    operator= (const PointFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
      }

      return *this;
    }

    PointFeatureItemType::
    ~PointFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointFeatureItemType >
    _xsd_PointFeatureItemType_type_factory_init (
      "PointFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // PointFeatureDefinitionType
    //

    PointFeatureDefinitionType::
    PointFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    PointFeatureDefinitionType::
    PointFeatureDefinitionType (const PointFeatureDefinitionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    PointFeatureDefinitionType::
    PointFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    PointFeatureDefinitionType* PointFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureDefinitionType (*this, f, c);
    }

    PointFeatureDefinitionType::
    ~PointFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointFeatureDefinitionType >
    _xsd_PointFeatureDefinitionType_type_factory_init (
      "PointFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // PointFeatureNominalType
    //

    PointFeatureNominalType::
    PointFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             const Location_type& Location)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (this)
    {
    }

    PointFeatureNominalType::
    PointFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             ::std::auto_ptr< Location_type > Location)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      Normal_ (this)
    {
    }

    PointFeatureNominalType::
    PointFeatureNominalType (const PointFeatureNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    PointFeatureNominalType::
    PointFeatureNominalType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    PointFeatureNominalType* PointFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureNominalType (*this, f, c);
    }

    PointFeatureNominalType& PointFeatureNominalType::
    operator= (const PointFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    PointFeatureNominalType::
    ~PointFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointFeatureNominalType >
    _xsd_PointFeatureNominalType_type_factory_init (
      "PointFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // PointFeatureActualType
    //

    PointFeatureActualType::
    PointFeatureActualType (const id_type& id,
                            const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Normal_ (this)
    {
    }

    PointFeatureActualType::
    PointFeatureActualType (const id_type& id,
                            ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Normal_ (this)
    {
    }

    PointFeatureActualType::
    PointFeatureActualType (const PointFeatureActualType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Normal_ (x.Normal_, f, this)
    {
    }

    PointFeatureActualType::
    PointFeatureActualType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Normal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PointFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Normal
        //
        if (n.name () == "Normal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Normal_type > r (
            Normal_traits::create (i, f, this));

          if (!this->Normal_)
          {
            this->Normal_.set (r);
            continue;
          }
        }

        break;
      }
    }

    PointFeatureActualType* PointFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PointFeatureActualType (*this, f, c);
    }

    PointFeatureActualType& PointFeatureActualType::
    operator= (const PointFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Normal_ = x.Normal_;
      }

      return *this;
    }

    PointFeatureActualType::
    ~PointFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointFeatureActualType >
    _xsd_PointFeatureActualType_type_factory_init (
      "PointFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // SphereConstructionMethodType
    //

    SphereConstructionMethodType::
    SphereConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    SphereConstructionMethodType::
    SphereConstructionMethodType (const SphereConstructionMethodType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    SphereConstructionMethodType::
    SphereConstructionMethodType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphereConstructionMethodType* SphereConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereConstructionMethodType (*this, f, c);
    }

    SphereConstructionMethodType& SphereConstructionMethodType::
    operator= (const SphereConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    SphereConstructionMethodType::
    ~SphereConstructionMethodType ()
    {
    }

    // SphereBestFitType
    //

    SphereBestFitType::
    SphereBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    SphereBestFitType::
    SphereBestFitType (const SphereBestFitType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SphereBestFitType::
    SphereBestFitType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    SphereBestFitType* SphereBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereBestFitType (*this, f, c);
    }

    SphereBestFitType& SphereBestFitType::
    operator= (const SphereBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    SphereBestFitType::
    ~SphereBestFitType ()
    {
    }

    // SphereRecompType
    //

    SphereRecompType::
    SphereRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    SphereRecompType::
    SphereRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    SphereRecompType::
    SphereRecompType (const SphereRecompType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    SphereRecompType::
    SphereRecompType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereRecompType* SphereRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereRecompType (*this, f, c);
    }

    SphereRecompType& SphereRecompType::
    operator= (const SphereRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    SphereRecompType::
    ~SphereRecompType ()
    {
    }

    // SphereCopyType
    //

    SphereCopyType::
    SphereCopyType (const BaseSphere_type& BaseSphere)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphere_ (BaseSphere, this)
    {
    }

    SphereCopyType::
    SphereCopyType (::std::auto_ptr< BaseSphere_type > BaseSphere)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphere_ (BaseSphere, this)
    {
    }

    SphereCopyType::
    SphereCopyType (const SphereCopyType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSphere_ (x.BaseSphere_, f, this)
    {
    }

    SphereCopyType::
    SphereCopyType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphere_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSphere
        //
        if (n.name () == "BaseSphere" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSphere_type > r (
            BaseSphere_traits::create (i, f, this));

          if (!BaseSphere_.present ())
          {
            this->BaseSphere_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSphere_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSphere",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereCopyType* SphereCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCopyType (*this, f, c);
    }

    SphereCopyType& SphereCopyType::
    operator= (const SphereCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSphere_ = x.BaseSphere_;
      }

      return *this;
    }

    SphereCopyType::
    ~SphereCopyType ()
    {
    }

    // SphereCastType
    //

    SphereCastType::
    SphereCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    SphereCastType::
    SphereCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    SphereCastType::
    SphereCastType (const SphereCastType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SphereCastType::
    SphereCastType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereCastType* SphereCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCastType (*this, f, c);
    }

    SphereCastType& SphereCastType::
    operator= (const SphereCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    SphereCastType::
    ~SphereCastType ()
    {
    }

    // SphereTransformType
    //

    SphereTransformType::
    SphereTransformType (const BaseSphere_type& BaseSphere,
                         const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphere_ (BaseSphere, this),
      Transformation_ (Transformation, this)
    {
    }

    SphereTransformType::
    SphereTransformType (::std::auto_ptr< BaseSphere_type > BaseSphere,
                         ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphere_ (BaseSphere, this),
      Transformation_ (Transformation, this)
    {
    }

    SphereTransformType::
    SphereTransformType (const SphereTransformType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSphere_ (x.BaseSphere_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    SphereTransformType::
    SphereTransformType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphere_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSphere
        //
        if (n.name () == "BaseSphere" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSphere_type > r (
            BaseSphere_traits::create (i, f, this));

          if (!BaseSphere_.present ())
          {
            this->BaseSphere_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSphere_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSphere",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereTransformType* SphereTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereTransformType (*this, f, c);
    }

    SphereTransformType& SphereTransformType::
    operator= (const SphereTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSphere_ = x.BaseSphere_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    SphereTransformType::
    ~SphereTransformType ()
    {
    }

    // SphereFromScanType
    //

    SphereFromScanType::
    SphereFromScanType (const SurfaceFeature_type& SurfaceFeature,
                        const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Vector_ (this)
    {
    }

    SphereFromScanType::
    SphereFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                        ::std::auto_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this),
      Vector_ (this)
    {
    }

    SphereFromScanType::
    SphereFromScanType (const SphereFromScanType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this),
      Vector_ (x.Vector_, f, this)
    {
    }

    SphereFromScanType::
    SphereFromScanType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this),
      Vector_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        // Vector
        //
        if (n.name () == "Vector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Vector_type > r (
            Vector_traits::create (i, f, this));

          if (!this->Vector_)
          {
            this->Vector_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereFromScanType* SphereFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFromScanType (*this, f, c);
    }

    SphereFromScanType& SphereFromScanType::
    operator= (const SphereFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
        this->Vector_ = x.Vector_;
      }

      return *this;
    }

    SphereFromScanType::
    ~SphereFromScanType ()
    {
    }

    // SphereCheckedType
    //

    SphereCheckedType::
    SphereCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    SphereCheckedType::
    SphereCheckedType (const SphereCheckedType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SphereCheckedType::
    SphereCheckedType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphereCheckedType* SphereCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCheckedType (*this, f, c);
    }

    SphereCheckedType& SphereCheckedType::
    operator= (const SphereCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    SphereCheckedType::
    ~SphereCheckedType ()
    {
    }

    // SphereCheckedFeatureType
    //

    SphereCheckedFeatureType::
    SphereCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    SphereCheckedFeatureType::
    SphereCheckedFeatureType (const SphereCheckedFeatureType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    SphereCheckedFeatureType::
    SphereCheckedFeatureType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphereCheckedFeatureType* SphereCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereCheckedFeatureType (*this, f, c);
    }

    SphereCheckedFeatureType& SphereCheckedFeatureType::
    operator= (const SphereCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    SphereCheckedFeatureType::
    ~SphereCheckedFeatureType ()
    {
    }

    // SphereActualDeterminationType
    //

    SphereActualDeterminationType::
    SphereActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    SphereActualDeterminationType::
    SphereActualDeterminationType (const SphereActualDeterminationType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    SphereActualDeterminationType::
    SphereActualDeterminationType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphereActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphereActualDeterminationType* SphereActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereActualDeterminationType (*this, f, c);
    }

    SphereActualDeterminationType& SphereActualDeterminationType::
    operator= (const SphereActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    SphereActualDeterminationType::
    ~SphereActualDeterminationType ()
    {
    }

    // SphereFeatureItemType
    //

    SphereFeatureItemType::
    SphereFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    SphereFeatureItemType::
    SphereFeatureItemType (const id_type& id,
                           const FeatureName_type& FeatureName,
                           ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    SphereFeatureItemType::
    SphereFeatureItemType (const SphereFeatureItemType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    SphereFeatureItemType::
    SphereFeatureItemType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereFeatureItemType* SphereFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureItemType (*this, f, c);
    }

    SphereFeatureItemType& SphereFeatureItemType::
    operator= (const SphereFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    SphereFeatureItemType::
    ~SphereFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SphereFeatureItemType >
    _xsd_SphereFeatureItemType_type_factory_init (
      "SphereFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // SphereFeatureDefinitionType
    //

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this)
    {
    }

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const id_type& id,
                                 const InternalExternal_type& InternalExternal,
                                 ::std::auto_ptr< Diameter_type > Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this)
    {
    }

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const SphereFeatureDefinitionType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this)
    {
    }

    SphereFeatureDefinitionType::
    SphereFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereFeatureDefinitionType* SphereFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureDefinitionType (*this, f, c);
    }

    SphereFeatureDefinitionType& SphereFeatureDefinitionType::
    operator= (const SphereFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
      }

      return *this;
    }

    SphereFeatureDefinitionType::
    ~SphereFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SphereFeatureDefinitionType >
    _xsd_SphereFeatureDefinitionType_type_factory_init (
      "SphereFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // SphereFeatureNominalType
    //

    SphereFeatureNominalType::
    SphereFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              const Location_type& Location)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      LatitudeLongitudeSweep_ (this)
    {
    }

    SphereFeatureNominalType::
    SphereFeatureNominalType (const id_type& id,
                              const FeatureDefinitionId_type& FeatureDefinitionId,
                              ::std::auto_ptr< Location_type > Location)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      LatitudeLongitudeSweep_ (this)
    {
    }

    SphereFeatureNominalType::
    SphereFeatureNominalType (const SphereFeatureNominalType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this)
    {
    }

    SphereFeatureNominalType::
    SphereFeatureNominalType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      LatitudeLongitudeSweep_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphereFeatureNominalType* SphereFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureNominalType (*this, f, c);
    }

    SphereFeatureNominalType& SphereFeatureNominalType::
    operator= (const SphereFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
      }

      return *this;
    }

    SphereFeatureNominalType::
    ~SphereFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SphereFeatureNominalType >
    _xsd_SphereFeatureNominalType_type_factory_init (
      "SphereFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // SphereFeatureActualType
    //

    SphereFeatureActualType::
    SphereFeatureActualType (const id_type& id,
                             const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
    }

    SphereFeatureActualType::
    SphereFeatureActualType (const id_type& id,
                             ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
    }

    SphereFeatureActualType::
    SphereFeatureActualType (const SphereFeatureActualType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    SphereFeatureActualType::
    SphereFeatureActualType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphereFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphereFeatureActualType* SphereFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphereFeatureActualType (*this, f, c);
    }

    SphereFeatureActualType& SphereFeatureActualType::
    operator= (const SphereFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    SphereFeatureActualType::
    ~SphereFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SphereFeatureActualType >
    _xsd_SphereFeatureActualType_type_factory_init (
      "SphereFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // SphericalSegmentConstructionMethodType
    //

    SphericalSegmentConstructionMethodType::
    SphericalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    SphericalSegmentConstructionMethodType::
    SphericalSegmentConstructionMethodType (const SphericalSegmentConstructionMethodType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    SphericalSegmentConstructionMethodType::
    SphericalSegmentConstructionMethodType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentConstructionMethodType* SphericalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentConstructionMethodType (*this, f, c);
    }

    SphericalSegmentConstructionMethodType& SphericalSegmentConstructionMethodType::
    operator= (const SphericalSegmentConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    SphericalSegmentConstructionMethodType::
    ~SphericalSegmentConstructionMethodType ()
    {
    }

    // SphericalSegmentBestFitType
    //

    SphericalSegmentBestFitType::
    SphericalSegmentBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    SphericalSegmentBestFitType::
    SphericalSegmentBestFitType (const SphericalSegmentBestFitType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SphericalSegmentBestFitType::
    SphericalSegmentBestFitType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    SphericalSegmentBestFitType* SphericalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentBestFitType (*this, f, c);
    }

    SphericalSegmentBestFitType& SphericalSegmentBestFitType::
    operator= (const SphericalSegmentBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    SphericalSegmentBestFitType::
    ~SphericalSegmentBestFitType ()
    {
    }

    // SphericalSegmentRecompType
    //

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (const SphericalSegmentRecompType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    SphericalSegmentRecompType::
    SphericalSegmentRecompType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentRecompType* SphericalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentRecompType (*this, f, c);
    }

    SphericalSegmentRecompType& SphericalSegmentRecompType::
    operator= (const SphericalSegmentRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    SphericalSegmentRecompType::
    ~SphericalSegmentRecompType ()
    {
    }

    // SphericalSegmentCopyType
    //

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (const BaseSphericalSegment_type& BaseSphericalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (BaseSphericalSegment, this)
    {
    }

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (::std::auto_ptr< BaseSphericalSegment_type > BaseSphericalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (BaseSphericalSegment, this)
    {
    }

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (const SphericalSegmentCopyType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSphericalSegment_ (x.BaseSphericalSegment_, f, this)
    {
    }

    SphericalSegmentCopyType::
    SphericalSegmentCopyType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphericalSegment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSphericalSegment
        //
        if (n.name () == "BaseSphericalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSphericalSegment_type > r (
            BaseSphericalSegment_traits::create (i, f, this));

          if (!BaseSphericalSegment_.present ())
          {
            this->BaseSphericalSegment_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSphericalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSphericalSegment",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentCopyType* SphericalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCopyType (*this, f, c);
    }

    SphericalSegmentCopyType& SphericalSegmentCopyType::
    operator= (const SphericalSegmentCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSphericalSegment_ = x.BaseSphericalSegment_;
      }

      return *this;
    }

    SphericalSegmentCopyType::
    ~SphericalSegmentCopyType ()
    {
    }

    // SphericalSegmentCastType
    //

    SphericalSegmentCastType::
    SphericalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    SphericalSegmentCastType::
    SphericalSegmentCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    SphericalSegmentCastType::
    SphericalSegmentCastType (const SphericalSegmentCastType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SphericalSegmentCastType::
    SphericalSegmentCastType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentCastType* SphericalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCastType (*this, f, c);
    }

    SphericalSegmentCastType& SphericalSegmentCastType::
    operator= (const SphericalSegmentCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    SphericalSegmentCastType::
    ~SphericalSegmentCastType ()
    {
    }

    // SphericalSegmentTransformType
    //

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (const BaseSphericalSegment_type& BaseSphericalSegment,
                                   const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (BaseSphericalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (::std::auto_ptr< BaseSphericalSegment_type > BaseSphericalSegment,
                                   ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSphericalSegment_ (BaseSphericalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (const SphericalSegmentTransformType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSphericalSegment_ (x.BaseSphericalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    SphericalSegmentTransformType::
    SphericalSegmentTransformType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSphericalSegment_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSphericalSegment
        //
        if (n.name () == "BaseSphericalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSphericalSegment_type > r (
            BaseSphericalSegment_traits::create (i, f, this));

          if (!BaseSphericalSegment_.present ())
          {
            this->BaseSphericalSegment_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSphericalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSphericalSegment",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentTransformType* SphericalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentTransformType (*this, f, c);
    }

    SphericalSegmentTransformType& SphericalSegmentTransformType::
    operator= (const SphericalSegmentTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSphericalSegment_ = x.BaseSphericalSegment_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    SphericalSegmentTransformType::
    ~SphericalSegmentTransformType ()
    {
    }

    // SphericalSegmentCheckedType
    //

    SphericalSegmentCheckedType::
    SphericalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    SphericalSegmentCheckedType::
    SphericalSegmentCheckedType (const SphericalSegmentCheckedType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SphericalSegmentCheckedType::
    SphericalSegmentCheckedType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentCheckedType* SphericalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCheckedType (*this, f, c);
    }

    SphericalSegmentCheckedType& SphericalSegmentCheckedType::
    operator= (const SphericalSegmentCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    SphericalSegmentCheckedType::
    ~SphericalSegmentCheckedType ()
    {
    }

    // SphericalSegmentCheckedFeatureType
    //

    SphericalSegmentCheckedFeatureType::
    SphericalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    SphericalSegmentCheckedFeatureType::
    SphericalSegmentCheckedFeatureType (const SphericalSegmentCheckedFeatureType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    SphericalSegmentCheckedFeatureType::
    SphericalSegmentCheckedFeatureType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentCheckedFeatureType* SphericalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentCheckedFeatureType (*this, f, c);
    }

    SphericalSegmentCheckedFeatureType& SphericalSegmentCheckedFeatureType::
    operator= (const SphericalSegmentCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    SphericalSegmentCheckedFeatureType::
    ~SphericalSegmentCheckedFeatureType ()
    {
    }

    // SphericalSegmentActualDeterminationType
    //

    SphericalSegmentActualDeterminationType::
    SphericalSegmentActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    SphericalSegmentActualDeterminationType::
    SphericalSegmentActualDeterminationType (const SphericalSegmentActualDeterminationType& x,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    SphericalSegmentActualDeterminationType::
    SphericalSegmentActualDeterminationType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::flags f,
                                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SphericalSegmentActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentActualDeterminationType* SphericalSegmentActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentActualDeterminationType (*this, f, c);
    }

    SphericalSegmentActualDeterminationType& SphericalSegmentActualDeterminationType::
    operator= (const SphericalSegmentActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    SphericalSegmentActualDeterminationType::
    ~SphericalSegmentActualDeterminationType ()
    {
    }

    // SphericalSegmentFeatureItemType
    //

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const id_type& id,
                                     const FeatureName_type& FeatureName,
                                     const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const id_type& id,
                                     const FeatureName_type& FeatureName,
                                     ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const SphericalSegmentFeatureItemType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    SphericalSegmentFeatureItemType::
    SphericalSegmentFeatureItemType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentFeatureItemType* SphericalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureItemType (*this, f, c);
    }

    SphericalSegmentFeatureItemType& SphericalSegmentFeatureItemType::
    operator= (const SphericalSegmentFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    SphericalSegmentFeatureItemType::
    ~SphericalSegmentFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SphericalSegmentFeatureItemType >
    _xsd_SphericalSegmentFeatureItemType_type_factory_init (
      "SphericalSegmentFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // SphericalSegmentFeatureDefinitionType
    //

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const id_type& id,
                                           const InternalExternal_type& InternalExternal,
                                           const Diameter_type& Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this)
    {
    }

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const id_type& id,
                                           const InternalExternal_type& InternalExternal,
                                           ::std::auto_ptr< Diameter_type > Diameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Diameter_ (Diameter, this)
    {
    }

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const SphericalSegmentFeatureDefinitionType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Diameter_ (x.Diameter_, f, this)
    {
    }

    SphericalSegmentFeatureDefinitionType::
    SphericalSegmentFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Diameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!Diameter_.present ())
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Diameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentFeatureDefinitionType* SphericalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureDefinitionType (*this, f, c);
    }

    SphericalSegmentFeatureDefinitionType& SphericalSegmentFeatureDefinitionType::
    operator= (const SphericalSegmentFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Diameter_ = x.Diameter_;
      }

      return *this;
    }

    SphericalSegmentFeatureDefinitionType::
    ~SphericalSegmentFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SphericalSegmentFeatureDefinitionType >
    _xsd_SphericalSegmentFeatureDefinitionType_type_factory_init (
      "SphericalSegmentFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // SphericalSegmentFeatureNominalType
    //

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const id_type& id,
                                        const FeatureDefinitionId_type& FeatureDefinitionId,
                                        const Location_type& Location,
                                        const LatitudeLongitudeSweep_type& LatitudeLongitudeSweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, this)
    {
    }

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const id_type& id,
                                        const FeatureDefinitionId_type& FeatureDefinitionId,
                                        ::std::auto_ptr< Location_type > Location,
                                        ::std::auto_ptr< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, this)
    {
    }

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const SphericalSegmentFeatureNominalType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this)
    {
    }

    SphericalSegmentFeatureNominalType::
    SphericalSegmentFeatureNominalType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      LatitudeLongitudeSweep_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!LatitudeLongitudeSweep_.present ())
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!LatitudeLongitudeSweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LatitudeLongitudeSweep",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SphericalSegmentFeatureNominalType* SphericalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureNominalType (*this, f, c);
    }

    SphericalSegmentFeatureNominalType& SphericalSegmentFeatureNominalType::
    operator= (const SphericalSegmentFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
      }

      return *this;
    }

    SphericalSegmentFeatureNominalType::
    ~SphericalSegmentFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SphericalSegmentFeatureNominalType >
    _xsd_SphericalSegmentFeatureNominalType_type_factory_init (
      "SphericalSegmentFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // SphericalSegmentFeatureActualType
    //

    SphericalSegmentFeatureActualType::
    SphericalSegmentFeatureActualType (const id_type& id,
                                       const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
    }

    SphericalSegmentFeatureActualType::
    SphericalSegmentFeatureActualType (const id_type& id,
                                       ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
    }

    SphericalSegmentFeatureActualType::
    SphericalSegmentFeatureActualType (const SphericalSegmentFeatureActualType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Diameter_ (x.Diameter_, f, this),
      DiameterMin_ (x.DiameterMin_, f, this),
      DiameterMax_ (x.DiameterMax_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    SphericalSegmentFeatureActualType::
    SphericalSegmentFeatureActualType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Diameter_ (this),
      DiameterMin_ (this),
      DiameterMax_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SphericalSegmentFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Diameter
        //
        if (n.name () == "Diameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Diameter_type > r (
            Diameter_traits::create (i, f, this));

          if (!this->Diameter_)
          {
            this->Diameter_.set (r);
            continue;
          }
        }

        // DiameterMin
        //
        if (n.name () == "DiameterMin" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMin_type > r (
            DiameterMin_traits::create (i, f, this));

          if (!this->DiameterMin_)
          {
            this->DiameterMin_.set (r);
            continue;
          }
        }

        // DiameterMax
        //
        if (n.name () == "DiameterMax" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DiameterMax_type > r (
            DiameterMax_traits::create (i, f, this));

          if (!this->DiameterMax_)
          {
            this->DiameterMax_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SphericalSegmentFeatureActualType* SphericalSegmentFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SphericalSegmentFeatureActualType (*this, f, c);
    }

    SphericalSegmentFeatureActualType& SphericalSegmentFeatureActualType::
    operator= (const SphericalSegmentFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Diameter_ = x.Diameter_;
        this->DiameterMin_ = x.DiameterMin_;
        this->DiameterMax_ = x.DiameterMax_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    SphericalSegmentFeatureActualType::
    ~SphericalSegmentFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SphericalSegmentFeatureActualType >
    _xsd_SphericalSegmentFeatureActualType_type_factory_init (
      "SphericalSegmentFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // SurfaceOfRevolutionConstructionMethodType
    //

    SurfaceOfRevolutionConstructionMethodType::
    SurfaceOfRevolutionConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    SurfaceOfRevolutionConstructionMethodType::
    SurfaceOfRevolutionConstructionMethodType (const SurfaceOfRevolutionConstructionMethodType& x,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    SurfaceOfRevolutionConstructionMethodType::
    SurfaceOfRevolutionConstructionMethodType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionConstructionMethodType* SurfaceOfRevolutionConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionConstructionMethodType (*this, f, c);
    }

    SurfaceOfRevolutionConstructionMethodType& SurfaceOfRevolutionConstructionMethodType::
    operator= (const SurfaceOfRevolutionConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    SurfaceOfRevolutionConstructionMethodType::
    ~SurfaceOfRevolutionConstructionMethodType ()
    {
    }

    // SurfaceOfRevolutionBestFitType
    //

    SurfaceOfRevolutionBestFitType::
    SurfaceOfRevolutionBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    SurfaceOfRevolutionBestFitType::
    SurfaceOfRevolutionBestFitType (const SurfaceOfRevolutionBestFitType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SurfaceOfRevolutionBestFitType::
    SurfaceOfRevolutionBestFitType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    SurfaceOfRevolutionBestFitType* SurfaceOfRevolutionBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionBestFitType (*this, f, c);
    }

    SurfaceOfRevolutionBestFitType& SurfaceOfRevolutionBestFitType::
    operator= (const SurfaceOfRevolutionBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    SurfaceOfRevolutionBestFitType::
    ~SurfaceOfRevolutionBestFitType ()
    {
    }

    // SurfaceOfRevolutionRecompType
    //

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (const SurfaceOfRevolutionRecompType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    SurfaceOfRevolutionRecompType::
    SurfaceOfRevolutionRecompType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionRecompType* SurfaceOfRevolutionRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionRecompType (*this, f, c);
    }

    SurfaceOfRevolutionRecompType& SurfaceOfRevolutionRecompType::
    operator= (const SurfaceOfRevolutionRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    SurfaceOfRevolutionRecompType::
    ~SurfaceOfRevolutionRecompType ()
    {
    }

    // SurfaceOfRevolutionCopyType
    //

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (const BaseSurfaceOfRevolution_type& BaseSurfaceOfRevolution)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (BaseSurfaceOfRevolution, this)
    {
    }

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (::std::auto_ptr< BaseSurfaceOfRevolution_type > BaseSurfaceOfRevolution)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (BaseSurfaceOfRevolution, this)
    {
    }

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (const SurfaceOfRevolutionCopyType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSurfaceOfRevolution_ (x.BaseSurfaceOfRevolution_, f, this)
    {
    }

    SurfaceOfRevolutionCopyType::
    SurfaceOfRevolutionCopyType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSurfaceOfRevolution_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSurfaceOfRevolution
        //
        if (n.name () == "BaseSurfaceOfRevolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSurfaceOfRevolution_type > r (
            BaseSurfaceOfRevolution_traits::create (i, f, this));

          if (!BaseSurfaceOfRevolution_.present ())
          {
            this->BaseSurfaceOfRevolution_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSurfaceOfRevolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSurfaceOfRevolution",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionCopyType* SurfaceOfRevolutionCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCopyType (*this, f, c);
    }

    SurfaceOfRevolutionCopyType& SurfaceOfRevolutionCopyType::
    operator= (const SurfaceOfRevolutionCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSurfaceOfRevolution_ = x.BaseSurfaceOfRevolution_;
      }

      return *this;
    }

    SurfaceOfRevolutionCopyType::
    ~SurfaceOfRevolutionCopyType ()
    {
    }

    // SurfaceOfRevolutionCastType
    //

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (const SurfaceOfRevolutionCastType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    SurfaceOfRevolutionCastType::
    SurfaceOfRevolutionCastType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionCastType* SurfaceOfRevolutionCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCastType (*this, f, c);
    }

    SurfaceOfRevolutionCastType& SurfaceOfRevolutionCastType::
    operator= (const SurfaceOfRevolutionCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    SurfaceOfRevolutionCastType::
    ~SurfaceOfRevolutionCastType ()
    {
    }

    // SurfaceOfRevolutionTransformType
    //

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (const BaseSurfaceOfRevolution_type& BaseSurfaceOfRevolution,
                                      const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (BaseSurfaceOfRevolution, this),
      Transformation_ (Transformation, this)
    {
    }

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (::std::auto_ptr< BaseSurfaceOfRevolution_type > BaseSurfaceOfRevolution,
                                      ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseSurfaceOfRevolution_ (BaseSurfaceOfRevolution, this),
      Transformation_ (Transformation, this)
    {
    }

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (const SurfaceOfRevolutionTransformType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseSurfaceOfRevolution_ (x.BaseSurfaceOfRevolution_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    SurfaceOfRevolutionTransformType::
    SurfaceOfRevolutionTransformType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseSurfaceOfRevolution_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseSurfaceOfRevolution
        //
        if (n.name () == "BaseSurfaceOfRevolution" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseSurfaceOfRevolution_type > r (
            BaseSurfaceOfRevolution_traits::create (i, f, this));

          if (!BaseSurfaceOfRevolution_.present ())
          {
            this->BaseSurfaceOfRevolution_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseSurfaceOfRevolution_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseSurfaceOfRevolution",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionTransformType* SurfaceOfRevolutionTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionTransformType (*this, f, c);
    }

    SurfaceOfRevolutionTransformType& SurfaceOfRevolutionTransformType::
    operator= (const SurfaceOfRevolutionTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseSurfaceOfRevolution_ = x.BaseSurfaceOfRevolution_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    SurfaceOfRevolutionTransformType::
    ~SurfaceOfRevolutionTransformType ()
    {
    }

    // SurfaceOfRevolutionCheckedType
    //

    SurfaceOfRevolutionCheckedType::
    SurfaceOfRevolutionCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    SurfaceOfRevolutionCheckedType::
    SurfaceOfRevolutionCheckedType (const SurfaceOfRevolutionCheckedType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    SurfaceOfRevolutionCheckedType::
    SurfaceOfRevolutionCheckedType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionCheckedType* SurfaceOfRevolutionCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCheckedType (*this, f, c);
    }

    SurfaceOfRevolutionCheckedType& SurfaceOfRevolutionCheckedType::
    operator= (const SurfaceOfRevolutionCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    SurfaceOfRevolutionCheckedType::
    ~SurfaceOfRevolutionCheckedType ()
    {
    }

    // SurfaceOfRevolutionCheckedFeatureType
    //

    SurfaceOfRevolutionCheckedFeatureType::
    SurfaceOfRevolutionCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    SurfaceOfRevolutionCheckedFeatureType::
    SurfaceOfRevolutionCheckedFeatureType (const SurfaceOfRevolutionCheckedFeatureType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    SurfaceOfRevolutionCheckedFeatureType::
    SurfaceOfRevolutionCheckedFeatureType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionCheckedFeatureType* SurfaceOfRevolutionCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionCheckedFeatureType (*this, f, c);
    }

    SurfaceOfRevolutionCheckedFeatureType& SurfaceOfRevolutionCheckedFeatureType::
    operator= (const SurfaceOfRevolutionCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    SurfaceOfRevolutionCheckedFeatureType::
    ~SurfaceOfRevolutionCheckedFeatureType ()
    {
    }

    // SurfaceOfRevolutionActualDeterminationType
    //

    SurfaceOfRevolutionActualDeterminationType::
    SurfaceOfRevolutionActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    SurfaceOfRevolutionActualDeterminationType::
    SurfaceOfRevolutionActualDeterminationType (const SurfaceOfRevolutionActualDeterminationType& x,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    SurfaceOfRevolutionActualDeterminationType::
    SurfaceOfRevolutionActualDeterminationType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::flags f,
                                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionActualDeterminationType* SurfaceOfRevolutionActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionActualDeterminationType (*this, f, c);
    }

    SurfaceOfRevolutionActualDeterminationType& SurfaceOfRevolutionActualDeterminationType::
    operator= (const SurfaceOfRevolutionActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    SurfaceOfRevolutionActualDeterminationType::
    ~SurfaceOfRevolutionActualDeterminationType ()
    {
    }

    // SurfaceOfRevolutionFeatureItemType
    //

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const id_type& id,
                                        const FeatureName_type& FeatureName,
                                        const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const id_type& id,
                                        const FeatureName_type& FeatureName,
                                        ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const SurfaceOfRevolutionFeatureItemType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureItemType::
    SurfaceOfRevolutionFeatureItemType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionFeatureItemType* SurfaceOfRevolutionFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureItemType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureItemType& SurfaceOfRevolutionFeatureItemType::
    operator= (const SurfaceOfRevolutionFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    SurfaceOfRevolutionFeatureItemType::
    ~SurfaceOfRevolutionFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SurfaceOfRevolutionFeatureItemType >
    _xsd_SurfaceOfRevolutionFeatureItemType_type_factory_init (
      "SurfaceOfRevolutionFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // SurfaceOfRevolutionFeatureDefinitionType
    //

    SurfaceOfRevolutionFeatureDefinitionType::
    SurfaceOfRevolutionFeatureDefinitionType (const id_type& id,
                                              const InternalExternal_type& InternalExternal)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      Length_ (this)
    {
    }

    SurfaceOfRevolutionFeatureDefinitionType::
    SurfaceOfRevolutionFeatureDefinitionType (const SurfaceOfRevolutionFeatureDefinitionType& x,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureDefinitionType::
    SurfaceOfRevolutionFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::flags f,
                                              ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      Length_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionFeatureDefinitionType* SurfaceOfRevolutionFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureDefinitionType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureDefinitionType& SurfaceOfRevolutionFeatureDefinitionType::
    operator= (const SurfaceOfRevolutionFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->Length_ = x.Length_;
      }

      return *this;
    }

    SurfaceOfRevolutionFeatureDefinitionType::
    ~SurfaceOfRevolutionFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SurfaceOfRevolutionFeatureDefinitionType >
    _xsd_SurfaceOfRevolutionFeatureDefinitionType_type_factory_init (
      "SurfaceOfRevolutionFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // SurfaceOfRevolutionFeatureNominalType
    //

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const id_type& id,
                                           const FeatureDefinitionId_type& FeatureDefinitionId,
                                           const Axis_type& Axis,
                                           const ReferenceFeatureNominalId_type& ReferenceFeatureNominalId)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (this),
      ReferenceFeatureNominalId_ (ReferenceFeatureNominalId, this)
    {
    }

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const id_type& id,
                                           const FeatureDefinitionId_type& FeatureDefinitionId,
                                           ::std::auto_ptr< Axis_type > Axis,
                                           ::std::auto_ptr< ReferenceFeatureNominalId_type > ReferenceFeatureNominalId)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this),
      Sweep_ (this),
      ReferenceFeatureNominalId_ (ReferenceFeatureNominalId, this)
    {
    }

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const SurfaceOfRevolutionFeatureNominalType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this),
      ReferenceFeatureNominalId_ (x.ReferenceFeatureNominalId_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureNominalType::
    SurfaceOfRevolutionFeatureNominalType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Sweep_ (this),
      ReferenceFeatureNominalId_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // ReferenceFeatureNominalId
        //
        if (n.name () == "ReferenceFeatureNominalId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ReferenceFeatureNominalId_type > r (
            ReferenceFeatureNominalId_traits::create (i, f, this));

          if (!ReferenceFeatureNominalId_.present ())
          {
            this->ReferenceFeatureNominalId_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ReferenceFeatureNominalId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ReferenceFeatureNominalId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    SurfaceOfRevolutionFeatureNominalType* SurfaceOfRevolutionFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureNominalType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureNominalType& SurfaceOfRevolutionFeatureNominalType::
    operator= (const SurfaceOfRevolutionFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
        this->ReferenceFeatureNominalId_ = x.ReferenceFeatureNominalId_;
      }

      return *this;
    }

    SurfaceOfRevolutionFeatureNominalType::
    ~SurfaceOfRevolutionFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SurfaceOfRevolutionFeatureNominalType >
    _xsd_SurfaceOfRevolutionFeatureNominalType_type_factory_init (
      "SurfaceOfRevolutionFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // SurfaceOfRevolutionFeatureActualType
    //

    SurfaceOfRevolutionFeatureActualType::
    SurfaceOfRevolutionFeatureActualType (const id_type& id,
                                          const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Sweep_ (this),
      Length_ (this),
      Form_ (this)
    {
    }

    SurfaceOfRevolutionFeatureActualType::
    SurfaceOfRevolutionFeatureActualType (const id_type& id,
                                          ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      Sweep_ (this),
      Length_ (this),
      Form_ (this)
    {
    }

    SurfaceOfRevolutionFeatureActualType::
    SurfaceOfRevolutionFeatureActualType (const SurfaceOfRevolutionFeatureActualType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      Sweep_ (x.Sweep_, f, this),
      Length_ (x.Length_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    SurfaceOfRevolutionFeatureActualType::
    SurfaceOfRevolutionFeatureActualType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      Sweep_ (this),
      Length_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SurfaceOfRevolutionFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // Sweep
        //
        if (n.name () == "Sweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Sweep_type > r (
            Sweep_traits::create (i, f, this));

          if (!this->Sweep_)
          {
            this->Sweep_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    SurfaceOfRevolutionFeatureActualType* SurfaceOfRevolutionFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SurfaceOfRevolutionFeatureActualType (*this, f, c);
    }

    SurfaceOfRevolutionFeatureActualType& SurfaceOfRevolutionFeatureActualType::
    operator= (const SurfaceOfRevolutionFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->Sweep_ = x.Sweep_;
        this->Length_ = x.Length_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    SurfaceOfRevolutionFeatureActualType::
    ~SurfaceOfRevolutionFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SurfaceOfRevolutionFeatureActualType >
    _xsd_SurfaceOfRevolutionFeatureActualType_type_factory_init (
      "SurfaceOfRevolutionFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // ThreadedFeatureConstructionMethodType
    //

    ThreadedFeatureConstructionMethodType::
    ThreadedFeatureConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromCylinder_ (this)
    {
    }

    ThreadedFeatureConstructionMethodType::
    ThreadedFeatureConstructionMethodType (const ThreadedFeatureConstructionMethodType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromCylinder_ (x.FromCylinder_, f, this)
    {
    }

    ThreadedFeatureConstructionMethodType::
    ThreadedFeatureConstructionMethodType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromCylinder_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromCylinder
        //
        if (n.name () == "FromCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromCylinder_type > r (
            FromCylinder_traits::create (i, f, this));

          if (!this->FromCylinder_)
          {
            this->FromCylinder_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureConstructionMethodType* ThreadedFeatureConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureConstructionMethodType (*this, f, c);
    }

    ThreadedFeatureConstructionMethodType& ThreadedFeatureConstructionMethodType::
    operator= (const ThreadedFeatureConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromCylinder_ = x.FromCylinder_;
      }

      return *this;
    }

    ThreadedFeatureConstructionMethodType::
    ~ThreadedFeatureConstructionMethodType ()
    {
    }

    // ThreadedFeatureBestFitType
    //

    ThreadedFeatureBestFitType::
    ThreadedFeatureBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ThreadedFeatureBestFitType::
    ThreadedFeatureBestFitType (const ThreadedFeatureBestFitType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ThreadedFeatureBestFitType::
    ThreadedFeatureBestFitType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ThreadedFeatureBestFitType* ThreadedFeatureBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureBestFitType (*this, f, c);
    }

    ThreadedFeatureBestFitType& ThreadedFeatureBestFitType::
    operator= (const ThreadedFeatureBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ThreadedFeatureBestFitType::
    ~ThreadedFeatureBestFitType ()
    {
    }

    // ThreadedFeatureRecompType
    //

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (const ThreadedFeatureRecompType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ThreadedFeatureRecompType::
    ThreadedFeatureRecompType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureRecompType* ThreadedFeatureRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureRecompType (*this, f, c);
    }

    ThreadedFeatureRecompType& ThreadedFeatureRecompType::
    operator= (const ThreadedFeatureRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ThreadedFeatureRecompType::
    ~ThreadedFeatureRecompType ()
    {
    }

    // ThreadedFeatureCopyType
    //

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (const BaseThreadedFeature_type& BaseThreadedFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (BaseThreadedFeature, this)
    {
    }

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (::std::auto_ptr< BaseThreadedFeature_type > BaseThreadedFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (BaseThreadedFeature, this)
    {
    }

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (const ThreadedFeatureCopyType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseThreadedFeature_ (x.BaseThreadedFeature_, f, this)
    {
    }

    ThreadedFeatureCopyType::
    ThreadedFeatureCopyType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseThreadedFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseThreadedFeature
        //
        if (n.name () == "BaseThreadedFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseThreadedFeature_type > r (
            BaseThreadedFeature_traits::create (i, f, this));

          if (!BaseThreadedFeature_.present ())
          {
            this->BaseThreadedFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseThreadedFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseThreadedFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureCopyType* ThreadedFeatureCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCopyType (*this, f, c);
    }

    ThreadedFeatureCopyType& ThreadedFeatureCopyType::
    operator= (const ThreadedFeatureCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseThreadedFeature_ = x.BaseThreadedFeature_;
      }

      return *this;
    }

    ThreadedFeatureCopyType::
    ~ThreadedFeatureCopyType ()
    {
    }

    // ThreadedFeatureCastType
    //

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (const ThreadedFeatureCastType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ThreadedFeatureCastType::
    ThreadedFeatureCastType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureCastType* ThreadedFeatureCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCastType (*this, f, c);
    }

    ThreadedFeatureCastType& ThreadedFeatureCastType::
    operator= (const ThreadedFeatureCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ThreadedFeatureCastType::
    ~ThreadedFeatureCastType ()
    {
    }

    // ThreadedFeatureTransformType
    //

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (const BaseThreadedFeature_type& BaseThreadedFeature,
                                  const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (BaseThreadedFeature, this),
      Transformation_ (Transformation, this)
    {
    }

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (::std::auto_ptr< BaseThreadedFeature_type > BaseThreadedFeature,
                                  ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseThreadedFeature_ (BaseThreadedFeature, this),
      Transformation_ (Transformation, this)
    {
    }

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (const ThreadedFeatureTransformType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseThreadedFeature_ (x.BaseThreadedFeature_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ThreadedFeatureTransformType::
    ThreadedFeatureTransformType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseThreadedFeature_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseThreadedFeature
        //
        if (n.name () == "BaseThreadedFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseThreadedFeature_type > r (
            BaseThreadedFeature_traits::create (i, f, this));

          if (!BaseThreadedFeature_.present ())
          {
            this->BaseThreadedFeature_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseThreadedFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseThreadedFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureTransformType* ThreadedFeatureTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureTransformType (*this, f, c);
    }

    ThreadedFeatureTransformType& ThreadedFeatureTransformType::
    operator= (const ThreadedFeatureTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseThreadedFeature_ = x.BaseThreadedFeature_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ThreadedFeatureTransformType::
    ~ThreadedFeatureTransformType ()
    {
    }

    // ThreadedFeatureFromCylinderType
    //

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (const BaseCylinder_type& BaseCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, this),
      Offset_ (this)
    {
    }

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (::std::auto_ptr< BaseCylinder_type > BaseCylinder)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseCylinder_ (BaseCylinder, this),
      Offset_ (this)
    {
    }

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (const ThreadedFeatureFromCylinderType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseCylinder_ (x.BaseCylinder_, f, this),
      Offset_ (x.Offset_, f, this)
    {
    }

    ThreadedFeatureFromCylinderType::
    ThreadedFeatureFromCylinderType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseCylinder_ (this),
      Offset_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureFromCylinderType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseCylinder
        //
        if (n.name () == "BaseCylinder" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseCylinder_type > r (
            BaseCylinder_traits::create (i, f, this));

          if (!BaseCylinder_.present ())
          {
            this->BaseCylinder_.set (r);
            continue;
          }
        }

        // Offset
        //
        if (n.name () == "Offset" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Offset_type > r (
            Offset_traits::create (i, f, this));

          if (!this->Offset_)
          {
            this->Offset_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseCylinder_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseCylinder",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureFromCylinderType* ThreadedFeatureFromCylinderType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureFromCylinderType (*this, f, c);
    }

    ThreadedFeatureFromCylinderType& ThreadedFeatureFromCylinderType::
    operator= (const ThreadedFeatureFromCylinderType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseCylinder_ = x.BaseCylinder_;
        this->Offset_ = x.Offset_;
      }

      return *this;
    }

    ThreadedFeatureFromCylinderType::
    ~ThreadedFeatureFromCylinderType ()
    {
    }

    // ThreadedFeatureCheckedType
    //

    ThreadedFeatureCheckedType::
    ThreadedFeatureCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ThreadedFeatureCheckedType::
    ThreadedFeatureCheckedType (const ThreadedFeatureCheckedType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ThreadedFeatureCheckedType::
    ThreadedFeatureCheckedType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureCheckedType* ThreadedFeatureCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCheckedType (*this, f, c);
    }

    ThreadedFeatureCheckedType& ThreadedFeatureCheckedType::
    operator= (const ThreadedFeatureCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ThreadedFeatureCheckedType::
    ~ThreadedFeatureCheckedType ()
    {
    }

    // ThreadedFeatureCheckedFeatureType
    //

    ThreadedFeatureCheckedFeatureType::
    ThreadedFeatureCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ThreadedFeatureCheckedFeatureType::
    ThreadedFeatureCheckedFeatureType (const ThreadedFeatureCheckedFeatureType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ThreadedFeatureCheckedFeatureType::
    ThreadedFeatureCheckedFeatureType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureCheckedFeatureType* ThreadedFeatureCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureCheckedFeatureType (*this, f, c);
    }

    ThreadedFeatureCheckedFeatureType& ThreadedFeatureCheckedFeatureType::
    operator= (const ThreadedFeatureCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ThreadedFeatureCheckedFeatureType::
    ~ThreadedFeatureCheckedFeatureType ()
    {
    }

    // ThreadedFeatureActualDeterminationType
    //

    ThreadedFeatureActualDeterminationType::
    ThreadedFeatureActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ThreadedFeatureActualDeterminationType::
    ThreadedFeatureActualDeterminationType (const ThreadedFeatureActualDeterminationType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ThreadedFeatureActualDeterminationType::
    ThreadedFeatureActualDeterminationType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureActualDeterminationType* ThreadedFeatureActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureActualDeterminationType (*this, f, c);
    }

    ThreadedFeatureActualDeterminationType& ThreadedFeatureActualDeterminationType::
    operator= (const ThreadedFeatureActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ThreadedFeatureActualDeterminationType::
    ~ThreadedFeatureActualDeterminationType ()
    {
    }

    // ThreadedFeatureItemType
    //

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const id_type& id,
                             const FeatureName_type& FeatureName,
                             const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const id_type& id,
                             const FeatureName_type& FeatureName,
                             ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const ThreadedFeatureItemType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ThreadedFeatureItemType::
    ThreadedFeatureItemType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureItemType* ThreadedFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureItemType (*this, f, c);
    }

    ThreadedFeatureItemType& ThreadedFeatureItemType::
    operator= (const ThreadedFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    ThreadedFeatureItemType::
    ~ThreadedFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThreadedFeatureItemType >
    _xsd_ThreadedFeatureItemType_type_factory_init (
      "ThreadedFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // ThreadedFeatureDefinitionType
    //

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   const ThreadSpecificationId_type& ThreadSpecificationId)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      ThreadSpecificationId_ (ThreadSpecificationId, this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const id_type& id,
                                   const InternalExternal_type& InternalExternal,
                                   ::std::auto_ptr< ThreadSpecificationId_type > ThreadSpecificationId)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      ThreadSpecificationId_ (ThreadSpecificationId, this),
      Length_ (this),
      Bottom_ (this)
    {
    }

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const ThreadedFeatureDefinitionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      ThreadSpecificationId_ (x.ThreadSpecificationId_, f, this),
      Length_ (x.Length_, f, this),
      Bottom_ (x.Bottom_, f, this)
    {
    }

    ThreadedFeatureDefinitionType::
    ThreadedFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      ThreadSpecificationId_ (this),
      Length_ (this),
      Bottom_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // ThreadSpecificationId
        //
        if (n.name () == "ThreadSpecificationId" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< ThreadSpecificationId_type > r (
            ThreadSpecificationId_traits::create (i, f, this));

          if (!ThreadSpecificationId_.present ())
          {
            this->ThreadSpecificationId_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        // Bottom
        //
        if (n.name () == "Bottom" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Bottom_type > r (
            Bottom_traits::create (i, f, this));

          if (!this->Bottom_)
          {
            this->Bottom_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!ThreadSpecificationId_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ThreadSpecificationId",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureDefinitionType* ThreadedFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureDefinitionType (*this, f, c);
    }

    ThreadedFeatureDefinitionType& ThreadedFeatureDefinitionType::
    operator= (const ThreadedFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->ThreadSpecificationId_ = x.ThreadSpecificationId_;
        this->Length_ = x.Length_;
        this->Bottom_ = x.Bottom_;
      }

      return *this;
    }

    ThreadedFeatureDefinitionType::
    ~ThreadedFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThreadedFeatureDefinitionType >
    _xsd_ThreadedFeatureDefinitionType_type_factory_init (
      "ThreadedFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // ThreadedFeatureNominalType
    //

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                const Axis_type& Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this)
    {
    }

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                ::std::auto_ptr< Axis_type > Axis)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Axis_ (Axis, this)
    {
    }

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const ThreadedFeatureNominalType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Axis_ (x.Axis_, f, this)
    {
    }

    ThreadedFeatureNominalType::
    ThreadedFeatureNominalType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!Axis_.present ())
          {
            this->Axis_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Axis_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Axis",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ThreadedFeatureNominalType* ThreadedFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureNominalType (*this, f, c);
    }

    ThreadedFeatureNominalType& ThreadedFeatureNominalType::
    operator= (const ThreadedFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
      }

      return *this;
    }

    ThreadedFeatureNominalType::
    ~ThreadedFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThreadedFeatureNominalType >
    _xsd_ThreadedFeatureNominalType_type_factory_init (
      "ThreadedFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // ThreadedFeatureActualType
    //

    ThreadedFeatureActualType::
    ThreadedFeatureActualType (const id_type& id,
                               const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      PitchDiameter_ (this),
      FunctionalSize_ (this),
      Length_ (this)
    {
    }

    ThreadedFeatureActualType::
    ThreadedFeatureActualType (const id_type& id,
                               ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Axis_ (this),
      PitchDiameter_ (this),
      FunctionalSize_ (this),
      Length_ (this)
    {
    }

    ThreadedFeatureActualType::
    ThreadedFeatureActualType (const ThreadedFeatureActualType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Axis_ (x.Axis_, f, this),
      PitchDiameter_ (x.PitchDiameter_, f, this),
      FunctionalSize_ (x.FunctionalSize_, f, this),
      Length_ (x.Length_, f, this)
    {
    }

    ThreadedFeatureActualType::
    ThreadedFeatureActualType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Axis_ (this),
      PitchDiameter_ (this),
      FunctionalSize_ (this),
      Length_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ThreadedFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Axis
        //
        if (n.name () == "Axis" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Axis_type > r (
            Axis_traits::create (i, f, this));

          if (!this->Axis_)
          {
            this->Axis_.set (r);
            continue;
          }
        }

        // PitchDiameter
        //
        if (n.name () == "PitchDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< PitchDiameter_type > r (
            PitchDiameter_traits::create (i, f, this));

          if (!this->PitchDiameter_)
          {
            this->PitchDiameter_.set (r);
            continue;
          }
        }

        // FunctionalSize
        //
        if (n.name () == "FunctionalSize" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FunctionalSize_type > r (
            FunctionalSize_traits::create (i, f, this));

          if (!this->FunctionalSize_)
          {
            this->FunctionalSize_.set (r);
            continue;
          }
        }

        // Length
        //
        if (n.name () == "Length" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Length_type > r (
            Length_traits::create (i, f, this));

          if (!this->Length_)
          {
            this->Length_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ThreadedFeatureActualType* ThreadedFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ThreadedFeatureActualType (*this, f, c);
    }

    ThreadedFeatureActualType& ThreadedFeatureActualType::
    operator= (const ThreadedFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Axis_ = x.Axis_;
        this->PitchDiameter_ = x.PitchDiameter_;
        this->FunctionalSize_ = x.FunctionalSize_;
        this->Length_ = x.Length_;
      }

      return *this;
    }

    ThreadedFeatureActualType::
    ~ThreadedFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThreadedFeatureActualType >
    _xsd_ThreadedFeatureActualType_type_factory_init (
      "ThreadedFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // ToroidalSegmentConstructionMethodType
    //

    ToroidalSegmentConstructionMethodType::
    ToroidalSegmentConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
    }

    ToroidalSegmentConstructionMethodType::
    ToroidalSegmentConstructionMethodType (const ToroidalSegmentConstructionMethodType& x,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this)
    {
    }

    ToroidalSegmentConstructionMethodType::
    ToroidalSegmentConstructionMethodType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f,
                                           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentConstructionMethodType* ToroidalSegmentConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentConstructionMethodType (*this, f, c);
    }

    ToroidalSegmentConstructionMethodType& ToroidalSegmentConstructionMethodType::
    operator= (const ToroidalSegmentConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
      }

      return *this;
    }

    ToroidalSegmentConstructionMethodType::
    ~ToroidalSegmentConstructionMethodType ()
    {
    }

    // ToroidalSegmentBestFitType
    //

    ToroidalSegmentBestFitType::
    ToroidalSegmentBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    ToroidalSegmentBestFitType::
    ToroidalSegmentBestFitType (const ToroidalSegmentBestFitType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ToroidalSegmentBestFitType::
    ToroidalSegmentBestFitType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    ToroidalSegmentBestFitType* ToroidalSegmentBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentBestFitType (*this, f, c);
    }

    ToroidalSegmentBestFitType& ToroidalSegmentBestFitType::
    operator= (const ToroidalSegmentBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ToroidalSegmentBestFitType::
    ~ToroidalSegmentBestFitType ()
    {
    }

    // ToroidalSegmentRecompType
    //

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (const ToroidalSegmentRecompType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    ToroidalSegmentRecompType::
    ToroidalSegmentRecompType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentRecompType* ToroidalSegmentRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentRecompType (*this, f, c);
    }

    ToroidalSegmentRecompType& ToroidalSegmentRecompType::
    operator= (const ToroidalSegmentRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    ToroidalSegmentRecompType::
    ~ToroidalSegmentRecompType ()
    {
    }

    // ToroidalSegmentCopyType
    //

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (const BaseToroidalSegment_type& BaseToroidalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (BaseToroidalSegment, this)
    {
    }

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (::std::auto_ptr< BaseToroidalSegment_type > BaseToroidalSegment)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (BaseToroidalSegment, this)
    {
    }

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (const ToroidalSegmentCopyType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseToroidalSegment_ (x.BaseToroidalSegment_, f, this)
    {
    }

    ToroidalSegmentCopyType::
    ToroidalSegmentCopyType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseToroidalSegment_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseToroidalSegment
        //
        if (n.name () == "BaseToroidalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseToroidalSegment_type > r (
            BaseToroidalSegment_traits::create (i, f, this));

          if (!BaseToroidalSegment_.present ())
          {
            this->BaseToroidalSegment_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseToroidalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseToroidalSegment",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentCopyType* ToroidalSegmentCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCopyType (*this, f, c);
    }

    ToroidalSegmentCopyType& ToroidalSegmentCopyType::
    operator= (const ToroidalSegmentCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseToroidalSegment_ = x.BaseToroidalSegment_;
      }

      return *this;
    }

    ToroidalSegmentCopyType::
    ~ToroidalSegmentCopyType ()
    {
    }

    // ToroidalSegmentCastType
    //

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (const ToroidalSegmentCastType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    ToroidalSegmentCastType::
    ToroidalSegmentCastType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentCastType* ToroidalSegmentCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCastType (*this, f, c);
    }

    ToroidalSegmentCastType& ToroidalSegmentCastType::
    operator= (const ToroidalSegmentCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    ToroidalSegmentCastType::
    ~ToroidalSegmentCastType ()
    {
    }

    // ToroidalSegmentTransformType
    //

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (const BaseToroidalSegment_type& BaseToroidalSegment,
                                  const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (BaseToroidalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (::std::auto_ptr< BaseToroidalSegment_type > BaseToroidalSegment,
                                  ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseToroidalSegment_ (BaseToroidalSegment, this),
      Transformation_ (Transformation, this)
    {
    }

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (const ToroidalSegmentTransformType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseToroidalSegment_ (x.BaseToroidalSegment_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    ToroidalSegmentTransformType::
    ToroidalSegmentTransformType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseToroidalSegment_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseToroidalSegment
        //
        if (n.name () == "BaseToroidalSegment" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseToroidalSegment_type > r (
            BaseToroidalSegment_traits::create (i, f, this));

          if (!BaseToroidalSegment_.present ())
          {
            this->BaseToroidalSegment_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseToroidalSegment_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseToroidalSegment",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentTransformType* ToroidalSegmentTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentTransformType (*this, f, c);
    }

    ToroidalSegmentTransformType& ToroidalSegmentTransformType::
    operator= (const ToroidalSegmentTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseToroidalSegment_ = x.BaseToroidalSegment_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    ToroidalSegmentTransformType::
    ~ToroidalSegmentTransformType ()
    {
    }

    // ToroidalSegmentCheckedType
    //

    ToroidalSegmentCheckedType::
    ToroidalSegmentCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    ToroidalSegmentCheckedType::
    ToroidalSegmentCheckedType (const ToroidalSegmentCheckedType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    ToroidalSegmentCheckedType::
    ToroidalSegmentCheckedType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentCheckedType* ToroidalSegmentCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCheckedType (*this, f, c);
    }

    ToroidalSegmentCheckedType& ToroidalSegmentCheckedType::
    operator= (const ToroidalSegmentCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    ToroidalSegmentCheckedType::
    ~ToroidalSegmentCheckedType ()
    {
    }

    // ToroidalSegmentCheckedFeatureType
    //

    ToroidalSegmentCheckedFeatureType::
    ToroidalSegmentCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    ToroidalSegmentCheckedFeatureType::
    ToroidalSegmentCheckedFeatureType (const ToroidalSegmentCheckedFeatureType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    ToroidalSegmentCheckedFeatureType::
    ToroidalSegmentCheckedFeatureType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentCheckedFeatureType* ToroidalSegmentCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentCheckedFeatureType (*this, f, c);
    }

    ToroidalSegmentCheckedFeatureType& ToroidalSegmentCheckedFeatureType::
    operator= (const ToroidalSegmentCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    ToroidalSegmentCheckedFeatureType::
    ~ToroidalSegmentCheckedFeatureType ()
    {
    }

    // ToroidalSegmentActualDeterminationType
    //

    ToroidalSegmentActualDeterminationType::
    ToroidalSegmentActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    ToroidalSegmentActualDeterminationType::
    ToroidalSegmentActualDeterminationType (const ToroidalSegmentActualDeterminationType& x,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    ToroidalSegmentActualDeterminationType::
    ToroidalSegmentActualDeterminationType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::flags f,
                                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentActualDeterminationType* ToroidalSegmentActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentActualDeterminationType (*this, f, c);
    }

    ToroidalSegmentActualDeterminationType& ToroidalSegmentActualDeterminationType::
    operator= (const ToroidalSegmentActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    ToroidalSegmentActualDeterminationType::
    ~ToroidalSegmentActualDeterminationType ()
    {
    }

    // ToroidalSegmentFeatureItemType
    //

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const id_type& id,
                                    const FeatureName_type& FeatureName,
                                    const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const id_type& id,
                                    const FeatureName_type& FeatureName,
                                    ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const ToroidalSegmentFeatureItemType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    ToroidalSegmentFeatureItemType::
    ToroidalSegmentFeatureItemType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentFeatureItemType* ToroidalSegmentFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureItemType (*this, f, c);
    }

    ToroidalSegmentFeatureItemType& ToroidalSegmentFeatureItemType::
    operator= (const ToroidalSegmentFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    ToroidalSegmentFeatureItemType::
    ~ToroidalSegmentFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ToroidalSegmentFeatureItemType >
    _xsd_ToroidalSegmentFeatureItemType_type_factory_init (
      "ToroidalSegmentFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // ToroidalSegmentFeatureDefinitionType
    //

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const id_type& id,
                                          const InternalExternal_type& InternalExternal,
                                          const MinorDiameter_type& MinorDiameter,
                                          const MajorDiameter_type& MajorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MinorDiameter_ (MinorDiameter, this),
      MajorDiameter_ (MajorDiameter, this)
    {
    }

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const id_type& id,
                                          const InternalExternal_type& InternalExternal,
                                          ::std::auto_ptr< MinorDiameter_type > MinorDiameter,
                                          ::std::auto_ptr< MajorDiameter_type > MajorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MinorDiameter_ (MinorDiameter, this),
      MajorDiameter_ (MajorDiameter, this)
    {
    }

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const ToroidalSegmentFeatureDefinitionType& x,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this)
    {
    }

    ToroidalSegmentFeatureDefinitionType::
    ToroidalSegmentFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f,
                                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!MinorDiameter_.present ())
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!MajorDiameter_.present ())
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MinorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MinorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MajorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MajorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentFeatureDefinitionType* ToroidalSegmentFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureDefinitionType (*this, f, c);
    }

    ToroidalSegmentFeatureDefinitionType& ToroidalSegmentFeatureDefinitionType::
    operator= (const ToroidalSegmentFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->MinorDiameter_ = x.MinorDiameter_;
        this->MajorDiameter_ = x.MajorDiameter_;
      }

      return *this;
    }

    ToroidalSegmentFeatureDefinitionType::
    ~ToroidalSegmentFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ToroidalSegmentFeatureDefinitionType >
    _xsd_ToroidalSegmentFeatureDefinitionType_type_factory_init (
      "ToroidalSegmentFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // ToroidalSegmentFeatureNominalType
    //

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const id_type& id,
                                       const FeatureDefinitionId_type& FeatureDefinitionId,
                                       const Location_type& Location,
                                       const AxisVector_type& AxisVector,
                                       const LatitudeLongitudeSweep_type& LatitudeLongitudeSweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      AxisVector_ (AxisVector, this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, this)
    {
    }

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const id_type& id,
                                       const FeatureDefinitionId_type& FeatureDefinitionId,
                                       ::std::auto_ptr< Location_type > Location,
                                       ::std::auto_ptr< AxisVector_type > AxisVector,
                                       ::std::auto_ptr< LatitudeLongitudeSweep_type > LatitudeLongitudeSweep)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      AxisVector_ (AxisVector, this),
      LatitudeLongitudeSweep_ (LatitudeLongitudeSweep, this)
    {
    }

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const ToroidalSegmentFeatureNominalType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this)
    {
    }

    ToroidalSegmentFeatureNominalType::
    ToroidalSegmentFeatureNominalType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      AxisVector_ (this),
      LatitudeLongitudeSweep_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == "AxisVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!AxisVector_.present ())
          {
            this->AxisVector_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!LatitudeLongitudeSweep_.present ())
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!AxisVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AxisVector",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!LatitudeLongitudeSweep_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "LatitudeLongitudeSweep",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    ToroidalSegmentFeatureNominalType* ToroidalSegmentFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureNominalType (*this, f, c);
    }

    ToroidalSegmentFeatureNominalType& ToroidalSegmentFeatureNominalType::
    operator= (const ToroidalSegmentFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->AxisVector_ = x.AxisVector_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
      }

      return *this;
    }

    ToroidalSegmentFeatureNominalType::
    ~ToroidalSegmentFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ToroidalSegmentFeatureNominalType >
    _xsd_ToroidalSegmentFeatureNominalType_type_factory_init (
      "ToroidalSegmentFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // ToroidalSegmentFeatureActualType
    //

    ToroidalSegmentFeatureActualType::
    ToroidalSegmentFeatureActualType (const id_type& id,
                                      const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
    }

    ToroidalSegmentFeatureActualType::
    ToroidalSegmentFeatureActualType (const id_type& id,
                                      ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
    }

    ToroidalSegmentFeatureActualType::
    ToroidalSegmentFeatureActualType (const ToroidalSegmentFeatureActualType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    ToroidalSegmentFeatureActualType::
    ToroidalSegmentFeatureActualType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ToroidalSegmentFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == "AxisVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!this->AxisVector_)
          {
            this->AxisVector_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!this->MinorDiameter_)
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!this->MajorDiameter_)
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    ToroidalSegmentFeatureActualType* ToroidalSegmentFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ToroidalSegmentFeatureActualType (*this, f, c);
    }

    ToroidalSegmentFeatureActualType& ToroidalSegmentFeatureActualType::
    operator= (const ToroidalSegmentFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->AxisVector_ = x.AxisVector_;
        this->MinorDiameter_ = x.MinorDiameter_;
        this->MajorDiameter_ = x.MajorDiameter_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    ToroidalSegmentFeatureActualType::
    ~ToroidalSegmentFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ToroidalSegmentFeatureActualType >
    _xsd_ToroidalSegmentFeatureActualType_type_factory_init (
      "ToroidalSegmentFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // TorusConstructionMethodType
    //

    TorusConstructionMethodType::
    TorusConstructionMethodType ()
    : ::xml_schema::type (),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
    }

    TorusConstructionMethodType::
    TorusConstructionMethodType (const TorusConstructionMethodType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      BestFit_ (x.BestFit_, f, this),
      Recompensated_ (x.Recompensated_, f, this),
      Copy_ (x.Copy_, f, this),
      Cast_ (x.Cast_, f, this),
      Transform_ (x.Transform_, f, this),
      FromScan_ (x.FromScan_, f, this)
    {
    }

    TorusConstructionMethodType::
    TorusConstructionMethodType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      BestFit_ (this),
      Recompensated_ (this),
      Copy_ (this),
      Cast_ (this),
      Transform_ (this),
      FromScan_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusConstructionMethodType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BestFit
        //
        if (n.name () == "BestFit" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BestFit_type > r (
            BestFit_traits::create (i, f, this));

          if (!this->BestFit_)
          {
            this->BestFit_.set (r);
            continue;
          }
        }

        // Recompensated
        //
        if (n.name () == "Recompensated" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Recompensated_type > r (
            Recompensated_traits::create (i, f, this));

          if (!this->Recompensated_)
          {
            this->Recompensated_.set (r);
            continue;
          }
        }

        // Copy
        //
        if (n.name () == "Copy" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Copy_type > r (
            Copy_traits::create (i, f, this));

          if (!this->Copy_)
          {
            this->Copy_.set (r);
            continue;
          }
        }

        // Cast
        //
        if (n.name () == "Cast" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Cast_type > r (
            Cast_traits::create (i, f, this));

          if (!this->Cast_)
          {
            this->Cast_.set (r);
            continue;
          }
        }

        // Transform
        //
        if (n.name () == "Transform" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transform_type > r (
            Transform_traits::create (i, f, this));

          if (!this->Transform_)
          {
            this->Transform_.set (r);
            continue;
          }
        }

        // FromScan
        //
        if (n.name () == "FromScan" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FromScan_type > r (
            FromScan_traits::create (i, f, this));

          if (!this->FromScan_)
          {
            this->FromScan_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusConstructionMethodType* TorusConstructionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusConstructionMethodType (*this, f, c);
    }

    TorusConstructionMethodType& TorusConstructionMethodType::
    operator= (const TorusConstructionMethodType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->BestFit_ = x.BestFit_;
        this->Recompensated_ = x.Recompensated_;
        this->Copy_ = x.Copy_;
        this->Cast_ = x.Cast_;
        this->Transform_ = x.Transform_;
        this->FromScan_ = x.FromScan_;
      }

      return *this;
    }

    TorusConstructionMethodType::
    ~TorusConstructionMethodType ()
    {
    }

    // TorusBestFitType
    //

    TorusBestFitType::
    TorusBestFitType ()
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (this)
    {
    }

    TorusBestFitType::
    TorusBestFitType (const TorusBestFitType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    TorusBestFitType::
    TorusBestFitType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusBestFitType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          this->BaseFeature_.push_back (r);
          continue;
        }

        break;
      }
    }

    TorusBestFitType* TorusBestFitType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusBestFitType (*this, f, c);
    }

    TorusBestFitType& TorusBestFitType::
    operator= (const TorusBestFitType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    TorusBestFitType::
    ~TorusBestFitType ()
    {
    }

    // TorusRecompType
    //

    TorusRecompType::
    TorusRecompType (const BaseFeaturePointList_type& BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    TorusRecompType::
    TorusRecompType (::std::auto_ptr< BaseFeaturePointList_type > BaseFeaturePointList)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeaturePointList_ (BaseFeaturePointList, this)
    {
    }

    TorusRecompType::
    TorusRecompType (const TorusRecompType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeaturePointList_ (x.BaseFeaturePointList_, f, this)
    {
    }

    TorusRecompType::
    TorusRecompType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeaturePointList_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusRecompType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeaturePointList
        //
        if (n.name () == "BaseFeaturePointList" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeaturePointList_type > r (
            BaseFeaturePointList_traits::create (i, f, this));

          if (!BaseFeaturePointList_.present ())
          {
            this->BaseFeaturePointList_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeaturePointList_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeaturePointList",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusRecompType* TorusRecompType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusRecompType (*this, f, c);
    }

    TorusRecompType& TorusRecompType::
    operator= (const TorusRecompType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeaturePointList_ = x.BaseFeaturePointList_;
      }

      return *this;
    }

    TorusRecompType::
    ~TorusRecompType ()
    {
    }

    // TorusCopyType
    //

    TorusCopyType::
    TorusCopyType (const BaseTorus_type& BaseTorus)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseTorus_ (BaseTorus, this)
    {
    }

    TorusCopyType::
    TorusCopyType (::std::auto_ptr< BaseTorus_type > BaseTorus)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseTorus_ (BaseTorus, this)
    {
    }

    TorusCopyType::
    TorusCopyType (const TorusCopyType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseTorus_ (x.BaseTorus_, f, this)
    {
    }

    TorusCopyType::
    TorusCopyType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseTorus_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusCopyType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseTorus
        //
        if (n.name () == "BaseTorus" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseTorus_type > r (
            BaseTorus_traits::create (i, f, this));

          if (!BaseTorus_.present ())
          {
            this->BaseTorus_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseTorus_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseTorus",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusCopyType* TorusCopyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCopyType (*this, f, c);
    }

    TorusCopyType& TorusCopyType::
    operator= (const TorusCopyType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseTorus_ = x.BaseTorus_;
      }

      return *this;
    }

    TorusCopyType::
    ~TorusCopyType ()
    {
    }

    // TorusCastType
    //

    TorusCastType::
    TorusCastType (const BaseFeature_type& BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    TorusCastType::
    TorusCastType (::std::auto_ptr< BaseFeature_type > BaseFeature)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseFeature_ (BaseFeature, this)
    {
    }

    TorusCastType::
    TorusCastType (const TorusCastType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseFeature_ (x.BaseFeature_, f, this)
    {
    }

    TorusCastType::
    TorusCastType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseFeature_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusCastType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseFeature
        //
        if (n.name () == "BaseFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseFeature_type > r (
            BaseFeature_traits::create (i, f, this));

          if (!BaseFeature_.present ())
          {
            this->BaseFeature_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseFeature",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusCastType* TorusCastType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCastType (*this, f, c);
    }

    TorusCastType& TorusCastType::
    operator= (const TorusCastType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseFeature_ = x.BaseFeature_;
      }

      return *this;
    }

    TorusCastType::
    ~TorusCastType ()
    {
    }

    // TorusTransformType
    //

    TorusTransformType::
    TorusTransformType (const BaseTorus_type& BaseTorus,
                        const Transformation_type& Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseTorus_ (BaseTorus, this),
      Transformation_ (Transformation, this)
    {
    }

    TorusTransformType::
    TorusTransformType (::std::auto_ptr< BaseTorus_type > BaseTorus,
                        ::std::auto_ptr< Transformation_type > Transformation)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      BaseTorus_ (BaseTorus, this),
      Transformation_ (Transformation, this)
    {
    }

    TorusTransformType::
    TorusTransformType (const TorusTransformType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      BaseTorus_ (x.BaseTorus_, f, this),
      Transformation_ (x.Transformation_, f, this)
    {
    }

    TorusTransformType::
    TorusTransformType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      BaseTorus_ (this),
      Transformation_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusTransformType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BaseTorus
        //
        if (n.name () == "BaseTorus" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< BaseTorus_type > r (
            BaseTorus_traits::create (i, f, this));

          if (!BaseTorus_.present ())
          {
            this->BaseTorus_.set (r);
            continue;
          }
        }

        // Transformation
        //
        if (n.name () == "Transformation" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Transformation_type > r (
            Transformation_traits::create (i, f, this));

          if (!Transformation_.present ())
          {
            this->Transformation_.set (r);
            continue;
          }
        }

        break;
      }

      if (!BaseTorus_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BaseTorus",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Transformation_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Transformation",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusTransformType* TorusTransformType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusTransformType (*this, f, c);
    }

    TorusTransformType& TorusTransformType::
    operator= (const TorusTransformType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->BaseTorus_ = x.BaseTorus_;
        this->Transformation_ = x.Transformation_;
      }

      return *this;
    }

    TorusTransformType::
    ~TorusTransformType ()
    {
    }

    // TorusFromScanType
    //

    TorusFromScanType::
    TorusFromScanType (const SurfaceFeature_type& SurfaceFeature,
                       const SearchRadius_type& SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    TorusFromScanType::
    TorusFromScanType (::std::auto_ptr< SurfaceFeature_type > SurfaceFeature,
                       ::std::auto_ptr< SearchRadius_type > SearchRadius)
    : ::xsd::qif2::ConstructionMethodBaseType (),
      SurfaceFeature_ (SurfaceFeature, this),
      SearchRadius_ (SearchRadius, this)
    {
    }

    TorusFromScanType::
    TorusFromScanType (const TorusFromScanType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (x, f, c),
      SurfaceFeature_ (x.SurfaceFeature_, f, this),
      SearchRadius_ (x.SearchRadius_, f, this)
    {
    }

    TorusFromScanType::
    TorusFromScanType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xsd::qif2::ConstructionMethodBaseType (e, f | ::xml_schema::flags::base, c),
      SurfaceFeature_ (this),
      SearchRadius_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusFromScanType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::ConstructionMethodBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SurfaceFeature
        //
        if (n.name () == "SurfaceFeature" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SurfaceFeature_type > r (
            SurfaceFeature_traits::create (i, f, this));

          if (!SurfaceFeature_.present ())
          {
            this->SurfaceFeature_.set (r);
            continue;
          }
        }

        // SearchRadius
        //
        if (n.name () == "SearchRadius" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SearchRadius_type > r (
            SearchRadius_traits::create (i, f, this));

          if (!SearchRadius_.present ())
          {
            this->SearchRadius_.set (r);
            continue;
          }
        }

        break;
      }

      if (!SurfaceFeature_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SurfaceFeature",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!SearchRadius_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "SearchRadius",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusFromScanType* TorusFromScanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFromScanType (*this, f, c);
    }

    TorusFromScanType& TorusFromScanType::
    operator= (const TorusFromScanType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ConstructionMethodBaseType& > (*this) = x;
        this->SurfaceFeature_ = x.SurfaceFeature_;
        this->SearchRadius_ = x.SearchRadius_;
      }

      return *this;
    }

    TorusFromScanType::
    ~TorusFromScanType ()
    {
    }

    // TorusCheckedType
    //

    TorusCheckedType::
    TorusCheckedType ()
    : ::xml_schema::type (),
      Measured_ (this),
      Constructed_ (this)
    {
    }

    TorusCheckedType::
    TorusCheckedType (const TorusCheckedType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Measured_ (x.Measured_, f, this),
      Constructed_ (x.Constructed_, f, this)
    {
    }

    TorusCheckedType::
    TorusCheckedType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Measured_ (this),
      Constructed_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusCheckedType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Measured
        //
        if (n.name () == "Measured" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Measured_type > r (
            Measured_traits::create (i, f, this));

          if (!this->Measured_)
          {
            this->Measured_.set (r);
            continue;
          }
        }

        // Constructed
        //
        if (n.name () == "Constructed" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Constructed_type > r (
            Constructed_traits::create (i, f, this));

          if (!this->Constructed_)
          {
            this->Constructed_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusCheckedType* TorusCheckedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCheckedType (*this, f, c);
    }

    TorusCheckedType& TorusCheckedType::
    operator= (const TorusCheckedType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Measured_ = x.Measured_;
        this->Constructed_ = x.Constructed_;
      }

      return *this;
    }

    TorusCheckedType::
    ~TorusCheckedType ()
    {
    }

    // TorusCheckedFeatureType
    //

    TorusCheckedFeatureType::
    TorusCheckedFeatureType ()
    : ::xml_schema::type (),
      CheckDetails_ (this)
    {
    }

    TorusCheckedFeatureType::
    TorusCheckedFeatureType (const TorusCheckedFeatureType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CheckDetails_ (x.CheckDetails_, f, this)
    {
    }

    TorusCheckedFeatureType::
    TorusCheckedFeatureType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CheckDetails_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusCheckedFeatureType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // CheckDetails
        //
        if (n.name () == "CheckDetails" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CheckDetails_type > r (
            CheckDetails_traits::create (i, f, this));

          if (!this->CheckDetails_)
          {
            this->CheckDetails_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusCheckedFeatureType* TorusCheckedFeatureType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusCheckedFeatureType (*this, f, c);
    }

    TorusCheckedFeatureType& TorusCheckedFeatureType::
    operator= (const TorusCheckedFeatureType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->CheckDetails_ = x.CheckDetails_;
      }

      return *this;
    }

    TorusCheckedFeatureType::
    ~TorusCheckedFeatureType ()
    {
    }

    // TorusActualDeterminationType
    //

    TorusActualDeterminationType::
    TorusActualDeterminationType ()
    : ::xml_schema::type (),
      Checked_ (this),
      Set_ (this)
    {
    }

    TorusActualDeterminationType::
    TorusActualDeterminationType (const TorusActualDeterminationType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Checked_ (x.Checked_, f, this),
      Set_ (x.Set_, f, this)
    {
    }

    TorusActualDeterminationType::
    TorusActualDeterminationType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Checked_ (this),
      Set_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void TorusActualDeterminationType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Checked
        //
        if (n.name () == "Checked" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Checked_type > r (
            Checked_traits::create (i, f, this));

          if (!this->Checked_)
          {
            this->Checked_.set (r);
            continue;
          }
        }

        // Set
        //
        if (n.name () == "Set" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Set_type > r (
            Set_traits::create (i, f, this));

          if (!this->Set_)
          {
            this->Set_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusActualDeterminationType* TorusActualDeterminationType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusActualDeterminationType (*this, f, c);
    }

    TorusActualDeterminationType& TorusActualDeterminationType::
    operator= (const TorusActualDeterminationType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->Checked_ = x.Checked_;
        this->Set_ = x.Set_;
      }

      return *this;
    }

    TorusActualDeterminationType::
    ~TorusActualDeterminationType ()
    {
    }

    // TorusFeatureItemType
    //

    TorusFeatureItemType::
    TorusFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          const DeterminationMode_type& DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    TorusFeatureItemType::
    TorusFeatureItemType (const id_type& id,
                          const FeatureName_type& FeatureName,
                          ::std::auto_ptr< DeterminationMode_type > DeterminationMode)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName),
      DeterminationMode_ (DeterminationMode, this),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    TorusFeatureItemType::
    TorusFeatureItemType (const TorusFeatureItemType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c),
      DeterminationMode_ (x.DeterminationMode_, f, this),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    TorusFeatureItemType::
    TorusFeatureItemType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      DeterminationMode_ (this),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // DeterminationMode
        //
        if (n.name () == "DeterminationMode" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< DeterminationMode_type > r (
            DeterminationMode_traits::create (i, f, this));

          if (!DeterminationMode_.present ())
          {
            this->DeterminationMode_.set (r);
            continue;
          }
        }

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!DeterminationMode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "DeterminationMode",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusFeatureItemType* TorusFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureItemType (*this, f, c);
    }

    TorusFeatureItemType& TorusFeatureItemType::
    operator= (const TorusFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureItemBaseType& > (*this) = x;
        this->DeterminationMode_ = x.DeterminationMode_;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    TorusFeatureItemType::
    ~TorusFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TorusFeatureItemType >
    _xsd_TorusFeatureItemType_type_factory_init (
      "TorusFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // TorusFeatureDefinitionType
    //

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const id_type& id,
                                const InternalExternal_type& InternalExternal,
                                const MinorDiameter_type& MinorDiameter,
                                const MajorDiameter_type& MajorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MinorDiameter_ (MinorDiameter, this),
      MajorDiameter_ (MajorDiameter, this)
    {
    }

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const id_type& id,
                                const InternalExternal_type& InternalExternal,
                                ::std::auto_ptr< MinorDiameter_type > MinorDiameter,
                                ::std::auto_ptr< MajorDiameter_type > MajorDiameter)
    : ::xsd::qif2::FeatureDefinitionBaseType (id),
      InternalExternal_ (InternalExternal, this),
      MinorDiameter_ (MinorDiameter, this),
      MajorDiameter_ (MajorDiameter, this)
    {
    }

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const TorusFeatureDefinitionType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c),
      InternalExternal_ (x.InternalExternal_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this)
    {
    }

    TorusFeatureDefinitionType::
    TorusFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f | ::xml_schema::flags::base, c),
      InternalExternal_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureDefinitionType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureDefinitionBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // InternalExternal
        //
        if (n.name () == "InternalExternal" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< InternalExternal_type > r (
            InternalExternal_traits::create (i, f, this));

          if (!InternalExternal_.present ())
          {
            this->InternalExternal_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!MinorDiameter_.present ())
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!MajorDiameter_.present ())
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        break;
      }

      if (!InternalExternal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "InternalExternal",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MinorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MinorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!MajorDiameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "MajorDiameter",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusFeatureDefinitionType* TorusFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureDefinitionType (*this, f, c);
    }

    TorusFeatureDefinitionType& TorusFeatureDefinitionType::
    operator= (const TorusFeatureDefinitionType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureDefinitionBaseType& > (*this) = x;
        this->InternalExternal_ = x.InternalExternal_;
        this->MinorDiameter_ = x.MinorDiameter_;
        this->MajorDiameter_ = x.MajorDiameter_;
      }

      return *this;
    }

    TorusFeatureDefinitionType::
    ~TorusFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TorusFeatureDefinitionType >
    _xsd_TorusFeatureDefinitionType_type_factory_init (
      "TorusFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // TorusFeatureNominalType
    //

    TorusFeatureNominalType::
    TorusFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             const Location_type& Location,
                             const AxisVector_type& AxisVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      AxisVector_ (AxisVector, this),
      LatitudeLongitudeSweep_ (this)
    {
    }

    TorusFeatureNominalType::
    TorusFeatureNominalType (const id_type& id,
                             const FeatureDefinitionId_type& FeatureDefinitionId,
                             ::std::auto_ptr< Location_type > Location,
                             ::std::auto_ptr< AxisVector_type > AxisVector)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      Location_ (Location, this),
      AxisVector_ (AxisVector, this),
      LatitudeLongitudeSweep_ (this)
    {
    }

    TorusFeatureNominalType::
    TorusFeatureNominalType (const TorusFeatureNominalType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this)
    {
    }

    TorusFeatureNominalType::
    TorusFeatureNominalType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      AxisVector_ (this),
      LatitudeLongitudeSweep_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == "AxisVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!AxisVector_.present ())
          {
            this->AxisVector_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!AxisVector_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "AxisVector",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    TorusFeatureNominalType* TorusFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureNominalType (*this, f, c);
    }

    TorusFeatureNominalType& TorusFeatureNominalType::
    operator= (const TorusFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->AxisVector_ = x.AxisVector_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
      }

      return *this;
    }

    TorusFeatureNominalType::
    ~TorusFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TorusFeatureNominalType >
    _xsd_TorusFeatureNominalType_type_factory_init (
      "TorusFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // TorusFeatureActualType
    //

    TorusFeatureActualType::
    TorusFeatureActualType (const id_type& id,
                            const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
    }

    TorusFeatureActualType::
    TorusFeatureActualType (const id_type& id,
                            ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
    }

    TorusFeatureActualType::
    TorusFeatureActualType (const TorusFeatureActualType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      AxisVector_ (x.AxisVector_, f, this),
      MinorDiameter_ (x.MinorDiameter_, f, this),
      MajorDiameter_ (x.MajorDiameter_, f, this),
      LatitudeLongitudeSweep_ (x.LatitudeLongitudeSweep_, f, this),
      Form_ (x.Form_, f, this)
    {
    }

    TorusFeatureActualType::
    TorusFeatureActualType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      AxisVector_ (this),
      MinorDiameter_ (this),
      MajorDiameter_ (this),
      LatitudeLongitudeSweep_ (this),
      Form_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TorusFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // AxisVector
        //
        if (n.name () == "AxisVector" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< AxisVector_type > r (
            AxisVector_traits::create (i, f, this));

          if (!this->AxisVector_)
          {
            this->AxisVector_.set (r);
            continue;
          }
        }

        // MinorDiameter
        //
        if (n.name () == "MinorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MinorDiameter_type > r (
            MinorDiameter_traits::create (i, f, this));

          if (!this->MinorDiameter_)
          {
            this->MinorDiameter_.set (r);
            continue;
          }
        }

        // MajorDiameter
        //
        if (n.name () == "MajorDiameter" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< MajorDiameter_type > r (
            MajorDiameter_traits::create (i, f, this));

          if (!this->MajorDiameter_)
          {
            this->MajorDiameter_.set (r);
            continue;
          }
        }

        // LatitudeLongitudeSweep
        //
        if (n.name () == "LatitudeLongitudeSweep" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< LatitudeLongitudeSweep_type > r (
            LatitudeLongitudeSweep_traits::create (i, f, this));

          if (!this->LatitudeLongitudeSweep_)
          {
            this->LatitudeLongitudeSweep_.set (r);
            continue;
          }
        }

        // Form
        //
        if (n.name () == "Form" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Form_type > r (
            Form_traits::create (i, f, this));

          if (!this->Form_)
          {
            this->Form_.set (r);
            continue;
          }
        }

        break;
      }
    }

    TorusFeatureActualType* TorusFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TorusFeatureActualType (*this, f, c);
    }

    TorusFeatureActualType& TorusFeatureActualType::
    operator= (const TorusFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->AxisVector_ = x.AxisVector_;
        this->MinorDiameter_ = x.MinorDiameter_;
        this->MajorDiameter_ = x.MajorDiameter_;
        this->LatitudeLongitudeSweep_ = x.LatitudeLongitudeSweep_;
        this->Form_ = x.Form_;
      }

      return *this;
    }

    TorusFeatureActualType::
    ~TorusFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TorusFeatureActualType >
    _xsd_TorusFeatureActualType_type_factory_init (
      "TorusFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // CompositeFeatureItemBaseType
    //

    CompositeFeatureItemBaseType::
    CompositeFeatureItemBaseType (const id_type& id,
                                  const FeatureName_type& FeatureName)
    : ::xsd::qif2::FeatureItemBaseType (id,
                                        FeatureName)
    {
    }

    CompositeFeatureItemBaseType::
    CompositeFeatureItemBaseType (const CompositeFeatureItemBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (x, f, c)
    {
    }

    CompositeFeatureItemBaseType::
    CompositeFeatureItemBaseType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::FeatureItemBaseType (e, f, c)
    {
    }

    CompositeFeatureItemBaseType* CompositeFeatureItemBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeFeatureItemBaseType (*this, f, c);
    }

    CompositeFeatureItemBaseType::
    ~CompositeFeatureItemBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CompositeFeatureItemBaseType >
    _xsd_CompositeFeatureItemBaseType_type_factory_init (
      "CompositeFeatureItemBaseType",
      "http://qifstandards.org/xsd/qif2");

    // CompositeFeatureDefinitionBaseType
    //

    CompositeFeatureDefinitionBaseType::
    CompositeFeatureDefinitionBaseType (const id_type& id)
    : ::xsd::qif2::FeatureDefinitionBaseType (id)
    {
    }

    CompositeFeatureDefinitionBaseType::
    CompositeFeatureDefinitionBaseType (const CompositeFeatureDefinitionBaseType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (x, f, c)
    {
    }

    CompositeFeatureDefinitionBaseType::
    CompositeFeatureDefinitionBaseType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::FeatureDefinitionBaseType (e, f, c)
    {
    }

    CompositeFeatureDefinitionBaseType* CompositeFeatureDefinitionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeFeatureDefinitionBaseType (*this, f, c);
    }

    CompositeFeatureDefinitionBaseType::
    ~CompositeFeatureDefinitionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CompositeFeatureDefinitionBaseType >
    _xsd_CompositeFeatureDefinitionBaseType_type_factory_init (
      "CompositeFeatureDefinitionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // CompositeFeatureNominalBaseType
    //

    CompositeFeatureNominalBaseType::
    CompositeFeatureNominalBaseType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId,
                                     const FeatureNominalIds_type& FeatureNominalIds)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      FeatureNominalIds_ (FeatureNominalIds, this)
    {
    }

    CompositeFeatureNominalBaseType::
    CompositeFeatureNominalBaseType (const id_type& id,
                                     const FeatureDefinitionId_type& FeatureDefinitionId,
                                     ::std::auto_ptr< FeatureNominalIds_type > FeatureNominalIds)
    : ::xsd::qif2::FeatureNominalBaseType (id,
                                           FeatureDefinitionId),
      FeatureNominalIds_ (FeatureNominalIds, this)
    {
    }

    CompositeFeatureNominalBaseType::
    CompositeFeatureNominalBaseType (const CompositeFeatureNominalBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (x, f, c),
      FeatureNominalIds_ (x.FeatureNominalIds_, f, this)
    {
    }

    CompositeFeatureNominalBaseType::
    CompositeFeatureNominalBaseType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::FeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      FeatureNominalIds_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CompositeFeatureNominalBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::FeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureNominalIds
        //
        if (n.name () == "FeatureNominalIds" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureNominalIds_type > r (
            FeatureNominalIds_traits::create (i, f, this));

          if (!FeatureNominalIds_.present ())
          {
            this->FeatureNominalIds_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureNominalIds_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureNominalIds",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CompositeFeatureNominalBaseType* CompositeFeatureNominalBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeFeatureNominalBaseType (*this, f, c);
    }

    CompositeFeatureNominalBaseType& CompositeFeatureNominalBaseType::
    operator= (const CompositeFeatureNominalBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::FeatureNominalBaseType& > (*this) = x;
        this->FeatureNominalIds_ = x.FeatureNominalIds_;
      }

      return *this;
    }

    CompositeFeatureNominalBaseType::
    ~CompositeFeatureNominalBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CompositeFeatureNominalBaseType >
    _xsd_CompositeFeatureNominalBaseType_type_factory_init (
      "CompositeFeatureNominalBaseType",
      "http://qifstandards.org/xsd/qif2");

    // CompositeFeatureActualBaseType
    //

    CompositeFeatureActualBaseType::
    CompositeFeatureActualBaseType (const id_type& id,
                                    const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId)
    {
    }

    CompositeFeatureActualBaseType::
    CompositeFeatureActualBaseType (const id_type& id,
                                    ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::FeatureActualBaseType (id,
                                          FeatureItemId)
    {
    }

    CompositeFeatureActualBaseType::
    CompositeFeatureActualBaseType (const CompositeFeatureActualBaseType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (x, f, c)
    {
    }

    CompositeFeatureActualBaseType::
    CompositeFeatureActualBaseType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::FeatureActualBaseType (e, f, c)
    {
    }

    CompositeFeatureActualBaseType* CompositeFeatureActualBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompositeFeatureActualBaseType (*this, f, c);
    }

    CompositeFeatureActualBaseType::
    ~CompositeFeatureActualBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CompositeFeatureActualBaseType >
    _xsd_CompositeFeatureActualBaseType_type_factory_init (
      "CompositeFeatureActualBaseType",
      "http://qifstandards.org/xsd/qif2");

    // CompoundFeatureItemType
    //

    CompoundFeatureItemType::
    CompoundFeatureItemType (const id_type& id,
                             const FeatureName_type& FeatureName)
    : ::xsd::qif2::CompositeFeatureItemBaseType (id,
                                                 FeatureName),
      SubstituteFeatureAlgorithm_ (this)
    {
    }

    CompoundFeatureItemType::
    CompoundFeatureItemType (const CompoundFeatureItemType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (x, f, c),
      SubstituteFeatureAlgorithm_ (x.SubstituteFeatureAlgorithm_, f, this)
    {
    }

    CompoundFeatureItemType::
    CompoundFeatureItemType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (e, f | ::xml_schema::flags::base, c),
      SubstituteFeatureAlgorithm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CompoundFeatureItemType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::CompositeFeatureItemBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // SubstituteFeatureAlgorithm
        //
        if (n.name () == "SubstituteFeatureAlgorithm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< SubstituteFeatureAlgorithm_type > r (
            SubstituteFeatureAlgorithm_traits::create (i, f, this));

          if (!this->SubstituteFeatureAlgorithm_)
          {
            this->SubstituteFeatureAlgorithm_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CompoundFeatureItemType* CompoundFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompoundFeatureItemType (*this, f, c);
    }

    CompoundFeatureItemType& CompoundFeatureItemType::
    operator= (const CompoundFeatureItemType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::CompositeFeatureItemBaseType& > (*this) = x;
        this->SubstituteFeatureAlgorithm_ = x.SubstituteFeatureAlgorithm_;
      }

      return *this;
    }

    CompoundFeatureItemType::
    ~CompoundFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CompoundFeatureItemType >
    _xsd_CompoundFeatureItemType_type_factory_init (
      "CompoundFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // CompoundFeatureDefinitionType
    //

    CompoundFeatureDefinitionType::
    CompoundFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (id)
    {
    }

    CompoundFeatureDefinitionType::
    CompoundFeatureDefinitionType (const CompoundFeatureDefinitionType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (x, f, c)
    {
    }

    CompoundFeatureDefinitionType::
    CompoundFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (e, f, c)
    {
    }

    CompoundFeatureDefinitionType* CompoundFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompoundFeatureDefinitionType (*this, f, c);
    }

    CompoundFeatureDefinitionType::
    ~CompoundFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CompoundFeatureDefinitionType >
    _xsd_CompoundFeatureDefinitionType_type_factory_init (
      "CompoundFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // CompoundFeatureNominalType
    //

    CompoundFeatureNominalType::
    CompoundFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                const FeatureNominalIds_type& FeatureNominalIds,
                                const Location_type& Location,
                                const Direction_type& Direction,
                                const CompoundFeatureForm_type& CompoundFeatureForm)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds),
      Location_ (Location, this),
      Direction_ (Direction, this),
      CompoundFeatureForm_ (CompoundFeatureForm, this)
    {
    }

    CompoundFeatureNominalType::
    CompoundFeatureNominalType (const id_type& id,
                                const FeatureDefinitionId_type& FeatureDefinitionId,
                                ::std::auto_ptr< FeatureNominalIds_type > FeatureNominalIds,
                                ::std::auto_ptr< Location_type > Location,
                                ::std::auto_ptr< Direction_type > Direction,
                                const CompoundFeatureForm_type& CompoundFeatureForm)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds),
      Location_ (Location, this),
      Direction_ (Direction, this),
      CompoundFeatureForm_ (CompoundFeatureForm, this)
    {
    }

    CompoundFeatureNominalType::
    CompoundFeatureNominalType (const CompoundFeatureNominalType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Direction_ (x.Direction_, f, this),
      CompoundFeatureForm_ (x.CompoundFeatureForm_, f, this)
    {
    }

    CompoundFeatureNominalType::
    CompoundFeatureNominalType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Direction_ (this),
      CompoundFeatureForm_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CompoundFeatureNominalType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::CompositeFeatureNominalBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!Location_.present ())
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!Direction_.present ())
          {
            this->Direction_.set (r);
            continue;
          }
        }

        // CompoundFeatureForm
        //
        if (n.name () == "CompoundFeatureForm" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< CompoundFeatureForm_type > r (
            CompoundFeatureForm_traits::create (i, f, this));

          if (!CompoundFeatureForm_.present ())
          {
            this->CompoundFeatureForm_.set (r);
            continue;
          }
        }

        break;
      }

      if (!Location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Location",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!Direction_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "Direction",
          "http://qifstandards.org/xsd/qif2");
      }

      if (!CompoundFeatureForm_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "CompoundFeatureForm",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    CompoundFeatureNominalType* CompoundFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompoundFeatureNominalType (*this, f, c);
    }

    CompoundFeatureNominalType& CompoundFeatureNominalType::
    operator= (const CompoundFeatureNominalType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::CompositeFeatureNominalBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Direction_ = x.Direction_;
        this->CompoundFeatureForm_ = x.CompoundFeatureForm_;
      }

      return *this;
    }

    CompoundFeatureNominalType::
    ~CompoundFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CompoundFeatureNominalType >
    _xsd_CompoundFeatureNominalType_type_factory_init (
      "CompoundFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // CompoundFeatureActualType
    //

    CompoundFeatureActualType::
    CompoundFeatureActualType (const id_type& id,
                               const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId),
      Location_ (this),
      Direction_ (this)
    {
    }

    CompoundFeatureActualType::
    CompoundFeatureActualType (const id_type& id,
                               ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId),
      Location_ (this),
      Direction_ (this)
    {
    }

    CompoundFeatureActualType::
    CompoundFeatureActualType (const CompoundFeatureActualType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (x, f, c),
      Location_ (x.Location_, f, this),
      Direction_ (x.Direction_, f, this)
    {
    }

    CompoundFeatureActualType::
    CompoundFeatureActualType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (e, f | ::xml_schema::flags::base, c),
      Location_ (this),
      Direction_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CompoundFeatureActualType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      this->::xsd::qif2::CompositeFeatureActualBaseType::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // Location
        //
        if (n.name () == "Location" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Location_type > r (
            Location_traits::create (i, f, this));

          if (!this->Location_)
          {
            this->Location_.set (r);
            continue;
          }
        }

        // Direction
        //
        if (n.name () == "Direction" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< Direction_type > r (
            Direction_traits::create (i, f, this));

          if (!this->Direction_)
          {
            this->Direction_.set (r);
            continue;
          }
        }

        break;
      }
    }

    CompoundFeatureActualType* CompoundFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CompoundFeatureActualType (*this, f, c);
    }

    CompoundFeatureActualType& CompoundFeatureActualType::
    operator= (const CompoundFeatureActualType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::CompositeFeatureActualBaseType& > (*this) = x;
        this->Location_ = x.Location_;
        this->Direction_ = x.Direction_;
      }

      return *this;
    }

    CompoundFeatureActualType::
    ~CompoundFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CompoundFeatureActualType >
    _xsd_CompoundFeatureActualType_type_factory_init (
      "CompoundFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // PatternFeatureItemType
    //

    PatternFeatureItemType::
    PatternFeatureItemType (const id_type& id,
                            const FeatureName_type& FeatureName)
    : ::xsd::qif2::CompositeFeatureItemBaseType (id,
                                                 FeatureName)
    {
    }

    PatternFeatureItemType::
    PatternFeatureItemType (const PatternFeatureItemType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (x, f, c)
    {
    }

    PatternFeatureItemType::
    PatternFeatureItemType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (e, f, c)
    {
    }

    PatternFeatureItemType* PatternFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureItemType (*this, f, c);
    }

    PatternFeatureItemType::
    ~PatternFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatternFeatureItemType >
    _xsd_PatternFeatureItemType_type_factory_init (
      "PatternFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // PatternFeatureDefinitionType
    //

    PatternFeatureDefinitionType::
    PatternFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (id)
    {
    }

    PatternFeatureDefinitionType::
    PatternFeatureDefinitionType (const PatternFeatureDefinitionType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (x, f, c)
    {
    }

    PatternFeatureDefinitionType::
    PatternFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (e, f, c)
    {
    }

    PatternFeatureDefinitionType* PatternFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureDefinitionType (*this, f, c);
    }

    PatternFeatureDefinitionType::
    ~PatternFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatternFeatureDefinitionType >
    _xsd_PatternFeatureDefinitionType_type_factory_init (
      "PatternFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // PatternFeatureNominalType
    //

    PatternFeatureNominalType::
    PatternFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId,
                               const FeatureNominalIds_type& FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    PatternFeatureNominalType::
    PatternFeatureNominalType (const id_type& id,
                               const FeatureDefinitionId_type& FeatureDefinitionId,
                               ::std::auto_ptr< FeatureNominalIds_type > FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    PatternFeatureNominalType::
    PatternFeatureNominalType (const PatternFeatureNominalType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (x, f, c)
    {
    }

    PatternFeatureNominalType::
    PatternFeatureNominalType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (e, f, c)
    {
    }

    PatternFeatureNominalType* PatternFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureNominalType (*this, f, c);
    }

    PatternFeatureNominalType::
    ~PatternFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatternFeatureNominalType >
    _xsd_PatternFeatureNominalType_type_factory_init (
      "PatternFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // PatternFeatureActualType
    //

    PatternFeatureActualType::
    PatternFeatureActualType (const id_type& id,
                              const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    PatternFeatureActualType::
    PatternFeatureActualType (const id_type& id,
                              ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    PatternFeatureActualType::
    PatternFeatureActualType (const PatternFeatureActualType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (x, f, c)
    {
    }

    PatternFeatureActualType::
    PatternFeatureActualType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (e, f, c)
    {
    }

    PatternFeatureActualType* PatternFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PatternFeatureActualType (*this, f, c);
    }

    PatternFeatureActualType::
    ~PatternFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PatternFeatureActualType >
    _xsd_PatternFeatureActualType_type_factory_init (
      "PatternFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // ProfileGroupFeatureItemType
    //

    ProfileGroupFeatureItemType::
    ProfileGroupFeatureItemType (const id_type& id,
                                 const FeatureName_type& FeatureName)
    : ::xsd::qif2::CompositeFeatureItemBaseType (id,
                                                 FeatureName)
    {
    }

    ProfileGroupFeatureItemType::
    ProfileGroupFeatureItemType (const ProfileGroupFeatureItemType& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (x, f, c)
    {
    }

    ProfileGroupFeatureItemType::
    ProfileGroupFeatureItemType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (e, f, c)
    {
    }

    ProfileGroupFeatureItemType* ProfileGroupFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProfileGroupFeatureItemType (*this, f, c);
    }

    ProfileGroupFeatureItemType::
    ~ProfileGroupFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProfileGroupFeatureItemType >
    _xsd_ProfileGroupFeatureItemType_type_factory_init (
      "ProfileGroupFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // ProfileGroupFeatureDefinitionType
    //

    ProfileGroupFeatureDefinitionType::
    ProfileGroupFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (id)
    {
    }

    ProfileGroupFeatureDefinitionType::
    ProfileGroupFeatureDefinitionType (const ProfileGroupFeatureDefinitionType& x,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (x, f, c)
    {
    }

    ProfileGroupFeatureDefinitionType::
    ProfileGroupFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f,
                                       ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (e, f, c)
    {
    }

    ProfileGroupFeatureDefinitionType* ProfileGroupFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProfileGroupFeatureDefinitionType (*this, f, c);
    }

    ProfileGroupFeatureDefinitionType::
    ~ProfileGroupFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProfileGroupFeatureDefinitionType >
    _xsd_ProfileGroupFeatureDefinitionType_type_factory_init (
      "ProfileGroupFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // ProfileGroupFeatureNominalType
    //

    ProfileGroupFeatureNominalType::
    ProfileGroupFeatureNominalType (const id_type& id,
                                    const FeatureDefinitionId_type& FeatureDefinitionId,
                                    const FeatureNominalIds_type& FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    ProfileGroupFeatureNominalType::
    ProfileGroupFeatureNominalType (const id_type& id,
                                    const FeatureDefinitionId_type& FeatureDefinitionId,
                                    ::std::auto_ptr< FeatureNominalIds_type > FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    ProfileGroupFeatureNominalType::
    ProfileGroupFeatureNominalType (const ProfileGroupFeatureNominalType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (x, f, c)
    {
    }

    ProfileGroupFeatureNominalType::
    ProfileGroupFeatureNominalType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (e, f, c)
    {
    }

    ProfileGroupFeatureNominalType* ProfileGroupFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProfileGroupFeatureNominalType (*this, f, c);
    }

    ProfileGroupFeatureNominalType::
    ~ProfileGroupFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProfileGroupFeatureNominalType >
    _xsd_ProfileGroupFeatureNominalType_type_factory_init (
      "ProfileGroupFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // ProfileGroupFeatureActualType
    //

    ProfileGroupFeatureActualType::
    ProfileGroupFeatureActualType (const id_type& id,
                                   const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    ProfileGroupFeatureActualType::
    ProfileGroupFeatureActualType (const id_type& id,
                                   ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    ProfileGroupFeatureActualType::
    ProfileGroupFeatureActualType (const ProfileGroupFeatureActualType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (x, f, c)
    {
    }

    ProfileGroupFeatureActualType::
    ProfileGroupFeatureActualType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (e, f, c)
    {
    }

    ProfileGroupFeatureActualType* ProfileGroupFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ProfileGroupFeatureActualType (*this, f, c);
    }

    ProfileGroupFeatureActualType::
    ~ProfileGroupFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ProfileGroupFeatureActualType >
    _xsd_ProfileGroupFeatureActualType_type_factory_init (
      "ProfileGroupFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // RunoutGroupFeatureItemType
    //

    RunoutGroupFeatureItemType::
    RunoutGroupFeatureItemType (const id_type& id,
                                const FeatureName_type& FeatureName)
    : ::xsd::qif2::CompositeFeatureItemBaseType (id,
                                                 FeatureName)
    {
    }

    RunoutGroupFeatureItemType::
    RunoutGroupFeatureItemType (const RunoutGroupFeatureItemType& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (x, f, c)
    {
    }

    RunoutGroupFeatureItemType::
    RunoutGroupFeatureItemType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureItemBaseType (e, f, c)
    {
    }

    RunoutGroupFeatureItemType* RunoutGroupFeatureItemType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RunoutGroupFeatureItemType (*this, f, c);
    }

    RunoutGroupFeatureItemType::
    ~RunoutGroupFeatureItemType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, RunoutGroupFeatureItemType >
    _xsd_RunoutGroupFeatureItemType_type_factory_init (
      "RunoutGroupFeatureItemType",
      "http://qifstandards.org/xsd/qif2");

    // RunoutGroupFeatureDefinitionType
    //

    RunoutGroupFeatureDefinitionType::
    RunoutGroupFeatureDefinitionType (const id_type& id)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (id)
    {
    }

    RunoutGroupFeatureDefinitionType::
    RunoutGroupFeatureDefinitionType (const RunoutGroupFeatureDefinitionType& x,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (x, f, c)
    {
    }

    RunoutGroupFeatureDefinitionType::
    RunoutGroupFeatureDefinitionType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f,
                                      ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureDefinitionBaseType (e, f, c)
    {
    }

    RunoutGroupFeatureDefinitionType* RunoutGroupFeatureDefinitionType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RunoutGroupFeatureDefinitionType (*this, f, c);
    }

    RunoutGroupFeatureDefinitionType::
    ~RunoutGroupFeatureDefinitionType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, RunoutGroupFeatureDefinitionType >
    _xsd_RunoutGroupFeatureDefinitionType_type_factory_init (
      "RunoutGroupFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");

    // RunoutGroupFeatureNominalType
    //

    RunoutGroupFeatureNominalType::
    RunoutGroupFeatureNominalType (const id_type& id,
                                   const FeatureDefinitionId_type& FeatureDefinitionId,
                                   const FeatureNominalIds_type& FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    RunoutGroupFeatureNominalType::
    RunoutGroupFeatureNominalType (const id_type& id,
                                   const FeatureDefinitionId_type& FeatureDefinitionId,
                                   ::std::auto_ptr< FeatureNominalIds_type > FeatureNominalIds)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (id,
                                                    FeatureDefinitionId,
                                                    FeatureNominalIds)
    {
    }

    RunoutGroupFeatureNominalType::
    RunoutGroupFeatureNominalType (const RunoutGroupFeatureNominalType& x,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (x, f, c)
    {
    }

    RunoutGroupFeatureNominalType::
    RunoutGroupFeatureNominalType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f,
                                   ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureNominalBaseType (e, f, c)
    {
    }

    RunoutGroupFeatureNominalType* RunoutGroupFeatureNominalType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RunoutGroupFeatureNominalType (*this, f, c);
    }

    RunoutGroupFeatureNominalType::
    ~RunoutGroupFeatureNominalType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, RunoutGroupFeatureNominalType >
    _xsd_RunoutGroupFeatureNominalType_type_factory_init (
      "RunoutGroupFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");

    // RunoutGroupFeatureActualType
    //

    RunoutGroupFeatureActualType::
    RunoutGroupFeatureActualType (const id_type& id,
                                  const FeatureItemId_type& FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    RunoutGroupFeatureActualType::
    RunoutGroupFeatureActualType (const id_type& id,
                                  ::std::auto_ptr< FeatureItemId_type > FeatureItemId)
    : ::xsd::qif2::CompositeFeatureActualBaseType (id,
                                                   FeatureItemId)
    {
    }

    RunoutGroupFeatureActualType::
    RunoutGroupFeatureActualType (const RunoutGroupFeatureActualType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (x, f, c)
    {
    }

    RunoutGroupFeatureActualType::
    RunoutGroupFeatureActualType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::CompositeFeatureActualBaseType (e, f, c)
    {
    }

    RunoutGroupFeatureActualType* RunoutGroupFeatureActualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class RunoutGroupFeatureActualType (*this, f, c);
    }

    RunoutGroupFeatureActualType::
    ~RunoutGroupFeatureActualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, RunoutGroupFeatureActualType >
    _xsd_RunoutGroupFeatureActualType_type_factory_init (
      "RunoutGroupFeatureActualType",
      "http://qifstandards.org/xsd/qif2");

    // FeatureAspectsListsType
    //

    FeatureAspectsListsType::
    FeatureAspectsListsType ()
    : ::xml_schema::type (),
      FeatureDefinitions_ (this),
      FeatureNominals_ (this),
      FeatureItems_ (this)
    {
    }

    FeatureAspectsListsType::
    FeatureAspectsListsType (const FeatureAspectsListsType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureDefinitions_ (x.FeatureDefinitions_, f, this),
      FeatureNominals_ (x.FeatureNominals_, f, this),
      FeatureItems_ (x.FeatureItems_, f, this)
    {
    }

    FeatureAspectsListsType::
    FeatureAspectsListsType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureDefinitions_ (this),
      FeatureNominals_ (this),
      FeatureItems_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureAspectsListsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureDefinitions
        //
        if (n.name () == "FeatureDefinitions" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureDefinitions_type > r (
            FeatureDefinitions_traits::create (i, f, this));

          if (!this->FeatureDefinitions_)
          {
            this->FeatureDefinitions_.set (r);
            continue;
          }
        }

        // FeatureNominals
        //
        if (n.name () == "FeatureNominals" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureNominals_type > r (
            FeatureNominals_traits::create (i, f, this));

          if (!this->FeatureNominals_)
          {
            this->FeatureNominals_.set (r);
            continue;
          }
        }

        // FeatureItems
        //
        if (n.name () == "FeatureItems" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureItems_type > r (
            FeatureItems_traits::create (i, f, this));

          if (!this->FeatureItems_)
          {
            this->FeatureItems_.set (r);
            continue;
          }
        }

        break;
      }
    }

    FeatureAspectsListsType* FeatureAspectsListsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureAspectsListsType (*this, f, c);
    }

    FeatureAspectsListsType& FeatureAspectsListsType::
    operator= (const FeatureAspectsListsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureDefinitions_ = x.FeatureDefinitions_;
        this->FeatureNominals_ = x.FeatureNominals_;
        this->FeatureItems_ = x.FeatureItems_;
      }

      return *this;
    }

    FeatureAspectsListsType::
    ~FeatureAspectsListsType ()
    {
    }

    // MeasuredFeaturesType
    //

    MeasuredFeaturesType::
    MeasuredFeaturesType (const FeatureActuals_type& FeatureActuals)
    : ::xml_schema::type (),
      FeatureActuals_ (FeatureActuals, this)
    {
    }

    MeasuredFeaturesType::
    MeasuredFeaturesType (::std::auto_ptr< FeatureActuals_type > FeatureActuals)
    : ::xml_schema::type (),
      FeatureActuals_ (FeatureActuals, this)
    {
    }

    MeasuredFeaturesType::
    MeasuredFeaturesType (const MeasuredFeaturesType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureActuals_ (x.FeatureActuals_, f, this)
    {
    }

    MeasuredFeaturesType::
    MeasuredFeaturesType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureActuals_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MeasuredFeaturesType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureActuals
        //
        if (n.name () == "FeatureActuals" && n.namespace_ () == "http://qifstandards.org/xsd/qif2")
        {
          ::std::auto_ptr< FeatureActuals_type > r (
            FeatureActuals_traits::create (i, f, this));

          if (!FeatureActuals_.present ())
          {
            this->FeatureActuals_.set (r);
            continue;
          }
        }

        break;
      }

      if (!FeatureActuals_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "FeatureActuals",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    MeasuredFeaturesType* MeasuredFeaturesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MeasuredFeaturesType (*this, f, c);
    }

    MeasuredFeaturesType& MeasuredFeaturesType::
    operator= (const MeasuredFeaturesType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureActuals_ = x.FeatureActuals_;
      }

      return *this;
    }

    MeasuredFeaturesType::
    ~MeasuredFeaturesType ()
    {
    }

    // FeatureDefinitionsType
    //

    FeatureDefinitionsType::
    FeatureDefinitionsType ()
    : ::xml_schema::type (),
      FeatureDefinition_ (this)
    {
    }

    FeatureDefinitionsType::
    FeatureDefinitionsType (const FeatureDefinitionsType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureDefinition_ (x.FeatureDefinition_, f, this)
    {
    }

    FeatureDefinitionsType::
    FeatureDefinitionsType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureDefinition_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureDefinitionsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureDefinition
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "FeatureDefinition",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< FeatureDefinition_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< FeatureDefinition_type > r (
              dynamic_cast< FeatureDefinition_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FeatureDefinition_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    FeatureDefinitionsType* FeatureDefinitionsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureDefinitionsType (*this, f, c);
    }

    FeatureDefinitionsType& FeatureDefinitionsType::
    operator= (const FeatureDefinitionsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureDefinition_ = x.FeatureDefinition_;
      }

      return *this;
    }

    FeatureDefinitionsType::
    ~FeatureDefinitionsType ()
    {
    }

    // FeatureNominalsType
    //

    FeatureNominalsType::
    FeatureNominalsType ()
    : ::xml_schema::type (),
      FeatureNominal_ (this)
    {
    }

    FeatureNominalsType::
    FeatureNominalsType (const FeatureNominalsType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureNominal_ (x.FeatureNominal_, f, this)
    {
    }

    FeatureNominalsType::
    FeatureNominalsType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureNominal_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureNominalsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureNominal
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "FeatureNominal",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< FeatureNominal_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< FeatureNominal_type > r (
              dynamic_cast< FeatureNominal_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FeatureNominal_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    FeatureNominalsType* FeatureNominalsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureNominalsType (*this, f, c);
    }

    FeatureNominalsType& FeatureNominalsType::
    operator= (const FeatureNominalsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureNominal_ = x.FeatureNominal_;
      }

      return *this;
    }

    FeatureNominalsType::
    ~FeatureNominalsType ()
    {
    }

    // FeatureItemsType
    //

    FeatureItemsType::
    FeatureItemsType ()
    : ::xml_schema::type (),
      FeatureItem_ (this)
    {
    }

    FeatureItemsType::
    FeatureItemsType (const FeatureItemsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureItem_ (x.FeatureItem_, f, this)
    {
    }

    FeatureItemsType::
    FeatureItemsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureItem_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureItemsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureItem
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "FeatureItem",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< FeatureItem_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< FeatureItem_type > r (
              dynamic_cast< FeatureItem_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FeatureItem_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    FeatureItemsType* FeatureItemsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureItemsType (*this, f, c);
    }

    FeatureItemsType& FeatureItemsType::
    operator= (const FeatureItemsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureItem_ = x.FeatureItem_;
      }

      return *this;
    }

    FeatureItemsType::
    ~FeatureItemsType ()
    {
    }

    // FeatureActualsType
    //

    FeatureActualsType::
    FeatureActualsType ()
    : ::xml_schema::type (),
      FeatureActual_ (this)
    {
    }

    FeatureActualsType::
    FeatureActualsType (const FeatureActualsType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      FeatureActual_ (x.FeatureActual_, f, this)
    {
    }

    FeatureActualsType::
    FeatureActualsType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      FeatureActual_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void FeatureActualsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // FeatureActual
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "FeatureActual",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< FeatureActual_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< FeatureActual_type > r (
              dynamic_cast< FeatureActual_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->FeatureActual_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    FeatureActualsType* FeatureActualsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class FeatureActualsType (*this, f, c);
    }

    FeatureActualsType& FeatureActualsType::
    operator= (const FeatureActualsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->FeatureActual_ = x.FeatureActual_;
      }

      return *this;
    }

    FeatureActualsType::
    ~FeatureActualsType ()
    {
    }

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ArcFeatureDefinitionType >
    _xsd_ArcFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ArcFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::GenericFeatureDefinitionType >
    _xsd_GenericFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "GenericFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CircleFeatureDefinitionType >
    _xsd_CircleFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "CircleFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CompoundFeatureDefinitionType >
    _xsd_CompoundFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "CompoundFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ConeFeatureDefinitionType >
    _xsd_ConeFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ConeFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    _xsd_ConicalSegmentFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ConicalSegmentFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CuboidFeatureDefinitionType >
    _xsd_CuboidFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "CuboidFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CylinderFeatureDefinitionType >
    _xsd_CylinderFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "CylinderFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    _xsd_CylindricalSegmentFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "CylindricalSegmentFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::EdgePointFeatureDefinitionType >
    _xsd_EdgePointFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "EdgePointFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::EllipseFeatureDefinitionType >
    _xsd_EllipseFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "EllipseFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    _xsd_ElongatedCylinderFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ElongatedCylinderFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    _xsd_ExtrudedCrossSectionFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ExtrudedCrossSectionFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::LineFeatureDefinitionType >
    _xsd_LineFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "LineFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    _xsd_OppositeLinesFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "OppositeLinesFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    _xsd_OppositePlanesFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "OppositePlanesFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PatternFeatureDefinitionType >
    _xsd_PatternFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "PatternFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PlaneFeatureDefinitionType >
    _xsd_PlaneFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "PlaneFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    _xsd_PointDefinedCurveFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedCurveFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    _xsd_PointDefinedSurfaceFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedSurfaceFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointFeatureDefinitionType >
    _xsd_PointFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "PointFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    _xsd_ProfileGroupFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ProfileGroupFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    _xsd_RunoutGroupFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "RunoutGroupFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SphereFeatureDefinitionType >
    _xsd_SphereFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "SphereFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    _xsd_SphericalSegmentFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "SphericalSegmentFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    _xsd_SurfaceOfRevolutionFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "SurfaceOfRevolutionFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ThreadedFeatureDefinitionType >
    _xsd_ThreadedFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ThreadedFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    _xsd_ToroidalSegmentFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ToroidalSegmentFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::TorusFeatureDefinitionType >
    _xsd_TorusFeatureDefinition_element_factory_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "TorusFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ArcFeatureNominalType >
    _xsd_ArcFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ArcFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::GenericFeatureNominalType >
    _xsd_GenericFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "GenericFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CircleFeatureNominalType >
    _xsd_CircleFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "CircleFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CompoundFeatureNominalType >
    _xsd_CompoundFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "CompoundFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ConeFeatureNominalType >
    _xsd_ConeFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ConeFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ConicalSegmentFeatureNominalType >
    _xsd_ConicalSegmentFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ConicalSegmentFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CuboidFeatureNominalType >
    _xsd_CuboidFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "CuboidFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CylinderFeatureNominalType >
    _xsd_CylinderFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "CylinderFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    _xsd_CylindricalSegmentFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "CylindricalSegmentFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::EdgePointFeatureNominalType >
    _xsd_EdgePointFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "EdgePointFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::EllipseFeatureNominalType >
    _xsd_EllipseFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "EllipseFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    _xsd_ElongatedCylinderFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ElongatedCylinderFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    _xsd_ExtrudedCrossSectionFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ExtrudedCrossSectionFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::LineFeatureNominalType >
    _xsd_LineFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "LineFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PatternFeatureNominalType >
    _xsd_PatternFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "PatternFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PlaneFeatureNominalType >
    _xsd_PlaneFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "PlaneFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    _xsd_PointDefinedCurveFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedCurveFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    _xsd_PointDefinedSurfaceFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedSurfaceFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointFeatureNominalType >
    _xsd_PointFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "PointFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OppositeLinesFeatureNominalType >
    _xsd_OppositeLinesFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "OppositeLinesFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OppositePlanesFeatureNominalType >
    _xsd_OppositePlanesFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "OppositePlanesFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ProfileGroupFeatureNominalType >
    _xsd_ProfileGroupFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ProfileGroupFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::RunoutGroupFeatureNominalType >
    _xsd_RunoutGroupFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "RunoutGroupFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SphereFeatureNominalType >
    _xsd_SphereFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "SphereFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SphericalSegmentFeatureNominalType >
    _xsd_SphericalSegmentFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "SphericalSegmentFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    _xsd_SurfaceOfRevolutionFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "SurfaceOfRevolutionFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ThreadedFeatureNominalType >
    _xsd_ThreadedFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ThreadedFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    _xsd_ToroidalSegmentFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ToroidalSegmentFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::TorusFeatureNominalType >
    _xsd_TorusFeatureNominal_element_factory_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "TorusFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ArcFeatureActualType >
    _xsd_ArcFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ArcFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::GenericFeatureActualType >
    _xsd_GenericFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "GenericFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CircleFeatureActualType >
    _xsd_CircleFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "CircleFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CompoundFeatureActualType >
    _xsd_CompoundFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "CompoundFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ConeFeatureActualType >
    _xsd_ConeFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ConeFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ConicalSegmentFeatureActualType >
    _xsd_ConicalSegmentFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ConicalSegmentFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CuboidFeatureActualType >
    _xsd_CuboidFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "CuboidFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CylinderFeatureActualType >
    _xsd_CylinderFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "CylinderFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CylindricalSegmentFeatureActualType >
    _xsd_CylindricalSegmentFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "CylindricalSegmentFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::EdgePointFeatureActualType >
    _xsd_EdgePointFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "EdgePointFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::EllipseFeatureActualType >
    _xsd_EllipseFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "EllipseFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ElongatedCylinderFeatureActualType >
    _xsd_ElongatedCylinderFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ElongatedCylinderFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    _xsd_ExtrudedCrossSectionFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ExtrudedCrossSectionFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::LineFeatureActualType >
    _xsd_LineFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "LineFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OppositeLinesFeatureActualType >
    _xsd_OppositeLinesFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "OppositeLinesFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OppositePlanesFeatureActualType >
    _xsd_OppositePlanesFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "OppositePlanesFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PatternFeatureActualType >
    _xsd_PatternFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "PatternFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PlaneFeatureActualType >
    _xsd_PlaneFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "PlaneFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointDefinedCurveFeatureActualType >
    _xsd_PointDefinedCurveFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedCurveFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    _xsd_PointDefinedSurfaceFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedSurfaceFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointFeatureActualType >
    _xsd_PointFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "PointFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ProfileGroupFeatureActualType >
    _xsd_ProfileGroupFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ProfileGroupFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::RunoutGroupFeatureActualType >
    _xsd_RunoutGroupFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "RunoutGroupFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SphereFeatureActualType >
    _xsd_SphereFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "SphereFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SphericalSegmentFeatureActualType >
    _xsd_SphericalSegmentFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "SphericalSegmentFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    _xsd_SurfaceOfRevolutionFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "SurfaceOfRevolutionFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ThreadedFeatureActualType >
    _xsd_ThreadedFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ThreadedFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ToroidalSegmentFeatureActualType >
    _xsd_ToroidalSegmentFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ToroidalSegmentFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::TorusFeatureActualType >
    _xsd_TorusFeatureActual_element_factory_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "TorusFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ArcFeatureItemType >
    _xsd_ArcFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ArcFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::GenericFeatureItemType >
    _xsd_GenericFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "GenericFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CircleFeatureItemType >
    _xsd_CircleFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "CircleFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CompoundFeatureItemType >
    _xsd_CompoundFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "CompoundFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ConeFeatureItemType >
    _xsd_ConeFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ConeFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ConicalSegmentFeatureItemType >
    _xsd_ConicalSegmentFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ConicalSegmentFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CuboidFeatureItemType >
    _xsd_CuboidFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "CuboidFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CylinderFeatureItemType >
    _xsd_CylinderFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "CylinderFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::CylindricalSegmentFeatureItemType >
    _xsd_CylindricalSegmentFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "CylindricalSegmentFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::EdgePointFeatureItemType >
    _xsd_EdgePointFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "EdgePointFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::EllipseFeatureItemType >
    _xsd_EllipseFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "EllipseFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ElongatedCylinderFeatureItemType >
    _xsd_ElongatedCylinderFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ElongatedCylinderFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    _xsd_ExtrudedCrossSectionFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ExtrudedCrossSectionFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::LineFeatureItemType >
    _xsd_LineFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "LineFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OppositeLinesFeatureItemType >
    _xsd_OppositeLinesFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "OppositeLinesFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OppositePlanesFeatureItemType >
    _xsd_OppositePlanesFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "OppositePlanesFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PatternFeatureItemType >
    _xsd_PatternFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "PatternFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PlaneFeatureItemType >
    _xsd_PlaneFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "PlaneFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointDefinedCurveFeatureItemType >
    _xsd_PointDefinedCurveFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedCurveFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    _xsd_PointDefinedSurfaceFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedSurfaceFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PointFeatureItemType >
    _xsd_PointFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "PointFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ProfileGroupFeatureItemType >
    _xsd_ProfileGroupFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ProfileGroupFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::RunoutGroupFeatureItemType >
    _xsd_RunoutGroupFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "RunoutGroupFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SphereFeatureItemType >
    _xsd_SphereFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "SphereFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SphericalSegmentFeatureItemType >
    _xsd_SphericalSegmentFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "SphericalSegmentFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    _xsd_SurfaceOfRevolutionFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "SurfaceOfRevolutionFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ThreadedFeatureItemType >
    _xsd_ThreadedFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ThreadedFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ToroidalSegmentFeatureItemType >
    _xsd_ToroidalSegmentFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ToroidalSegmentFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::TorusFeatureItemType >
    _xsd_TorusFeatureItem_element_factory_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "TorusFeatureItem",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement& e, const FeatureBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Attributes
      //
      if (i.Attributes ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Attributes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Attributes ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "id",
            e));

        a << i.id ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureItemBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureBaseType& > (i);

      // FeatureNominalId
      //
      if (i.FeatureNominalId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureNominalId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FeatureNominalId ();
      }

      // ParentFeatureItemId
      //
      if (i.ParentFeatureItemId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ParentFeatureItemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ParentFeatureItemId ();
      }

      // FeatureName
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureName",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.FeatureName ();
      }

      // QPId
      //
      if (i.QPId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "QPId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.QPId ();
      }

      // NotableEventIds
      //
      if (i.NotableEventIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NotableEventIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NotableEventIds ();
      }

      // CoordinateSystemId
      //
      if (i.CoordinateSystemId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoordinateSystemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CoordinateSystemId ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FeatureItemBaseType >
    _xsd_FeatureItemBaseType_type_serializer_init (
      "FeatureItemBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const FeatureDefinitionBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FeatureDefinitionBaseType >
    _xsd_FeatureDefinitionBaseType_type_serializer_init (
      "FeatureDefinitionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointListNominalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasurePoint
      //
      for (PointListNominalType::MeasurePoint_const_iterator
           b (i.MeasurePoint ().begin ()), n (i.MeasurePoint ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurePoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // linearUnit
      //
      if (i.linearUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zValidity",
            e));

        a << *i.zValidity ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureNominalBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureBaseType& > (i);

      // Name
      //
      if (i.Name ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Name ();
      }

      // PointList
      //
      if (i.PointList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointList ();
      }

      // FeatureDefinitionId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureDefinitionId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.FeatureDefinitionId ();
      }

      // EntityInternalIds
      //
      if (i.EntityInternalIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EntityInternalIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EntityInternalIds ();
      }

      // EntityExternalIds
      //
      if (i.EntityExternalIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EntityExternalIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EntityExternalIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FeatureNominalBaseType >
    _xsd_FeatureNominalBaseType_type_serializer_init (
      "FeatureNominalBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointListActualType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // MeasurePoint
      //
      for (PointListActualType::MeasurePoint_const_iterator
           b (i.MeasurePoint ().begin ()), n (i.MeasurePoint ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurePoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // linearUnit
      //
      if (i.linearUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zValidity",
            e));

        a << *i.zValidity ();
      }

      // combinedUncertainty
      //
      if (i.combinedUncertainty ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "combinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.combinedUncertainty ());
      }

      // meanError
      //
      if (i.meanError ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "meanError",
            e));

        a << ::xml_schema::as_decimal(*i.meanError ());
      }

      // xCombinedUncertainty
      //
      if (i.xCombinedUncertainty ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.xCombinedUncertainty ());
      }

      // xMeanError
      //
      if (i.xMeanError ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.xMeanError ());
      }

      // yCombinedUncertainty
      //
      if (i.yCombinedUncertainty ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.yCombinedUncertainty ());
      }

      // yMeanError
      //
      if (i.yMeanError ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.yMeanError ());
      }

      // zCombinedUncertainty
      //
      if (i.zCombinedUncertainty ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.zCombinedUncertainty ());
      }

      // zMeanError
      //
      if (i.zMeanError ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.zMeanError ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureActualBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureBaseType& > (i);

      // PointList
      //
      if (i.PointList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointList ();
      }

      // FeatureItemId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureItemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.FeatureItemId ();
      }

      // ActualComponentId
      //
      if (i.ActualComponentId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ActualComponentId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ActualComponentId ();
      }

      // ManufacturingProcessId
      //
      if (i.ManufacturingProcessId ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ManufacturingProcessId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.ManufacturingProcessId ();
      }

      // MeasurementDeviceIds
      //
      if (i.MeasurementDeviceIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MeasurementDeviceIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MeasurementDeviceIds ();
      }

      // NotedEventIds
      //
      if (i.NotedEventIds ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NotedEventIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NotedEventIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FeatureActualBaseType >
    _xsd_FeatureActualBaseType_type_serializer_init (
      "FeatureActualBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SetFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&, const SetFeatureType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const SetFeatureType&)
    {
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasuredFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // PointList
      //
      if (i.PointList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConstructionMethodBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // NominalsCalculated
      //
      if (i.NominalsCalculated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "NominalsCalculated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.NominalsCalculated ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointRangeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Start
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Start",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Start ();
      }

      // Stop
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Stop",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Stop ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointIndexType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Single
      //
      if (i.Single ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Single",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Single ();
      }

      // Range
      //
      if (i.Range ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Range",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Range ();
      }

      // All
      //
      if (i.All ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "All",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.All ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const BaseFeaturePointSetType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureItemId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureItemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.FeatureItemId ();
      }

      // PointIndex
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointIndex",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PointIndex ();
      }

      // ReferencedComponent
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReferencedComponent",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ReferencedComponent ();
      }

      // SequenceNumber
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SequenceNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SequenceNumber ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const BaseFeaturePointListType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BaseFeaturePointSet
      //
      for (BaseFeaturePointListType::BaseFeaturePointSet_const_iterator
           b (i.BaseFeaturePointSet ().begin ()), n (i.BaseFeaturePointSet ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointSet",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TransformationReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ReferencedComponent
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReferencedComponent",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ReferencedComponent ();
      }

      // CoordinateSystemId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CoordinateSystemId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CoordinateSystemId ();
      }

      // SequenceNumber
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SequenceNumber",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SequenceNumber ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Projection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }

      // Extract
      //
      if (i.Extract ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Extract",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Extract ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ArcBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcProjectionType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // ProjectionArc
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionArc",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionArc ();
      }

      // ProjectionPlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionPlane ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseArc
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseArc",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseArc ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseArc
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseArc",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseArc ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }

      // Depth
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Depth",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Depth ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcExtractType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // CurveFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CurveFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CurveFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ArcFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArcFeatureItemType >
    _xsd_ArcFeatureItemType_type_serializer_init (
      "ArcFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ArcFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Radius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Radius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Radius ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArcFeatureDefinitionType >
    _xsd_ArcFeatureDefinitionType_type_serializer_init (
      "ArcFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ArcFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // Sweep
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Sweep ();
      }

      // Normal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Normal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArcFeatureNominalType >
    _xsd_ArcFeatureNominalType_type_serializer_init (
      "ArcFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ArcFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }

      // Radius
      //
      if (i.Radius ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Radius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Radius ();
      }

      // RadiusMin
      //
      if (i.RadiusMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RadiusMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.RadiusMin ();
      }

      // RadiusMax
      //
      if (i.RadiusMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RadiusMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.RadiusMax ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Sweep ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArcFeatureActualType >
    _xsd_ArcFeatureActualType_type_serializer_init (
      "ArcFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CircleConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Intersection
      //
      if (i.Intersection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Intersection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Intersection ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Projection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Tangent
      //
      if (i.Tangent ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Tangent",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Tangent ();
      }

      // TangentThrough
      //
      if (i.TangentThrough ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TangentThrough",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TangentThrough ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromCone
      //
      if (i.FromCone ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromCone",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromCone ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (CircleBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // IntersectionPlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IntersectionPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.IntersectionPlane ();
      }

      // IntersectionFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IntersectionFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.IntersectionFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleProjectionType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // ProjectionCircle
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionCircle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionCircle ();
      }

      // ProjectionPlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionPlane ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCircle
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCircle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCircle ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleTangentType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // TangentFeature
      //
      for (CircleTangentType::TangentFeature_const_iterator
           b (i.TangentFeature ().begin ()), n (i.TangentFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TangentFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleTangentThroughType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // TangentFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TangentFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TangentFeature ();
      }

      // PointFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCircle
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCircle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCircle ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleFromConeType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // Diameter
      //
      if (i.Diameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Diameter ();
      }

      // Distance
      //
      if (i.Distance ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Distance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Distance ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }

      // Depth
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Depth",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Depth ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CircleFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CircleFeatureItemType >
    _xsd_CircleFeatureItemType_type_serializer_init (
      "CircleFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CircleFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CircleFeatureDefinitionType >
    _xsd_CircleFeatureDefinitionType_type_serializer_init (
      "CircleFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CircleFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // Normal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Normal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CircleFeatureNominalType >
    _xsd_CircleFeatureNominalType_type_serializer_init (
      "CircleFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CircleFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMax ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CircleFeatureActualType >
    _xsd_CircleFeatureActualType_type_serializer_init (
      "CircleFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConeConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConeBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ConeBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConeRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConeCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCone
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCone",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCone ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConeCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConeTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCone
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCone",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCone ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConeFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConeCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConeCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConeActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConeFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConeFeatureItemType >
    _xsd_ConeFeatureItemType_type_serializer_init (
      "ConeFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConeFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }

      // HalfAngle
      //
      if (i.HalfAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HalfAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.HalfAngle ();
      }

      // FullAngle
      //
      if (i.FullAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FullAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FullAngle ();
      }

      // LargeEndDistance
      //
      if (i.LargeEndDistance ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LargeEndDistance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LargeEndDistance ();
      }

      // SmallEndDistance
      //
      if (i.SmallEndDistance ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SmallEndDistance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SmallEndDistance ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConeFeatureDefinitionType >
    _xsd_ConeFeatureDefinitionType_type_serializer_init (
      "ConeFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConeFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Axis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Sweep ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConeFeatureNominalType >
    _xsd_ConeFeatureNominalType_type_serializer_init (
      "ConeFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConeFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Axis ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMax ();
      }

      // HalfAngle
      //
      if (i.HalfAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HalfAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.HalfAngle ();
      }

      // FullAngle
      //
      if (i.FullAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FullAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FullAngle ();
      }

      // SmallEndDistance
      //
      if (i.SmallEndDistance ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SmallEndDistance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SmallEndDistance ();
      }

      // LargeEndDistance
      //
      if (i.LargeEndDistance ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LargeEndDistance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LargeEndDistance ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Sweep ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConeFeatureActualType >
    _xsd_ConeFeatureActualType_type_serializer_init (
      "ConeFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ConicalSegmentBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseConicalSegment
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseConicalSegment",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseConicalSegment ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseConicalSegment
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseConicalSegment",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseConicalSegment ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConicalSegmentFeatureItemType >
    _xsd_ConicalSegmentFeatureItemType_type_serializer_init (
      "ConicalSegmentFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }

      // HalfAngle
      //
      if (i.HalfAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HalfAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.HalfAngle ();
      }

      // FullAngle
      //
      if (i.FullAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FullAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FullAngle ();
      }

      // LargeEndDistance
      //
      if (i.LargeEndDistance ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LargeEndDistance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LargeEndDistance ();
      }

      // SmallEndDistance
      //
      if (i.SmallEndDistance ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SmallEndDistance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SmallEndDistance ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConicalSegmentFeatureDefinitionType >
    _xsd_ConicalSegmentFeatureDefinitionType_type_serializer_init (
      "ConicalSegmentFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Axis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Sweep ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConicalSegmentFeatureNominalType >
    _xsd_ConicalSegmentFeatureNominalType_type_serializer_init (
      "ConicalSegmentFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConicalSegmentFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Axis ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMax ();
      }

      // HalfAngle
      //
      if (i.HalfAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HalfAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.HalfAngle ();
      }

      // FullAngle
      //
      if (i.FullAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FullAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FullAngle ();
      }

      // SmallEndDistance
      //
      if (i.SmallEndDistance ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SmallEndDistance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SmallEndDistance ();
      }

      // LargeEndDistance
      //
      if (i.LargeEndDistance ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LargeEndDistance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LargeEndDistance ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Sweep ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConicalSegmentFeatureActualType >
    _xsd_ConicalSegmentFeatureActualType_type_serializer_init (
      "ConicalSegmentFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CuboidConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CuboidBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (CuboidBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CuboidRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CuboidCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCuboid
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCuboid",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCuboid ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CuboidCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CuboidTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCuboid
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCuboid",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCuboid ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CuboidCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CuboidCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CuboidActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CuboidFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CuboidFeatureItemType >
    _xsd_CuboidFeatureItemType_type_serializer_init (
      "CuboidFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CuboidFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Length
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Length ();
      }

      // Width
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Width",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Width ();
      }

      // Height
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Height",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Height ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CuboidFeatureDefinitionType >
    _xsd_CuboidFeatureDefinitionType_type_serializer_init (
      "CuboidFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CuboidFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // LengthVector
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.LengthVector ();
      }

      // HeightVector
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HeightVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.HeightVector ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CuboidFeatureNominalType >
    _xsd_CuboidFeatureNominalType_type_serializer_init (
      "CuboidFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CuboidFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // LengthMax
      //
      if (i.LengthMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LengthMax ();
      }

      // LengthMin
      //
      if (i.LengthMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LengthMin ();
      }

      // LengthVector
      //
      if (i.LengthVector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LengthVector ();
      }

      // Width
      //
      if (i.Width ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Width",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Width ();
      }

      // WidthMax
      //
      if (i.WidthMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WidthMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WidthMax ();
      }

      // WidthMin
      //
      if (i.WidthMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WidthMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WidthMin ();
      }

      // Height
      //
      if (i.Height ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Height",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Height ();
      }

      // HeightMax
      //
      if (i.HeightMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HeightMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.HeightMax ();
      }

      // HeightMin
      //
      if (i.HeightMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HeightMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.HeightMin ();
      }

      // HeightVector
      //
      if (i.HeightVector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "HeightVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.HeightVector ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CuboidFeatureActualType >
    _xsd_CuboidFeatureActualType_type_serializer_init (
      "CuboidFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CylinderConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylinderBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (CylinderBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylinderRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylinderCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCylinder
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCylinder",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCylinder ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylinderCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylinderTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCylinder
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCylinder",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCylinder ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylinderFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylinderCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylinderCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylinderActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylinderFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CylinderFeatureItemType >
    _xsd_CylinderFeatureItemType_type_serializer_init (
      "CylinderFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CylinderFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // Bottom
      //
      if (i.Bottom ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Bottom",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Bottom ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CylinderFeatureDefinitionType >
    _xsd_CylinderFeatureDefinitionType_type_serializer_init (
      "CylinderFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CylinderFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Axis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Sweep ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CylinderFeatureNominalType >
    _xsd_CylinderFeatureNominalType_type_serializer_init (
      "CylinderFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CylinderFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Axis ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Diameter ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMax ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Sweep ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CylinderFeatureActualType >
    _xsd_CylinderFeatureActualType_type_serializer_init (
      "CylinderFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (CylindricalSegmentBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCylindricalSegment
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCylindricalSegment",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCylindricalSegment ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCylindricalSegment
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCylindricalSegment",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCylindricalSegment ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CylindricalSegmentFeatureItemType >
    _xsd_CylindricalSegmentFeatureItemType_type_serializer_init (
      "CylindricalSegmentFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // Bottom
      //
      if (i.Bottom ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Bottom",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Bottom ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CylindricalSegmentFeatureDefinitionType >
    _xsd_CylindricalSegmentFeatureDefinitionType_type_serializer_init (
      "CylindricalSegmentFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Axis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Sweep ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CylindricalSegmentFeatureNominalType >
    _xsd_CylindricalSegmentFeatureNominalType_type_serializer_init (
      "CylindricalSegmentFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CylindricalSegmentFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Axis ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Diameter ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMax ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Sweep ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CylindricalSegmentFeatureActualType >
    _xsd_CylindricalSegmentFeatureActualType_type_serializer_init (
      "CylindricalSegmentFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EdgePointConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgePointCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseEdgePoint
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseEdgePoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseEdgePoint ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgePointCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgePointTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseEdgePoint
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseEdgePoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseEdgePoint ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgePointFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }

      // PatchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PatchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PatchRadius ();
      }

      // Distance
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Distance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Distance ();
      }

      // Depth
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Depth",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Depth ();
      }

      // RetrievalMethod
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RetrievalMethod",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.RetrievalMethod ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgePointCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgePointCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgePointActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EdgePointFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EdgePointFeatureItemType >
    _xsd_EdgePointFeatureItemType_type_serializer_init (
      "EdgePointFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EdgePointFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EdgePointFeatureDefinitionType >
    _xsd_EdgePointFeatureDefinitionType_type_serializer_init (
      "EdgePointFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EdgePointFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // Normal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Normal ();
      }

      // AdjacentNormal
      //
      if (i.AdjacentNormal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AdjacentNormal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AdjacentNormal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EdgePointFeatureNominalType >
    _xsd_EdgePointFeatureNominalType_type_serializer_init (
      "EdgePointFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EdgePointFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }

      // AdjacentNormal
      //
      if (i.AdjacentNormal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AdjacentNormal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AdjacentNormal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EdgePointFeatureActualType >
    _xsd_EdgePointFeatureActualType_type_serializer_init (
      "EdgePointFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EllipseConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Intersection
      //
      if (i.Intersection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Intersection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Intersection ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Projection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (EllipseBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseProjectionType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // ProjectionFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionFeature ();
      }

      // ProjectionPlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionPlane ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // IntersectionPlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IntersectionPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.IntersectionPlane ();
      }

      // IntersectionFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IntersectionFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.IntersectionFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseEllipse
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseEllipse",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseEllipse ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseEllipse
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseEllipse",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseEllipse ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }

      // Depth
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Depth",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Depth ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const EllipseFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EllipseFeatureItemType >
    _xsd_EllipseFeatureItemType_type_serializer_init (
      "EllipseFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EllipseFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // MajorDiameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MajorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MajorDiameter ();
      }

      // MinorDiameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MinorDiameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EllipseFeatureDefinitionType >
    _xsd_EllipseFeatureDefinitionType_type_serializer_init (
      "EllipseFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EllipseFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Axis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Axis ();
      }

      // Normal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Normal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EllipseFeatureNominalType >
    _xsd_EllipseFeatureNominalType_type_serializer_init (
      "EllipseFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const EllipseFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Axis ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }

      // MajorDiameter
      //
      if (i.MajorDiameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MajorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MajorDiameter ();
      }

      // MinorDiameter
      //
      if (i.MinorDiameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinorDiameter ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, EllipseFeatureActualType >
    _xsd_EllipseFeatureActualType_type_serializer_init (
      "EllipseFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ElongatedCylinderBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseElongatedCylinder
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseElongatedCylinder",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseElongatedCylinder ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseElongatedCylinder
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseElongatedCylinder",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseElongatedCylinder ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ElongatedCylinderFeatureItemType >
    _xsd_ElongatedCylinderFeatureItemType_type_serializer_init (
      "ElongatedCylinderFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }

      // Length
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Length ();
      }

      // Width
      //
      if (i.Width ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Width",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Width ();
      }

      // Depth
      //
      if (i.Depth ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Depth",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Depth ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ElongatedCylinderFeatureDefinitionType >
    _xsd_ElongatedCylinderFeatureDefinitionType_type_serializer_init (
      "ElongatedCylinderFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // CenterPlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CenterPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CenterPlane ();
      }

      // DepthVector
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DepthVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DepthVector ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ElongatedCylinderFeatureNominalType >
    _xsd_ElongatedCylinderFeatureNominalType_type_serializer_init (
      "ElongatedCylinderFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ElongatedCylinderFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Diameter
      //
      if (i.Diameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMax ();
      }

      // CenterPlane
      //
      if (i.CenterPlane ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CenterPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CenterPlane ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // LengthMax
      //
      if (i.LengthMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LengthMax ();
      }

      // LengthMin
      //
      if (i.LengthMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LengthMin ();
      }

      // Width
      //
      if (i.Width ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Width",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Width ();
      }

      // WidthMax
      //
      if (i.WidthMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WidthMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WidthMax ();
      }

      // WidthMin
      //
      if (i.WidthMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WidthMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WidthMin ();
      }

      // Depth
      //
      if (i.Depth ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Depth",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Depth ();
      }

      // DepthMax
      //
      if (i.DepthMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DepthMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DepthMax ();
      }

      // DepthMin
      //
      if (i.DepthMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DepthMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DepthMin ();
      }

      // DepthVector
      //
      if (i.DepthVector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DepthVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DepthVector ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ElongatedCylinderFeatureActualType >
    _xsd_ElongatedCylinderFeatureActualType_type_serializer_init (
      "ElongatedCylinderFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ExtrudedCrossSectionBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseExtrudedCrossSection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseExtrudedCrossSection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseExtrudedCrossSection ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseExtrudedCrossSection
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseExtrudedCrossSection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseExtrudedCrossSection ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ExtrudedCrossSectionFeatureItemType >
    _xsd_ExtrudedCrossSectionFeatureItemType_type_serializer_init (
      "ExtrudedCrossSectionFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Length
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Length ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ExtrudedCrossSectionFeatureDefinitionType >
    _xsd_ExtrudedCrossSectionFeatureDefinitionType_type_serializer_init (
      "ExtrudedCrossSectionFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Direction
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Direction",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Direction ();
      }

      // CrossSectionReferenceFeatureId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CrossSectionReferenceFeatureId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CrossSectionReferenceFeatureId ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ExtrudedCrossSectionFeatureNominalType >
    _xsd_ExtrudedCrossSectionFeatureNominalType_type_serializer_init (
      "ExtrudedCrossSectionFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ExtrudedCrossSectionFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Direction
      //
      if (i.Direction ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Direction",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Direction ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ExtrudedCrossSectionFeatureActualType >
    _xsd_ExtrudedCrossSectionFeatureActualType_type_serializer_init (
      "ExtrudedCrossSectionFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const GenericFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GenericFeatureItemType >
    _xsd_GenericFeatureItemType_type_serializer_init (
      "GenericFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const GenericFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GenericFeatureDefinitionType >
    _xsd_GenericFeatureDefinitionType_type_serializer_init (
      "GenericFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const GenericFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // ReferenceFeatureNominalId
      //
      for (GenericFeatureNominalType::ReferenceFeatureNominalId_const_iterator
           b (i.ReferenceFeatureNominalId ().begin ()), n (i.ReferenceFeatureNominalId ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReferenceFeatureNominalId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GenericFeatureNominalType >
    _xsd_GenericFeatureNominalType_type_serializer_init (
      "GenericFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const GenericFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GenericFeatureActualType >
    _xsd_GenericFeatureActualType_type_serializer_init (
      "GenericFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LineConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Midline
      //
      if (i.Midline ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Midline",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Midline ();
      }

      // Intersection
      //
      if (i.Intersection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Intersection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Intersection ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Projection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Projection ();
      }

      // Perpendicular
      //
      if (i.Perpendicular ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Perpendicular",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Perpendicular ();
      }

      // Parallel
      //
      if (i.Parallel ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Parallel",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Parallel ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // TangentThrough
      //
      if (i.TangentThrough ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TangentThrough",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TangentThrough ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // Extract
      //
      if (i.Extract ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Extract",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Extract ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (LineBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineMidlineType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseLine
      //
      for (LineMidlineType::BaseLine_const_iterator
           b (i.BaseLine ().begin ()), n (i.BaseLine ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseLine",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BasePlane
      //
      for (LineIntersectionType::BasePlane_const_iterator
           b (i.BasePlane ().begin ()), n (i.BasePlane ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasePlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineProjectionType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // ProjectionPlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionPlane ();
      }

      // ProjectionLine
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionLine",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionLine ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LinePerpendicularType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // PerpendicularFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PerpendicularFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PerpendicularFeature ();
      }

      // PointFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineParallelType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // ParallelFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ParallelFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ParallelFeature ();
      }

      // PointFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseLine
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseLine",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseLine ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineTangentThroughType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // TangentFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TangentFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TangentFeature ();
      }

      // PointFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseLine
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseLine",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseLine ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineExtractType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // CurveFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CurveFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CurveFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const LineFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LineFeatureItemType >
    _xsd_LineFeatureItemType_type_serializer_init (
      "LineFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LineFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LineFeatureDefinitionType >
    _xsd_LineFeatureDefinitionType_type_serializer_init (
      "LineFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LineFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // Direction
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Direction",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Direction ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LineFeatureNominalType >
    _xsd_LineFeatureNominalType_type_serializer_init (
      "LineFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LineFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // Direction
      //
      if (i.Direction ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Direction",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Direction ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LineFeatureActualType >
    _xsd_LineFeatureActualType_type_serializer_init (
      "LineFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Projection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (OppositeLinesBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesProjectionType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // ProjectionPlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionPlane ();
      }

      // ProjectionOppositeLines
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionOppositeLines",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionOppositeLines ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseOppositeLines
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseOppositeLines",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseOppositeLines ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseOppositeLines
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseOppositeLines",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseOppositeLines ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }

      // Depth
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Depth",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Depth ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OppositeLinesFeatureItemType >
    _xsd_OppositeLinesFeatureItemType_type_serializer_init (
      "OppositeLinesFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Width
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Width",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Width ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // EndType
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndType",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.EndType ();
      }

      // TaperAngle
      //
      if (i.TaperAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TaperAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TaperAngle ();
      }

      // SingleOpenEnd
      //
      if (i.SingleOpenEnd ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SingleOpenEnd",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SingleOpenEnd ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndRadius1",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndRadius2",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EndRadius2 ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OppositeLinesFeatureDefinitionType >
    _xsd_OppositeLinesFeatureDefinitionType_type_serializer_init (
      "OppositeLinesFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // CenterLine
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CenterLine",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CenterLine ();
      }

      // Normal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Normal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OppositeLinesFeatureNominalType >
    _xsd_OppositeLinesFeatureNominalType_type_serializer_init (
      "OppositeLinesFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OppositeLinesFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // CenterLine
      //
      if (i.CenterLine ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CenterLine",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CenterLine ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }

      // Width
      //
      if (i.Width ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Width",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Width ();
      }

      // WidthMin
      //
      if (i.WidthMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WidthMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WidthMin ();
      }

      // WidthMax
      //
      if (i.WidthMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WidthMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WidthMax ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // LengthMin
      //
      if (i.LengthMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LengthMin ();
      }

      // LengthMax
      //
      if (i.LengthMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LengthMax ();
      }

      // TaperAngle
      //
      if (i.TaperAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TaperAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TaperAngle ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndRadius1",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndRadius2",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EndRadius2 ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OppositeLinesFeatureActualType >
    _xsd_OppositeLinesFeatureActualType_type_serializer_init (
      "OppositeLinesFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (OppositePlanesBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseOppositePlanes
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseOppositePlanes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseOppositePlanes ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseOppositePlanes
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseOppositePlanes",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseOppositePlanes ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OppositePlanesFeatureItemType >
    _xsd_OppositePlanesFeatureItemType_type_serializer_init (
      "OppositePlanesFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Width
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Width",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Width ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // EndType
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndType",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.EndType ();
      }

      // Depth
      //
      if (i.Depth ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Depth",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Depth ();
      }

      // Bottom
      //
      if (i.Bottom ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Bottom",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Bottom ();
      }

      // SingleOpenEnd
      //
      if (i.SingleOpenEnd ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SingleOpenEnd",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SingleOpenEnd ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndRadius1",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndRadius2",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EndRadius2 ();
      }

      // TaperAngle
      //
      if (i.TaperAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TaperAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TaperAngle ();
      }

      // DraftAngle
      //
      if (i.DraftAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DraftAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DraftAngle ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OppositePlanesFeatureDefinitionType >
    _xsd_OppositePlanesFeatureDefinitionType_type_serializer_init (
      "OppositePlanesFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // CenterPlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CenterPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CenterPlane ();
      }

      // LengthVector
      //
      if (i.LengthVector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LengthVector ();
      }

      // DepthVector
      //
      if (i.DepthVector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DepthVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DepthVector ();
      }

      // DraftVector
      //
      if (i.DraftVector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DraftVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DraftVector ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OppositePlanesFeatureNominalType >
    _xsd_OppositePlanesFeatureNominalType_type_serializer_init (
      "OppositePlanesFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OppositePlanesFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // CenterPlane
      //
      if (i.CenterPlane ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CenterPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CenterPlane ();
      }

      // LengthVector
      //
      if (i.LengthVector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LengthVector ();
      }

      // DepthVector
      //
      if (i.DepthVector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DepthVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DepthVector ();
      }

      // Width
      //
      if (i.Width ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Width",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Width ();
      }

      // WidthMin
      //
      if (i.WidthMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WidthMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WidthMin ();
      }

      // WidthMax
      //
      if (i.WidthMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "WidthMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.WidthMax ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // LengthMin
      //
      if (i.LengthMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LengthMin ();
      }

      // LengthMax
      //
      if (i.LengthMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LengthMax ();
      }

      // Depth
      //
      if (i.Depth ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Depth",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Depth ();
      }

      // TaperAngle
      //
      if (i.TaperAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TaperAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TaperAngle ();
      }

      // DraftAngle
      //
      if (i.DraftAngle ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DraftAngle",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DraftAngle ();
      }

      // EndRadius1
      //
      if (i.EndRadius1 ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndRadius1",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EndRadius1 ();
      }

      // EndRadius2
      //
      if (i.EndRadius2 ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndRadius2",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.EndRadius2 ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OppositePlanesFeatureActualType >
    _xsd_OppositePlanesFeatureActualType_type_serializer_init (
      "OppositePlanesFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PlaneConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Midplane
      //
      if (i.Midplane ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Midplane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Midplane ();
      }

      // Offset
      //
      if (i.Offset ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Offset",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Offset ();
      }

      // Perpendicular
      //
      if (i.Perpendicular ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Perpendicular",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Perpendicular ();
      }

      // Parallel
      //
      if (i.Parallel ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Parallel",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Parallel ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // TangentThrough
      //
      if (i.TangentThrough ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TangentThrough",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.TangentThrough ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // Extract
      //
      if (i.Extract ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Extract",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Extract ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (PlaneBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneMidplaneType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BasePlane
      //
      for (PlaneMidplaneType::BasePlane_const_iterator
           b (i.BasePlane ().begin ()), n (i.BasePlane ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasePlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneOffsetType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BasePlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasePlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BasePlane ();
      }

      // Offset
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Offset",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Offset ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlanePerpendicularType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // PerpendicularFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PerpendicularFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PerpendicularFeature ();
      }

      // PointFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneParallelType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // ParallelFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ParallelFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ParallelFeature ();
      }

      // PointFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BasePlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasePlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BasePlane ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneTangentThroughType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // TangentFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TangentFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.TangentFeature ();
      }

      // PointFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PointFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.PointFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BasePlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasePlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BasePlane ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneExtractType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PlaneFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PlaneFeatureItemType >
    _xsd_PlaneFeatureItemType_type_serializer_init (
      "PlaneFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PlaneFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PlaneFeatureDefinitionType >
    _xsd_PlaneFeatureDefinitionType_type_serializer_init (
      "PlaneFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PlaneFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // Normal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Normal ();
      }

      // PolyLine
      //
      if (i.PolyLine ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PolyLine",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PolyLine ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PlaneFeatureNominalType >
    _xsd_PlaneFeatureNominalType_type_serializer_init (
      "PlaneFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PlaneFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }

      // PolyLine
      //
      if (i.PolyLine ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PolyLine",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PolyLine ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PlaneFeatureActualType >
    _xsd_PlaneFeatureActualType_type_serializer_init (
      "PlaneFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }

      // Extract
      //
      if (i.Extract ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Extract",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Extract ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (PointDefinedCurveBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BasePointDefinedCurve
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasePointDefinedCurve",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BasePointDefinedCurve ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BasePointDefinedCurve
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasePointDefinedCurve",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BasePointDefinedCurve ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveExtractType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // CurveFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CurveFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CurveFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointDefinedCurveFeatureItemType >
    _xsd_PointDefinedCurveFeatureItemType_type_serializer_init (
      "PointDefinedCurveFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointDefinedCurveFeatureDefinitionType >
    _xsd_PointDefinedCurveFeatureDefinitionType_type_serializer_init (
      "PointDefinedCurveFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // DefiningPoints
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefiningPoints",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DefiningPoints ();
      }

      // Plane
      //
      if (i.Plane ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Plane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Plane ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointDefinedCurveFeatureNominalType >
    _xsd_PointDefinedCurveFeatureNominalType_type_serializer_init (
      "PointDefinedCurveFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const TargetPointsActualType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TargetPoint
      //
      for (TargetPointsActualType::TargetPoint_const_iterator
           b (i.TargetPoint ().begin ()), n (i.TargetPoint ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TargetPoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // linearUnit
      //
      if (i.linearUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zValidity",
            e));

        a << *i.zValidity ();
      }

      // combinedUncertainty
      //
      if (i.combinedUncertainty ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "combinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.combinedUncertainty ());
      }

      // meanError
      //
      if (i.meanError ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "meanError",
            e));

        a << ::xml_schema::as_decimal(*i.meanError ());
      }

      // xCombinedUncertainty
      //
      if (i.xCombinedUncertainty ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.xCombinedUncertainty ());
      }

      // xMeanError
      //
      if (i.xMeanError ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.xMeanError ());
      }

      // yCombinedUncertainty
      //
      if (i.yCombinedUncertainty ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.yCombinedUncertainty ());
      }

      // yMeanError
      //
      if (i.yMeanError ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.yMeanError ());
      }

      // zCombinedUncertainty
      //
      if (i.zCombinedUncertainty ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zCombinedUncertainty",
            e));

        a << ::xml_schema::as_decimal(*i.zCombinedUncertainty ());
      }

      // zMeanError
      //
      if (i.zMeanError ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zMeanError",
            e));

        a << ::xml_schema::as_decimal(*i.zMeanError ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedCurveFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // DefiningPoints
      //
      if (i.DefiningPoints ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefiningPoints",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DefiningPoints ();
      }

      // Plane
      //
      if (i.Plane ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Plane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Plane ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointDefinedCurveFeatureActualType >
    _xsd_PointDefinedCurveFeatureActualType_type_serializer_init (
      "PointDefinedCurveFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // Extract
      //
      if (i.Extract ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Extract",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Extract ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (PointDefinedSurfaceBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BasePointDefinedSurface
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasePointDefinedSurface",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BasePointDefinedSurface ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BasePointDefinedSurface
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasePointDefinedSurface",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BasePointDefinedSurface ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceExtractType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointDefinedSurfaceFeatureItemType >
    _xsd_PointDefinedSurfaceFeatureItemType_type_serializer_init (
      "PointDefinedSurfaceFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointDefinedSurfaceFeatureDefinitionType >
    _xsd_PointDefinedSurfaceFeatureDefinitionType_type_serializer_init (
      "PointDefinedSurfaceFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const TargetPointsNominalType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // TargetPoint
      //
      for (TargetPointsNominalType::TargetPoint_const_iterator
           b (i.TargetPoint ().begin ()), n (i.TargetPoint ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TargetPoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }

      // linearUnit
      //
      if (i.linearUnit ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "linearUnit",
            e));

        a << *i.linearUnit ();
      }

      // decimalPlaces
      //
      if (i.decimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "decimalPlaces",
            e));

        a << *i.decimalPlaces ();
      }

      // significantFigures
      //
      if (i.significantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "significantFigures",
            e));

        a << *i.significantFigures ();
      }

      // validity
      //
      if (i.validity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "validity",
            e));

        a << *i.validity ();
      }

      // xDecimalPlaces
      //
      if (i.xDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xDecimalPlaces",
            e));

        a << *i.xDecimalPlaces ();
      }

      // xSignificantFigures
      //
      if (i.xSignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xSignificantFigures",
            e));

        a << *i.xSignificantFigures ();
      }

      // xValidity
      //
      if (i.xValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "xValidity",
            e));

        a << *i.xValidity ();
      }

      // yDecimalPlaces
      //
      if (i.yDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yDecimalPlaces",
            e));

        a << *i.yDecimalPlaces ();
      }

      // ySignificantFigures
      //
      if (i.ySignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "ySignificantFigures",
            e));

        a << *i.ySignificantFigures ();
      }

      // yValidity
      //
      if (i.yValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "yValidity",
            e));

        a << *i.yValidity ();
      }

      // zDecimalPlaces
      //
      if (i.zDecimalPlaces ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zDecimalPlaces",
            e));

        a << *i.zDecimalPlaces ();
      }

      // zSignificantFigures
      //
      if (i.zSignificantFigures ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zSignificantFigures",
            e));

        a << *i.zSignificantFigures ();
      }

      // zValidity
      //
      if (i.zValidity ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "zValidity",
            e));

        a << *i.zValidity ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // DefiningPoints
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefiningPoints",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DefiningPoints ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointDefinedSurfaceFeatureNominalType >
    _xsd_PointDefinedSurfaceFeatureNominalType_type_serializer_init (
      "PointDefinedSurfaceFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointDefinedSurfaceFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // DefiningPoints
      //
      if (i.DefiningPoints ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DefiningPoints",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DefiningPoints ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointDefinedSurfaceFeatureActualType >
    _xsd_PointDefinedSurfaceFeatureActualType_type_serializer_init (
      "PointDefinedSurfaceFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Intersection
      //
      if (i.Intersection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Intersection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Intersection ();
      }

      // Projection
      //
      if (i.Projection ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Projection",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Projection ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromCone
      //
      if (i.FromCone ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromCone",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromCone ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }

      // CenterOfGravity
      //
      if (i.CenterOfGravity ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CenterOfGravity",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CenterOfGravity ();
      }

      // Pierce
      //
      if (i.Pierce ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Pierce",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Pierce ();
      }

      // MidPoint
      //
      if (i.MidPoint ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MidPoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MidPoint ();
      }

      // MovePoint
      //
      if (i.MovePoint ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MovePoint",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MovePoint ();
      }

      // MovePointVector
      //
      if (i.MovePointVector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MovePointVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MovePointVector ();
      }

      // MovePointAxis
      //
      if (i.MovePointAxis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MovePointAxis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MovePointAxis ();
      }

      // Extreme
      //
      if (i.Extreme ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Extreme",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Extreme ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureIntersectionType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // IntersectionFeature
      //
      for (PointFeatureIntersectionType::IntersectionFeature_const_iterator
           b (i.IntersectionFeature ().begin ()), n (i.IntersectionFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IntersectionFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeaturePierceType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // CurveFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CurveFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CurveFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureProjectionType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // ProjectionPlane
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionPlane",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionPlane ();
      }

      // ProjectionFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProjectionFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ProjectionFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureFromConeType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCone
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCone",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCone ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BasePointFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasePointFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BasePointFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BasePointFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BasePointFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BasePointFeature ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }

      // RetrievalMethod
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RetrievalMethod",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.RetrievalMethod ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureCenterOfGravityType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (PointFeatureCenterOfGravityType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureMidPointType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (PointFeatureMidPointType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureMovePointType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }

      // Offset
      //
      if (i.Offset ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Offset",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Offset ();
      }

      // DirectionalOffset
      //
      if (i.DirectionalOffset ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DirectionalOffset",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DirectionalOffset ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureMovePointVectorType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }

      // Distance
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Distance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Distance ();
      }

      // Vector
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Vector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Vector ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureMovePointAxisType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseLocationFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseLocationFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseLocationFeature ();
      }

      // Distance
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Distance",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Distance ();
      }

      // BaseAxisFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseAxisFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseAxisFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureExtremeType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }

      // Minimum
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Minimum",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Minimum ();
      }

      // BaseAxisFeature
      //
      if (i.BaseAxisFeature ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseAxisFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BaseAxisFeature ();
      }

      // Vector
      //
      if (i.Vector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Vector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Vector ();
      }

      // Radial
      //
      if (i.Radial ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Radial",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Radial ();
      }

      // Xaxis
      //
      if (i.Xaxis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Xaxis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Xaxis ();
      }

      // Yaxis
      //
      if (i.Yaxis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Yaxis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Yaxis ();
      }

      // Zaxis
      //
      if (i.Zaxis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Zaxis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Zaxis ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointFeatureItemType >
    _xsd_PointFeatureItemType_type_serializer_init (
      "PointFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointFeatureDefinitionType >
    _xsd_PointFeatureDefinitionType_type_serializer_init (
      "PointFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointFeatureNominalType >
    _xsd_PointFeatureNominalType_type_serializer_init (
      "PointFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PointFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // Normal
      //
      if (i.Normal ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Normal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Normal ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointFeatureActualType >
    _xsd_PointFeatureActualType_type_serializer_init (
      "PointFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SphereConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphereBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (SphereBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphereRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphereCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseSphere
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseSphere",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseSphere ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphereCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphereTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseSphere
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseSphere",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseSphere ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphereFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }

      // Vector
      //
      if (i.Vector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Vector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Vector ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphereCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphereCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphereActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphereFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SphereFeatureItemType >
    _xsd_SphereFeatureItemType_type_serializer_init (
      "SphereFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SphereFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SphereFeatureDefinitionType >
    _xsd_SphereFeatureDefinitionType_type_serializer_init (
      "SphereFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SphereFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // LatitudeLongitudeSweep
      //
      if (i.LatitudeLongitudeSweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LatitudeLongitudeSweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LatitudeLongitudeSweep ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SphereFeatureNominalType >
    _xsd_SphereFeatureNominalType_type_serializer_init (
      "SphereFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SphereFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMax ();
      }

      // LatitudeLongitudeSweep
      //
      if (i.LatitudeLongitudeSweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LatitudeLongitudeSweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LatitudeLongitudeSweep ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SphereFeatureActualType >
    _xsd_SphereFeatureActualType_type_serializer_init (
      "SphereFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (SphericalSegmentBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseSphericalSegment
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseSphericalSegment",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseSphericalSegment ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseSphericalSegment
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseSphericalSegment",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseSphericalSegment ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SphericalSegmentFeatureItemType >
    _xsd_SphericalSegmentFeatureItemType_type_serializer_init (
      "SphericalSegmentFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Diameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Diameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SphericalSegmentFeatureDefinitionType >
    _xsd_SphericalSegmentFeatureDefinitionType_type_serializer_init (
      "SphericalSegmentFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // LatitudeLongitudeSweep
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LatitudeLongitudeSweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.LatitudeLongitudeSweep ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SphericalSegmentFeatureNominalType >
    _xsd_SphericalSegmentFeatureNominalType_type_serializer_init (
      "SphericalSegmentFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SphericalSegmentFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // Diameter
      //
      if (i.Diameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Diameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Diameter ();
      }

      // DiameterMin
      //
      if (i.DiameterMin ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMin",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMin ();
      }

      // DiameterMax
      //
      if (i.DiameterMax ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DiameterMax",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.DiameterMax ();
      }

      // LatitudeLongitudeSweep
      //
      if (i.LatitudeLongitudeSweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LatitudeLongitudeSweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LatitudeLongitudeSweep ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SphericalSegmentFeatureActualType >
    _xsd_SphericalSegmentFeatureActualType_type_serializer_init (
      "SphericalSegmentFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (SurfaceOfRevolutionBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseSurfaceOfRevolution
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseSurfaceOfRevolution",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseSurfaceOfRevolution ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseSurfaceOfRevolution
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseSurfaceOfRevolution",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseSurfaceOfRevolution ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SurfaceOfRevolutionFeatureItemType >
    _xsd_SurfaceOfRevolutionFeatureItemType_type_serializer_init (
      "SurfaceOfRevolutionFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SurfaceOfRevolutionFeatureDefinitionType >
    _xsd_SurfaceOfRevolutionFeatureDefinitionType_type_serializer_init (
      "SurfaceOfRevolutionFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Axis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Axis ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Sweep ();
      }

      // ReferenceFeatureNominalId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ReferenceFeatureNominalId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ReferenceFeatureNominalId ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SurfaceOfRevolutionFeatureNominalType >
    _xsd_SurfaceOfRevolutionFeatureNominalType_type_serializer_init (
      "SurfaceOfRevolutionFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const SurfaceOfRevolutionFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Axis ();
      }

      // Sweep
      //
      if (i.Sweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Sweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Sweep ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SurfaceOfRevolutionFeatureActualType >
    _xsd_SurfaceOfRevolutionFeatureActualType_type_serializer_init (
      "SurfaceOfRevolutionFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromCylinder
      //
      if (i.FromCylinder ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromCylinder",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromCylinder ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ThreadedFeatureBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseThreadedFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseThreadedFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseThreadedFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseThreadedFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseThreadedFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseThreadedFeature ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureFromCylinderType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseCylinder
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseCylinder",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseCylinder ();
      }

      // Offset
      //
      if (i.Offset ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Offset",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Offset ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThreadedFeatureItemType >
    _xsd_ThreadedFeatureItemType_type_serializer_init (
      "ThreadedFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // ThreadSpecificationId
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ThreadSpecificationId",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.ThreadSpecificationId ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }

      // Bottom
      //
      if (i.Bottom ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Bottom",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Bottom ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThreadedFeatureDefinitionType >
    _xsd_ThreadedFeatureDefinitionType_type_serializer_init (
      "ThreadedFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Axis
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Axis ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThreadedFeatureNominalType >
    _xsd_ThreadedFeatureNominalType_type_serializer_init (
      "ThreadedFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ThreadedFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Axis
      //
      if (i.Axis ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Axis",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Axis ();
      }

      // PitchDiameter
      //
      if (i.PitchDiameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PitchDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.PitchDiameter ();
      }

      // FunctionalSize
      //
      if (i.FunctionalSize ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FunctionalSize",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FunctionalSize ();
      }

      // Length
      //
      if (i.Length ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Length",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Length ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThreadedFeatureActualType >
    _xsd_ThreadedFeatureActualType_type_serializer_init (
      "ThreadedFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (ToroidalSegmentBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseToroidalSegment
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseToroidalSegment",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseToroidalSegment ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseToroidalSegment
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseToroidalSegment",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseToroidalSegment ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ToroidalSegmentFeatureItemType >
    _xsd_ToroidalSegmentFeatureItemType_type_serializer_init (
      "ToroidalSegmentFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // MinorDiameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MinorDiameter ();
      }

      // MajorDiameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MajorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MajorDiameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ToroidalSegmentFeatureDefinitionType >
    _xsd_ToroidalSegmentFeatureDefinitionType_type_serializer_init (
      "ToroidalSegmentFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // AxisVector
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AxisVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.AxisVector ();
      }

      // LatitudeLongitudeSweep
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LatitudeLongitudeSweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.LatitudeLongitudeSweep ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ToroidalSegmentFeatureNominalType >
    _xsd_ToroidalSegmentFeatureNominalType_type_serializer_init (
      "ToroidalSegmentFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ToroidalSegmentFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // AxisVector
      //
      if (i.AxisVector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AxisVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AxisVector ();
      }

      // MinorDiameter
      //
      if (i.MinorDiameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinorDiameter ();
      }

      // MajorDiameter
      //
      if (i.MajorDiameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MajorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MajorDiameter ();
      }

      // LatitudeLongitudeSweep
      //
      if (i.LatitudeLongitudeSweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LatitudeLongitudeSweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LatitudeLongitudeSweep ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ToroidalSegmentFeatureActualType >
    _xsd_ToroidalSegmentFeatureActualType_type_serializer_init (
      "ToroidalSegmentFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const TorusConstructionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // BestFit
      //
      if (i.BestFit ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BestFit",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.BestFit ();
      }

      // Recompensated
      //
      if (i.Recompensated ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Recompensated",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Recompensated ();
      }

      // Copy
      //
      if (i.Copy ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Copy",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Copy ();
      }

      // Cast
      //
      if (i.Cast ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Cast",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Cast ();
      }

      // Transform
      //
      if (i.Transform ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transform",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Transform ();
      }

      // FromScan
      //
      if (i.FromScan ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FromScan",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FromScan ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TorusBestFitType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      for (TorusBestFitType::BaseFeature_const_iterator
           b (i.BaseFeature ().begin ()), n (i.BaseFeature ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TorusRecompType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeaturePointList
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeaturePointList",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeaturePointList ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TorusCopyType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseTorus
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseTorus",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseTorus ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TorusCastType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseFeature ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TorusTransformType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // BaseTorus
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "BaseTorus",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.BaseTorus ();
      }

      // Transformation
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Transformation",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Transformation ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TorusFromScanType& i)
    {
      e << static_cast< const ::xsd::qif2::ConstructionMethodBaseType& > (i);

      // SurfaceFeature
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SurfaceFeature",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SurfaceFeature ();
      }

      // SearchRadius
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SearchRadius",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.SearchRadius ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TorusCheckedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Measured
      //
      if (i.Measured ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Measured",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Measured ();
      }

      // Constructed
      //
      if (i.Constructed ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Constructed",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Constructed ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TorusCheckedFeatureType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CheckDetails
      //
      if (i.CheckDetails ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CheckDetails",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.CheckDetails ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TorusActualDeterminationType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Checked
      //
      if (i.Checked ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Checked",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Checked ();
      }

      // Set
      //
      if (i.Set ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Set",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Set ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const TorusFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);

      // DeterminationMode
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "DeterminationMode",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.DeterminationMode ();
      }

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TorusFeatureItemType >
    _xsd_TorusFeatureItemType_type_serializer_init (
      "TorusFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const TorusFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);

      // InternalExternal
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "InternalExternal",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.InternalExternal ();
      }

      // MinorDiameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MinorDiameter ();
      }

      // MajorDiameter
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MajorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.MajorDiameter ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TorusFeatureDefinitionType >
    _xsd_TorusFeatureDefinitionType_type_serializer_init (
      "TorusFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const TorusFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // AxisVector
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AxisVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.AxisVector ();
      }

      // LatitudeLongitudeSweep
      //
      if (i.LatitudeLongitudeSweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LatitudeLongitudeSweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LatitudeLongitudeSweep ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TorusFeatureNominalType >
    _xsd_TorusFeatureNominalType_type_serializer_init (
      "TorusFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const TorusFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // AxisVector
      //
      if (i.AxisVector ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AxisVector",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.AxisVector ();
      }

      // MinorDiameter
      //
      if (i.MinorDiameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MinorDiameter ();
      }

      // MajorDiameter
      //
      if (i.MajorDiameter ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MajorDiameter",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.MajorDiameter ();
      }

      // LatitudeLongitudeSweep
      //
      if (i.LatitudeLongitudeSweep ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LatitudeLongitudeSweep",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.LatitudeLongitudeSweep ();
      }

      // Form
      //
      if (i.Form ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Form",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Form ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TorusFeatureActualType >
    _xsd_TorusFeatureActualType_type_serializer_init (
      "TorusFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CompositeFeatureItemBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CompositeFeatureItemBaseType >
    _xsd_CompositeFeatureItemBaseType_type_serializer_init (
      "CompositeFeatureItemBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CompositeFeatureDefinitionBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CompositeFeatureDefinitionBaseType >
    _xsd_CompositeFeatureDefinitionBaseType_type_serializer_init (
      "CompositeFeatureDefinitionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CompositeFeatureNominalBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureNominalBaseType& > (i);

      // FeatureNominalIds
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureNominalIds",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.FeatureNominalIds ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CompositeFeatureNominalBaseType >
    _xsd_CompositeFeatureNominalBaseType_type_serializer_init (
      "CompositeFeatureNominalBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CompositeFeatureActualBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::FeatureActualBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CompositeFeatureActualBaseType >
    _xsd_CompositeFeatureActualBaseType_type_serializer_init (
      "CompositeFeatureActualBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CompoundFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureItemBaseType& > (i);

      // SubstituteFeatureAlgorithm
      //
      if (i.SubstituteFeatureAlgorithm ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SubstituteFeatureAlgorithm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.SubstituteFeatureAlgorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CompoundFeatureItemType >
    _xsd_CompoundFeatureItemType_type_serializer_init (
      "CompoundFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CompoundFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CompoundFeatureDefinitionType >
    _xsd_CompoundFeatureDefinitionType_type_serializer_init (
      "CompoundFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CompoundFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureNominalBaseType& > (i);

      // Location
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Location ();
      }

      // Direction
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Direction",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.Direction ();
      }

      // CompoundFeatureForm
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "CompoundFeatureForm",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.CompoundFeatureForm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CompoundFeatureNominalType >
    _xsd_CompoundFeatureNominalType_type_serializer_init (
      "CompoundFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const CompoundFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureActualBaseType& > (i);

      // Location
      //
      if (i.Location ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Location",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Location ();
      }

      // Direction
      //
      if (i.Direction ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Direction",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.Direction ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CompoundFeatureActualType >
    _xsd_CompoundFeatureActualType_type_serializer_init (
      "CompoundFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PatternFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatternFeatureItemType >
    _xsd_PatternFeatureItemType_type_serializer_init (
      "PatternFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PatternFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatternFeatureDefinitionType >
    _xsd_PatternFeatureDefinitionType_type_serializer_init (
      "PatternFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PatternFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureNominalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatternFeatureNominalType >
    _xsd_PatternFeatureNominalType_type_serializer_init (
      "PatternFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PatternFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureActualBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PatternFeatureActualType >
    _xsd_PatternFeatureActualType_type_serializer_init (
      "PatternFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ProfileGroupFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProfileGroupFeatureItemType >
    _xsd_ProfileGroupFeatureItemType_type_serializer_init (
      "ProfileGroupFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ProfileGroupFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProfileGroupFeatureDefinitionType >
    _xsd_ProfileGroupFeatureDefinitionType_type_serializer_init (
      "ProfileGroupFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ProfileGroupFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureNominalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProfileGroupFeatureNominalType >
    _xsd_ProfileGroupFeatureNominalType_type_serializer_init (
      "ProfileGroupFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ProfileGroupFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureActualBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ProfileGroupFeatureActualType >
    _xsd_ProfileGroupFeatureActualType_type_serializer_init (
      "ProfileGroupFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const RunoutGroupFeatureItemType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureItemBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RunoutGroupFeatureItemType >
    _xsd_RunoutGroupFeatureItemType_type_serializer_init (
      "RunoutGroupFeatureItemType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const RunoutGroupFeatureDefinitionType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureDefinitionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RunoutGroupFeatureDefinitionType >
    _xsd_RunoutGroupFeatureDefinitionType_type_serializer_init (
      "RunoutGroupFeatureDefinitionType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const RunoutGroupFeatureNominalType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureNominalBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RunoutGroupFeatureNominalType >
    _xsd_RunoutGroupFeatureNominalType_type_serializer_init (
      "RunoutGroupFeatureNominalType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const RunoutGroupFeatureActualType& i)
    {
      e << static_cast< const ::xsd::qif2::CompositeFeatureActualBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RunoutGroupFeatureActualType >
    _xsd_RunoutGroupFeatureActualType_type_serializer_init (
      "RunoutGroupFeatureActualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const FeatureAspectsListsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureDefinitions
      //
      if (i.FeatureDefinitions ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureDefinitions",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FeatureDefinitions ();
      }

      // FeatureNominals
      //
      if (i.FeatureNominals ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureNominals",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FeatureNominals ();
      }

      // FeatureItems
      //
      if (i.FeatureItems ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureItems",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << *i.FeatureItems ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const MeasuredFeaturesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureActuals
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "FeatureActuals",
            "http://qifstandards.org/xsd/qif2",
            e));

        s << i.FeatureActuals ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureDefinitionsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureDefinition
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (FeatureDefinitionsType::FeatureDefinition_const_iterator
             b (i.FeatureDefinition ().begin ()), n (i.FeatureDefinition ().end ());
             b != n; ++b)
        {
          if (typeid (FeatureDefinitionsType::FeatureDefinition_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "FeatureDefinition",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "FeatureDefinition",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureNominalsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureNominal
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (FeatureNominalsType::FeatureNominal_const_iterator
             b (i.FeatureNominal ().begin ()), n (i.FeatureNominal ().end ());
             b != n; ++b)
        {
          if (typeid (FeatureNominalsType::FeatureNominal_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "FeatureNominal",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "FeatureNominal",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureItemsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureItem
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (FeatureItemsType::FeatureItem_const_iterator
             b (i.FeatureItem ().begin ()), n (i.FeatureItem ().end ());
             b != n; ++b)
        {
          if (typeid (FeatureItemsType::FeatureItem_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "FeatureItem",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "FeatureItem",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const FeatureActualsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // FeatureActual
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (FeatureActualsType::FeatureActual_const_iterator
             b (i.FeatureActual ().begin ()), n (i.FeatureActual ().end ());
             b != n; ++b)
        {
          if (typeid (FeatureActualsType::FeatureActual_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "FeatureActual",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "FeatureActual",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ArcFeatureDefinitionType >
    _xsd_ArcFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ArcFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::GenericFeatureDefinitionType >
    _xsd_GenericFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "GenericFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CircleFeatureDefinitionType >
    _xsd_CircleFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "CircleFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CompoundFeatureDefinitionType >
    _xsd_CompoundFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "CompoundFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ConeFeatureDefinitionType >
    _xsd_ConeFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ConeFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ConicalSegmentFeatureDefinitionType >
    _xsd_ConicalSegmentFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ConicalSegmentFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CuboidFeatureDefinitionType >
    _xsd_CuboidFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "CuboidFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CylinderFeatureDefinitionType >
    _xsd_CylinderFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "CylinderFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CylindricalSegmentFeatureDefinitionType >
    _xsd_CylindricalSegmentFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "CylindricalSegmentFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::EdgePointFeatureDefinitionType >
    _xsd_EdgePointFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "EdgePointFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::EllipseFeatureDefinitionType >
    _xsd_EllipseFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "EllipseFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ElongatedCylinderFeatureDefinitionType >
    _xsd_ElongatedCylinderFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ElongatedCylinderFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ExtrudedCrossSectionFeatureDefinitionType >
    _xsd_ExtrudedCrossSectionFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ExtrudedCrossSectionFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::LineFeatureDefinitionType >
    _xsd_LineFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "LineFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OppositeLinesFeatureDefinitionType >
    _xsd_OppositeLinesFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "OppositeLinesFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OppositePlanesFeatureDefinitionType >
    _xsd_OppositePlanesFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "OppositePlanesFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PatternFeatureDefinitionType >
    _xsd_PatternFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "PatternFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PlaneFeatureDefinitionType >
    _xsd_PlaneFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "PlaneFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointDefinedCurveFeatureDefinitionType >
    _xsd_PointDefinedCurveFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedCurveFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointDefinedSurfaceFeatureDefinitionType >
    _xsd_PointDefinedSurfaceFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedSurfaceFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointFeatureDefinitionType >
    _xsd_PointFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "PointFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ProfileGroupFeatureDefinitionType >
    _xsd_ProfileGroupFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ProfileGroupFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::RunoutGroupFeatureDefinitionType >
    _xsd_RunoutGroupFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "RunoutGroupFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SphereFeatureDefinitionType >
    _xsd_SphereFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "SphereFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SphericalSegmentFeatureDefinitionType >
    _xsd_SphericalSegmentFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "SphericalSegmentFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SurfaceOfRevolutionFeatureDefinitionType >
    _xsd_SurfaceOfRevolutionFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "SurfaceOfRevolutionFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ThreadedFeatureDefinitionType >
    _xsd_ThreadedFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ThreadedFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ToroidalSegmentFeatureDefinitionType >
    _xsd_ToroidalSegmentFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "ToroidalSegmentFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::TorusFeatureDefinitionType >
    _xsd_TorusFeatureDefinition_element_serializer_init (
      "FeatureDefinition",
      "http://qifstandards.org/xsd/qif2",
      "TorusFeatureDefinition",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ArcFeatureNominalType >
    _xsd_ArcFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ArcFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::GenericFeatureNominalType >
    _xsd_GenericFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "GenericFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CircleFeatureNominalType >
    _xsd_CircleFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "CircleFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CompoundFeatureNominalType >
    _xsd_CompoundFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "CompoundFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ConeFeatureNominalType >
    _xsd_ConeFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ConeFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ConicalSegmentFeatureNominalType >
    _xsd_ConicalSegmentFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ConicalSegmentFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CuboidFeatureNominalType >
    _xsd_CuboidFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "CuboidFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CylinderFeatureNominalType >
    _xsd_CylinderFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "CylinderFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CylindricalSegmentFeatureNominalType >
    _xsd_CylindricalSegmentFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "CylindricalSegmentFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::EdgePointFeatureNominalType >
    _xsd_EdgePointFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "EdgePointFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::EllipseFeatureNominalType >
    _xsd_EllipseFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "EllipseFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ElongatedCylinderFeatureNominalType >
    _xsd_ElongatedCylinderFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ElongatedCylinderFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ExtrudedCrossSectionFeatureNominalType >
    _xsd_ExtrudedCrossSectionFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ExtrudedCrossSectionFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::LineFeatureNominalType >
    _xsd_LineFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "LineFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PatternFeatureNominalType >
    _xsd_PatternFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "PatternFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PlaneFeatureNominalType >
    _xsd_PlaneFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "PlaneFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointDefinedCurveFeatureNominalType >
    _xsd_PointDefinedCurveFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedCurveFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointDefinedSurfaceFeatureNominalType >
    _xsd_PointDefinedSurfaceFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedSurfaceFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointFeatureNominalType >
    _xsd_PointFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "PointFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OppositeLinesFeatureNominalType >
    _xsd_OppositeLinesFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "OppositeLinesFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OppositePlanesFeatureNominalType >
    _xsd_OppositePlanesFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "OppositePlanesFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ProfileGroupFeatureNominalType >
    _xsd_ProfileGroupFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ProfileGroupFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::RunoutGroupFeatureNominalType >
    _xsd_RunoutGroupFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "RunoutGroupFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SphereFeatureNominalType >
    _xsd_SphereFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "SphereFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SphericalSegmentFeatureNominalType >
    _xsd_SphericalSegmentFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "SphericalSegmentFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SurfaceOfRevolutionFeatureNominalType >
    _xsd_SurfaceOfRevolutionFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "SurfaceOfRevolutionFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ThreadedFeatureNominalType >
    _xsd_ThreadedFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ThreadedFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ToroidalSegmentFeatureNominalType >
    _xsd_ToroidalSegmentFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "ToroidalSegmentFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::TorusFeatureNominalType >
    _xsd_TorusFeatureNominal_element_serializer_init (
      "FeatureNominal",
      "http://qifstandards.org/xsd/qif2",
      "TorusFeatureNominal",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ArcFeatureActualType >
    _xsd_ArcFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ArcFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::GenericFeatureActualType >
    _xsd_GenericFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "GenericFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CircleFeatureActualType >
    _xsd_CircleFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "CircleFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CompoundFeatureActualType >
    _xsd_CompoundFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "CompoundFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ConeFeatureActualType >
    _xsd_ConeFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ConeFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ConicalSegmentFeatureActualType >
    _xsd_ConicalSegmentFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ConicalSegmentFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CuboidFeatureActualType >
    _xsd_CuboidFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "CuboidFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CylinderFeatureActualType >
    _xsd_CylinderFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "CylinderFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CylindricalSegmentFeatureActualType >
    _xsd_CylindricalSegmentFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "CylindricalSegmentFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::EdgePointFeatureActualType >
    _xsd_EdgePointFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "EdgePointFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::EllipseFeatureActualType >
    _xsd_EllipseFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "EllipseFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ElongatedCylinderFeatureActualType >
    _xsd_ElongatedCylinderFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ElongatedCylinderFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ExtrudedCrossSectionFeatureActualType >
    _xsd_ExtrudedCrossSectionFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ExtrudedCrossSectionFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::LineFeatureActualType >
    _xsd_LineFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "LineFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OppositeLinesFeatureActualType >
    _xsd_OppositeLinesFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "OppositeLinesFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OppositePlanesFeatureActualType >
    _xsd_OppositePlanesFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "OppositePlanesFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PatternFeatureActualType >
    _xsd_PatternFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "PatternFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PlaneFeatureActualType >
    _xsd_PlaneFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "PlaneFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointDefinedCurveFeatureActualType >
    _xsd_PointDefinedCurveFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedCurveFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointDefinedSurfaceFeatureActualType >
    _xsd_PointDefinedSurfaceFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedSurfaceFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointFeatureActualType >
    _xsd_PointFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "PointFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ProfileGroupFeatureActualType >
    _xsd_ProfileGroupFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ProfileGroupFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::RunoutGroupFeatureActualType >
    _xsd_RunoutGroupFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "RunoutGroupFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SphereFeatureActualType >
    _xsd_SphereFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "SphereFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SphericalSegmentFeatureActualType >
    _xsd_SphericalSegmentFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "SphericalSegmentFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SurfaceOfRevolutionFeatureActualType >
    _xsd_SurfaceOfRevolutionFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "SurfaceOfRevolutionFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ThreadedFeatureActualType >
    _xsd_ThreadedFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ThreadedFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ToroidalSegmentFeatureActualType >
    _xsd_ToroidalSegmentFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "ToroidalSegmentFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::TorusFeatureActualType >
    _xsd_TorusFeatureActual_element_serializer_init (
      "FeatureActual",
      "http://qifstandards.org/xsd/qif2",
      "TorusFeatureActual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ArcFeatureItemType >
    _xsd_ArcFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ArcFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::GenericFeatureItemType >
    _xsd_GenericFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "GenericFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CircleFeatureItemType >
    _xsd_CircleFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "CircleFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CompoundFeatureItemType >
    _xsd_CompoundFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "CompoundFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ConeFeatureItemType >
    _xsd_ConeFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ConeFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ConicalSegmentFeatureItemType >
    _xsd_ConicalSegmentFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ConicalSegmentFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CuboidFeatureItemType >
    _xsd_CuboidFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "CuboidFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CylinderFeatureItemType >
    _xsd_CylinderFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "CylinderFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::CylindricalSegmentFeatureItemType >
    _xsd_CylindricalSegmentFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "CylindricalSegmentFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::EdgePointFeatureItemType >
    _xsd_EdgePointFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "EdgePointFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::EllipseFeatureItemType >
    _xsd_EllipseFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "EllipseFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ElongatedCylinderFeatureItemType >
    _xsd_ElongatedCylinderFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ElongatedCylinderFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ExtrudedCrossSectionFeatureItemType >
    _xsd_ExtrudedCrossSectionFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ExtrudedCrossSectionFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::LineFeatureItemType >
    _xsd_LineFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "LineFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OppositeLinesFeatureItemType >
    _xsd_OppositeLinesFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "OppositeLinesFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OppositePlanesFeatureItemType >
    _xsd_OppositePlanesFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "OppositePlanesFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PatternFeatureItemType >
    _xsd_PatternFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "PatternFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PlaneFeatureItemType >
    _xsd_PlaneFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "PlaneFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointDefinedCurveFeatureItemType >
    _xsd_PointDefinedCurveFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedCurveFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointDefinedSurfaceFeatureItemType >
    _xsd_PointDefinedSurfaceFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "PointDefinedSurfaceFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PointFeatureItemType >
    _xsd_PointFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "PointFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ProfileGroupFeatureItemType >
    _xsd_ProfileGroupFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ProfileGroupFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::RunoutGroupFeatureItemType >
    _xsd_RunoutGroupFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "RunoutGroupFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SphereFeatureItemType >
    _xsd_SphereFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "SphereFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SphericalSegmentFeatureItemType >
    _xsd_SphericalSegmentFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "SphericalSegmentFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::SurfaceOfRevolutionFeatureItemType >
    _xsd_SurfaceOfRevolutionFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "SurfaceOfRevolutionFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ThreadedFeatureItemType >
    _xsd_ThreadedFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ThreadedFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ToroidalSegmentFeatureItemType >
    _xsd_ToroidalSegmentFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "ToroidalSegmentFeatureItem",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::TorusFeatureItemType >
    _xsd_TorusFeatureItem_element_serializer_init (
      "FeatureItem",
      "http://qifstandards.org/xsd/qif2",
      "TorusFeatureItem",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

