// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "GenericExpressions.hxx"

namespace xsd
{
  namespace qif2
  {
    // BooleanExpressionBaseType
    // 


    // NotType
    // 

    const NotType::BooleanExpression_type& NotType::
    BooleanExpression () const
    {
      return this->BooleanExpression_.get ();
    }

    NotType::BooleanExpression_type& NotType::
    BooleanExpression ()
    {
      return this->BooleanExpression_.get ();
    }

    void NotType::
    BooleanExpression (const BooleanExpression_type& x)
    {
      this->BooleanExpression_.set (x);
    }

    void NotType::
    BooleanExpression (::std::auto_ptr< BooleanExpression_type > x)
    {
      this->BooleanExpression_.set (x);
    }


    // BinaryBooleanExpressionBaseType
    // 

    const BinaryBooleanExpressionBaseType::BooleanExpression_sequence& BinaryBooleanExpressionBaseType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    BinaryBooleanExpressionBaseType::BooleanExpression_sequence& BinaryBooleanExpressionBaseType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void BinaryBooleanExpressionBaseType::
    BooleanExpression (const BooleanExpression_sequence& s)
    {
      this->BooleanExpression_ = s;
    }


    // AndType
    // 

    const AndType::BooleanExpression_sequence& AndType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    AndType::BooleanExpression_sequence& AndType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void AndType::
    BooleanExpression (const BooleanExpression_sequence& s)
    {
      this->BooleanExpression_ = s;
    }


    // OrType
    // 

    const OrType::BooleanExpression_sequence& OrType::
    BooleanExpression () const
    {
      return this->BooleanExpression_;
    }

    OrType::BooleanExpression_sequence& OrType::
    BooleanExpression ()
    {
      return this->BooleanExpression_;
    }

    void OrType::
    BooleanExpression (const BooleanExpression_sequence& s)
    {
      this->BooleanExpression_ = s;
    }


    // BooleanEqualType
    // 


    // ConstantIsType
    // 

    const ConstantIsType::val_type& ConstantIsType::
    val () const
    {
      return this->val_.get ();
    }

    ConstantIsType::val_type& ConstantIsType::
    val ()
    {
      return this->val_.get ();
    }

    void ConstantIsType::
    val (const val_type& x)
    {
      this->val_.set (x);
    }

    void ConstantIsType::
    val (::std::auto_ptr< val_type > x)
    {
      this->val_.set (x);
    }


    // ArithmeticComparisonBaseType
    // 

    const ArithmeticComparisonBaseType::ArithmeticExpression_sequence& ArithmeticComparisonBaseType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_;
    }

    ArithmeticComparisonBaseType::ArithmeticExpression_sequence& ArithmeticComparisonBaseType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_;
    }

    void ArithmeticComparisonBaseType::
    ArithmeticExpression (const ArithmeticExpression_sequence& s)
    {
      this->ArithmeticExpression_ = s;
    }


    // ArithmeticEqualType
    // 


    // GreaterThanType
    // 


    // GreaterOrEqualType
    // 


    // LessThanType
    // 


    // LessOrEqualType
    // 


    // BooleanConstantEnumType
    // 

    BooleanConstantEnumType::
    BooleanConstantEnumType (value v)
    : ::xml_schema::nmtoken (_xsd_BooleanConstantEnumType_literals_[v])
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const char* v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::std::string& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::xml_schema::nmtoken& v)
    : ::xml_schema::nmtoken (v)
    {
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const BooleanConstantEnumType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (v, f, c)
    {
    }

    BooleanConstantEnumType& BooleanConstantEnumType::
    operator= (value v)
    {
      static_cast< ::xml_schema::nmtoken& > (*this) = 
      ::xml_schema::nmtoken (_xsd_BooleanConstantEnumType_literals_[v]);

      return *this;
    }


    // ArithmeticExpressionBaseType
    // 


    // ArithmeticConstantType
    // 

    const ArithmeticConstantType::val_type& ArithmeticConstantType::
    val () const
    {
      return this->val_.get ();
    }

    ArithmeticConstantType::val_type& ArithmeticConstantType::
    val ()
    {
      return this->val_.get ();
    }

    void ArithmeticConstantType::
    val (const val_type& x)
    {
      this->val_.set (x);
    }


    // NegateType
    // 

    const NegateType::ArithmeticExpression_type& NegateType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_.get ();
    }

    NegateType::ArithmeticExpression_type& NegateType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_.get ();
    }

    void NegateType::
    ArithmeticExpression (const ArithmeticExpression_type& x)
    {
      this->ArithmeticExpression_.set (x);
    }

    void NegateType::
    ArithmeticExpression (::std::auto_ptr< ArithmeticExpression_type > x)
    {
      this->ArithmeticExpression_.set (x);
    }


    // BinaryArithmeticExpressionBaseType
    // 

    const BinaryArithmeticExpressionBaseType::ArithmeticExpression_sequence& BinaryArithmeticExpressionBaseType::
    ArithmeticExpression () const
    {
      return this->ArithmeticExpression_;
    }

    BinaryArithmeticExpressionBaseType::ArithmeticExpression_sequence& BinaryArithmeticExpressionBaseType::
    ArithmeticExpression ()
    {
      return this->ArithmeticExpression_;
    }

    void BinaryArithmeticExpressionBaseType::
    ArithmeticExpression (const ArithmeticExpression_sequence& s)
    {
      this->ArithmeticExpression_ = s;
    }


    // PlusType
    // 


    // MinusType
    // 


    // TimesType
    // 


    // DividedByType
    // 
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    // BooleanExpressionBaseType
    //

    BooleanExpressionBaseType::
    BooleanExpressionBaseType ()
    : ::xml_schema::type ()
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const BooleanExpressionBaseType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    BooleanExpressionBaseType::
    BooleanExpressionBaseType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    BooleanExpressionBaseType* BooleanExpressionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BooleanExpressionBaseType (*this, f, c);
    }

    BooleanExpressionBaseType::
    ~BooleanExpressionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BooleanExpressionBaseType >
    _xsd_BooleanExpressionBaseType_type_factory_init (
      "BooleanExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // NotType
    //

    NotType::
    NotType (const BooleanExpression_type& BooleanExpression)
    : ::xsd::qif2::BooleanExpressionBaseType (),
      BooleanExpression_ (BooleanExpression, this)
    {
    }

    NotType::
    NotType (::std::auto_ptr< BooleanExpression_type > BooleanExpression)
    : ::xsd::qif2::BooleanExpressionBaseType (),
      BooleanExpression_ (BooleanExpression, this)
    {
    }

    NotType::
    NotType (const NotType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this)
    {
    }

    NotType::
    NotType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NotType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BooleanExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< BooleanExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!BooleanExpression_.present ())
            {
              ::std::auto_ptr< BooleanExpression_type > r (
                dynamic_cast< BooleanExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->BooleanExpression_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!BooleanExpression_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "BooleanExpression",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    NotType* NotType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotType (*this, f, c);
    }

    NotType& NotType::
    operator= (const NotType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
      }

      return *this;
    }

    NotType::
    ~NotType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, NotType >
    _xsd_NotType_type_factory_init (
      "NotType",
      "http://qifstandards.org/xsd/qif2");

    // BinaryBooleanExpressionBaseType
    //

    BinaryBooleanExpressionBaseType::
    BinaryBooleanExpressionBaseType ()
    : ::xsd::qif2::BooleanExpressionBaseType (),
      BooleanExpression_ (this)
    {
    }

    BinaryBooleanExpressionBaseType::
    BinaryBooleanExpressionBaseType (const BinaryBooleanExpressionBaseType& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this)
    {
    }

    BinaryBooleanExpressionBaseType::
    BinaryBooleanExpressionBaseType (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BinaryBooleanExpressionBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BooleanExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< BooleanExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< BooleanExpression_type > r (
              dynamic_cast< BooleanExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BooleanExpression_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    BinaryBooleanExpressionBaseType* BinaryBooleanExpressionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BinaryBooleanExpressionBaseType (*this, f, c);
    }

    BinaryBooleanExpressionBaseType& BinaryBooleanExpressionBaseType::
    operator= (const BinaryBooleanExpressionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
      }

      return *this;
    }

    BinaryBooleanExpressionBaseType::
    ~BinaryBooleanExpressionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BinaryBooleanExpressionBaseType >
    _xsd_BinaryBooleanExpressionBaseType_type_factory_init (
      "BinaryBooleanExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // AndType
    //

    AndType::
    AndType ()
    : ::xsd::qif2::BooleanExpressionBaseType (),
      BooleanExpression_ (this)
    {
    }

    AndType::
    AndType (const AndType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this)
    {
    }

    AndType::
    AndType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void AndType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BooleanExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< BooleanExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< BooleanExpression_type > r (
              dynamic_cast< BooleanExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BooleanExpression_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    AndType* AndType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AndType (*this, f, c);
    }

    AndType& AndType::
    operator= (const AndType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
      }

      return *this;
    }

    AndType::
    ~AndType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, AndType >
    _xsd_AndType_type_factory_init (
      "AndType",
      "http://qifstandards.org/xsd/qif2");

    // OrType
    //

    OrType::
    OrType ()
    : ::xsd::qif2::BooleanExpressionBaseType (),
      BooleanExpression_ (this)
    {
    }

    OrType::
    OrType (const OrType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      BooleanExpression_ (x.BooleanExpression_, f, this)
    {
    }

    OrType::
    OrType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      BooleanExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void OrType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // BooleanExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< BooleanExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< BooleanExpression_type > r (
              dynamic_cast< BooleanExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->BooleanExpression_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    OrType* OrType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class OrType (*this, f, c);
    }

    OrType& OrType::
    operator= (const OrType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->BooleanExpression_ = x.BooleanExpression_;
      }

      return *this;
    }

    OrType::
    ~OrType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, OrType >
    _xsd_OrType_type_factory_init (
      "OrType",
      "http://qifstandards.org/xsd/qif2");

    // BooleanEqualType
    //

    BooleanEqualType::
    BooleanEqualType ()
    : ::xsd::qif2::BinaryBooleanExpressionBaseType ()
    {
    }

    BooleanEqualType::
    BooleanEqualType (const BooleanEqualType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::BinaryBooleanExpressionBaseType (x, f, c)
    {
    }

    BooleanEqualType::
    BooleanEqualType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xsd::qif2::BinaryBooleanExpressionBaseType (e, f, c)
    {
    }

    BooleanEqualType* BooleanEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BooleanEqualType (*this, f, c);
    }

    BooleanEqualType::
    ~BooleanEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BooleanEqualType >
    _xsd_BooleanEqualType_type_factory_init (
      "BooleanEqualType",
      "http://qifstandards.org/xsd/qif2");

    // ConstantIsType
    //

    ConstantIsType::
    ConstantIsType (const val_type& val)
    : ::xsd::qif2::BooleanExpressionBaseType (),
      val_ (val, this)
    {
    }

    ConstantIsType::
    ConstantIsType (const ConstantIsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      val_ (x.val_, f, this)
    {
    }

    ConstantIsType::
    ConstantIsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ConstantIsType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "val" && n.namespace_ ().empty ())
        {
          this->val_.set (val_traits::create (i, f, this));
          continue;
        }
      }

      if (!val_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "val",
          "");
      }
    }

    ConstantIsType* ConstantIsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ConstantIsType (*this, f, c);
    }

    ConstantIsType& ConstantIsType::
    operator= (const ConstantIsType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->val_ = x.val_;
      }

      return *this;
    }

    ConstantIsType::
    ~ConstantIsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ConstantIsType >
    _xsd_ConstantIsType_type_factory_init (
      "ConstantIsType",
      "http://qifstandards.org/xsd/qif2");

    // ArithmeticComparisonBaseType
    //

    ArithmeticComparisonBaseType::
    ArithmeticComparisonBaseType ()
    : ::xsd::qif2::BooleanExpressionBaseType (),
      ArithmeticExpression_ (this)
    {
    }

    ArithmeticComparisonBaseType::
    ArithmeticComparisonBaseType (const ArithmeticComparisonBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (x, f, c),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    ArithmeticComparisonBaseType::
    ArithmeticComparisonBaseType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xsd::qif2::BooleanExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ArithmeticComparisonBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ArithmeticExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< ArithmeticExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ArithmeticExpression_type > r (
              dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ArithmeticExpression_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    ArithmeticComparisonBaseType* ArithmeticComparisonBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticComparisonBaseType (*this, f, c);
    }

    ArithmeticComparisonBaseType& ArithmeticComparisonBaseType::
    operator= (const ArithmeticComparisonBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::BooleanExpressionBaseType& > (*this) = x;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    ArithmeticComparisonBaseType::
    ~ArithmeticComparisonBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArithmeticComparisonBaseType >
    _xsd_ArithmeticComparisonBaseType_type_factory_init (
      "ArithmeticComparisonBaseType",
      "http://qifstandards.org/xsd/qif2");

    // ArithmeticEqualType
    //

    ArithmeticEqualType::
    ArithmeticEqualType ()
    : ::xsd::qif2::ArithmeticComparisonBaseType ()
    {
    }

    ArithmeticEqualType::
    ArithmeticEqualType (const ArithmeticEqualType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    ArithmeticEqualType::
    ArithmeticEqualType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    ArithmeticEqualType* ArithmeticEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticEqualType (*this, f, c);
    }

    ArithmeticEqualType::
    ~ArithmeticEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArithmeticEqualType >
    _xsd_ArithmeticEqualType_type_factory_init (
      "ArithmeticEqualType",
      "http://qifstandards.org/xsd/qif2");

    // GreaterThanType
    //

    GreaterThanType::
    GreaterThanType ()
    : ::xsd::qif2::ArithmeticComparisonBaseType ()
    {
    }

    GreaterThanType::
    GreaterThanType (const GreaterThanType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    GreaterThanType::
    GreaterThanType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    GreaterThanType* GreaterThanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GreaterThanType (*this, f, c);
    }

    GreaterThanType::
    ~GreaterThanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, GreaterThanType >
    _xsd_GreaterThanType_type_factory_init (
      "GreaterThanType",
      "http://qifstandards.org/xsd/qif2");

    // GreaterOrEqualType
    //

    GreaterOrEqualType::
    GreaterOrEqualType ()
    : ::xsd::qif2::ArithmeticComparisonBaseType ()
    {
    }

    GreaterOrEqualType::
    GreaterOrEqualType (const GreaterOrEqualType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    GreaterOrEqualType::
    GreaterOrEqualType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    GreaterOrEqualType* GreaterOrEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class GreaterOrEqualType (*this, f, c);
    }

    GreaterOrEqualType::
    ~GreaterOrEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, GreaterOrEqualType >
    _xsd_GreaterOrEqualType_type_factory_init (
      "GreaterOrEqualType",
      "http://qifstandards.org/xsd/qif2");

    // LessThanType
    //

    LessThanType::
    LessThanType ()
    : ::xsd::qif2::ArithmeticComparisonBaseType ()
    {
    }

    LessThanType::
    LessThanType (const LessThanType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    LessThanType::
    LessThanType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    LessThanType* LessThanType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LessThanType (*this, f, c);
    }

    LessThanType::
    ~LessThanType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LessThanType >
    _xsd_LessThanType_type_factory_init (
      "LessThanType",
      "http://qifstandards.org/xsd/qif2");

    // LessOrEqualType
    //

    LessOrEqualType::
    LessOrEqualType ()
    : ::xsd::qif2::ArithmeticComparisonBaseType ()
    {
    }

    LessOrEqualType::
    LessOrEqualType (const LessOrEqualType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (x, f, c)
    {
    }

    LessOrEqualType::
    LessOrEqualType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticComparisonBaseType (e, f, c)
    {
    }

    LessOrEqualType* LessOrEqualType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class LessOrEqualType (*this, f, c);
    }

    LessOrEqualType::
    ~LessOrEqualType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LessOrEqualType >
    _xsd_LessOrEqualType_type_factory_init (
      "LessOrEqualType",
      "http://qifstandards.org/xsd/qif2");

    // BooleanConstantEnumType
    //

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (e, f, c)
    {
      _xsd_BooleanConstantEnumType_convert ();
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (a, f, c)
    {
      _xsd_BooleanConstantEnumType_convert ();
    }

    BooleanConstantEnumType::
    BooleanConstantEnumType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
    : ::xml_schema::nmtoken (s, e, f, c)
    {
      _xsd_BooleanConstantEnumType_convert ();
    }

    BooleanConstantEnumType* BooleanConstantEnumType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BooleanConstantEnumType (*this, f, c);
    }

    BooleanConstantEnumType::value BooleanConstantEnumType::
    _xsd_BooleanConstantEnumType_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BooleanConstantEnumType_literals_);
      const value* i (::std::lower_bound (
                        _xsd_BooleanConstantEnumType_indexes_,
                        _xsd_BooleanConstantEnumType_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_BooleanConstantEnumType_indexes_ + 2 || _xsd_BooleanConstantEnumType_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const BooleanConstantEnumType::
    _xsd_BooleanConstantEnumType_literals_[2] =
    {
      "QIF_TRUE",
      "QIF_FALSE"
    };

    const BooleanConstantEnumType::value BooleanConstantEnumType::
    _xsd_BooleanConstantEnumType_indexes_[2] =
    {
      ::xsd::qif2::BooleanConstantEnumType::QIF_FALSE,
      ::xsd::qif2::BooleanConstantEnumType::QIF_TRUE
    };

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::NotType >
    _xsd_Not_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "Not",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ConstantIsType >
    _xsd_ConstantIs_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "ConstantIs",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::AndType >
    _xsd_And_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "And",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::OrType >
    _xsd_Or_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "Or",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::BooleanEqualType >
    _xsd_BooleanEqual_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "BooleanEqual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ArithmeticEqualType >
    _xsd_ArithmeticEqual_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "ArithmeticEqual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::GreaterThanType >
    _xsd_GreaterThan_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "GreaterThan",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::GreaterOrEqualType >
    _xsd_GreaterOrEqual_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "GreaterOrEqual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::LessThanType >
    _xsd_LessThan_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "LessThan",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::LessOrEqualType >
    _xsd_LessOrEqual_element_factory_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "LessOrEqual",
      "http://qifstandards.org/xsd/qif2");


    // ArithmeticExpressionBaseType
    //

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType ()
    : ::xml_schema::type ()
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const ArithmeticExpressionBaseType& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c)
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f, c)
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (a, f, c)
    {
    }

    ArithmeticExpressionBaseType::
    ArithmeticExpressionBaseType (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
    : ::xml_schema::type (s, e, f, c)
    {
    }

    ArithmeticExpressionBaseType* ArithmeticExpressionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticExpressionBaseType (*this, f, c);
    }

    ArithmeticExpressionBaseType::
    ~ArithmeticExpressionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArithmeticExpressionBaseType >
    _xsd_ArithmeticExpressionBaseType_type_factory_init (
      "ArithmeticExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // ArithmeticConstantType
    //

    ArithmeticConstantType::
    ArithmeticConstantType (const val_type& val)
    : ::xsd::qif2::ArithmeticExpressionBaseType (),
      val_ (val, this)
    {
    }

    ArithmeticConstantType::
    ArithmeticConstantType (const ArithmeticConstantType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (x, f, c),
      val_ (x.val_, f, this)
    {
    }

    ArithmeticConstantType::
    ArithmeticConstantType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      val_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ArithmeticConstantType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "val" && n.namespace_ ().empty ())
        {
          this->val_.set (val_traits::create (i, f, this));
          continue;
        }
      }

      if (!val_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "val",
          "");
      }
    }

    ArithmeticConstantType* ArithmeticConstantType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ArithmeticConstantType (*this, f, c);
    }

    ArithmeticConstantType& ArithmeticConstantType::
    operator= (const ArithmeticConstantType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ArithmeticExpressionBaseType& > (*this) = x;
        this->val_ = x.val_;
      }

      return *this;
    }

    ArithmeticConstantType::
    ~ArithmeticConstantType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ArithmeticConstantType >
    _xsd_ArithmeticConstantType_type_factory_init (
      "ArithmeticConstantType",
      "http://qifstandards.org/xsd/qif2");

    // NegateType
    //

    NegateType::
    NegateType (const ArithmeticExpression_type& ArithmeticExpression)
    : ::xsd::qif2::ArithmeticExpressionBaseType (),
      ArithmeticExpression_ (ArithmeticExpression, this)
    {
    }

    NegateType::
    NegateType (::std::auto_ptr< ArithmeticExpression_type > ArithmeticExpression)
    : ::xsd::qif2::ArithmeticExpressionBaseType (),
      ArithmeticExpression_ (ArithmeticExpression, this)
    {
    }

    NegateType::
    NegateType (const NegateType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (x, f, c),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    NegateType::
    NegateType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void NegateType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ArithmeticExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< ArithmeticExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!ArithmeticExpression_.present ())
            {
              ::std::auto_ptr< ArithmeticExpression_type > r (
                dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->ArithmeticExpression_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!ArithmeticExpression_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "ArithmeticExpression",
          "http://qifstandards.org/xsd/qif2");
      }
    }

    NegateType* NegateType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NegateType (*this, f, c);
    }

    NegateType& NegateType::
    operator= (const NegateType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ArithmeticExpressionBaseType& > (*this) = x;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    NegateType::
    ~NegateType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, NegateType >
    _xsd_NegateType_type_factory_init (
      "NegateType",
      "http://qifstandards.org/xsd/qif2");

    // BinaryArithmeticExpressionBaseType
    //

    BinaryArithmeticExpressionBaseType::
    BinaryArithmeticExpressionBaseType ()
    : ::xsd::qif2::ArithmeticExpressionBaseType (),
      ArithmeticExpression_ (this)
    {
    }

    BinaryArithmeticExpressionBaseType::
    BinaryArithmeticExpressionBaseType (const BinaryArithmeticExpressionBaseType& x,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (x, f, c),
      ArithmeticExpression_ (x.ArithmeticExpression_, f, this)
    {
    }

    BinaryArithmeticExpressionBaseType::
    BinaryArithmeticExpressionBaseType (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f,
                                        ::xml_schema::container* c)
    : ::xsd::qif2::ArithmeticExpressionBaseType (e, f | ::xml_schema::flags::base, c),
      ArithmeticExpression_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void BinaryArithmeticExpressionBaseType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // ArithmeticExpression
        //
        {
          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              &::xsd::cxx::tree::factory_impl< ArithmeticExpression_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< ArithmeticExpression_type > r (
              dynamic_cast< ArithmeticExpression_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->ArithmeticExpression_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    BinaryArithmeticExpressionBaseType* BinaryArithmeticExpressionBaseType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class BinaryArithmeticExpressionBaseType (*this, f, c);
    }

    BinaryArithmeticExpressionBaseType& BinaryArithmeticExpressionBaseType::
    operator= (const BinaryArithmeticExpressionBaseType& x)
    {
      if (this != &x)
      {
        static_cast< ::xsd::qif2::ArithmeticExpressionBaseType& > (*this) = x;
        this->ArithmeticExpression_ = x.ArithmeticExpression_;
      }

      return *this;
    }

    BinaryArithmeticExpressionBaseType::
    ~BinaryArithmeticExpressionBaseType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BinaryArithmeticExpressionBaseType >
    _xsd_BinaryArithmeticExpressionBaseType_type_factory_init (
      "BinaryArithmeticExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");

    // PlusType
    //

    PlusType::
    PlusType ()
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType ()
    {
    }

    PlusType::
    PlusType (const PlusType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (x, f, c)
    {
    }

    PlusType::
    PlusType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (e, f, c)
    {
    }

    PlusType* PlusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class PlusType (*this, f, c);
    }

    PlusType::
    ~PlusType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PlusType >
    _xsd_PlusType_type_factory_init (
      "PlusType",
      "http://qifstandards.org/xsd/qif2");

    // MinusType
    //

    MinusType::
    MinusType ()
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType ()
    {
    }

    MinusType::
    MinusType (const MinusType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (x, f, c)
    {
    }

    MinusType::
    MinusType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (e, f, c)
    {
    }

    MinusType* MinusType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class MinusType (*this, f, c);
    }

    MinusType::
    ~MinusType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MinusType >
    _xsd_MinusType_type_factory_init (
      "MinusType",
      "http://qifstandards.org/xsd/qif2");

    // TimesType
    //

    TimesType::
    TimesType ()
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType ()
    {
    }

    TimesType::
    TimesType (const TimesType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (x, f, c)
    {
    }

    TimesType::
    TimesType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (e, f, c)
    {
    }

    TimesType* TimesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TimesType (*this, f, c);
    }

    TimesType::
    ~TimesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TimesType >
    _xsd_TimesType_type_factory_init (
      "TimesType",
      "http://qifstandards.org/xsd/qif2");

    // DividedByType
    //

    DividedByType::
    DividedByType ()
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType ()
    {
    }

    DividedByType::
    DividedByType (const DividedByType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (x, f, c)
    {
    }

    DividedByType::
    DividedByType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xsd::qif2::BinaryArithmeticExpressionBaseType (e, f, c)
    {
    }

    DividedByType* DividedByType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class DividedByType (*this, f, c);
    }

    DividedByType::
    ~DividedByType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DividedByType >
    _xsd_DividedByType_type_factory_init (
      "DividedByType",
      "http://qifstandards.org/xsd/qif2");

    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::ArithmeticConstantType >
    _xsd_ArithmeticConstant_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "ArithmeticConstant",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::PlusType >
    _xsd_Plus_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Plus",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::MinusType >
    _xsd_Minus_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Minus",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::NegateType >
    _xsd_Negate_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Negate",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::TimesType >
    _xsd_Times_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Times",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_factory_initializer< 0, char, ::xsd::qif2::DividedByType >
    _xsd_DividedBy_element_factory_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "DividedBy",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xsd
{
  namespace qif2
  {
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace xsd
{
  namespace qif2
  {
    void
    operator<< (::xercesc::DOMElement& e, const BooleanExpressionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&, const BooleanExpressionBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const BooleanExpressionBaseType&)
    {
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BooleanExpressionBaseType >
    _xsd_BooleanExpressionBaseType_type_serializer_init (
      "BooleanExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const NotType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const NotType::BooleanExpression_type& x (i.BooleanExpression ());
        if (typeid (NotType::BooleanExpression_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "BooleanExpression",
            "http://qifstandards.org/xsd/qif2",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NotType >
    _xsd_NotType_type_serializer_init (
      "NotType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const BinaryBooleanExpressionBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (BinaryBooleanExpressionBaseType::BooleanExpression_const_iterator
             b (i.BooleanExpression ().begin ()), n (i.BooleanExpression ().end ());
             b != n; ++b)
        {
          if (typeid (BinaryBooleanExpressionBaseType::BooleanExpression_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "BooleanExpression",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BinaryBooleanExpressionBaseType >
    _xsd_BinaryBooleanExpressionBaseType_type_serializer_init (
      "BinaryBooleanExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const AndType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (AndType::BooleanExpression_const_iterator
             b (i.BooleanExpression ().begin ()), n (i.BooleanExpression ().end ());
             b != n; ++b)
        {
          if (typeid (AndType::BooleanExpression_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "BooleanExpression",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AndType >
    _xsd_AndType_type_serializer_init (
      "AndType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const OrType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // BooleanExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (OrType::BooleanExpression_const_iterator
             b (i.BooleanExpression ().begin ()), n (i.BooleanExpression ().end ());
             b != n; ++b)
        {
          if (typeid (OrType::BooleanExpression_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "BooleanExpression",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "BooleanExpression",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, OrType >
    _xsd_OrType_type_serializer_init (
      "OrType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const BooleanEqualType& i)
    {
      e << static_cast< const ::xsd::qif2::BinaryBooleanExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BooleanEqualType >
    _xsd_BooleanEqualType_type_serializer_init (
      "BooleanEqualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ConstantIsType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // val
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "val",
            e));

        a << i.val ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ConstantIsType >
    _xsd_ConstantIsType_type_serializer_init (
      "ConstantIsType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ArithmeticComparisonBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::BooleanExpressionBaseType& > (i);

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (ArithmeticComparisonBaseType::ArithmeticExpression_const_iterator
             b (i.ArithmeticExpression ().begin ()), n (i.ArithmeticExpression ().end ());
             b != n; ++b)
        {
          if (typeid (ArithmeticComparisonBaseType::ArithmeticExpression_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ArithmeticExpression",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArithmeticComparisonBaseType >
    _xsd_ArithmeticComparisonBaseType_type_serializer_init (
      "ArithmeticComparisonBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ArithmeticEqualType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArithmeticEqualType >
    _xsd_ArithmeticEqualType_type_serializer_init (
      "ArithmeticEqualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const GreaterThanType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GreaterThanType >
    _xsd_GreaterThanType_type_serializer_init (
      "GreaterThanType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const GreaterOrEqualType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GreaterOrEqualType >
    _xsd_GreaterOrEqualType_type_serializer_init (
      "GreaterOrEqualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LessThanType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LessThanType >
    _xsd_LessThanType_type_serializer_init (
      "LessThanType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const LessOrEqualType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticComparisonBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LessOrEqualType >
    _xsd_LessOrEqualType_type_serializer_init (
      "LessOrEqualType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const BooleanConstantEnumType& i)
    {
      e << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const BooleanConstantEnumType& i)
    {
      a << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const BooleanConstantEnumType& i)
    {
      l << static_cast< const ::xml_schema::nmtoken& > (i);
    }

    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::NotType >
    _xsd_Not_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "Not",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ConstantIsType >
    _xsd_ConstantIs_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "ConstantIs",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::AndType >
    _xsd_And_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "And",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::OrType >
    _xsd_Or_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "Or",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::BooleanEqualType >
    _xsd_BooleanEqual_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "BooleanEqual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ArithmeticEqualType >
    _xsd_ArithmeticEqual_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "ArithmeticEqual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::GreaterThanType >
    _xsd_GreaterThan_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "GreaterThan",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::GreaterOrEqualType >
    _xsd_GreaterOrEqual_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "GreaterOrEqual",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::LessThanType >
    _xsd_LessThan_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "LessThan",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::LessOrEqualType >
    _xsd_LessOrEqual_element_serializer_init (
      "BooleanExpression",
      "http://qifstandards.org/xsd/qif2",
      "LessOrEqual",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ArithmeticExpressionBaseType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr&, const ArithmeticExpressionBaseType&)
    {
    }

    void
    operator<< (::xml_schema::list_stream&,
                const ArithmeticExpressionBaseType&)
    {
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArithmeticExpressionBaseType >
    _xsd_ArithmeticExpressionBaseType_type_serializer_init (
      "ArithmeticExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const ArithmeticConstantType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticExpressionBaseType& > (i);

      // val
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            "val",
            e));

        a << ::xml_schema::as_decimal(i.val ());
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ArithmeticConstantType >
    _xsd_ArithmeticConstantType_type_serializer_init (
      "ArithmeticConstantType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const NegateType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticExpressionBaseType& > (i);

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        const NegateType::ArithmeticExpression_type& x (i.ArithmeticExpression ());
        if (typeid (NegateType::ArithmeticExpression_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "ArithmeticExpression",
            "http://qifstandards.org/xsd/qif2",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, NegateType >
    _xsd_NegateType_type_serializer_init (
      "NegateType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const BinaryArithmeticExpressionBaseType& i)
    {
      e << static_cast< const ::xsd::qif2::ArithmeticExpressionBaseType& > (i);

      // ArithmeticExpression
      //
      {
        ::xsd::cxx::tree::type_serializer_map< char >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

        for (BinaryArithmeticExpressionBaseType::ArithmeticExpression_const_iterator
             b (i.ArithmeticExpression ().begin ()), n (i.ArithmeticExpression ().end ());
             b != n; ++b)
        {
          if (typeid (BinaryArithmeticExpressionBaseType::ArithmeticExpression_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                "ArithmeticExpression",
                "http://qifstandards.org/xsd/qif2",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              "ArithmeticExpression",
              "http://qifstandards.org/xsd/qif2",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BinaryArithmeticExpressionBaseType >
    _xsd_BinaryArithmeticExpressionBaseType_type_serializer_init (
      "BinaryArithmeticExpressionBaseType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const PlusType& i)
    {
      e << static_cast< const ::xsd::qif2::BinaryArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PlusType >
    _xsd_PlusType_type_serializer_init (
      "PlusType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const MinusType& i)
    {
      e << static_cast< const ::xsd::qif2::BinaryArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MinusType >
    _xsd_MinusType_type_serializer_init (
      "MinusType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const TimesType& i)
    {
      e << static_cast< const ::xsd::qif2::BinaryArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TimesType >
    _xsd_TimesType_type_serializer_init (
      "TimesType",
      "http://qifstandards.org/xsd/qif2");


    void
    operator<< (::xercesc::DOMElement& e, const DividedByType& i)
    {
      e << static_cast< const ::xsd::qif2::BinaryArithmeticExpressionBaseType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DividedByType >
    _xsd_DividedByType_type_serializer_init (
      "DividedByType",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::ArithmeticConstantType >
    _xsd_ArithmeticConstant_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "ArithmeticConstant",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::PlusType >
    _xsd_Plus_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Plus",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::MinusType >
    _xsd_Minus_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Minus",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::NegateType >
    _xsd_Negate_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Negate",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::TimesType >
    _xsd_Times_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "Times",
      "http://qifstandards.org/xsd/qif2");


    static
    const ::xsd::cxx::tree::element_serializer_initializer< 0, char, ::xsd::qif2::DividedByType >
    _xsd_DividedBy_element_serializer_init (
      "ArithmeticExpression",
      "http://qifstandards.org/xsd/qif2",
      "DividedBy",
      "http://qifstandards.org/xsd/qif2");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

